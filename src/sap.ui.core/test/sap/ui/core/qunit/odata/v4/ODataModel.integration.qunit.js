/*!
 * ${copyright}
 */
sap.ui.define([
	"sap/base/Log",
	"sap/base/i18n/Localization",
	"sap/base/util/uid",
	"sap/m/ColumnListItem",
	"sap/m/CustomListItem",
	"sap/m/FlexBox",
	// hopefully speed up sap.m.plugins.DataStateIndicator#showMessage
	"sap/m/MessageStrip",
	"sap/m/Text",
	"sap/ui/Device",
	"sap/ui/base/EventProvider",
	"sap/ui/base/SyncPromise",
	"sap/ui/core/Messaging",
	"sap/ui/core/Rendering",
	"sap/ui/core/Supportability",
	"sap/ui/core/message/Message",
	"sap/ui/core/mvc/Controller",
	"sap/ui/core/mvc/View",
	"sap/ui/model/ChangeReason",
	"sap/ui/model/Filter",
	"sap/ui/model/FilterOperator",
	"sap/ui/model/FilterType",
	"sap/ui/model/Sorter",
	"sap/ui/model/odata/OperationMode",
	"sap/ui/model/odata/type/Decimal",
	"sap/ui/model/odata/v4/AnnotationHelper",
	"sap/ui/model/odata/v4/ODataListBinding",
	"sap/ui/model/odata/v4/ODataMetaModel",
	"sap/ui/model/odata/v4/ODataModel",
	"sap/ui/model/odata/v4/ODataPropertyBinding",
	"sap/ui/model/odata/v4/ValueListType",
	"sap/ui/model/odata/v4/lib/_Helper",
	"sap/ui/security/Security",
	"sap/ui/test/TestUtils",
	"sap/ui/util/XMLHelper",
	// load Table resources upfront to avoid loading times > 1 second for the first test using Table
	"sap/ui/table/Table"
], function (Log, Localization, uid, ColumnListItem, CustomListItem, FlexBox, _MessageStrip,
		Text, Device, EventProvider, SyncPromise, Messaging, Rendering, Supportability, Message,
		Controller, View, ChangeReason, Filter, FilterOperator, FilterType, Sorter, OperationMode,
		Decimal, AnnotationHelper, ODataListBinding, ODataMetaModel, ODataModel,
		ODataPropertyBinding, ValueListType, _Helper, Security, TestUtils, XMLHelper) {
	/*eslint no-sparse-arrays: 0, "max-len": ["error", {"code": 100,
		"ignorePattern": "/sap/opu/odata4/|\" :$|\" : \\{$|\\{meta>"}], */
	"use strict";

		// system query options for collection responses, but not inside $expand
	var rCollection = /[?&]\$(?:count|filter|orderby|search|skip|top)/,
		sContext = "sap.ui.model.odata.v4.Context",
		rCountTrue = /[?&]\$count=true/, // $count=true, but not inside $expand
		rCountUrl = /\/\$count(?:\?|$)/, // URL for ".../$count?..."
		sDefaultLanguage = Localization.getLanguage(),
		fnFireEvent = EventProvider.prototype.fireEvent,
		sNextSiblingAction
			= "/com.sap.gateway.default.iwbep.tea_busi.v0001.__FAKE__AcChangeNextSibling",
		sODCB = "sap.ui.model.odata.v4.ODataContextBinding",
		sODLB = "sap.ui.model.odata.v4.ODataListBinding",
		sODPrB = "sap.ui.model.odata.v4.ODataPropertyBinding",
		sPreviousFailed = "HTTP request was not processed because the previous request failed",
		sSalesOrderService = "/sap/opu/odata4/sap/zui5_testv4/default/sap/zui5_epm_sample/0002/",
		rSkip = /&\$skip=(\d+)/, // $skip=<number>
		sTeaBusi = "/sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001/",
		// the timeout for the tests and for waitForChanges in millseconds, 0 = keep defaults
		iTestTimeout = parseInt(new URLSearchParams(window.location.search).get("timeout")),
		rTop = /&\$top=(\d+)/, // $top=<number>
		rTransientPredicate = /\(\$uid=[-\w]+\)/g;

	if (isNaN(iTestTimeout)) {
		iTestTimeout = 0;
	} else {
		iTestTimeout *= 1000;
	}

	/**
	 * Asserts that the given contexts have the expected indices, both internally and from a view
	 * perspective.
	 *
	 * @param {object} assert - The QUnit assert object
	 * @param {sap.ui.model.odata.v4.Context[]} aContexts - Some contexts
	 * @param {number[]} aExpectedIndices - Expected internal <code>iIndex</code> values per context
	 */
	function assertIndices(assert, aContexts, aExpectedIndices) {
		aContexts.forEach(function (oContext, i) {
			assert.strictEqual(oContext.getIndex(), i);
			assert.strictEqual(oContext.iIndex, aExpectedIndices[i]);
		});
	}

	/**
	 * Checks that the given list binding's _AggregationCache has a consistent state.
	 *
	 * @param {string} sTitle - A test title
	 * @param {object} assert - The QUnit assert object
	 * @param {sap.ui.model.odata.v4.ODataListBinding} oListBinding - A list binding
	 */
	function checkAggregationCache(sTitle, assert, oListBinding) {
		const aParentByLevel = [];

		function checkCache(oCache) {
			for (let i = 0, n = oCache.aElements.$created; i < n; i += 1) {
				const oElement = oCache.aElements[i];
				if (oElement) {
					strictEqual(_Helper.hasPrivateAnnotation(oElement, "transientPredicate"), true,
						"created", oElement);
				}
			}
			for (let i = oCache.aElements.$created, n = oCache.aElements.length; i < n; i += 1) {
				const oElement = oCache.aElements[i];
				if (oElement) {
					strictEqual(_Helper.hasPrivateAnnotation(oElement, "transientPredicate"), false,
						"not created", oElement);
				}
			}
			strictEqual(oCache.aElements.$count === oCache.iLimit + oCache.iActiveElements, true,
				`${oCache.aElements.$count} === ${oCache.iLimit} + ${oCache.iActiveElements}`);
		}

		function isKeepAlive(sPredicate) {
			return oListBinding.getAllCurrentContexts()
				.filter((oContext) => oContext.isEffectivelyKeptAlive())
				.some((oContext) => oContext.getPath().endsWith(sPredicate));
		}

		function strictEqual(vActual, vExpected, sMyTitle, oElement) {
			if (vActual !== vExpected) {
				if (oElement) {
					sMyTitle += ": " + JSON.stringify(_Helper.publicClone(oElement));
				}
				assert.strictEqual(vActual, vExpected, sTitle + ": " + sMyTitle);
			} // else: do not spam the output ;-)
		}

		function visitElements(aElements, bSkipByPredicate = false, iLevelOffset = 0,
				iRankOffset = 0) {
			aElements.forEach((oElement) => {
				// Note: "@$ui5.node.level" is outdated after #move!
				const iLevel = oElement["@$ui5.node.level"] + iLevelOffset;

				// every "created" element needs to know its context, no others must do so
				strictEqual(oElement["@$ui5.context.isTransient"] !== undefined,
					 _Helper.hasPrivateAnnotation(oElement, "context"),
					`"context" @ level ${iLevel}`, oElement);
				if (_Helper.hasPrivateAnnotation(oElement, "context")) {
					strictEqual(oElement["@$ui5.context.isTransient"],
						_Helper.getPrivateAnnotation(oElement, "context").isTransient(),
						`"@$ui5.context.isTransient" @ level ${iLevel}`, oElement);
				}

				if (oElement["@$ui5.node.isExpanded"] === undefined) {
					strictEqual(_Helper.getPrivateAnnotation(oElement, "descendants") === undefined,
						true, "no descendants for a leaf", oElement);
				}

				let iRank = _Helper.getPrivateAnnotation(oElement, "rank");
				const oParent = aParentByLevel[iLevel];
				if (oParent === aParentByLevel[0] && iRank !== undefined) {
					iRank += iRankOffset;
				}
				const bPlaceholder = _Helper.hasPrivateAnnotation(oElement, "placeholder");
				if (oParent) {
					strictEqual(_Helper.getPrivateAnnotation(oElement, "parent"), oParent,
						`"parent" @ level ${iLevel}`, oElement);
					if (_Helper.hasPrivateAnnotation(oElement, "transientPredicate")) {
						strictEqual(iRank, undefined,
							`created persisted @ level ${iLevel}`, oElement);
					} else if (bPlaceholder) {
						strictEqual(oParent.aElements.indexOf(oElement), -1,
							`placeholder @ level ${iLevel}`, oElement);
					} else {
						strictEqual(iRank,
							oParent.aElements.indexOf(oElement) - oParent.aElements.$created,
							`$skip index @ level ${iLevel}`, oElement);
					}
				} else {
					assert.ok(false, `no known parent for level ${iLevel}`);
				}

				if (!bPlaceholder && !bSkipByPredicate) {
					const checkByPredicate = function (sKey) {
						const sPredicate = _Helper.getPrivateAnnotation(oElement, sKey);
						if (sPredicate === undefined) {
							return;
						}
						strictEqual(oListBinding.oCache.aElements.$byPredicate[sPredicate],
							oElement, `${sPredicate} in $byPredicate`, oElement);
					};

					checkByPredicate("predicate");
					checkByPredicate("transientPredicate");
				}

				const oCache = _Helper.getPrivateAnnotation(oElement, "cache");
				if (oCache) {
					checkCache(oCache);
					aParentByLevel[iLevel + 1] = oCache;
				}

				const aSpliced = _Helper.getPrivateAnnotation(oElement, "spliced");
				if (aSpliced) {
					visitElements(aSpliced, true, iLevel + 1 - aSpliced[0]["@$ui5.node.level"],
						iRank - aSpliced.$rank);
				}
			});
		}

		const aElements = oListBinding.oCache.aElements;
		strictEqual(aElements.length, aElements.$count, "$count");
		for (const sPredicate in aElements.$byPredicate) {
			const oElement = aElements.$byPredicate[sPredicate];
			strictEqual(oElement["@$ui5.context.isDeleted"] || aElements.includes(oElement)
					|| isKeepAlive(sPredicate),
				true, `$byPredicate[${sPredicate}] in aElements`, oElement);
			strictEqual(_Helper.getPrivateAnnotation(oElement, "predicate") === sPredicate
					|| _Helper.getPrivateAnnotation(oElement, "transientPredicate") === sPredicate,
				true, `unknown predicate ${sPredicate}`, oElement);
		}

		let iExpandTo = oListBinding.getAggregation().expandTo || 1;
		if (iExpandTo >= Number.MAX_SAFE_INTEGER || oListBinding.oCache.bUnifiedCache) {
			iExpandTo = 99; // avoid "Invalid array length" :-)
		}
		for (let i = 0; i <= iExpandTo; i += 1) {
			// Note: level 0 or 1 is used for initial placeholders of 1st level cache!
			aParentByLevel[i] = oListBinding.oCache.oFirstLevel;
		}
		checkCache(oListBinding.oCache.oFirstLevel);
		visitElements(aElements);

		if (iExpandTo > 1) {
			const aElements = oListBinding.oCache.oFirstLevel.aElements;
			if (!aElements.$created && aElements.$count === aElements.length) {
				aElements.forEach((oElement, i) => {
					if (oElement["@$ui5.node.isExpanded"]) {
						const iLevel = oElement["@$ui5.node.level"];
						let iDescendants = 0;
						for (let j = i + 1; j < aElements.length; j += 1) {
							if (!aElements[j]) {
								return; // cannot count "descendants" for this oElement
							}
							if (iLevel >= aElements[j]["@$ui5.node.level"]) {
								break; // end of "descendants"
							}
							iDescendants += 1;
						}
						strictEqual(_Helper.getPrivateAnnotation(oElement, "descendants", 0),
							iDescendants, "descendants", oElement);
					}
				});
			} // else: cannot count "descendants" this way
		}
	}

	/**
	 * Checks that the given promise is rejected with a cancellation error.
	 *
	 * @param {object} assert - The QUnit assert object
	 * @param {Promise} oPromise - The promise to be checked
	 * @returns {Promise} A promise that resolves after the check is done
	 */
	function checkCanceled(assert, oPromise) {
		return oPromise.then(mustFail(assert), function (oError) {
			assert.ok(oError instanceof Error && oError.canceled, "canceled error expected");
		});
	}

	/**
	 * Checks that the given context looks "created persisted".
	 *
	 * @param {object} assert - The QUnit assert object
	 * @param {sap.ui.model.odata.v4.Context} oContext - A context
	 * @param {Promise} [oCreatedPromise]
	 *   Expected {@link sap.ui.model.odata.v4.Context#created} promise
	 */
	function checkCreatedPersisted(assert, oContext, oCreatedPromise) {
		assert.strictEqual(oContext.isTransient(), false, "created persisted");
		assert.strictEqual(oContext.getProperty("@$ui5.context.isTransient"), false);
		if (oCreatedPromise) {
			assert.strictEqual(oContext.created(), oCreatedPromise);
		} else {
			assert.ok(oContext.created() instanceof Promise);
		}
	}

	/**
	 * Checks that the given context looks "persisted, not created".
	 *
	 * @param {object} assert - The QUnit assert object
	 * @param {sap.ui.model.odata.v4.Context} oContext - A context
	 */
	function checkPersisted(assert, oContext) {
		assert.strictEqual(oContext.created(), undefined, "persisted, not created");
		assert.strictEqual(oContext.getProperty("@$ui5.context.isTransient"), undefined);
		assert.strictEqual(oContext.isTransient(), undefined);
		// Note: due to cloning, undefined values are dropped anyway
		// assert.notOk("@$ui5.context.isTransient" in oContext.getObject());
	}

	/**
	 * Checks the selection state of the given context.
	 *
	 * @param {object} assert - The QUnit assert object
	 * @param {sap.ui.model.odata.v4.Context} oContext - A context
	 * @param {boolean} bSelected - The expected value for the "selected" property.
	 *   If <code>undefined</code> is given, the selection state of the context is asserted against
	 *   <code>false</code>.
	 * @param {string} [sText] - A message for the assertion
	 */
	function checkSelected(assert, oContext, bSelected, sText) {
		if (bSelected && oContext.isDeleted()) {
			assert.strictEqual(oContext.isSelected(), false, "selection hidden while deleted");
		} else {
			assert.strictEqual(oContext.isSelected(), !!bSelected,
				sText || "JIRA: CPOUI5ODATAV4-1943");
		}
		assert.strictEqual(oContext.getProperty("@$ui5.context.isSelected"), bSelected,
			sText || "JIRA: CPOUI5ODATAV4-1944");
	}

	/**
	 * Checks that the given table has the expected state w.r.t. contexts and content.
	 *
	 * @param {string} sTitle - A test title
	 * @param {object} assert - The QUnit assert object
	 * @param {sap.m.Table|sap.ui.table.Table} oTable - A table
	 * @param {string[]|sap.ui.model.odata.v4.Context} aExpectedPaths
	 *   List of all expected (normalized) current context paths or the corresponding context
	 * @param {any[][]} aExpectedContent - "Table" of expected cell contents
	 * @param {number} [iExpectedLength=aExpectedPaths.length] - Expected length
	 */
	// eslint-disable-next-line valid-jsdoc -- [][] is unsupported
	function checkTable(sTitle, assert, oTable, aExpectedPaths, aExpectedContent, iExpectedLength) {
		var oListBinding = oTable.getBinding("items") || oTable.getBinding("rows"),
			aRows = oTable.getItems ? oTable.getItems() : oTable.getRows();

		assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
		assert.strictEqual(oListBinding.getLength(), iExpectedLength || aExpectedPaths.length,
			sTitle);
		const aAllCurrentContexts = oListBinding.getAllCurrentContexts();
		aExpectedPaths.forEach((vExpectedPath, i) => {
			if (typeof vExpectedPath !== "string") {
				if (vExpectedPath !== aAllCurrentContexts[i]) {
					assert.ok(false, `${sTitle}: Context not same @${i}: ${vExpectedPath}`);
				}
				aExpectedPaths[i] = vExpectedPath.getPath();
			}
		});
		assert.deepEqual(aAllCurrentContexts.map(getNormalizedPath), aExpectedPaths);

		aExpectedContent = aExpectedContent.map(function (aTexts) {
			return aTexts.map(function (vText) {
				return vText !== undefined ? String(vText) : "";
			});
		});
		while (aExpectedContent.length < aRows.length) { // pad with "empty" rows
			aExpectedContent.push(aExpectedContent[0].slice().fill(""));
		}
		assert.deepEqual(aRows.map(function (oRow) {
			return oRow.getCells().map(function (oCell) {
				return oCell.getText ? oCell.getText() : oCell.getValue();
			});
		}), aExpectedContent, sTitle);

		if (oListBinding.getAggregation()?.hierarchyQualifier) {
			checkAggregationCache(sTitle, assert, oListBinding);
		}
	}

	/**
	 * Creates an error to be used in {@link #expectRequest}. The result is similar to that of
	 * {@link _Helper.createError} and lets a $direct or $batch request fail.
	 *
	 * @param {object} [oErrorResponse]
	 *   The <code>error</code> property of a simulated JSON error response; default values for the
	 *   properties "code" and "message" are provided in that case
	 * @param {number} [iHttpStatus=500]
	 *   The HTTP status code for the simulated error response
	 * @param {Date} [dRetryAfter]
	 *   The data corresponding to a "Retry-After" HTTP response header value in case of 503
	 * @returns {Error}
	 *   The error object for {@link #expectRequest}
	 */
	function createError(oErrorResponse, iHttpStatus = 500, dRetryAfter = false) {
		const oError = new Error("Communication error: " + iHttpStatus + " ");
		if (oErrorResponse) {
			oError.error = Object.assign({
					code : "CODE",
					message : "Request intentionally failed"
				}, oErrorResponse);
		}
		// oError.requestUrl = undefined; // @see checkRequest
		// oError.resourcePath = undefined; // @see checkRequest
		oError.retryAfter = dRetryAfter;
		oError.status = iHttpStatus;
		// oError.statusText = ""; // not needed

		return oError;
	}

	/**
	 * Creates an error to be used in {@link #expectRequest} in order to simulate a JSON error
	 * response inside a $batch by giving an object defining the relevant <code>error</code>
	 * property of that JSON.
	 *
	 * @param {object} [oErrorResponse={}]
	 *   The <code>error</code> property of the simulated JSON error response; default
	 *   values for the properties "code" and "message" are provided anyway
	 * @param {number} [iHttpStatus=500]
	 *   The HTTP status code for the simulated error response
	 * @returns {Error}
	 *   The error object for {@link #expectRequest}
	 */
	function createErrorInsideBatch(oErrorResponse, iHttpStatus) {
		var oError = new Error("n/a");

		oError.$insideBatch = true;
		oError.error = Object.assign({
				code : "CODE",
				message : "Request intentionally failed"
			}, oErrorResponse);
		oError.status = iHttpStatus || 500;

		return oError;
	}

	/**
	 * Returns the binding context's path for a given managed object.
	 *
	 * @param {sap.ui.model.ManagedObject} oManagedObject - A managed object
	 * @returns {string} The binding context's path
	 */
	function getBindingContextPath(oManagedObject) {
		return oManagedObject.getBindingContext().getPath();
	}

	/**
	 * Returns the given context's path. Transient predicates are normalized to "($uid=...)".
	 *
	 * @param {sap.ui.model.Context} oContext - A context
	 * @returns {string} The context's path
	 */
	function getNormalizedPath(oContext) {
		return normalizeUID(oContext.getPath());
	}

	/**
	 * Returns the given context's data object.
	 *
	 * @param {sap.ui.model.Context} oContext - A context
	 * @returns {object} The context's data
	 */
	function getObject(oContext) {
		return oContext.getObject();
	}

	/**
	 * Returns the given context's path.
	 *
	 * @param {sap.ui.model.Context} oContext - A context
	 * @returns {string} The context's path
	 */
	function getPath(oContext) {
		return oContext.getPath();
	}

	/**
	 * Returns a function that simply emits a failed assertion "Unexpected success", to be used as a
	 * "then" handler when only a rejection is expected.
	 *
	 * @param {object} assert The QUnit assert object
	 * @returns {function} The function
	 */
	function mustFail(assert) {
		if (!assert || typeof assert.ok !== "function") {
			throw new Error("QUnit assert object expected");
		}
		return function () {
			assert.ok(false, "Unexpected success");
		};
	}

	/**
	 * Returns the given text with transient predicates normalized to "($uid=...)".
	 *
	 * @param {string} sText - Any text
	 * @returns {string} The text with normalized UIDs
	 */
	function normalizeUID(sText) {
		return sText.replace(rTransientPredicate, "($uid=...)");
	}

	/**
	 * @param {any|function} [vValue]
	 *   The value to be returned later or a callback function delivering it
	 * @param {number} [iDelay=5]
	 *   A delay in milliseconds
	 * @returns {Promise}
	 *   A promise which resolves with the given value after the given delay
	 */
	function resolveLater(vValue, iDelay) {
		return new Promise(function (resolve, reject) {
			setTimeout(function () {
				try {
					resolve(typeof vValue === "function" ? vValue() : vValue);
				} catch (e) {
					reject(e);
				}
			}, iDelay === undefined ? 5 : iDelay);
		});
	}

	/**
	 * Sets the "selected" property for the given context.
	 *
	 * @param {boolean} bUseAnnotation - If <code>true</code>, setProperty with the client-side
	 *   annotation is used for selection; otherwise, the context's setSelected method is used.
	 * @param {sap.ui.model.odata.v4.Context} oContext - A context
	 * @param {boolean} bSelected - The new "selected" state
	 */
	function setSelected(bUseAnnotation, oContext, bSelected) {
		if (bUseAnnotation) {
			oContext.setProperty("@$ui5.context.isSelected", bSelected);
		} else {
			oContext.setSelected(bSelected);
		}
	}

	/**
	 * Creates a test with the given title and invokes viewStart with the given parameters.
	 *
	 * @param {string} sTitle The title of the test case
	 * @param {string} sView The XML snippet of the view
	 * @param {object} mResponseByRequest A map containing the request as key
	 *   and response as value
	 * @param {object|object[]} mValueByControl A map or an array of maps containing control id as
	 *   key and the expected control values as value
	 * @param {function|string|sap.ui.model.odata.v4.ODataModel} [vModel]
	 *   The model (or the name of a function at <code>this</code> which creates it, of a function
	 *   called on <code>this</code> which creates it); it is attached to the view and to the test
	 *   instance.
	 *   If no model is given, the <code>TEA_BUSI</code> model is created and used.
	 * @param {function} [fnAssert]
	 *   A function containing additional assertions such as expected log messages which is called
	 *   just before view creation with the test as "this"
	 */
	function testViewStart(sTitle, sView, mResponseByRequest, mValueByControl, vModel, fnAssert) {
		QUnit.test(sTitle, function (assert) {
			var sControlId, sRequest,
				that = this;

			function expectChanges(mValueByControl) {
				for (sControlId in mValueByControl) {
					that.expectChange(sControlId, mValueByControl[sControlId]);
				}
			}

			for (sRequest in mResponseByRequest) {
				this.expectRequest(sRequest, mResponseByRequest[sRequest]);
			}
			if (Array.isArray(mValueByControl)) {
				mValueByControl.forEach(expectChanges);
			} else {
				expectChanges(mValueByControl);
			}
			if (typeof vModel === "function") {
				vModel = vModel.apply(this);
			} else if (typeof vModel === "string") {
				vModel = this[vModel]();
			}
			if (fnAssert) {
				fnAssert.call(this);
			}

			return this.createView(assert, sView, vModel);
		});
	}

	/**
	 * Creates a QUnit.test which tests that the template output is as expected.
	 *
	 * @param {string} sTitle The title of the test case
	 * @param {object|string} vXMLPreprocessorConfig
	 *   Holds a preprocessor configuration for type "xml", see {@link sap.ui.core.mvc.View.create},
	 *   or the name of a function at <code>this</code> which creates the corresponding model
	 * @param {string} sTemplate The template used to generate the expected view as XML
	 * @param {string} sView The expected resulting view from templating
	 *
	 * @private
	 */
	function testXMLTemplating(sTitle, vXMLPreprocessorConfig, sTemplate, sView) {
		QUnit.test(sTitle, function (assert) {
			if (typeof vXMLPreprocessorConfig === "string") {
				vXMLPreprocessorConfig = {
					models : {
						meta : this[vXMLPreprocessorConfig]().getMetaModel()
					}
				};
			}

			return this.doTestXMLTemplating(assert, vXMLPreprocessorConfig, sTemplate, sView);
		});
	}

	/**
	 * Wraps the given XML string into a <View> and creates an XML document for it. Verifies that
	 * the sap.m.Table does not use <items>, because this is the default aggregation and may be
	 * omitted. (This ensures that <ColumnListItem> is a direct child.)
	 *
	 * An XML string starting with a space allows additional attributes to the surrounding <View>
	 * (like template:require or core:require). In this case the closing ">" for the <View> must
	 * also be given.
	 *
	 * If the binding uses <ColumnListItem>, <columns> is not allowed. The columns are automatically
	 * determined from the number of the elements in <ColumnListItem>.
	 *
	 * @param {string} sViewXML - The view content as XML string
	 * @returns {Document} The view as XML document
	 * @throws {Error} In case parsing fails
	 */
	function xml(sViewXML) {
		var oDocument, oParseError;

		oDocument = XMLHelper.parse(
			'<mvc:View xmlns="sap.m" xmlns:core="sap.ui.core" xmlns:mvc="sap.ui.core.mvc"'
			+ ' xmlns:plugins="sap.m.plugins"'
			+ ' xmlns:t="sap.ui.table" xmlns:trm="sap.ui.table.rowmodes"'
			+ ' xmlns:template="http://schemas.sap.com/sapui5/extension/sap.ui.core.template/1"'
			+ (sViewXML.startsWith(" ") ? "" : ">")
			+ sViewXML
			+ "</mvc:View>",
			"application/xml"
		);
		oParseError = XMLHelper.getParseError(oDocument);
		if (oParseError.errorCode) {
			throw new Error("Parse error: " + JSON.stringify(oParseError));
		}
		xmlConvertMTables(oDocument);
		xmlConvertGridTables(oDocument);

		return oDocument;
	}

	/**
	 * Converts the sap.ui.table.Table controls within the document. Embeds all inner controls into
	 * a <t:Column> with <t:template> each. <t:Column> may still be used however. Do not use <rows>,
	 * it breaks this automatic conversion (and is unnecessary anyway).
	 *
	 * @param {Document} oDocument The view as XML document
	 */
	function xmlConvertGridTables(oDocument) {
		var oChildNode, aChildNodes, oColumn, oElement, i, j, aTableElements, oTemplate,
			oRowMode, oFixedRowMode;

		aTableElements = oDocument.getElementsByTagNameNS("sap.ui.table", "Table");
		for (i = aTableElements.length - 1; i >= 0; i -= 1) {
			oElement = aTableElements[i];

			if (oElement.hasAttribute("visibleRowCount")) {
				oRowMode = document.createElementNS("sap.ui.table", "rowMode");
				oElement.appendChild(oRowMode);
				oFixedRowMode = document.createElementNS("sap.ui.table.rowmodes", "Fixed");
				oFixedRowMode.setAttribute("rowCount", oElement.getAttribute("visibleRowCount"));
				oRowMode.appendChild(oFixedRowMode);
				oElement.removeAttribute("visibleRowCount");
			}

			aChildNodes = oElement.childNodes;
			for (j = aChildNodes.length - 1; j >= 0; j -= 1) {
				oChildNode = aChildNodes[j];
				if (oChildNode.nodeType === Node.ELEMENT_NODE
						&& oChildNode.localName !== "Column"
						&& oChildNode.localName !== "rowMode") {
					oColumn = document.createElementNS("sap.ui.table", "Column");
					oElement.insertBefore(oColumn, oChildNode);
					oElement.removeChild(oChildNode);
					oTemplate = document.createElementNS("sap.ui.table", "template");
					oColumn.appendChild(oTemplate);
					oTemplate.appendChild(oChildNode);
				}
			}
		}
	}

	/**
	 * Converts the sap.m.Table controls within the document. Embeds all inner controls into a
	 * <ColumnListItem>. <ColumnListItem> may still be used however. Do not use <items>, it breaks
	 * this automatic conversion (and is unnecessary anyway). Do not use <columns>, they are added
	 * automatically.
	 *
	 * @param {Document} oDocument The view as XML document
	 */
	function xmlConvertMTables(oDocument) {
		var aControls, oChildNode, aChildNodes, iColumnCount, aColumnNodes, oColumnsElement,
			oElement, bHasColumns, bHasListItem, i, j, k, aTableElements;

		aTableElements = oDocument.getElementsByTagNameNS("sap.m", "Table");
		iColumnCount = 0;
		for (i = aTableElements.length - 1; i >= 0; i -= 1) {
			oElement = aTableElements[i];
			aControls = [];

			aChildNodes = oElement.childNodes;
			for (j = aChildNodes.length - 1; j >= 0; j -= 1) {
				oChildNode = aChildNodes[j];
				switch (oChildNode.nodeName) {
					case "columns":
						bHasColumns = true;
						break;
					case "dependents":
						break; // leave alone
					case "items":
						throw new Error("Do not use <items> in sap.m.Table");
					case "ColumnListItem":
						aColumnNodes = oChildNode.childNodes;
						bHasListItem = true;
						for (k = aColumnNodes.length - 1; k >= 0; k -= 1) {
							if (aColumnNodes[k].nodeType === Node.ELEMENT_NODE) {
								iColumnCount += 1;
							}
						}
						break;
					default:
						if (oChildNode.nodeType === Node.ELEMENT_NODE) {
							oElement.removeChild(oChildNode);
							aControls.unshift(oChildNode);
							iColumnCount += 1;
						}
				}
			}
			if (iColumnCount) {
				if (bHasColumns) {
					throw new Error("Do not use <columns> in sap.m.Table");
				}
				if (aControls.length) {
					if (bHasListItem) {
						throw new Error("Do not use controls w/ and w/o <ColumnListItem>"
							+ " in sap.m.Table");
					}
					oColumnsElement = document.createElementNS("sap.m", "ColumnListItem");
					for (j = 0; j < aControls.length; j += 1) {
						oColumnsElement.appendChild(aControls[j]);
					}
					oElement.appendChild(oColumnsElement);
				}
				oColumnsElement = oDocument.createElementNS("sap.m", "columns");
				while (iColumnCount > 0) {
					oColumnsElement.appendChild(oDocument.createElementNS("sap.m", "Column"));
					iColumnCount -= 1;
				}
				oElement.appendChild(oColumnsElement);
			}
		}
	}

	//*********************************************************************************************
	QUnit.module("sap.ui.model.odata.v4.ODataModel.integration", {
		beforeEach : function (assert) {
			if (iTestTimeout) {
				assert.timeout(iTestTimeout);
			}
			// We use a formatter to check for property changes. However before the formatter is
			// called, the value is passed through the type's formatValue
			// (see PropertyBinding#_toExternalValue). Ensure that this result is predictable.
			Localization.setLanguage("en-US");

			this.oLogMock = this.mock(Log);
			this.oLogMock.expects("warning")
				.withExactArgs(sinon.match.string, "LegacyParametersGet", "sap.ui.support",
					sinon.match.func)
				.atLeast(0);
			this.oLogMock.expects("error").never();

			// Counter for ($direct or $batch) requests.
			this.iBatchNo = 0;
			// {map<string, string[]>}
			// this.mChanges["id"] is a list of expected changes for the property "text" of the
			// control with ID "id"
			this.mChanges = {};
			// A list of expected canceled errors
			this.aExpectedCanceledErrors = [];
			// expected events, each as [this.toString(), sEventId, mParameters]
			this.aExpectedEvents = [];
			// regular expression to ignore certain canceled errors according to their message
			this.rIgnoredCanceledErrors = null;
			// {map<string, true>}
			// If an ID is in this.mIgnoredChanges, change events with null are ignored
			this.mIgnoredChanges = {};
			// {map<string, boolean|undefined>}
			// whether a control is part of a list or not; used when expecting changes;
			// undefined means we don't know yet because a null change is expected w/o index
			this.mIsListByControlId = {};
			// {map<string, string[][]>}
			// this.mListChanges["id"][i] is a list of expected changes for the property "text" of
			// the control with ID "id" in row i
			this.mListChanges = {};
			// A list of expected messages
			this.aMessages = [];
			// The number of pending responses checkFinish has to wait for
			this.iPendingResponses = 0;
			// A list of expected requests with the properties method, url, headers, response
			this.aRequests = [];

			// If the "rowMode" of the sap.ui.table.* is "Auto", the table uses the
			// screen height (Device.resize.height) to compute the amount of contexts it requests
			// initially. Make sure that this is stable across devices.
			this._oSandbox.stub(Device.resize, "height").value(1000);
		},

		afterEach : function (assert) {
			var that = this;

			function getGroupLocks() {
				return (that.oModel && that.oModel.oRequestor.aLockedGroupLocks || [])
					.filter(function (oGroupLock) {
						return oGroupLock.isLocked();
					});
			}

			function cleanup() {
				if (that.oView) {
					// avoid calls to formatters by UI5 localization changes in later tests
					that.oView.destroy();
				}
				if (that.oModel) {
					that.oModel.destroy();
				}
				Messaging.removeAllMessages();
				// reset the language
				Localization.setLanguage(sDefaultLanguage);
			}

			if (getGroupLocks().length) {
				return resolveLater(function () {
					getGroupLocks().forEach(function (oGroupLock) {
						assert.ok(false, "GroupLock remained: " + oGroupLock + "\n"
							+ oGroupLock.$stack);
					});

					cleanup();
				});
			}

			EventProvider.prototype.fireEvent = fnFireEvent;
			cleanup();
		},

		/**
		 * Adds a Text control with its text property bound to the given property path to the given
		 * form in the view created by {@link #createView}.
		 * Sets a formatter so that {@link #expectChange} can be used to expect change events on the
		 * text property.
		 *
		 * @param {object} oForm The form control
		 * @param {string} sPropertyPath The property path to bind the text property
		 * @param {object} assert The QUnit assert object
		 * @returns {string} The ID of the text control which can be used for {@link #expectChange}
		 */
		addToForm : function (oForm, sPropertyPath, assert) {
			var sId = "id" + sPropertyPath.replace("/", "_"),
				oText = new Text({
					id : this.oView.createId(sId),
					text : "{" + sPropertyPath + "}"
				});

			// attach formatter to check value for dynamically created control
			this.setFormatter(assert, oText, sId);
			oForm.addItem(oText);

			return sId;
		},

		/**
		 * Adds a cell with a text control with its text property bound to the given property path
		 * to the template control of the given table in the view created by {@link #createView}.
		 * Recreates the list binding as only then changes to the aggregation's template control are
		 * applied.
		 * Sets a formatter so that {@link #expectChange} can be used to expect change events on the
		 * text property.
		 *
		 * @param {object} oTable The table control
		 * @param {string} sPropertyPath The property path to bind the text property
		 * @param {object} assert The QUnit assert object
		 * @returns {string} The ID of the text control which can be used for {@link #expectChange}
		 */
		addToTable : function (oTable, sPropertyPath, assert) {
			var sId = "id" + sPropertyPath.replace("/", "_"),
				bRelative = oTable.getBinding("items").isRelative(),
				oTemplate = oTable.getBindingInfo("items").template,
				oText = new Text({
					id : this.oView.createId(sId),
					text : "{" + sPropertyPath + "}"
				});

			// attach formatter to check value for dynamically created control
			this.setFormatter(assert, oText, sId, true);
			oTemplate.addCell(oText);
			// ensure template control is not destroyed on re-creation of the "items" aggregation
			delete oTable.getBindingInfo("items").template;
			// It is not possible to modify the aggregation's template on an existing binding.
			// Hence, we have to re-create.
			oTable.bindItems(Object.assign({}, oTable.getBindingInfo("items"),
				{suspended : !bRelative, template : oTemplate}));

			return sId;
		},

		/**
		 * Asynchronously checks that the given list binding's contexts, when they all have been
		 * loaded, provide values for the given properties as expected. Includes
		 * {@link #waitForChanges}.
		 *
		 * @param {string} sTitle - A test title
		 * @param {object} assert - The QUnit assert object
		 * @param {sap.ui.model.odata.v4.ODataListBinding} oListBinding - A list binding
		 * @param {string[]} aProperties - List of all properties to be checked in aExpectedValues
		 * @param {any[][]} aExpectedValues - "Table" of expected property values
		 * @returns {Promise} A promise that resolves after the check is done
		 */
		// eslint-disable-next-line valid-jsdoc -- [][] is unsupported
		checkAllContexts : async function (sTitle, assert, oListBinding, aProperties,
				aExpectedValues) {
			function strictEqual(vActual, vExpected, sMyTitle) {
				if (vActual !== vExpected) {
					assert.strictEqual(vActual, vExpected, sMyTitle);
				} // else: do not spam the output ;-)
			}

			strictEqual(oListBinding.isLengthFinal(), true, "length is final");
			strictEqual(oListBinding.getLength(), aExpectedValues.length, "length as expected");

			const aContexts = await oListBinding.requestContexts(0, oListBinding.getLength());

			aContexts.forEach((oContext, i) => {
				strictEqual(oContext.getIndex(), i,
						`index of ${oContext.getPath()}`);
				aProperties.forEach((sProperty, j) => {
					strictEqual(oContext.getProperty(sProperty), aExpectedValues[i][j],
						`${oContext.getPath()}/${sProperty}`);
				});
			});

			await this.waitForChanges(assert, sTitle);

			if (oListBinding.getAggregation()?.hierarchyQualifier) {
				checkAggregationCache(sTitle, assert, oListBinding);
			}
		},

		/**
		 * Checks the messages and finishes the test if no pending changes are left, all
		 * expected requests and canceled errors have been received and the expected number of
		 * messages have been reported.
		 *
		 * @param {object} assert The QUnit assert object
		 */
		checkFinish : function (assert) {
			var sControlId, aExpectedValuesPerRow, i;

			if (this.aRequests.length || this.iPendingResponses
					|| this.aExpectedCanceledErrors.length) {
				return;
			}
			for (sControlId in this.mChanges) {
				if (this.mChanges[sControlId].length) {
					return;
				}
				delete this.mChanges[sControlId];
			}
			for (sControlId in this.mListChanges) {
				// Note: This may be a sparse array
				aExpectedValuesPerRow = this.mListChanges[sControlId];
				for (i in aExpectedValuesPerRow) {
					if (aExpectedValuesPerRow[i].length) {
						return;
					}
					delete aExpectedValuesPerRow[i];
				}
				delete this.mListChanges[sControlId];
			}

			if (Rendering.isPending() || this.oModel && this.oModel.aPrerenderingTasks
					|| Messaging.getMessageModel().getObject("/").length < this.aMessages.length) {
				setTimeout(this.checkFinish.bind(this, assert), 10);
			} else if (this.resolve) {
				this.resolve();
				this.resolve = null;
			}
		},

		/**
		 * Checks that exactly the expected messages have been reported, the order doesn't matter.
		 *
		 * @param {object} assert The QUnit assert object
		 */
		checkMessages : function (assert) {
			var aCurrentMessages = Messaging.getMessageModel()
					.getObject("/").map(function (oMessage) {
						var aTargets = oMessage.getTargets().map(function (sTarget) {
							return normalizeUID(sTarget);
						});

						return {
							code : oMessage.getCode(),
							descriptionUrl : oMessage.getDescriptionUrl(),
							message : oMessage.getMessage(),
							persistent : oMessage.getPersistent(),
							targets : aTargets,
							technical : oMessage.getTechnical(),
							technicalDetails : oMessage.getTechnicalDetails(),
							type : oMessage.getType()
						};
					}).sort(compareMessages),
				aExpectedMessages = this.aMessages.slice().sort(compareMessages),
				oMatcher;

			function compareMessages(oMessage1, oMessage2) {
				return oMessage1.message.localeCompare(oMessage2.message);
			}

			// in order to get a complete diff, add technicalDetails only if needed
			aExpectedMessages.forEach(function (oExpectedMessage, i) {
				if (i < aCurrentMessages.length && !("technicalDetails" in oExpectedMessage)) {
					delete aCurrentMessages[i].technicalDetails;
				}
			});

			if (this.aMessages.bHasMatcher) {
				oMatcher = sinon.match(aExpectedMessages);

				assert.ok(oMatcher.test(aCurrentMessages), oMatcher.message);
			} else {
				assert.deepEqual(aCurrentMessages, aExpectedMessages,
					this.aMessages.length + " expected messages in message manager");
			}
		},

		/**
		 * Checks the text of the 'More' button for a sap.m.Table with the ID "listReport". The
		 * button is invisible if all elements of a collection are visible. It is not necessarily
		 * updated in this case.
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {string} sExpected The expected count as text w/o "More" without spaces,
		 *    e.g. "[5/10]"
		 */
		checkMoreButton : function (assert, sExpected) {
			assert.strictEqual(this.oView.byId("listReport-trigger").getDomRef().innerText
				.replace(/\s/g, ""), "More" + sExpected, "check More button: " + sExpected);
		},

		/**
		 * Creates a view with a numeric property, "enters" incorrect text to reach an invalid data
		 * state, calls resetChanges at the given object and checks that the control gets another
		 * change event.
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {function} fnGetResettable The function to determine the object to call
		 *   resetChanges at. The function gets the view as parameter.
		 * @returns {Promise} A promise that is resolved when the change event has been fired
		 */
		checkResetInvalidDataState : function (assert, fnGetResettable) {
			var oModel = this.createTeaBusiModel({updateGroupId : "update"}),
				sView = '\
<FlexBox id="form" binding="{/EMPLOYEES(\'2\')}">\
	<Text id="age" text="{AGE}"/>\
</FlexBox>',
				that = this;

			this.expectRequest("EMPLOYEES('2')", {AGE : 32})
				.expectChange("age", "32");

			return this.createView(assert, sView, oModel).then(function () {
				var oBinding = that.oView.byId("age").getBinding("text"),
					fnFormatter = oBinding.fnFormatter;

				delete oBinding.fnFormatter;
				assert.throws(function () {
					oBinding.setExternalValue("bad");
				});
				assert.ok(oBinding.getDataState().isControlDirty());

				oBinding.fnFormatter = fnFormatter;

				that.expectChange("age", "32");

				// code under test
				// Note: $direct would be an "Invalid group ID" here
				fnGetResettable(that.oView).resetChanges();

				return that.waitForChanges(assert);
			});
		},

		/**
		 * Checks that the given value is the expected one for the control.
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {string} sValue The value
		 * @param {string} sControlId The control ID
		 * @param {number|string} [vRow] The row index in case the control's binding is below a
		 *   list binding or the path of the row's context (for example in the tests of the
		 *   ODataMetaModel), otherwise <code>undefined</code>.
		 */
		checkValue : function (assert, sValue, sControlId, vRow) {
			var sExpectedValue,
				aExpectedValues = vRow === undefined
					? this.mChanges[sControlId]
					: this.mListChanges[sControlId] && this.mListChanges[sControlId][vRow],
				sVisibleId = vRow === undefined ? sControlId : sControlId + "[" + vRow + "]";

			if (!aExpectedValues || !aExpectedValues.length) {
				if (!(sControlId in this.mIgnoredChanges && sValue === null)) {
					assert.ok(false, sVisibleId + ": " + JSON.stringify(sValue) + " (unexpected)");
				}
			} else {
				sExpectedValue = aExpectedValues.shift();
				// Note: avoid bad performance of assert.strictEqual(), e.g. DOM manipulation
				if (sValue !== sExpectedValue || vRow === undefined || typeof vRow !== "number"
						|| vRow < 10) {
					assert.strictEqual(sValue, sExpectedValue,
						sVisibleId + ": " + JSON.stringify(sValue));
				}
			}
			this.checkFinish(assert);
		},

		/**
		 * Checks the control's value state after waiting some time for the control to set it.
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {string|sap.m.InputBase} vControl The control ID or an instance of InputBase
		 * @param {sap.ui.core.ValueState} sState The expected value state
		 * @param {string} sText The expected text
		 *
		 * @returns {Promise} A promise resolving when the check is done
		 */
		checkValueState : function (assert, vControl, sState, sText) {
			var oControl = typeof vControl === "string" ? this.oView.byId(vControl) : vControl;

			return resolveLater(function () {
				assert.strictEqual(oControl.getValueState(), sState,
					oControl.getId() + ": value state: " + oControl.getValueState());
				assert.strictEqual(oControl.getValueStateText(), sText,
					oControl.getId() + ": value state text: " + oControl.getValueStateText());
			});
		},

		/**
		 * Searches the incoming request in the list of expected requests by comparing the URL.
		 * Removes the found request from the list.
		 *
		 * @param {object} oActualRequest The actual request
		 * @returns {object} The matching expected request or undefined if none was found
		 */
		consumeExpectedRequest : function (oActualRequest) {
			var oExpectedRequest, i;

			for (i = 0; i < this.aRequests.length; i += 1) {
				oExpectedRequest = this.aRequests[i];
				if (oExpectedRequest.url === oActualRequest.url) {
					this.aRequests.splice(i, 1);
					return oExpectedRequest;
				}
			}

			return this.aRequests.shift(); // consume the first candidate to get a diff
		},

		/**
		 * Creates a V4 OData model for data aggregation tests.
		 *
		 * @param {object} [mModelParameters] Map of parameters for model construction...
		 * @returns {ODataModel} The model
		 */
		createAggregationModel : function (mModelParameters) {
			return this.createModel("/aggregation/", mModelParameters, {
				"/aggregation/$metadata"
					: {source : "odata/v4/data/metadata_aggregation.xml"}
			});
		},

		/**
		 * Creates a view containing a list report and an object page. The list report contains a
		 * list of sales orders and the object page the details of a sales order. The list report is
		 * initially filtered to only show sales orders with a gross amount less than 150.
		 *
		 * Applies the following steps:
		 *
		 * 1. Select a sales order and see that late properties are requested. Keep its context
		 *    alive.
		 * 2. (optional) Filter the list, so that the context drops out of it. Check that the
		 *    context is still alive and has its data.
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {boolean} bDropFromCollection If <code>true</code> the context is no longer in
		 *   the collection
		 * @param {function} [fnOnBeforeDestroy]
		 *  Call back function that is invoked once the kept-alive context gets destroyed.
		 * @returns {Promise} A promise that is resolved with the kept-alive context when the
		 * view is created and ready
		 */
		createKeepAliveScenario : function (assert, bDropFromCollection, fnOnBeforeDestroy) {
			var oContext,
				oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
				oTable,
				sView = '\
<Table id="listReport" growing="true" growingThreshold="2" items="{path : \'/SalesOrderList\',\
		parameters : {$count : true}, \
		filters : {path : \'GrossAmount\', operator : \'LE\', value1 : 150}}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="grossAmount" text="{GrossAmount}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="objectPageGrossAmount" text="{GrossAmount}"/>\
	<Text id="objectPageNote" text="{Note}"/>\
	<Table items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="itemPosition" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
				that = this;

			this.expectRequest("SalesOrderList?$count=true&$filter=GrossAmount le 150"
					+ "&$select=GrossAmount,SalesOrderID&$skip=0&$top=2", {
					"@odata.count" : "42",
					value : [{
						"@odata.etag" : "etag1",
						GrossAmount : "123",
						SalesOrderID : "1"
					}, {
						"@odata.etag" : "etag2",
						GrossAmount : "149",
						SalesOrderID : "2"
					}]
				})
				.expectChange("id", ["1", "2"])
				.expectChange("grossAmount", ["123.00", "149.00"])
				.expectChange("objectPageGrossAmount")
				.expectChange("objectPageNote")
				.expectChange("itemPosition", []);

			return this.createView(assert, sView, oModel).then(function () {
				oTable = that.oView.byId("listReport");
				oContext = oTable.getItems()[0].getBindingContext();

				that.expectChange("objectPageGrossAmount", "123.00")
					.expectRequest("SalesOrderList('1')?$select=Note", {
						"@odata.etag" : "etag1",
						Note : "Before refresh"
					})
					.expectChange("objectPageNote", "Before refresh")
					.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
						+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100", {
						value : [{
							ItemPosition : "0010",
							SalesOrderID : "1"
						}]
					})
					// Note: it is important to wait for the table to get its data!
					.expectChange("itemPosition", ["0010"]);

				// code under test
				that.oView.byId("objectPage").setBindingContext(oContext);
				oContext.setKeepAlive(true, fnOnBeforeDestroy);

				return that.waitForChanges(assert, "(1)");
			}).then(function () {
				if (bDropFromCollection) {
					that.expectRequest("SalesOrderList?$count=true&$filter=GrossAmount gt 123"
							+ "&$select=GrossAmount,SalesOrderID&$skip=0&$top=2", {
							"@odata.count" : "27",
							value : [{
								"@odata.etag" : "etag2",
								GrossAmount : "149",
								SalesOrderID : "2"
							}, {
								"@odata.etag" : "etag3",
								GrossAmount : "789",
								SalesOrderID : "3"
							}]
						})
						.expectChange("id", [, "3"])
						.expectChange("grossAmount", [, "789.00"]);

					// code under test
					oTable.getBinding("items")
						.filter(new Filter("GrossAmount", FilterOperator.GT, 123));

					return that.waitForChanges(assert, "(2)");
				}
			}).then(function () {
				return oContext;
			});
		},

		/**
		 * Creates a V4 OData model.
		 *
		 * @param {string} sServiceUrl The service URL
		 * @param {object} [mModelParameters] Map of parameters for model construction to enhance
		 *   and potentially overwrite the parameters operationMode and serviceUrl which are set by
		 *   default
		 * @param {map} mFixture
		 *   The fixture. See {@link sap.ui.test.TestUtils.useFakeServer}
		 * @returns {sap.ui.model.odata.v4.ODataModel} The model
		 */
		createModel : function (sServiceUrl, mModelParameters, mFixture) {
			var mDefaultParameters = {
					operationMode : OperationMode.Server,
					serviceUrl : sServiceUrl
				};

			mFixture = TestUtils.normalizeFixture(mFixture, sServiceUrl);
			TestUtils.useFakeServer(this._oSandbox, "sap/ui/core/qunit", mFixture, [/*aRegExps*/],
				sServiceUrl, /*bStrict*/true);

			return new ODataModel(Object.assign(mDefaultParameters, mModelParameters));
		},

		/**
		 * Creates a V4 OData model for V2 service <code>RMTSAMPLEFLIGHT</code>.
		 *
		 * @param {object} [mModelParameters] Map of parameters for model construction...
		 * @returns {ODataModel} The model
		 */
		createModelForV2FlightService : function (mModelParameters) {
			var oLogMock = this.oLogMock;

			// The following warnings are logged when the RMTSAMPLEFLIGHT meta model is loaded
			[
				"semantics", "creatable", "creatable", "semantics", "semantics", "value-list",
				"value-list", "label", "label", "value-list", "value-list", "value-list",
				"value-list", "value-list", "value-list", "value-list", "label", "label",
				"supported-formats", "addressable", "value-list"
			].forEach(function (sAnnotation) {
				oLogMock.expects("warning")
					.withExactArgs("Unsupported annotation 'sap:" + sAnnotation + "'",
						sinon.match.string, "sap.ui.model.odata.v4.lib._V2MetadataConverter");
			});

			mModelParameters = Object.assign({}, {odataVersion : "2.0"}, mModelParameters);

			return this.createModel("/sap/opu/odata/IWFND/RMTSAMPLEFLIGHT/", mModelParameters, {
					"/sap/opu/odata/IWFND/RMTSAMPLEFLIGHT/$metadata"
						: {source : "model/RMTSAMPLEFLIGHT.metadata.xml"}
				});
		},

		/**
		 * Creates a V4 OData model for V2 service <code>GWSAMPLE_BASIC</code>.
		 *
		 * @param {object} [mModelParameters] Map of parameters for model construction...
		 * @returns {ODataModel} The model
		 */
		createModelForV2SalesOrderService : function (mModelParameters) {
			var oLogMock = this.oLogMock;

			// The following warnings are logged when the GWSAMPLE_BASIC meta model is loaded
			["filterable", "sortable"].forEach(function (sAnnotation) {
				oLogMock.expects("warning")
					.withExactArgs("Unsupported SAP annotation at a complex type in"
						+ " '/sap/opu/odata/IWBEP/GWSAMPLE_BASIC/$metadata'",
						"sap:" + sAnnotation + " at property 'GWSAMPLE_BASIC.CT_String/String'",
						"sap.ui.model.odata.v4.lib._V2MetadataConverter");
			});

			mModelParameters = Object.assign({}, {odataVersion : "2.0"}, mModelParameters);

			return this.createModel("/sap/opu/odata/IWBEP/GWSAMPLE_BASIC/", mModelParameters, {
					"/sap/opu/odata/IWBEP/GWSAMPLE_BASIC/$metadata"
						: {source : "model/GWSAMPLE_BASIC.metadata.xml"},
					"/sap/opu/odata/IWBEP/GWSAMPLE_BASIC/annotations.xml"
						: {source : "model/GWSAMPLE_BASIC.annotations.xml"}
				});
		},

		/**
		 * Creates a V4 OData model for <code>zui5_epm_sample</code>.
		 *
		 * @param {object} [mModelParameters] Map of parameters for model construction...
		 * @param {map} [mAdditionalFixture]
		 *   The additional fixture. See {@link sap.ui.test.TestUtils.useFakeServer}
		 * @returns {ODataModel} The model
		 */
		createSalesOrdersModel : function (mModelParameters, mAdditionalFixture) {
			return this.createModel(sSalesOrderService, mModelParameters,
				Object.assign({
					"/sap/opu/odata4/sap/zui5_testv4/default/sap/zui5_epm_sample/0002/$metadata"
						: {source : "odata/v4/data/metadata_zui5_epm_sample.xml"}
				}, mAdditionalFixture));
		},

		/**
		 * Creates a V4 OData model for <code>zui5_epm_sample</code> using client "123".
		 *
		 * @param {object} [mModelParameters] Map of parameters for model construction...
		 * @returns {ODataModel} The model
		 */
		createSalesOrdersModel123 : function (mModelParameters) {
			return this.createModel(sSalesOrderService + "?sap-client=123", mModelParameters, {
					"/sap/opu/odata4/sap/zui5_testv4/default/sap/zui5_epm_sample/0002/$metadata?sap-client=123"
						: {source : "odata/v4/data/metadata_zui5_epm_sample.xml"}
				});
		},

		/**
		 * Creates a V4 OData model for <code>TEA_BUSI</code>.
		 *
		 * @param {object} [mModelParameters] Map of parameters for model construction
		 * @returns {sap.ui.model.odata.v4.ODataModel} The model
		 */
		createTeaBusiModel : function (mModelParameters) {
			return this.createModel(sTeaBusi, mModelParameters, {
					"/sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001/$metadata"
						: {source : "odata/v4/data/metadata.xml"},
					"/sap/opu/odata4/IWBEP/TEA/default/iwbep/tea_busi_product/0001/$metadata"
						: {source : "odata/v4/data/metadata_tea_busi_product.xml"}
				});
		},

		/**
		 * Creates a V4 OData model for <code>TEA_BUSI</code> using client "123".
		 *
		 * @param {object} [mModelParameters] Map of parameters for model construction
		 * @returns {sap.ui.model.odata.v4.ODataModel} The model
		 */
		createTeaBusiModel123 : function (mModelParameters) {
			return this.createModel(sTeaBusi + "?sap-client=123", mModelParameters, {
					"/sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001/$metadata?sap-client=123"
						: {source : "odata/v4/data/metadata.xml"},
					"/sap/opu/odata4/IWBEP/TEA/default/iwbep/tea_busi_product/0001/$metadata?sap-client=123"
						: {source : "odata/v4/data/metadata_tea_busi_product.xml"}
				});
		},

		/**
		 * Helper to create a third sales order in a table. Performs checks on change events,
		 * requests and $count.
		 *
		 * @returns {sap.ui.model.odata.v4.Context} Context of the created sales order
		 */
		createThird : function () {
			this.expectChange("count", "4")
				.expectChange("id", ["", "44", "43", "42"])
				.expectChange("note", ["New 3", "New 2", "New 1", "First SalesOrder"]);

			return this.oView.byId("table").getBinding("items").create({Note : "New 3"}, true);
		},

		/**
		 * Helper to create two sales orders in a table, saved after each create. Performs checks on
		 * change events, requests and $count.
		 *
		 * @param {object} assert The QUnit assert object
		 * @returns {Promise} Promise resolving when the test is through
		 */
		createTwiceSaveInBetween : function (assert) {
			var oBinding,
				oCreatedContext,
				oModel = this.createSalesOrdersModel({
					autoExpandSelect : true,
					updateGroupId : "update"
				}),
				sView = '\
<Text id="count" text="{$count}"/>\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</Table>',
				that = this;

			this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
					// "@odata.count" : "1", // short read no $count parameter needed
					value : [{
						Note : "First SalesOrder",
						SalesOrderID : "42"
					}]
				})
				.expectChange("count")
				.expectChange("id", ["42"])
				.expectChange("note", ["First SalesOrder"]);

			return this.createView(assert, sView, oModel).then(function () {
				oBinding = that.oView.byId("table").getBinding("items");

				that.expectChange("count", "1");

				that.oView.byId("count").setBindingContext(oBinding.getHeaderContext());

				return that.waitForChanges(assert);
			}).then(function () {
				that.expectChange("count", "2")
					.expectChange("id", ["", "42"])
					.expectChange("note", ["New 1", "First SalesOrder"]);

				oCreatedContext = oBinding.create({Note : "New 1"}, true);

				return that.waitForChanges(assert);
			}).then(function () {
				that.expectRequest({
						method : "POST",
						url : "SalesOrderList",
						payload : {Note : "New 1"}
					}, {
						Note : "New 1",
						SalesOrderID : "43"
					})
					.expectChange("id", ["43"]);

				return Promise.all([
					oCreatedContext.created(),
					that.oModel.submitBatch("update"),
					that.waitForChanges(assert)
				]);
			}).then(function () {
				that.expectChange("count", "3")
					.expectChange("id", ["", "43", "42"])
					.expectChange("note", ["New 2", "New 1", "First SalesOrder"]);

				oCreatedContext = oBinding.create({Note : "New 2"}, true);

				return that.waitForChanges(assert);
			}).then(function () {
				that.expectRequest({
						method : "POST",
						url : "SalesOrderList",
						payload : {Note : "New 2"}
					}, {
						Note : "New 2",
						SalesOrderID : "44"
					})
					.expectChange("id", ["44"]);

				return Promise.all([
					oCreatedContext.created(),
					that.oModel.submitBatch("update"),
					that.waitForChanges(assert)
				]);
			});
		},

		/**
		 * Creates a view with a property used for Context#setProperty tests and returns a promise
		 * on the context to work with. The view contains an input control to visualize changes and
		 * messages.
		 *
		 * @param {object} assert The QUnit assert object
		 * @returns {Promise<sap.ui.model.odata.v4.Context>} A promise on the context
		 */
		createSetPropertyScenario : function (assert) {
			var oModel = this.createTeaBusiModel({
					autoExpandSelect : true,
					updateGroupId : "update"
				}),
				sView = '\
<FlexBox id="form" binding="{/TEAMS(\'TEAM_01\')}">\
	<Input id="name" value="{Name}"/>\
</FlexBox>',
				that = this;

			this.expectRequest("TEAMS('TEAM_01')?$select=Name,Team_Id", {
					Name : "Team #1",
					Team_Id : "TEAM_01"
				})
				.expectChange("name", "Team #1");

			return this.createView(assert, sView, oModel).then(function () {
				return that.oView.byId("form").getObjectBinding().getBoundContext();
			});
		},

		/**
		 * Creates a V4 OData model for special cases (not backed by Gateway).
		 *
		 * @param {object} [mModelParameters] Map of parameters for model construction...
		 * @param {map} [mAdditionalFixture]
		 *   The additional fixture. See {@link sap.ui.test.TestUtils.useFakeServer}
		 * @returns {ODataModel} The model
		 */
		createSpecialCasesModel : function (mModelParameters, mAdditionalFixture) {
			return this.createModel("/special/cases/", mModelParameters,
				Object.assign({
					"/special/cases/$metadata"
						: {source : "odata/v4/data/metadata_special_cases.xml"}
				}, mAdditionalFixture));
		},

		/**
		 * Creates the view and attaches it to the model. Checks that the expected requests (see
		 * {@link #expectRequest} are fired and the controls got the expected changes (see
		 * {@link #expectChange}).
		 *
		 * The given XML is embedded into a sap.ui.core.mvc.View with sap.m as the default namespace
		 * and aliases "mvc" for sap.ui.core.mvc and "t" for sap.ui.table. Both sap.m.Table and
		 * sap.ui.table.Table can (and should) be simplified. Simply add the dependent controls as
		 * direct children of the table. The function takes care to properly embed them into columns
		 * (one column per control).
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {string} [sViewXML=""] The view content as XML
		 * @param {sap.ui.model.odata.v4.ODataModel} [oModel] The model; it is attached to the view
		 *   and to the test instance.
		 *   If no model is given, <code>createTeaBusiModel</code> is used - unless
		 *   <code>null</code> is explicitly given.
		 * @param {object} [oController]
		 *   An object defining the methods and properties of the controller
		 * @param {object} [mPreprocessors] A map from the specified preprocessor type (e.g. "xml")
		 *    to a preprocessor configuration, see {@link sap.ui.core.mvc.View.create}
		 * @returns {Promise} A promise that is resolved when the view is created and all expected
		 *   values for controls have been set
		 */
		createView : function (assert, sViewXML, oModel, oController, mPreprocessors) {
			var fnLockGroup,
				fnReportError,
				that = this;

			/*
			 * Stub function for _Requestor#sendBatch. Checks that all requests in the batch are as
			 * expected.
			 *
			 * @param {object[]} aRequests The array of requests in a $batch
			 * @param {string} sGroupId The group ID of the $batch
			 * @returns {Promise} A promise on the array of batch responses
			 */
			function checkBatch(aRequests, sGroupId) {
				/*
				 * Processes a request or a change set within a batch/change set.
				 * @param {number} iChangeSetNo Number of the change set in the current batch
				 *   starting with 1; a value of 0 indicates that the request is not part of a
				 *   change set
				 * @param {object} oRequest The request
				 * @param {number} i The request's position in the batch/change set
				 * @returns {Promise} A promise resolving with an object suitable for visit of
				 *   _Requestor#submitBatch
				 */
				function processRequest(iChangeSetNo, oRequest, i) {
					if (Array.isArray(oRequest)) {
						return processRequests(oRequest, i + 1);
					}
					if (iChangeSetNo > 0) {
						oRequest.$ContentID = i + "." + (iChangeSetNo - 1);
					}
					return checkRequest(oRequest.method, oRequest.url, oRequest.headers,
						oRequest.body, undefined, sGroupId, that.iBatchNo, iChangeSetNo || i + 1,
						oRequest.$ContentID
					).catch(function (oError) {
						if (oError.$insideBatch) {
							// convert the error back to a response
							return {
								headers : Object.assign({"Content-Type" : "application/json"},
									oError.headers),
								status : oError.status,
								body : {error : oError.error}
							};
						}
						oError.resourcePath = undefined;
						throw oError; // let the $batch itself fail
					}).then(function (oResponse) {
						var mHeaders = oResponse.messages
								? Object.assign({}, oResponse.headers,
									{"sap-messages" : oResponse.messages})
								: oResponse.headers;

						return {
							headers : mHeaders,
							status : oResponse.status || 200,
							responseText : typeof oResponse.body === "object"
								? JSON.stringify(oResponse.body) // content type "application/json"
								: oResponse.body // keep string for "text/plain"
						};
					});
				}

				/*
				 * @param {object[]} aRequests The array of requests in a $batch or in a change set
				 * @param {number} iChangeSetNo Number of the change set in the current batch
				 *   starting with 1; a value of 0 indicates that the request is not part of a
				 *   change set
				 * @returns {Promise} A promise on the array of batch responses
				 */
				function processRequests(aRequests0, iChangeSetNo) {
					return Promise.all(
						aRequests0.map(processRequest.bind(null, iChangeSetNo))
					).then(function (aResponses) {
						var iErrorIndex = aResponses.findIndex(function (oResponse) {
								return oResponse.status >= 300;
							});

						if (iErrorIndex >= 0) {
							return iChangeSetNo
								? aResponses[iErrorIndex] // only one error for the whole change set
								: aResponses.slice(0, iErrorIndex + 1);
						}
						return aResponses;
					});
				}

				that.iBatchNo += 1;

				return processRequests(aRequests, 0);
			}

			/*
			 * Stub function for _Requestor#sendRequest. Checks that the expected request arrived
			 * and returns a promise for its response.
			 *
			 * @param {string} sMethod The request method
			 * @param {string} sUrl The request URL
			 * @param {object} mHeaders The headers (including various generic headers)
			 * @param {object|string} [vPayload] The payload (string from the requestor, object from
			 *   checkBatch)
			 * @param {string} [sOriginalResourcePath] The path by which the resource has originally
			 *   been requested
			 * @param {string} [sGroupId] The group ID this request, only available when sent with
			 *   a batch
			 * @param {number} [iBatchNo] Number of the batch which the request belongs to
			 * @param {number} [iChangeSetNo] Number of the change set in the current batch which
			 *   the request belongs to
			 * @param {string} [sContentID] Content ID of the actual request; only available if the
			 *   request is part of a change set
			 * @returns {Promise} A promise resolving with an object having following properties:
			 *     {string|object} body - The response body of the matching request
			 *     {string} [messages] - The messages contained in the "sap-messages" response
			 *       header as a JSON string
			 *     {string} resourcePath - The value of "sUrl"
			 *   If the response (see #expectRequest) is of type "Error" the promise rejects with
			 *   the error.
			 */
			function checkRequest(sMethod, sUrl, mHeaders, vPayload, sOriginalResourcePath,
					sGroupId, iBatchNo, iChangeSetNo, sContentID) {
				var oActualRequest = {
						method : sMethod,
						url : sUrl,
						headers : _Helper.resolveIfMatchHeader(mHeaders),
						payload : typeof vPayload === "string" ? JSON.parse(vPayload) : vPayload
					},
					oExpectedRequest = that.consumeExpectedRequest(oActualRequest),
					oResponse,
					mResponseHeaders,
					bWaitForResponse = true;

				function checkFinish() {
					if (!that.aRequests.length && !that.iPendingResponses) {
						// give some time to process the response
						setTimeout(that.checkFinish.bind(that, assert), 0);
					}
				}

				function readableUrl(sUrl) {
					return sUrl.replaceAll(/%([0-9a-fA-F]{2})/g,
						(_s, n) => String.fromCharCode(Number.parseInt(n, 16)));
				}

				if (iBatchNo === undefined) {
					that.iBatchNo += 1;
				}

				delete oActualRequest.headers["Accept"];
				delete oActualRequest.headers["Accept-Language"];
				delete oActualRequest.headers["Content-Type"];
				if (oExpectedRequest) {
					if (!oExpectedRequest.headers) {
						oExpectedRequest.headers = {};
						delete oActualRequest.headers["sap-cancel-on-close"];
					}
					oResponse = oExpectedRequest.response;
					if (typeof oResponse === "function") { // invoke "just in time"
						oResponse = oResponse();
					}
					bWaitForResponse = !(oResponse && typeof oResponse.then === "function");
					mResponseHeaders = oExpectedRequest.responseHeaders;
					delete oExpectedRequest.response;
					delete oExpectedRequest.responseHeaders;
					if ("groupId" in oExpectedRequest) {
						oActualRequest.groupId = sGroupId;
					}
					if ("batchNo" in oExpectedRequest) {
						oActualRequest.batchNo = iBatchNo ?? -that.iBatchNo;
					}
					if ("changeSetNo" in oExpectedRequest) {
						oActualRequest.changeSetNo = iChangeSetNo;
					}
					if ("$ContentID" in oExpectedRequest) {
						oActualRequest.$ContentID = sContentID;
					}
					assert.deepEqual(oActualRequest, oExpectedRequest,
						sMethod + " " + readableUrl(sUrl) + " (batchNo: " + iBatchNo + ")");
				} else {
					assert.ok(false, sMethod + " " + readableUrl(sUrl) + " (unexpected)");
					oResponse = {value : []}; // dummy response to avoid further errors
					mResponseHeaders = {};
				}

				if (bWaitForResponse) {
					that.iPendingResponses += 1;
				} else {
					checkFinish();
				}

				return Promise.resolve(oResponse).then(function (oResponseBody) {
					if (oResponseBody instanceof Error) {
						// missing only for metadata and security token requests
						oResponseBody.requestUrl = that.oModel.sServiceUrl + sUrl;
						// this is also missing for $batch itself! @see processRequest
						oResponseBody.resourcePath = sOriginalResourcePath;
						oResponseBody.headers = mResponseHeaders;
						throw oResponseBody;
					}

					if (typeof oResponseBody === "number") {
						oResponseBody = String(oResponseBody);
					} else if (oResponseBody !== undefined && typeof oResponseBody !== "object"
						&& typeof oResponseBody !== "string") {
						throw new Error("Response must be object|string: " + oResponseBody);
					}

					if ("ETag" in mResponseHeaders) {
						oResponseBody["@odata.etag"] = mResponseHeaders.ETag;
					}
					return {
						body : oResponseBody,
						messages : mResponseHeaders["sap-messages"],
						resourcePath : sUrl
					};
				}).finally(function () {
					if (bWaitForResponse) {
						that.iPendingResponses -= 1;
					}
					// Waiting may be over after the promise has been handled
					checkFinish();
				});
			}

			// A wrapper for _Requestor#lockGroup that attaches a stack trace to the lock
			function lockGroup() {
				var oError,
					oLock = fnLockGroup.apply(this, arguments);

				if (!oLock.$stack) {
					oError = new Error();
					if (oError.stack) {
						oLock.$stack = oError.stack.split("\n").slice(2).join("\n");
					}
				}

				return oLock;
			}

			function reportError(sLogMessage, _sReportingClassName, oError) {
				var oExpectedError;

				if (oError.canceled) {
					oExpectedError = that.aExpectedCanceledErrors.shift();
					if (oExpectedError) {
						assert.strictEqual(sLogMessage, oExpectedError.logMessage, "sLogMessage");
						assert.strictEqual(oError.message, oExpectedError.errorMessage,
							"oError.message");
					} else if (!that.rIgnoredCanceledErrors
							|| !that.rIgnoredCanceledErrors.test(oError.message)) {
						assert.ok(false, "Unexpected canceled error:\nsLogMessage=" + sLogMessage
							+ "\noError.message=" + oError.message);
					}
					that.checkFinish(assert);
					return;
				}

				fnReportError.apply(this, arguments);
			}

			this.oModel = oModel === null ? null : oModel || this.createTeaBusiModel();
			if (this.oModel && this.oModel.submitBatch) {
				if (!this.oModel.$keepSend) {
					// stub request methods for the requestor prototype to also check requests from
					// "hidden" model instances like the code list model...
					this.mock(Object.getPrototypeOf(this.oModel.oRequestor)).expects("sendBatch")
						.atLeast(0).callsFake(checkBatch);
					this.mock(Object.getPrototypeOf(this.oModel.oRequestor)).expects("sendRequest")
						.atLeast(0).callsFake(checkRequest);
					// ...but keep following stubs even after test ends!
					this.oModel.oRequestor.sendBatch = checkBatch;
					this.oModel.oRequestor.sendRequest = checkRequest;
				}
				fnLockGroup = this.oModel.oRequestor.lockGroup;
				this.oModel.oRequestor.lockGroup = lockGroup;
				fnReportError = this.oModel.reportError;
				this.oModel.reportError = reportError;
			} // else: it's a meta model
			//assert.ok(true, sViewXML); // uncomment to see XML in output, in case of parse issues

			return View.create({
				type : "XML",
				controller : oController && new (Controller.extend(uid(), oController))(),
				definition : xml(sViewXML || ""),
				preprocessors : mPreprocessors
			}).then(function (oView) {
				Object.keys(that.mChanges).forEach(function (sControlId) {
					var oControl = oView.byId(sControlId);

					if (oControl) {
						that.setFormatter(assert, oControl, sControlId);
					}
				});
				Object.keys(that.mListChanges).forEach(function (sControlId) {
					var oControl = oView.byId(sControlId);

					if (oControl) {
						that.setFormatter(assert, oControl, sControlId, true);
					}
				});

				oView.setModel(that.oModel);
				// enable parse error messages in the message manager
				Messaging.registerObject(oView, true);
				// Place the view in the page so that it is actually rendered. In some situations,
				// esp. for the sap.ui.table.Table this is essential.
				oView.placeAt("qunit-fixture");
				that.oView = oView;

				return that.waitForChanges(assert, "createView");
			});
		},

		/**
		 * Test that the template output is as expected.
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {object} oXMLPreprocessorConfig Holds a preprocessor configuration for type "xml",
		 *    see {@link sap.ui.core.mvc.View.create}
		 * @param {string} sTemplate The template used to generate the expected view as XML
		 * @param {string} sView The expected resulting view from templating
		 * @returns {Promise} A promise that is resolved when the test is done
		 *
		 * @private
		 */
		doTestXMLTemplating : function (assert, oXMLPreprocessorConfig, sTemplate, sView) {
			var that = this;

			/*
			* Remove all namespaces and all spaces before tag ends (..."/>) and all tabs from the
			* given XML string.
			*
			* @param {string} sXml
			*   XML string
			* @returns {string}
			*   Normalized XML string
			*/
			function _normalizeXml(sXml) {
				/*jslint regexp: true*/
				sXml = sXml
					.replace(/ xmlns.*?=".*?"/g, "")
					.replace(/ \/>/g, "/>")
					// Replace all tabulators
					.replace(/\t/g, "");
				return sXml;
			}

			// allow indents in expectation
			sView = sView.replace(/\t/g, "");

			return this.createView(assert, sTemplate, null, undefined,
				{xml : oXMLPreprocessorConfig}).then(function () {
				assert.strictEqual(
					_normalizeXml(XMLHelper.serialize(that.oView._xContent)),
					_normalizeXml(XMLHelper.serialize(xml(sView)))
				);
			});
		},

		/**
		 * The following code (either {@link #createView} or anything before
		 * {@link #waitForChanges}) is expected to report an error with
		 * <code>canceled === true</code>. Note: The reporting class name is ignored.
		 *
		 * @param {string} sLogMessage - The expected log message
		 * @param {string} [sErrorMessage=sLogMessage] - The expected error message
		 * @returns {object} The test instance for chaining
		 */
		expectCanceledError : function (sLogMessage, sErrorMessage) {
			this.aExpectedCanceledErrors.push({
				logMessage : sLogMessage,
				errorMessage : sErrorMessage || sLogMessage
			});

			return this;
		},

		/**
		 * The following code (either {@link #createView} or anything before
		 * {@link #waitForChanges}) is expected to set a value (or multiple values) at the property
		 * "text" of the control with the given ID. <code>vValue</code> must be a list with expected
		 * values for each row if the control is created via a template in a list. Use a sparse list
		 * if changes are expected for some rows only.
		 *
		 * You must call the function before {@link #createView}, even if you do not expect a change
		 * to the control's value initially. This is necessary because createView must attach a
		 * formatter function to the binding info before the bindings are created in order to see
		 * the change. If you do not expect a value initially, leave out the vValue parameter or use
		 * an empty array.
		 *
		 * @example
		 * this.expectChange("foo", "bar"); // expect value "bar" for the control with ID "foo"
		 * this.expectChange("foo"); // listen to changes for the control with ID "foo", but do not
		 *                           // expect a change (in createView)
		 * this.expectChange("foo", []); // listen to changes for the control with ID "foo", but do
		 *                               // not expect a change (in createView). To be used if the
		 *                               // control is a template within a table.
		 * this.expectChange("foo", ["a", "b"]); // expect values for two rows of the control with
		 *                                       // ID "foo"
		 * this.expectChange("foo", ["a",, "b"]); // expect values for the rows 0 and 2 of the
		 *                                       // control with the ID "foo", because this is a
		 *                                       // sparse array in which index 1 is unset
		 * this.expectChange("foo", "d", "/MyEntitySet/ID");
		 *                                 // expect value "d" for control with ID "foo" in a
		 *                                 // meta model table on "/MyEntitySet/ID"
		 * this.expectChange("foo", "bar").expectChange("foo", "baz"); // expect 2 changes for "foo"
		 * this.expectChange("foo", null); // initialization due to #setContext
		 *
		 * @param {string} sControlId The control ID
		 * @param {string|string[]|number|number[]} [vValue] The expected value or a list of
		 *   expected values
		 * @param {string} [sRow] (Only for meta model tests) The path of the binding's parent
		 *   context, in case that a change is expected for a single row of a list; in this case
		 *   <code>vValue</code> must be a string
		 * @returns {object} The test instance for chaining
		 * @throws {Error} For unsupported or inconsistently used control IDs
		 */
		expectChange : function (sControlId, vValue, sRow) {
			var aExpectations,
				that = this;

			// Ensures that oObject[vProperty] is an array and returns it
			function array(oObject, vProperty) {
				oObject[vProperty] ??= [];

				return oObject[vProperty];
			}

			/*
			 * @param {boolean} bInList
			 */
			function isList(bInList) {
				if (sControlId in that.mIsListByControlId) {
					if (bInList !== that.mIsListByControlId[sControlId]) {
						throw new Error("Inconsistent usage of array values for " + sControlId);
					}
				} else {
					if (that.oView) {
						throw new Error("The first expectChange must be before createView: "
							+ sControlId); //... or you need to call #setFormatter!
					}
					that.mIsListByControlId[sControlId] = bInList;
				}
			}

			if (arguments.length === 3) {
				isList(true);
				aExpectations = array(this.mListChanges, sControlId);
				// This may create a sparse array this.mListChanges[sControlId]
				array(aExpectations, sRow).push(vValue);
			} else if (Array.isArray(vValue)) {
				isList(true);
				aExpectations = array(this.mListChanges, sControlId);
				vValue.forEach(function (vRowValue, i) {
					array(aExpectations, i).push(vRowValue);
				});
			} else {
				isList(false);
				aExpectations = array(this.mChanges, sControlId);
				if (arguments.length > 1) {
					aExpectations.push(vValue);
				}
			}

			return this;
		},

		/**
		 * Expects the given events to be fired until the next call to <code>waitForChanges</code>.
		 * Events are first filtered by event source and then compared.
		 *
		 * @param {object} assert
		 *   The QUnit assert object
		 * @param {object|string} vExpectedEventSourcePrefix
		 *   Expected prefix of event source's <code>this.toString()</code> representation; an
		 *   object is transformed into a string
		 * @param {object[]} aExpectedEvents
		 *   Expected events, each as <code>[this.toString(), sEventId, mParameters]</code> from the
		 *   perspective of {@link sap.ui.base.EventProvider#fireEvent}. For convenience,
		 *   <code>this.toString()</code> may omit <code>sExpectedEventSourcePrefix</code> and even
		 *   be undefined. <code>undefined</code> need not be explicitly specified for event
		 *   parameters.
		 * @returns {object} The test instance for chaining
		 */
		expectEvents : function (assert, vExpectedEventSourcePrefix, aExpectedEvents) {
			var sExpectedEventSourcePrefix = String(vExpectedEventSourcePrefix),
				that = this;

			EventProvider.prototype.fireEvent = function (sEventId, mParameters) {
				var aDetails,
					sThis = this.toString();

				if (sThis.startsWith(sExpectedEventSourcePrefix)) {
					aDetails = [sThis, sEventId, mParameters];

					assert.deepEqual(aDetails, that.aExpectedEvents.shift(),
						JSON.stringify(aDetails));
				}
				return fnFireEvent.apply(this, arguments); // "call through"
			};

			aExpectedEvents.forEach(function (aExpectedDetails) {
				aExpectedDetails[0] ??= "";
				if (!aExpectedDetails[0].startsWith(sExpectedEventSourcePrefix)) {
					aExpectedDetails[0] = sExpectedEventSourcePrefix + aExpectedDetails[0];
				}
				if (aExpectedDetails.length === 2) {
					aExpectedDetails[2] = undefined;
				}
			});
			this.aExpectedEvents = aExpectedEvents;

			return this;
		},

		/**
		 * The following code (either {@link #createView} or anything before
		 * {@link #waitForChanges}) is expected to report the given message. It is added to the list
		 * of messages that the MessageModel should contain in the end (see
		 * {@link #expectMessages}).
		 *
		 * Note : All expected messages should have a different message text.
		 *
		 * @param {object} oExpectedMessage The expected message with properties corresponding
		 *   to the getters of sap.ui.core.message.Message: message and type are required; code,
		 *   descriptionUrl, persistent (default false), target (default ""), technical (default
		 *   false) are optional; technicalDetails is only compared if given
		 * @param {boolean} [bHasMatcher] Whether the expected message has a Sinon.JS matcher
		 * @returns {object} The test instance for chaining
		 */
		expectMessage : function (oExpectedMessage, bHasMatcher) {
			const aTargets = oExpectedMessage.targets || [oExpectedMessage.target || ""];
			const oClone = Object.assign({
				code : undefined,
				descriptionUrl : undefined,
				persistent : false,
				targets : aTargets,
				technical : false
			}, oExpectedMessage);

			if (oExpectedMessage.target && oExpectedMessage.targets) {
				throw new Error("Use either target or targets, not both!");
			}
			delete oClone.target;

			this.aMessages.push(oClone);
			this.aMessages.bHasMatcher ||= bHasMatcher;

			return this;
		},

		/**
		 * The MessageModel is expected to contain <b>exactly</b> the given messages when either
		 * {@link #createView} or {@link #waitForChanges}) have finished. This expectation remains
		 * valid for each subsequent {@link #waitForChanges}), until a new expectation is given.
		 *
		 * Note: The order does not matter, but all expected messages should have a different
		 * message text.
		 *
		 * @param {object[]} aExpectedMessages The expected messages with properties corresponding
		 *   to the getters of sap.ui.core.message.Message: message and type are required; code,
		 *   descriptionUrl, persistent (default false), target (default ""), technical (default
		 *   false) are optional; technicalDetails is only compared if given
		 * @param {boolean} [bHasMatcher] Whether the expected messages have a Sinon.JS matcher
		 * @returns {object} The test instance for chaining
		 *
		 * @see #expectMessage
		 */
		expectMessages : function (aExpectedMessages, bHasMatcher) {
			this.aMessages = [];
			this.aMessages.bHasMatcher = false;
			aExpectedMessages.forEach((oMessage) => { this.expectMessage(oMessage, bHasMatcher); });

			return this;
		},

		/**
		 * The following code (either {@link #createView} or anything before
		 * {@link #waitForChanges}) is expected to perform the given request. <code>oResponse</code>
		 * describes how to react on the request. Usually you simply give the JSON for the response
		 * and the request will be responded in the next microtask.
		 *
		 * A failure response is mocked if <code>oResponse</code> is an <code>Error</code> instance.
		 * For a $direct request, this error must be created via {@link createError} and is
		 * immediately used to reject the promise of
		 * {@link sap.ui.model.odata.v4.lib._Requestor#request}.
		 *
		 * If the request is part of a $batch, there are two possibilities.
		 * <ul>
		 *   <li> If the error was created via {@link createErrorInsideBatch}, {@link #checkBatch}
		 *     converts it to a response and inserts it into the $batch response. If the request is
		 *     part of a change set, the error is used as a response for the complete change set
		 *     (the following requests do not need a response). GET requests following an error
		 *     request are rejected automatically and do not need a response.
		 *   <li> If the error was created via {@link createError}, the complete $batch fails.
		 * </ul>
		 *
		 * <code>oResponse</code> may also be a promise resolving with the response or the error. In
		 * this case you can control the response time (typically to control the order of the
		 * responses).
		 *
		 * @param {string|object} vRequest
		 *   The request with the properties "method", "url" and "headers". A string is interpreted
		 *   as URL with method "GET" and no headers. Spaces inside the URL are percent-encoded
		 *   automatically. Additionally the following properties may be given for requests within a
		 *   $batch:
		 *   <ul>
		 *      <li> groupId: the group ID by which the $batch was sent
		 *      <li> batchNo: the number of the ($direct or $batch) request within the test
		 *        (starting with 1). Use a negative number to expect a $direct request.
		 *      <li> changeSetNo: The number of the change set within $batch (starting with 1)
		 *      <li> $ContentID: The content ID of the request within the change set
		 *   </ul>
		 * @param {object|string|number|Error|Promise|function} [vResponse]
		 *   The response message to be returned from the requestor or a promise on it or a function
		 *   (invoked "just in time" when the request is actually sent) returning the response
		 *   message (object, string, number, error, or promise). May be omitted in case it does not
		 *   matter. For content type "application/json", an object is expected in the end, and for
		 *   "text/plain", a string - but a number is automatically converted to a string to
		 *   facilitate requests for ".../$count".
		 * @param {object} [mResponseHeaders]
		 *   The response headers to be returned from the requestor
		 * @returns {object} The test instance for chaining
		 * @throws {Error} In case some sanity check around "@odata.count" and $count fails
		 */
		expectRequest : function (vRequest, vResponse, mResponseHeaders) {
			var iCount,
				iLength,
				aMatches,
				iSkip = 0,
				iTop;

			if (typeof vRequest === "string") {
				vRequest = {
					url : vRequest
				};
				if (vRequest.url.startsWith("DELETE ")) {
					vRequest.method = "DELETE";
					vRequest.url = vRequest.url.slice(7);
				}
			}
			// ensure that these properties are defined (required for deepEqual)
			vRequest.method ??= "GET";
			vRequest.payload ??= undefined;
			vRequest.responseHeaders = mResponseHeaders || {};
			vRequest.response = vResponse
					// With GET it must be visible that there is no content, with the other
					// methods it must be possible to insert the ETag from the header
					|| (vRequest.method === "GET" ? null : {});
			vRequest.url = vRequest.url.replaceAll(/[ "\[\]{}]/g,
				(s) => `%${s.charCodeAt(0).toString(16).padStart(2, 0).toUpperCase()}`);
			if (vResponse && !(vResponse instanceof Error || vResponse instanceof Promise
					|| typeof vResponse === "function")) { // vResponse may be inspected
				if (rCountTrue.test(vRequest.url)) { // $count=true
					if (!("@odata.count" in vResponse)) {
						throw new Error('Missing "@odata.count" in response for ' + vRequest.method
							+ " " + vRequest.url);
					}
					if (typeof vResponse["@odata.count"] !== "string") {
						throw new Error('Unexpected "@odata.count" : ' + vResponse["@odata.count"]
							+ " in response for " + vRequest.method + " " + vRequest.url);
					}
					if (!("@odata.nextLink" in vResponse)) {
						aMatches = rTop.exec(vRequest.url);
						if (aMatches) {
							iCount = parseInt(vResponse["@odata.count"]);
							iLength = vResponse.value.length;
							iTop = parseInt(aMatches[1]);
							aMatches = rSkip.exec(vRequest.url);
							if (aMatches) {
								iSkip = parseInt(aMatches[1]);
							}
							if (iLength !== iTop && iSkip + iLength !== iCount) {
								throw new Error("Unexpected short read?");
							}
						}
					}
				}
				if (!rCountUrl.test(vRequest.url) && rCollection.test(vRequest.url)) {
					// collection response expected (Note: d.results is V2)
					const aObjects = vResponse.d?.results || vResponse.value;
					if (!Array.isArray(aObjects)
						|| !aObjects.every((o) => typeof o === "object")) {
						throw new Error('Missing "value" array of objects in response for '
							+ vRequest.method + " " + vRequest.url);
					}
				}
			}
			this.aRequests.push(vRequest);

			return this;
		},

		/**
		 * Allows that the property "text" of the control with the given ID is set to undefined or
		 * null. This may happen when the property is part of a list, this list is reset and the
		 * request to deliver the new value is slowed down due to a group lock. (Then the row
		 * context might be destroyed in a prerendering task.)
		 *
		 * @param {string} sControlId The control ID
		 * @returns {object} The test instance for chaining
		 */
		ignoreNullChanges : function (sControlId) {
			this.mIgnoredChanges[sControlId] = true;

			return this;
		},

		/**
		 *  Create a view with a relative ODataListBinding which is ready to create a new entity.
		 *
		 * @param {object} assert The QUnit assert object
		 * @returns {Promise} A promise that is resolved when the view is created and ready to
		 *   create a relative entity
		 */
		prepareTestForCreateOnRelativeBinding : function (assert) {
			var oModel = this.createTeaBusiModel({updateGroupId : "update"}),
				sView = '\
<FlexBox id="form" binding="{path : \'/TEAMS(\\\'42\\\')\',\
	parameters : {$expand : {TEAM_2_EMPLOYEES : {$select : \'ID,Name\'}}}}">\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Text id="id" text="{ID}"/>\
		<Text id="text" text="{Name}"/>\
	</Table>\
</FlexBox>';

			this.expectRequest("TEAMS('42')?$expand=TEAM_2_EMPLOYEES($select=ID,Name)", {
					TEAM_2_EMPLOYEES : [
						{ID : "2", Name : "Frederic Fall"}
					]
				})
				.expectChange("id", ["2"])
				.expectChange("text", ["Frederic Fall"]);

			return this.createView(assert, sView, oModel);
		},

		/**
		 * Removes the control with the given ID from the given form in the view created by
		 * {@link #createView}.
		 *
		 * @param {object} oForm The form control
		 * @param {string} sControlId The ID of the control to remove
		 */
		removeFromForm : function (oForm, sControlId) {
			oForm.removeItem(this.oView.createId(sControlId));
		},

		/**
		 * Removes the control with the given ID from the given form in the view created by
		 * {@link #createView}.
		 * Recreates the list binding as only then changes to the aggregation's template control are
		 * applied.
		 *
		 * @param {object} oTable The table control
		 * @param {string} sControlId The ID of the control to remove
		 */
		removeFromTable : function (oTable, sControlId) {
			var bRelative = oTable.getBinding("items").isRelative(),
				oTemplate = oTable.getBindingInfo("items").template;

			oTemplate.removeCell(this.oView.byId(sControlId));
			// ensure template control is not destroyed on re-creation of the "items" aggregation
			delete oTable.getBindingInfo("items").template;
			oTable.bindItems(Object.assign({}, oTable.getBindingInfo("items"),
				{suspended : !bRelative, template : oTemplate}));
		},

		/**
		 * Sets the formatter function which calls {@link #checkValue} for the given control.
		 * Note that you may only use controls that have a 'text' or a 'value' property.
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {sap.ui.base.ManagedObject} oControl The control
		 * @param {string} sControlId The (symbolic) control ID for which changes are expected
		 * @param {boolean} [bInList] Whether the control resides in a list item
		 */
		setFormatter : function (assert, oControl, sControlId, bInList) {
			var oBindingInfo = oControl.getBindingInfo("text") || oControl.getBindingInfo("value"),
				bFoundInList,
				oHere,
				sName,
				fnOriginalFormatter = oBindingInfo.formatter,
				oType = oBindingInfo.type,
				bIsCompositeType = oType && oType.getMetadata().isA("sap.ui.model.CompositeType"),
				that = this;

			bInList = !!bInList; // must be a boolean
			if (this.mIsListByControlId[sControlId] !== undefined
				&& this.mIsListByControlId[sControlId] !== bInList) {
					throw new Error("Inconsistent usage of array values for " + sControlId);
			}
			for (oHere = oControl; oHere; oHere = oHere.getParent()) {
				sName = oHere.getMetadata().getName();
				if (sName.includes("Column") || sName.includes("List")) {
					bFoundInList = true;
					break;
				}
			}
			if (bInList) {
				if (!bFoundInList && oControl.getParent() && !sControlId.endsWith("__IN_LIST")) {
					// there are exceptions for direct calls to #setFormatter and some weird cases
					// with no list/table
					throw new Error("Unexpected bInList for sControlId: " + sControlId);
				}
			} else if (bFoundInList) {
				throw new Error("Missing bInList for sControlId: " + sControlId);
			}
			this.mIsListByControlId[sControlId] = bInList;

			oBindingInfo.formatter = function (sValue) {
				var oBinding,
					oContext = bInList ? this.getBindingContext() : undefined,
					vRow;

				if (fnOriginalFormatter) {
					sValue = fnOriginalFormatter.apply(this, arguments);
				} else if (bIsCompositeType) {
					// composite type at binding with type and no original formatter: call the
					// type's formatValue, as CompositeBinding#getExternalValue calls only the
					// formatter if it is set
					sValue = oType.formatValue.call(oType, Array.prototype.slice.call(arguments),
						"string");
				}
				// CompositeType#formatValue is called each time a part changes; we expect null if
				// not all parts are set as it is the case for sap.ui.model.odata.type.Unit.
				// Only check the value once all parts are available.
				if (!bIsCompositeType || sValue !== null) {
					if (oContext) { // Note: this implies bInList
						if (oContext.getBinding) { // v4.Context
							oBinding = oContext.getBinding();
							while (!(oBinding instanceof ODataListBinding)) {
								oContext = oBinding.getContext();
								oBinding = oContext.getBinding();
							}
							vRow = oContext.getIndex();
							if (oContext.isDeleted() || vRow === undefined) {
								return sValue; // a deleted context w/o row
							}
						} else { // e.g. meta model
							vRow = oContext.getPath();
						}
					} else if (bInList) { // a list property that lost its row context
						return sValue; // do not report the change event
					}
					that.checkValue(assert, sValue, sControlId, vRow);
				}

				return sValue;
			};
		},

		/**
		 * Sets an invalid value into an input control with id = 'budgetCurrency' and resolves after
		 * awaiting changes.
		 *
		 * @param {object} assert - The QUnit assert object
		 * @param {string} [sModelBudgetCurrency="EUR"] - The model's BudgetCurrency value
		 * @returns {Promise}
		 *   A promise which resolves after awaiting changes
		 */
		setInvalidBudgetCurrency : function (assert, sModelBudgetCurrency) {
			var oInput = this.oView.byId("budgetCurrency"),
				sMessage = "EnterTextMaxLength 5";

			this.expectMessages([{
					message : sMessage,
					persistent : false,
					target : this.oView.createId("budgetCurrency/value"),
					technical : false,
					type : "Error"
				}]);

			TestUtils.withNormalizedMessages(function () {
				// Note: Because the invalid value has to be set via control, changes for that
				// control cannot be observed via expectChange
				oInput.setValue("INVALID");
			});

			assert.strictEqual(oInput.getValue(), "INVALID");
			assert.strictEqual(oInput.getBinding("value").getValue(),
				sModelBudgetCurrency === undefined ? "EUR" : sModelBudgetCurrency);

			return Promise.all([
				this.checkValueState(assert, oInput, "Error", sMessage),
				this.waitForChanges(assert)
			]);
		},

		/**
		 * Waits for the expected requests and changes.
		 *
		 * @param {object} assert The QUnit assert object
		 * @param {string} [sTitle] Title for this section of a test
		 * @param {number} [iWaitTimeout=3000] The timeout time in milliseconds
		 * @returns {Promise} A promise that is resolved when all requests have been responded and
		 *   all expected values for controls have been set
		 */
		waitForChanges : function (assert, sTitle, iWaitTimeout) {
			var that = this;

			iWaitTimeout = Math.max(iWaitTimeout || 3000, iTestTimeout);
			return new SyncPromise(function (resolve) {
				that.resolve = resolve;
				// After three seconds everything should have run through
				// Resolve to have the missing requests and changes reported
				setTimeout(function () {
					resolve(true);
				}, iWaitTimeout);
				that.checkFinish();
			}).then(function (bTimeout) {
				var sControlId, aExpectedValuesPerRow, i, j;

				// Report (and forget about) missing requests
				that.aRequests.forEach(function (oRequest) {
					assert.ok(false, oRequest.method + " " + oRequest.url + " (not requested)");
				});
				that.aRequests = [];
				// Report (and forget about) missing canceled errors
				that.aExpectedCanceledErrors.forEach(function (oError) {
					assert.ok(false, "Expected canceled error:\nsLogMessage=" + oError.logMessage
						+ "\noError.message=" + oError.errorMessage);
				});
				that.aExpectedCanceledErrors = [];
				// Report (and forget about) missing changes
				for (sControlId in that.mChanges) {
					for (i in that.mChanges[sControlId]) {
						assert.ok(false, sControlId + ": "
							+ JSON.stringify(that.mChanges[sControlId][i]) + " (not set)");
					}
				}
				that.mChanges = {};
				for (sControlId in that.mListChanges) {
					// Note: This may be a sparse array
					aExpectedValuesPerRow = that.mListChanges[sControlId];
					for (i in aExpectedValuesPerRow) {
						for (j in aExpectedValuesPerRow[i]) {
							assert.ok(false, sControlId + "[" + i + "]: "
								+ JSON.stringify(aExpectedValuesPerRow[i][j]) + " (not set)");
						}
					}
				}
				that.mListChanges = {};
				assert.strictEqual(that.aExpectedEvents.length, 0, "no missing events");
				that.checkMessages(assert);
				assert.ok(!bTimeout, "waitForChanges(" + (sTitle || "") + "): "
					+ (bTimeout ? "Timeout (" + iWaitTimeout + " ms)" : "Done")
					+ " *".repeat(50));
			});
		}
	});

	//*********************************************************************************************
	// verify that error responses are processed correctly for direct requests
	//
	// Also check sap-statistics (JIRA: CPOUI5ODATAV4-1165)
	QUnit.test("error response: $direct (framework test)", function (assert) {
		var oModel,
			// no need to use UI5Date.getInstance as only the timestamp is relevant
			dRetryAfter = new Date(),
			sView = '<Text text="{/EMPLOYEES(\'1\')/ID}"/>';

		this.mock(Supportability).expects("isStatisticsEnabled").withExactArgs()
			.returns(true);
		oModel = this.createModel("/sap/statistics/", {groupId : "$direct"}, {
			"/sap/statistics/$metadata?sap-statistics=true"
				: {source : "odata/v4/data/metadata.xml"} // same as TEA_BUSI
		});
		this.oLogMock.expects("error").withArgs("Failed to read path /EMPLOYEES('1')/ID");
		this.expectRequest("EMPLOYEES('1')/ID?sap-statistics=true",
				createError({}, 503, dRetryAfter))
			.expectMessages([{
				code : "CODE",
				message : "Request intentionally failed",
				persistent : true,
				technical : true,
				technicalDetails : {
					httpStatus : 503, // CPOUI5ODATAV4-428, CPOUI5ODATAV4-965
					originalMessage : {
						code : "CODE",
						message : "Request intentionally failed"
					},
					retryAfter : dRetryAfter
				},
				type : "Error"
			}]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// verify that error responses are processed correctly for batch requests
	QUnit.test("error response: $batch (framework test)", function (assert) {
		var sView = '\
<Text text="{/EMPLOYEES(\'1\')/ID}"/>\
<Text text="{/EMPLOYEES(\'2\')/Name}"/>';

		this.oLogMock.expects("error").withArgs("Failed to read path /EMPLOYEES('1')/ID");
		this.oLogMock.expects("error").withArgs("Failed to read path /EMPLOYEES('2')/Name");

		this.expectRequest("EMPLOYEES('1')/ID", createErrorInsideBatch())
			.expectRequest("EMPLOYEES('2')/Name") // no response required
			.expectMessages([{
				code : "CODE",
				message : "Request intentionally failed",
				persistent : true,
				technical : true,
				technicalDetails : {
					httpStatus : 500, // CPOUI5ODATAV4-428
					originalMessage : {
						code : "CODE",
						message : "Request intentionally failed"
					}
				},
				type : "Error"
			}]);

		return this.createView(assert, sView);
	});

	//*********************************************************************************************
	// Check sap-statistics for $batch and $metadata (JIRA: CPOUI5ODATAV4-1165)
	QUnit.test("sap-statistics for $batch", function (assert) {
		var oModel;

		this.mock(Supportability).expects("isStatisticsEnabled").withExactArgs().returns(true);
		oModel = this.createModel("/sap/statistics/", {earlyRequests : true}, {
			"HEAD /sap/statistics/?sap-statistics=true" : {},
			"/sap/statistics/$metadata?sap-statistics=true"
				: {source : "odata/v4/data/metadata.xml"} // same as TEA_BUSI
		});
		oModel.submitBatch = false; // @see #createView
		this.mock(oModel.oRequestor).expects("sendRequest")
			.withArgs("POST", "$batch?sap-statistics=true").rejects();
		this.oLogMock.expects("error").withArgs("$batch failed");
		this.oLogMock.expects("error").withArgs("Failed to read path /EMPLOYEES('1')/ID");
		this.expectMessages([{
			message : "Error",
			persistent : true,
			technical : true,
			type : "Error"
		}, {
			message : "HTTP request was not processed because $batch failed",
			persistent : true,
			technical : true,
			type : "Error"
		}]);

		return this.createView(assert, '<Text text="{/EMPLOYEES(\'1\')/ID}"/>', oModel);
	});

	//*********************************************************************************************
	// verify that error responses are processed correctly for change sets
	//
	// ...even if 1st change set fails and 2nd contains more than one request (BCP: 2380075648)
	QUnit.test("error response: $batch w/ change set (framework test)", function (assert) {
		var oModel = this.createSalesOrdersModel(),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Input id="note" value="{Note}"/>\
</Table>\
<Text id="name" text="{/BusinessPartnerList(\'1\')/CompanyName}"/>',
			that = this;

		assert.strictEqual(oModel.getServiceUrl(), sSalesOrderService);

		this.expectRequest("SalesOrderList?$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1", Note : "Note 1"},
					{SalesOrderID : "2", Note : "Note 2"},
					{SalesOrderID : "3", Note : "Note 3"}
				]
			})
			.expectRequest("BusinessPartnerList('1')/CompanyName", {value : "SAP SE"})
			.expectChange("id", ["1", "2", "3"])
			.expectChange("note", ["Note 1", "Note 2", "Note 3"])
			.expectChange("name", "SAP SE");

		return this.createView(assert, sView, oModel).then(function () {
			var aTableRows = that.oView.byId("table").getItems(),
				oError = createErrorInsideBatch({
					details : [{
						code : "Code1",
						message : "Details 1"
					}]
				});

			that.oLogMock.expects("error")
				.withArgs("Failed to update path /SalesOrderList('1')/Note");
			that.oLogMock.expects("error")
				.withArgs("Failed to update path /SalesOrderList('2')/Note");
			that.oLogMock.expects("error")
				.withArgs("Failed to update path /SalesOrderList('3')/Note");
			that.oLogMock.expects("error")
				.withArgs("Failed to read path /BusinessPartnerList('1')/CompanyName");

			that.expectChange("note", ["Note 1 changed", "Note 2 changed", "Note 3 changed"])
				.expectRequest({
					changeSetNo : 1,
					method : "PATCH",
					url : "SalesOrderList('1')",
					payload : {Note : "Note 1 changed"}
				}, oError)
				.expectRequest({
					changeSetNo : 2,
					method : "PATCH",
					url : "SalesOrderList('2')",
					payload : {Note : "Note 2 changed"}
				}) // no response required
				.expectRequest({
					changeSetNo : 2,
					method : "PATCH",
					url : "SalesOrderList('3')",
					payload : {Note : "Note 3 changed"}
				}) // no response required
				.expectRequest("BusinessPartnerList('1')/CompanyName") // no response required
				.expectChange("name", null)
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					code : "Code1",
					message : "Details 1",
					persistent : true,
					type : "None"
				}]);

			aTableRows[0].getCells()[1].getBinding("value").setValue("Note 1 changed");
			oModel.submitBatch(oModel.getGroupId()); // close 1st change set
			aTableRows[1].getCells()[1].getBinding("value").setValue("Note 2 changed");
			aTableRows[2].getCells()[1].getBinding("value").setValue("Note 3 changed");
			that.oView.byId("name").getBinding("text").refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: PATCH an entity with a key predicate consisting of a single key property of type
	// Edm.DateTimeOffset. The PATCH failed and a UI5 message is created.
	// SNOW: CS20240007200281
	QUnit.test("CS20240007200281: key property is Edm.DateTimeOffset", async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sView = `
<Table id="table" items="{/Artists(ArtistID='42',IsActiveEntity=true)/_Event}">
	<Input id="name" value="{Name}"/>
</Table>`;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Event"
				+ "?$select=Name,TimeStamp&$skip=0&$top=100", {
				value : [
					{Name : "Taubertal Festival", TimeStamp : "08-08-2024T01:02:03Z"}
				]
			})
			.expectChange("name", ["Taubertal Festival"]);

		await this.createView(assert, sView, oModel);
		const aTableRows = this.oView.byId("table").getItems();

		this.expectChange("name", ["Woodstock"])
			.expectRequest({
				method : "PATCH",
				url : "Artists(ArtistID='42',IsActiveEntity=true)"
					+ "/_Event(08-08-2024T01%3A02%3A03Z)",
				payload : {Name : "Woodstock"}
			}, createErrorInsideBatch({target : "Name"}))
			.expectMessages([{
				code : "CODE",
				message : "Request intentionally failed",
				persistent : true,
				target : "/Artists(ArtistID='42',IsActiveEntity=true)"
					+ "/_Event(08-08-2024T01%3A02%3A03Z)/Name",
				technical : true,
				type : "Error"
			}]);

		this.oLogMock.expects("error")
			.withArgs("Failed to update path /Artists(ArtistID='42',IsActiveEntity=true)"
				+ "/_Event(08-08-2024T01%3A02%3A03Z)/Name");

		const oInput = aTableRows[0].getCells()[0];
		// code under test
		oInput.getBinding("value").setValue("Woodstock");

		await this.waitForChanges(assert);

		await this.checkValueState(assert, oInput, "Error",
			"Request intentionally failed");
	});

	//*********************************************************************************************
	// Scenario: Minimal test for an absolute ODataPropertyBinding. This scenario is comparable with
	// "FavoriteProduct" in the SalesOrders application.
	testViewStart("Absolute ODPB",
		'<Text id="text" text="{/EMPLOYEES(\'2\')/Name}"/>',
		{"EMPLOYEES('2')/Name" : {value : "Frederic Fall"}},
		{text : "Frederic Fall"}
	);

	//*********************************************************************************************
	// Scenario: Minimal test for an absolute ODataContextBinding without own parameters containing
	// a relative ODataPropertyBinding. The SalesOrders application does not have such a scenario.
	testViewStart("Absolute ODCB w/o parameters with relative ODPB", '\
<FlexBox binding="{/EMPLOYEES(\'2\')}">\
	<Text id="text" text="{Name}"/>\
</FlexBox>',
		{"EMPLOYEES('2')" : {Name : "Frederic Fall"}},
		{text : "Frederic Fall"}
	);

	//*********************************************************************************************
	// Scenario: Minimal test for an absolute ODataContextBinding with own parameters containing
	// a relative ODataPropertyBinding. The SalesOrders application does not have such a scenario.
	testViewStart("Absolute ODCB with parameters and relative ODPB", '\
<FlexBox binding="{path : \'/EMPLOYEES(\\\'2\\\')\', parameters : {$select : \'Name\'}}">\
	<Text id="text" text="{Name}"/>\
</FlexBox>',
		{"EMPLOYEES('2')?$select=Name" : {Name : "Frederic Fall"}},
		{text : "Frederic Fall"}
	);

	//*********************************************************************************************
	// Scenario: Minimal test for an absolute ODataListBinding without own parameters containing
	// a relative ODataPropertyBinding. This scenario is comparable with the suggestion list for
	// the "Buyer ID" while creating a new sales order in the SalesOrders application.
	// * Start the application and click on "Create sales order" button.
	// * Open the suggestion list for the "Buyer ID"
	testViewStart("Absolute ODLB w/o parameters and relative ODPB", '\
<Table items="{/EMPLOYEES}">\
	<Text id="text" text="{Name}"/>\
</Table>',
		{"EMPLOYEES?$skip=0&$top=100" :
			{value : [{Name : "Frederic Fall"}, {Name : "Jonathan Smith"}]}},
		{text : ["Frederic Fall", "Jonathan Smith"]}
	);

	//*********************************************************************************************
	// Scenario: Minimal test for an absolute ODataListBinding with own parameters containing
	// a relative ODataPropertyBinding. This scenario is comparable with the "Sales Orders" list in
	// the SalesOrders application.
	testViewStart("Absolute ODLB with parameters and relative ODPB", '\
<Table items="{path : \'/EMPLOYEES\', parameters : {$select : \'Name\'}}">\
	<Text id="text" text="{Name}"/>\
</Table>',
		{"EMPLOYEES?$select=Name&$skip=0&$top=100" :
			{value : [{Name : "Frederic Fall"}, {Name : "Jonathan Smith"}]}},
		{text : ["Frederic Fall", "Jonathan Smith"]}
	);

	//*********************************************************************************************
	// Scenario: Static and dynamic filters and sorters at absolute ODataListBindings influence
	// the query. This scenario is comparable with the "Sales Orders" list in the SalesOrders
	// application.
	// * Static filters ($filter system query option) are and-combined with dynamic filters (filter
	//   parameter)
	// * Static sorters ($orderby system query option) are appended to dynamic sorters (sorter
	//   parameter)
	testViewStart("Absolute ODLB with Filters and Sorters with relative ODPB", '\
<Table items="{path : \'/EMPLOYEES\', parameters : {\
			$select : \'Name\',\
			$filter : \'TEAM_ID eq 42\',\
			$orderby : \'Name desc\'\
		},\
		filters : {path : \'AGE\', operator : \'GT\', value1 : 21},\
		sorter : {path : \'AGE\'}\
	}">\
	<Text id="text" text="{Name}"/>\
</Table>',
		{"EMPLOYEES?$select=Name&$filter=AGE gt 21 and (TEAM_ID eq 42)&$orderby=AGE,Name desc&$skip=0&$top=100" :
			{value : [{Name : "Frederic Fall"}, {Name : "Jonathan Smith"}]}},
		{text : ["Frederic Fall", "Jonathan Smith"]}
	);

	//*********************************************************************************************
	// Scenario: Dependent list binding with own parameters causes a second request.
	// This scenario is similar to the "Sales Order Line Items" in the SalesOrders application.
	testViewStart("Absolute ODCB with parameters and relative ODLB with parameters", '\
<FlexBox binding="{path : \'/EMPLOYEES(\\\'2\\\')\', parameters : {$select : \'Name\'}}">\
	<Text id="name" text="{Name}"/>\
	<Table items="{path : \'EMPLOYEE_2_EQUIPMENTS\', parameters : {$select : \'Category\'}}">\
		<Text id="category" text="{Category}"/>\
	</Table>\
</FlexBox>',
		{
			"EMPLOYEES('2')?$select=Name" : {Name : "Frederic Fall"},
			"EMPLOYEES('2')/EMPLOYEE_2_EQUIPMENTS?$select=Category&$skip=0&$top=100" :
				{value : [{Category : "Electronics"}, {Category : "Furniture"}]}
		},
		{name : "Frederic Fall", category : ["Electronics", "Furniture"]}
	);

	//*********************************************************************************************
[false, true].forEach(function (bSuccess) {
	[false, true].forEach(function (bBubble) {
		var bDataReceivedOnBinding,
			bDataRequestedOnBinding,
			bDataReceivedOnModel,
			bDataRequestedOnModel,
			sTitle = "dataRequested/dataReceived, success=" + bSuccess + ", bubble=" + bBubble;

	function clearEvents() {
		bDataRequestedOnBinding = false;
		bDataReceivedOnBinding = false;
		bDataRequestedOnModel = false;
		bDataReceivedOnModel = false;
	}

	function setupListeners(assert, oBinding, oModel) {
		clearEvents();
		oBinding.attachDataRequested(function (oEvent) {
			bDataRequestedOnBinding = true;
			if (!bBubble) {
				oEvent.cancelBubble();
			}
		});
		oBinding.attachDataReceived(function (oEvent) {
			var oError = oEvent.getParameter("error");

			assert.deepEqual(oEvent.getParameter("data"), bSuccess ? {} : undefined);
			if (bSuccess) {
				assert.strictEqual(oError, undefined);
			} else {
				assert.strictEqual(oError.message, "Request intentionally failed");
				assert.strictEqual(oError.status, 500);
			}
			bDataReceivedOnBinding = true;
			if (!bBubble) {
				oEvent.cancelBubble();
			}
		});
		oModel.attachDataRequested(function () {
			bDataRequestedOnModel = true;
		}).attachDataRequested(function () {
			bDataReceivedOnModel = true;
		});
	}

	function checkEvents(assert, bModel) {
		assert.strictEqual(bDataRequestedOnBinding, true);
		assert.strictEqual(bDataReceivedOnBinding, true);
		assert.strictEqual(bDataRequestedOnModel, bModel);
		assert.strictEqual(bDataReceivedOnModel, bModel);
		clearEvents();
	}

	//*********************************************************************************************
	// Scenario: dataRequested/dataReceived on context binding and model. Check the initial request
	// (incl. cancelBubble), refresh and requestSideEffects
	QUnit.test("CPOUI5ODATAV4-1671: ODCB: " + sTitle, function (assert) {
		var oBinding,
			sView = '\
<FlexBox id="form" binding="{EMPLOYEES(\'1\')}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("name");

		return this.createView(assert, sView).then(function () {
			oBinding = that.oView.byId("form").getObjectBinding();
			setupListeners(assert, oBinding, that.oModel);

			that.expectRequest("EMPLOYEES('1')",
					bSuccess ? {Name : "Frederic Fall"} : createErrorInsideBatch()
				);
			if (bSuccess) {
				that.expectChange("name", "Frederic Fall");
			} else {
				that.oLogMock.expects("error")
					.withArgs("Failed to read path /EMPLOYEES('1')");
				that.oLogMock.expects("error")
					.withArgs("Failed to read path /EMPLOYEES('1')/Name");
				that.expectChange("name", null) // one change event is enforced
					.expectMessages([{
						code : "CODE",
						message : "Request intentionally failed",
						persistent : true,
						technical : true,
						type : "Error"
					}]);
			}

			oBinding.setContext(that.oModel.createBindingContext("/"));

			return that.waitForChanges(assert, bSuccess ? "success" : "failure");
		}).then(function () {
			checkEvents(assert, bBubble);

			if (bSuccess && bBubble) {
				that.expectRequest("EMPLOYEES('1')", {Name : "Frederic Fall"});

				return Promise.all([
					// code under test
					oBinding.requestRefresh(),
					that.waitForChanges(assert, "refresh")
				]).then(function () {
					checkEvents(assert, true);
					that.expectRequest("EMPLOYEES('1')", {Name : "Frederic Fall"});

					return Promise.all([
						// code under test
						oBinding.getBoundContext().requestSideEffects([""]),
						that.waitForChanges(assert, "requestSideEffects")
					]);
				}).then(function () {
					checkEvents(assert, false);
				});
			}
		});
	});

	//*********************************************************************************************
	// Scenario: dataRequested/dataReceived on list binding and model. Check the initial request
	// (incl. cancelBubble), refresh and requestSideEffects
	QUnit.test("CPOUI5ODATAV4-1671: ODLB: " + sTitle, function (assert) {
		var oBinding,
			sView = '\
<Table id="table" items="{EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectChange("name", []);

		return this.createView(assert, sView).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");
			setupListeners(assert, oBinding, that.oModel);

			that.expectRequest("EMPLOYEES?$skip=0&$top=100",
					bSuccess
						? {value : [{Name : "Frederic Fall"}, {Name : "Jonathan Smith"}]}
						: createErrorInsideBatch()
				);
			if (bSuccess) {
				that.expectChange("name", ["Frederic Fall", "Jonathan Smith"]);
			} else {
				that.oLogMock.expects("error")
					.withArgs("Failed to get contexts for " + sTeaBusi
						+ "EMPLOYEES with start index 0 and length 100");
				that.expectMessages([{
						code : "CODE",
						message : "Request intentionally failed",
						persistent : true,
						technical : true,
						type : "Error"
					}]);
			}

			oBinding.setContext(that.oModel.createBindingContext("/"));

			return that.waitForChanges(assert, bSuccess ? "success" : "failure");
		}).then(function () {
			checkEvents(assert, bBubble);

			if (bSuccess && bBubble) {
				that.expectRequest("EMPLOYEES?$skip=0&$top=100",
						{value : [{Name : "Frederic Fall"}, {Name : "Jonathan Smith"}]}
					);

				return Promise.all([
					// code under test
					oBinding.requestRefresh(),
					that.waitForChanges(assert, "refresh")
				]).then(function () {
					checkEvents(assert, true);
					that.expectRequest("EMPLOYEES?$skip=0&$top=100",
							{value : [{Name : "Frederic Fall"}, {Name : "Jonathan Smith"}]}
						);

					return Promise.all([
						// code under test
						oBinding.getHeaderContext().requestSideEffects([""]),
						that.waitForChanges(assert, "requestSideEffects")
					]);
				}).then(function () {
					checkEvents(assert, false);
				});
			}
		});
	});

	//*********************************************************************************************
	// Scenario: dataRequested/dataReceived on the property binding. Check refresh and
	// requestSideEffects. (The FlexBox is only required to have a context for requestSideEffects.)
	if (!(bSuccess && bBubble)) {
		return; // only testing refresh vs. requestSideEffects
	}

	QUnit.test("CPOUI5ODATAV4-1671: ODPB", function (assert) {
		var oBinding,
			sView = '\
<FlexBox id="form" binding="{/TEAMS(\'1\')}"/>\
<Text id="age" text="{/EMPLOYEES(\'1\')/AGE}"/>',
			that = this;

		this.expectRequest("EMPLOYEES('1')/AGE", {value : 42})
			.expectChange("age", "42");

		return this.createView(assert, sView).then(function () {
			oBinding = that.oView.byId("age").getBinding("text");
			setupListeners(assert, oBinding, that.oModel);

			that.expectRequest("EMPLOYEES('1')/AGE", {value : 42});

			return Promise.all([
				oBinding.requestRefresh(),
				that.waitForChanges(assert, "refresh")
			]);
		}).then(function () {
			checkEvents(assert, true);
			that.expectRequest("EMPLOYEES('1')/AGE", {value : 42});

			return Promise.all([
				that.oView.byId("form").getBindingContext().requestSideEffects([
					"/com.sap.gateway.default.iwbep.tea_busi.v0001.Container/EMPLOYEES/AGE"
				]),
				that.waitForChanges(assert, "requestSideEffects")
			]);
		}).then(function () {
			checkEvents(assert, false);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: Rebind a table that uses the cache of the form, so that a list binding is created
	// for which the data is already available in the cache. Ensure that it does not deliver the
	// contexts in getContexts for the initial refresh event, but fires an additional change event.
	// BCP: 1980383883
	//
	// Check how ODataMetaModel#fetchUIType works in case of Type="Edm.String" Nullable="false"
	// BCP: 2080251230
	QUnit.test("Relative ODLB created on a cache that already has its data", function (assert) {
		var sView = '\
<FlexBox id="form"\
		binding="{path : \'/TEAMS(\\\'1\\\')\', parameters : {$expand : \'TEAM_2_EMPLOYEES\'}}">\
	<Table id="table" items="{path : \'TEAM_2_EMPLOYEES\', templateShareable : true}">\
		<Text id="age" text="{AGE}"/>\
		<Text id="name" text="{Name}"/>\
	</Table>\
</FlexBox>',
			oTable,
			that = this;

		this.expectRequest("TEAMS('1')?$expand=TEAM_2_EMPLOYEES", {
				TEAM_2_EMPLOYEES : [{
					AGE : 42,
					ID : "2",
					Name : "Frederic Fall"
				}]
			})
			.expectChange("age", ["42"])
			.expectChange("name", ["Frederic Fall"]);

		return this.createView(assert, sView).then(function () {
			var oBindingInfo;

			oTable = that.oView.byId("table");
			oBindingInfo = oTable.getBindingInfo("items");
			oTable.unbindAggregation("items");

			assert.strictEqual(oTable.getItems().length, 0);

			that.expectChange("age", ["42"])
				.expectChange("name", ["Frederic Fall"]);

			// code under test
			oTable.bindItems(oBindingInfo);

			return that.waitForChanges(assert);
		}).then(function () {
			var oType = that.oModel.getMetaModel()
					.getUI5Type("/TEAMS('1')/TEAM_2_EMPLOYEES('2')/Name"),
				oTypeKeepsEmptyString;

			assert.strictEqual(oTable.getItems().length, 1);

			assert.strictEqual(oType.parseValue(""), null);
			assert.strictEqual(
				oTable.getItems()[0].getCells()[1].getBinding("text").getType(), // Name
				oType,
				"cached type is used on UI already");

			// code under test
			oTypeKeepsEmptyString = that.oModel.getMetaModel().getUI5Type(
				"/TEAMS('1')/TEAM_2_EMPLOYEES('2')/Name", {parseKeepsEmptyString : true});

			assert.strictEqual(oTypeKeepsEmptyString.parseValue(""), "");
			assert.strictEqual(
				that.oModel.getMetaModel().getUI5Type("/TEAMS('1')/TEAM_2_EMPLOYEES('2')/Name"),
				oType,
				"cached type is unchanged");

			// code under test
			oTypeKeepsEmptyString = that.oModel.getMetaModel().getUI5Type(
				"/TEAMS('1')/TEAM_2_EMPLOYEES('2')/AGE", {parseKeepsEmptyString : true});

			assert.strictEqual(oTypeKeepsEmptyString.parseValue(""), null); // Int16
			assert.strictEqual(
				oTable.getItems()[0].getCells()[0].getBinding("text").getType(), // AGE
				oTypeKeepsEmptyString,
				"parseKeepsEmptyString ignored, type is cached and used on UI already");

			// code under test (CPOUI5ODATAV4-1402)
			assert.deepEqual(oTable.getBinding("items").getAllCurrentContexts().map(getPath), [
				"/TEAMS('1')/TEAM_2_EMPLOYEES('2')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Function import.
	// This scenario is similar to the "Favorite product ID" in the SalesOrders application. In the
	// SalesOrders application the binding context is set programmatically. This example directly
	// invokes the function import.
	testViewStart("FunctionImport", '\
<FlexBox binding="{/GetEmployeeByID(EmployeeID=\'2\')}">\
	<Text id="text" text="{Name}"/>\
</FlexBox>',
		{"GetEmployeeByID(EmployeeID='2')" : {Name : "Frederic Fall"}},
		{text : "Frederic Fall"}
	);

	//*********************************************************************************************
	// Scenario: Request contexts from an ODataListBinding not bound to any control
	// JIRA: CPOUI5UISERVICESV3-1396
	// BCP: 2070245603 (regarding $select and autoExpandSelect)
[false, true].forEach(function (bAutoExpandSelect) {
	var sTitle = "OLDB#requestContexts standalone, autoExpandSelect=" + bAutoExpandSelect;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : bAutoExpandSelect}),
			oPromise,
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oBinding = that.oModel.bindList("/SalesOrderList", undefined, undefined, undefined,
					{$select : ["Note", "SalesOrderID"]});

			// code under test
			oPromise = oBinding.requestContexts(0, 3, "group").then(function (aContexts) {
				assert.deepEqual(aContexts.map(getPath), [
					"/SalesOrderList('01')",
					"/SalesOrderList('02')",
					"/SalesOrderList('03')"
				]);
				assert.strictEqual(aContexts[0].toString(), "/SalesOrderList('01')[0]",
					"Context#toString: persisted");
			});

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=3", {
				value : [
					{Note : "Note 01", SalesOrderID : "01"},
					{Note : "Note 02", SalesOrderID : "02"},
					{Note : "Note 03", SalesOrderID : "03"}
				]
			});

			return Promise.all([
				oPromise,
				that.oModel.submitBatch("group"),
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: requestContexts on a list binding with only properties from a different entity, so
	// that all $select entries move to $expand. Ensure that $select does not become empty. Do the
	// same using a table in the view to see that this produces the same result. (One property must
	// be bound to get a row template.)
	QUnit.test("BCP: 2280192214", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table items="{path : \'/SalesOrderList\', parameters : {$select : \'SO_2_BP/CompanyName\'}}">\
	<Text text="{SO_2_BP/BusinessPartnerID}"/>\
</Table>',
			that = this;

		that.expectRequest("SalesOrderList?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)&$skip=0&$top=100",
				{value : []});

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = oModel.bindList("/SalesOrderList", undefined, undefined, undefined,
					{$select : ["SO_2_BP/CompanyName", "SO_2_BP/BusinessPartnerID"]});

			that.expectRequest("SalesOrderList?$select=SO_2_BP"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)&$skip=0&$top=3",
					{value : []}
				);

			// code under test
			return oBinding.requestContexts(0, 3);
		});
	});

	//*********************************************************************************************
	// Scenario: Request contexts from an ODataListBinding not bound to any control, request
	// creation is async and submitBatch must wait for the request.
	// JIRA: CPOUI5UISERVICESV3-1396
	QUnit.test("OLDB#requestContexts standalone: submitBatch must wait", function (assert) {
		var that = this;

		return this.createView(assert).then(function () {
			var oBinding = that.oModel.bindList(
					"/Equipments(Category='C',ID=2)/EQUIPMENT_2_PRODUCT", undefined, undefined,
					[new Filter("Name", FilterOperator.GE, "M")]);

			that.expectRequest("Equipments(Category='C',ID=2)/EQUIPMENT_2_PRODUCT"
					+ "?$filter=Name ge 'M'&$skip=0&$top=3", {
					value : [
						{ID : 1},
						{ID : 2},
						{ID : 3}
					]
				});

			// code under test
			return Promise.all([
				oBinding.requestContexts(0, 3, "group").then(function (aContexts) {
					assert.deepEqual(aContexts.map(getPath), [
						"/Equipments(Category='C',ID=2)/EQUIPMENT_2_PRODUCT(1)",
						"/Equipments(Category='C',ID=2)/EQUIPMENT_2_PRODUCT(2)",
						"/Equipments(Category='C',ID=2)/EQUIPMENT_2_PRODUCT(3)"
					]);
				}),
				that.oModel.submitBatch("group")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Request contexts from an ODataListBinding bound to a growing sap.m.Table
	// JIRA: CPOUI5UISERVICESV3-1396
[false, true].forEach(function (bGrowing) {
	QUnit.test("OLDB#requestContexts w/ sap.m.Table, growing=" + bGrowing, function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" growing="' + bGrowing + '" growingThreshold="3" items="{/SalesOrderList}">\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		if (!bGrowing) {
			oModel.setSizeLimit(3);
		}
		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=3", {
				value : [
					{SalesOrderID : "01", Note : "Note 1"},
					{SalesOrderID : "02", Note : "Note 2"},
					{SalesOrderID : "03", Note : "Note 3"}
				]
			})
			.expectChange("note", ["Note 1", "Note 2", "Note 3"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=3&$top=9", {
				value : [
					{SalesOrderID : "04", Note : "Note 4"},
					{SalesOrderID : "05", Note : "Note 5"}
				]
			});

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			return Promise.all([
				oBinding.requestContexts(2, 10).then(function (aContexts) {
					assert.deepEqual(aContexts.map(getPath), [
						"/SalesOrderList('03')",
						"/SalesOrderList('04')",
						"/SalesOrderList('05')"
					]);
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			if (bGrowing) {
				that.expectChange("note", [,,, "Note 4", "Note 5"]);

				// show more items
				oTable.requestItems();
			}

			return that.waitForChanges(assert);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Request contexts from an ODataListBinding bound to a non-growing sap.ui.table.Table
	// JIRA: CPOUI5UISERVICESV3-1396
	QUnit.test("OLDB#requestContexts w/ sap.ui.table.Table", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			fnSpy = this.spy(ODataListBinding.prototype, "fetchResolvedQueryOptions"),
			oTable,
			sView = '\
<t:Table id="table" rows="{/SalesOrderList}" threshold="0" visibleRowCount="3">\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		// avoid that the metadata request disturbs the timing
		return oModel.getMetaModel().requestObject("/").then(function () {
			that.expectEvents(assert, "sap.ui.model.odata.v4.ODataListBinding: /SalesOrderList", [
					[, "change", {detailedReason : "AddVirtualContext", reason : "change"}],
					[, "dataRequested"],
					[, "change", {detailedReason : "RemoveVirtualContext", reason : "change"}],
					[, "refresh", {reason : "refresh"}],
					[, "change", {reason : "change"}],
					[, "dataReceived", {data : {}}]
				])
				.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=3", {
					value : [
						{SalesOrderID : "01", Note : "Note 1"},
						{SalesOrderID : "02", Note : "Note 2"},
						{SalesOrderID : "03", Note : "Note 3"}
					]
				})
				.expectChange("note", ["Note 1", "Note 2", "Note 3"]);

			return that.createView(assert, sView, oModel);
		}).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");
			assert.strictEqual(fnSpy.callCount, 1, "initial #fetchResolvedQueryOptions"); // was: 5

			that.expectEvents(assert, oBinding, [
					[, "change", {reason : "change"}]
				])
				.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=3&$top=9", {
					value : [
						{SalesOrderID : "04", Note : "Note 4"},
						{SalesOrderID : "05", Note : "Note 5"}
					]
				});

			return Promise.all([
				oBinding.requestContexts(2, 10).then(function (aContexts) {
					assert.deepEqual(aContexts.map(getPath), [
						"/SalesOrderList('03')",
						"/SalesOrderList('04')",
						"/SalesOrderList('05')"
					]);
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("note", [,, "Note 3", "Note 4", "Note 5"]);

			// scroll down
			oTable.setFirstVisibleRow(2);

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(fnSpy.callCount, 1, "no more #fetchResolvedQueryOptions"); // was: 8
		});
	});

	//*********************************************************************************************
	// Scenario: A relative ODataListBinding later gets its parent context; check that
	// auto-$expand/$select sends the right events
	// BCP: 2080228141
	//
	// Call some APIs before resolving the ODLB (JIRA: CPOUI5ODATAV4-2408)
	QUnit.test("BCP: 2080228141 - autoExpandSelect & late ODLB#setContext", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<t:Table id="table" rows="{}" threshold="0" visibleRowCount="3">\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		this.expectEvents(assert, "sap.ui.model.odata.v4.", []) // no events yet
			.expectChange("note", []);

		return this.createView(assert, sView, oModel).then(function () {
			// avoid that the metadata request disturbs the timing
			return oModel.getMetaModel().requestObject("/");
		}).then(function () {
			var oBinding = that.oView.byId("table").getBinding("rows");

			oBinding.filter(new Filter("SalesOrderID", FilterOperator.NE, "00"));
			oBinding.sort(new Sorter("SalesOrderID"));
			oBinding.changeParameters({$count : true, custom : "foo"});

			that.expectEvents(assert, "sap.ui.model.odata.v4.ODataListBinding: /SalesOrderList|", [
					[, "change", {detailedReason : "AddVirtualContext", reason : "context"}],
					[, "dataRequested"],
					[, "change", {detailedReason : "RemoveVirtualContext", reason : "change"}],
					[, "refresh", {reason : "refresh"}],
					[, "change", {reason : "change"}],
					[, "dataReceived", {data : {}}]
				])
				.expectRequest("SalesOrderList?$count=true&custom=foo&$orderby=SalesOrderID"
					+ "&$filter=SalesOrderID ne '00'&$select=Note,SalesOrderID&$skip=0&$top=3", {
					"@odata.count" : "3",
					value : [
						{SalesOrderID : "01", Note : "Note 1"},
						{SalesOrderID : "02", Note : "Note 2"},
						{SalesOrderID : "03", Note : "Note 3"}
					]
				})
				.expectChange("note", ["Note 1", "Note 2", "Note 3"]);

			// code under test
			oBinding.setContext(oModel.createBindingContext("/SalesOrderList"));

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Absolute ODCB, late property. See that it is requested only once, even when
	// multiple bindings and controller code request it in parallel. See that is written to the
	// cache. See that it is updated via requestSideEffects.
	// JIRA: CPOUI5UISERVICESV3-1878
	// BCP: 2070470932: see that sap-client is handled properly
	// JIRA: CPOUI5ODATAV4-1671: See that dataRequested/dataReceived events are fired for late
	//   property requests
	QUnit.test("ODCB: late property", function (assert) {
		var bChange = false,
			iDataReceived = 0,
			iDataRequested = 0,
			oFormContext,
			oModel = this.createSalesOrdersModel123({autoExpandSelect : true}),
			fnResolve,
			oPromise1,
			oPromise2,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')/SO_2_BP}">\
	<Text id="city" text="{Address/City}"/>\
</FlexBox>\
<Text id="longitude1" text="{Address/GeoLocation/Longitude}"/>\
<Text id="longitude2" text="{Address/GeoLocation/Longitude}"/>\
<Text id="longitude3" text="{Address/GeoLocation/Longitude}"/>',
			that = this;

		this.expectRequest("SalesOrderList('1')/SO_2_BP?sap-client=123"
				+ "&$select=Address/City,BusinessPartnerID", {
				"@odata.etag" : "etag",
				Address : {
					City : "Heidelberg"
				},
				BusinessPartnerID : "2"
			})
			.expectChange("city", "Heidelberg")
			.expectChange("longitude1")
			.expectChange("longitude2")
			.expectChange("longitude3");

		return this.createView(assert, sView, oModel).then(function () {
			var oLongitude1 = that.oView.byId("longitude1");

			oLongitude1.getBinding("text").attachEventOnce("change", function (oEvent) {
				bChange = true;
				assert.strictEqual(oEvent.getSource().getValue(), "8.7"); // unformatted
				assert.strictEqual(oLongitude1.getText(), "8.700000000000"); // formatted
			});
			oModel.attachDataRequested(function () {
				iDataRequested += 1;
			}).attachDataReceived(function (oEvent) {
				iDataReceived += 1;
				assert.strictEqual(bChange, true, "fired after change event");
				assert.deepEqual(oEvent.getParameter("data"), {});
			});

			that.expectRequest("SalesOrderList('1')/SO_2_BP?sap-client=123"
					+ "&$select=Address/GeoLocation/Longitude,BusinessPartnerID", {
					"@odata.etag" : "etag",
					Address : {
						GeoLocation : {
							Longitude : "8.7"
						}
					},
					BusinessPartnerID : "2"
				})
				.expectChange("longitude1", "8.700000000000")
				.expectChange("longitude2", "8.700000000000");

			oFormContext = that.oView.byId("form").getBindingContext();

			that.oLogMock.expects("error")
				.withArgs("Failed to drill-down into CompanyName, invalid segment: CompanyName");

			// code under test - CompanyName leads to a "failed to drill-down"
			assert.strictEqual(oFormContext.getProperty("CompanyName"), undefined);

			// code under test - Longitude is requested once
			that.oView.byId("longitude1").setBindingContext(oFormContext);
			that.oView.byId("longitude2").setBindingContext(oFormContext);

			return Promise.all([
				oFormContext.requestProperty("Address/GeoLocation/Longitude")
					.then(function (sLongitude) {
						assert.strictEqual(sLongitude, "8.7");
					}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(iDataRequested, 1);
			assert.strictEqual(iDataReceived, 1);

			// late property request
			that.expectRequest("SalesOrderList('1')/SO_2_BP?sap-client=123"
					+ "&$select=BusinessPartnerID,CompanyName",
					new Promise(function (resolve) { fnResolve = resolve; }));

			oPromise1 = oFormContext.requestProperty("CompanyName");

			return that.waitForChanges(assert); // so that the request has actually been sent
		}).then(function () {
			// code under test - must not be requested again, although the request is pending
			oPromise2 = oFormContext.requestProperty("CompanyName");

			fnResolve({
				"@odata.etag" : "etag",
				BusinessPartnerID : "2",
				CompanyName : "SAP"
			});

			return Promise.all([oPromise1, oPromise2]);
		}).then(function (aResults) {
			assert.deepEqual(aResults, ["SAP", "SAP"]);
			assert.strictEqual(iDataRequested, 2);
			assert.strictEqual(iDataReceived, 2);

			that.expectChange("longitude3", "8.700000000000");

			// code under test - Longitude is cached now
			that.oView.byId("longitude3").setBindingContext(oFormContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_BP?sap-client=123"
					+ "&$select=Address/City,Address/GeoLocation/Longitude,BusinessPartnerID", {
					"@odata.etag" : "etag",
					Address : {
						City : "Heidelberg",
						GeoLocation : {
							Longitude : "8.71"
						}
					},
					BusinessPartnerID : "2"
				})
				.expectChange("longitude1", "8.710000000000")
				.expectChange("longitude2", "8.710000000000")
				.expectChange("longitude3", "8.710000000000");

			return Promise.all([
				oFormContext.requestSideEffects([{$PropertyPath : "Address"}]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(iDataRequested, 2);
			assert.strictEqual(iDataReceived, 2);
		});
	});

	//*********************************************************************************************
	// Scenario: An ODCB for a BusinessPartner w/o cache is bound to "/SalesOrderList('1')". The
	// CompanyName is fetched late via requestProperty. Then the ODCB is bound to
	// "/SalesOrderList('2')", and requestProperty for the CompanyName must lead to another late
	// property request.
	// BCP: 2380079072
	QUnit.test("BCP: 2380079072", async function (assert) {
		const oModel = this.createSalesOrdersModel({autoExpandSelect : true});
		const sView = `
<FlexBox id="form" binding="{SO_2_BP}">
	<Text id="bp" text="{BusinessPartnerID}"/>
</FlexBox>`;

		this.expectChange("bp");

		await this.createView(assert, sView, oModel);

		this.expectRequest("SalesOrderList('1')/SO_2_BP?$select=BusinessPartnerID",
				{BusinessPartnerID : "3"})
			.expectChange("bp", "3");

		const oForm = this.oView.byId("form");
		oForm.setBindingContext(oModel.createBindingContext("/SalesOrderList('1')"));

		await this.waitForChanges(assert, "1st bind");

		this.expectRequest("SalesOrderList('1')/SO_2_BP?$select=BusinessPartnerID,CompanyName",
				{BusinessPartnerID : "3", CompanyName : "SAP"});

		const oInnerBinding = oForm.getObjectBinding();
		const [sCompanyName1] = await Promise.all([
			oInnerBinding.getBoundContext().requestProperty("CompanyName"),
			this.waitForChanges(assert, "1st requestProperty")
		]);

		assert.strictEqual(sCompanyName1, "SAP");

		this.expectRequest("SalesOrderList('2')?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID)", {
				SalesOrderID : "2",
				SO_2_BP : {BusinessPartnerID : "4"}
			})
			.expectChange("bp", "4");

		oForm.setBindingContext(oModel.bindContext("/SalesOrderList('2')").getBoundContext());

		await this.waitForChanges(assert, "2nd bind");

		this.expectRequest("SalesOrderList('2')/SO_2_BP?$select=BusinessPartnerID,CompanyName",
				{BusinessPartnerID : "4", CompanyName : "TECUM"});

		const [sCompanyName2] = await Promise.all([
			oInnerBinding.getBoundContext().requestProperty("CompanyName"),
			this.waitForChanges(assert, "2nd requestProperty")
		]);

		assert.strictEqual(sCompanyName2, "TECUM");
	});

	//*********************************************************************************************
	// Scenario: Return value context with data in cache, multiple context bindings w/o cache below,
	// multiple property bindings below these context bindings requesting their value late. One
	// request for all properties must occur. (The scenario of the incident.)
	// BCP: 2080093480
	QUnit.test("BCP: 2080093480", function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Text id="id1" text="{SalesOrderID}"/>\
	<FlexBox id="action" binding="{' + sAction + '(...)}"/>\
</FlexBox>\
<FlexBox id="result">\
	<Text id="id2" text="{SalesOrderID}"/>\
	<FlexBox binding="{}">\
		<Text id="note" text="{Note}"/>\
		<Text id="language" text="{NoteLanguage}"/>\
	</FlexBox>\
	<FlexBox binding="{SO_2_BP}">\
		<Text id="name" text="{CompanyName}"/>\
		<Text id="legalForm" text="{LegalForm}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID", {SalesOrderID : "1"})
			.expectChange("id1", "1")
			.expectChange("id2")
			.expectChange("note")
			.expectChange("language")
			.expectChange("name")
			.expectChange("legalForm");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
				method : "POST",
				url : "SalesOrderList('1')/" + sAction,
				payload : {}
			}, {
				SalesOrderID : "1"
			});

			return Promise.all([
				that.oView.byId("action").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			var oReturnValueContext = aResults[0];

			that.expectChange("id2", "1")
				.expectRequest("SalesOrderList('1')?$select=Note,NoteLanguage"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName,LegalForm)", {
					Note : "Note #1",
					NoteLanguage : "en",
					SO_2_BP : {
						BusinessPartnerID : "2",
						CompanyName : "TECUM",
						LegalForm : "Ltd"
					}
				})
				.expectChange("note", "Note #1")
				.expectChange("language", "en")
				.expectChange("name", "TECUM")
				.expectChange("legalForm", "Ltd");

			that.oView.byId("result").setBindingContext(oReturnValueContext);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Immediately after invoke the parameter is changed again. See that the request uses
	// the old value. Even refresh must still use it.
	// BCP: 2070180785
	// TODO What about changing the context for the binding parameter?
	QUnit.test("BCP: 2070180785", function (assert) {
		var oBinding,
			that = this;

		return this.createView(assert).then(function () {
			var oPromise;

			that.expectRequest("GetEmployeeByID(EmployeeID='1')", {ID : "1"});

			oBinding = that.oModel.bindContext("/GetEmployeeByID(...)");
			oBinding.setParameter("EmployeeID", "1");
			oPromise = oBinding.invoke();
			oBinding.setParameter("EmployeeID", "2");

			return Promise.all([oPromise, that.waitForChanges(assert)]);
		}).then(function () {
			that.expectRequest("GetEmployeeByID(EmployeeID='1')", {ID : "1"});

			oBinding.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("GetEmployeeByID(EmployeeID='2')", {ID : "2"});

			return Promise.all([
				oBinding.invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: relative ODCB without cache; late property must be added to the parent cache.
	// BCP: 2080093480
	QUnit.test("ODCB w/o cache: late property", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="outer" binding="{/SalesOrderList(\'1\')}">\
	<FlexBox id="inner" binding="{SO_2_BP}">\
		<Text id="companyName" text="{CompanyName}"/>\
	</FlexBox>\
</FlexBox>\
<Text id="legalForm" text="{LegalForm}"/>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
				SalesOrderID : "1",
				SO_2_BP : {
					BusinessPartnerID : "2",
					CompanyName : "TECUM"
				}
			})
			.expectChange("companyName", "TECUM")
			.expectChange("legalForm");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_BP?$select=BusinessPartnerID,LegalForm", {
					BusinessPartnerID : "2",
					LegalForm : "Ltd"
				})
				.expectChange("legalForm", "Ltd");

			// select an item
			that.oView.byId("legalForm").setBindingContext(
				that.oView.byId("inner").getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			// code under test - value must be in the parent cache
			assert.strictEqual(
				that.oView.byId("inner").getBindingContext().getProperty("LegalForm"),
				"Ltd"
			);
			assert.strictEqual(
				that.oView.byId("outer").getObjectBinding().getBoundContext()
					.getProperty("SO_2_BP/LegalForm"),
				"Ltd"
			);

			that.expectChange("legalForm", null);

			// this removes the property from the query options again
			that.oView.byId("legalForm").setBindingContext(null);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
					SalesOrderID : "1",
					SO_2_BP : {
						BusinessPartnerID : "2",
						CompanyName : "TECUM (refreshed)"
					}
				})
				.expectChange("companyName", "TECUM (refreshed)");

			that.oView.byId("outer").getObjectBinding().refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: relative ODLB without cache; late property must be added to the parent cache.
	// BCP: 2080093480
	QUnit.test("ODLB w/o cache: late property", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}">\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text id="position" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>\
<Text id="quantity" text="{Quantity}"/>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)", {
				SO_2_SOITEM : [
					{ItemPosition : "0010", SalesOrderID : "1"}
				]
			})
			.expectChange("position", ["0010"])
			.expectChange("quantity");

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectRequest("SalesOrderList('1')"
					+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')?$select=Quantity", {
					Quantity : "5"
				})
				.expectChange("quantity", "5.000");

			// select an item
			that.oView.byId("quantity").setBindingContext(
				oTable.getBinding("items").getCurrentContexts()[0]);

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(
				oTable.getBinding("items").getCurrentContexts()[0].getProperty("Quantity"), "5");
		});
	});

	//*********************************************************************************************
	// Scenario: Messages in $select of the binding parameter are transported to the binding of the
	// return value via $$inheritExpandSelect. A late property is added to the return value binding.
	// See that Context#requestSideEffects, Context#refresh and a dependent list binding creating
	// its own cache request the messages.
	// BCP: 2070011343
	QUnit.test("BCP: 2070011343", function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{path : \'/SalesOrderList(\\\'1\\\')\',\
		parameters : {$select : \'Messages,SO_2_SOITEM/Messages\'}}">\
	<Text id="id1" text="{SalesOrderID}"/>\
	<Table items="{SO_2_SOITEM}">\
		<Text text="{ItemPosition}"/>\
	</Table>\
	<FlexBox id="action" binding="{\
			path : \'' + sAction + '(...)\',\
			parameters : {$$inheritExpandSelect : true}\
		}"/>\
</FlexBox>\
<FlexBox id="returnValue">\
	<Text id="id2" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=Messages,SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,Messages,SalesOrderID)", {
				SalesOrderID : "1",
				SO_2_SOITEM : [
					{ItemPosition : "10", SalesOrderID : "1"}
				]
			})
			.expectChange("id1", "1")
			.expectChange("id2")
			.expectChange("note");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('1')/" + sAction + "?$select=Messages,SalesOrderID"
						+ "&$expand=SO_2_SOITEM($select=ItemPosition,Messages,SalesOrderID)",
					payload : {}
				}, {
					SalesOrderID : "1",
					SO_2_SOITEM : [
						{ItemPosition : "10", SalesOrderID : "1"}
					]
				});

			return Promise.all([
				that.oView.byId("action").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			that.expectChange("id2", "1") // from setBindingContext
				// late property request
				.expectRequest("SalesOrderList('1')?$select=Note", {Note : "Note #1"})
				.expectChange("note", "Note #1");

			that.oView.byId("returnValue").setBindingContext(aResults[0]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=Messages,Note", {Note : "Note #1"});

			return Promise.all([
				// code under test
				that.oView.byId("returnValue").getBindingContext()
					.requestSideEffects([{$PropertyPath : "Messages"}, {$PropertyPath : "Note"}]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$select=ItemPosition,Messages,"
					+ "SalesOrderID&$orderby=ItemPosition&$skip=0&$top=100", {
					value : [
						{ItemPosition : "10", SalesOrderID : "1"}
					]
				});

			// code under test
			that.oView.byId("table").getBinding("items").sort(new Sorter("ItemPosition"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=Messages,Note,SalesOrderID"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,Messages,SalesOrderID)", {
					Note : "Note #1",
					SalesOrderID : "1",
					SO_2_SOITEM : [
						{ItemPosition : "10", SalesOrderID : "1"}
					]
				})
				// Note: "table" has a sorter and thus sends own requests
				.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$select=ItemPosition,Messages,"
					+ "SalesOrderID&$orderby=ItemPosition&$skip=0&$top=100", {
					value : [
						{ItemPosition : "10", SalesOrderID : "1"}
					]
				});

			// code under test
			that.oView.byId("returnValue").getBindingContext().refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: ODLB, late property. See that it is requested only once, even when bound twice. See
	// that it is updated via requestSideEffects called at the parent binding (all visible rows).
	// JIRA: CPOUI5UISERVICESV3-1878
	//
	// See that a late property for a nested entity (within $expand) is fetched
	// JIRA: CPOUI5ODATAV4-23
	//
	// See that two late property requests are merged (JIRA: CPOUI5ODATAV4-27)
	// See that sap-client and system query options are handled properly (BCP: 2070470932)
	// Test ODLB#getCount (JIRA: CPOUI5ODATAV4-958)
	//
	// See that dataRequested/dataReceived events are fired for late property requests
	// JIRA: CPOUI5ODATAV4-1671
	//
	// See that every GET request for late property requests is causing dataRequested/dataReceived
	// events. The additional GET request for late properties is achieved by requesting an
	// additional item with ItemPosition "20". The path from the GET request is attached to the
	// event parameter, no matter whether the request failed or succeeded.
	// JIRA: CPOUI5ODATAV4-1746
	//
	// Rewritten to use SalesOrder instead of TEAM (JIRA: CPOUI5ODATAV4-2172)
	QUnit.test("ODLB: late property", function (assert) {
		var bChange = false,
			iDataReceived = 0,
			iDataRequested = 0,
			oModel,
			sPath,
			oRowContext,
			oTable,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Table id="table" growing="true" growingThreshold="2"\
			items="{path : \'SO_2_SOITEM\', \
				parameters : {$$ownRequest : true, $search : \'foo\', $select : \'Messages\'}}">\
		<Text id="note" text="{Note}"/>\
		<Text id="scheduleKey" text="{SOITEM_2_SCHDL/ScheduleKey}"/>\
	</Table>\
</FlexBox>\
<Input id="unit1" value="{QuantityUnit}"/>\
<Text id="unit2" text="{QuantityUnit}"/>\
<Input id="bp" value="{SOITEM_2_PRODUCT/PRODUCT_2_BP/CompanyName}"/>',
			that = this;

		oModel = this.createModel(sSalesOrderService + "?sap-client=123", {
			autoExpandSelect : true
		}, {
			"/sap/opu/odata4/sap/zui5_testv4/default/sap/zui5_epm_sample/0002/$metadata?sap-client=123"
				: {source : "odata/v4/data/metadata_zui5_epm_sample.xml"}
		});

		this.expectRequest("SalesOrderList('1')/SO_2_SOITEM?sap-client=123&$search=foo"
				+ "&$select=ItemPosition,Messages,Note,SalesOrderID"
				+ "&$expand=SOITEM_2_SCHDL($select=ScheduleKey)&$skip=0&$top=2", {
				value : [{
					"@odata.etag" : "etag0",
					ItemPosition : "10",
					Messages : [],
					Note : "Note #10",
					SalesOrderID : "1",
					SOITEM_2_SCHDL : {ScheduleKey : "Key #10"}
				}, {
					"@odata.etag" : "etag0",
					ItemPosition : "20",
					Messages : [],
					Note : "Note #20",
					SalesOrderID : "1",
					SOITEM_2_SCHDL : {ScheduleKey : "Key #20"}
				}]
			})
			.expectChange("note", ["Note #10", "Note #20"])
			.expectChange("scheduleKey", ["Key #10", "Key #20"])
			.expectChange("unit1")
			.expectChange("unit2")
			.expectChange("bp");

		return this.createView(assert, sView, oModel).then(function () {
			var oBusinessPartner = that.oView.byId("bp");

			oTable = that.oView.byId("table");
			oBusinessPartner.getBinding("value").attachEventOnce("change", function (oEvent) {
				bChange = true;
				assert.strictEqual(oEvent.getSource().getValue(), "ACM");
				assert.strictEqual(oBusinessPartner.getValue(), "ACM");
			});
			oModel.attachDataRequested(function (oEvent) {
				sPath = oEvent.getParameter("path");

				iDataRequested += 1;
				if (iDataRequested === 1) {
					assert.strictEqual(sPath,
						"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')");
				} else if (iDataRequested === 2) {
					assert.strictEqual(sPath,
						"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')");
				}
			}).attachDataReceived(function (oEvent) {
				sPath = oEvent.getParameter("path");

				iDataReceived += 1;
				assert.deepEqual(oEvent.getParameter("data"), {});

				if (iDataReceived === 1) {
					assert.strictEqual(sPath,
						"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')");
					assert.strictEqual(bChange, false, "change event not yet fired");
				} else if (iDataReceived === 2) {
					assert.strictEqual(sPath,
						"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')");
					assert.strictEqual(bChange, true, "fired after change event");
				}
			});

			// code under test - count is not requested
			assert.strictEqual(oTable.getBinding("items").getCount(), undefined);
			assert.strictEqual(oTable.getBinding("items").getLength(), 12);

			that.expectRequest({
					batchNo : 2,
					url : "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')"
						+ "?sap-client=123"
						+ "&$select=QuantityUnit&$expand=SOITEM_2_PRODUCT($select=ProductID;"
						+ "$expand=PRODUCT_2_BP($select=BusinessPartnerID,CompanyName))"
				}, {
					"@odata.etag" : "etag0",
					QuantityUnit : "kg",
					SOITEM_2_PRODUCT : {
						"@odata.etag" : "etag1",
						ProductID : "3",
						PRODUCT_2_BP : {
							"@odata.etag" : "ETag",
							BusinessPartnerID : "4",
							CompanyName : "ACM"
						}
					}
				})
				// the additional late property request
				.expectRequest({
					batchNo : 2,
					url : "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')"
						+ "?sap-client=123"
						+ "&$select=SOITEM_2_PRODUCT&$expand=SOITEM_2_PRODUCT($select=ProductID;"
						+ "$expand=PRODUCT_2_BP($select=BusinessPartnerID,CompanyName))"
				}, {
					"@odata.etag" : "etag0",
					SOITEM_2_PRODUCT : {
						"@odata.etag" : "etag1",
						ProductID : "3",
						PRODUCT_2_BP : {
							"@odata.etag" : "ETag",
							BusinessPartnerID : "4",
							CompanyName : "ACM"
						}
					}
				})
				.expectChange("unit1", "kg")
				.expectChange("bp", "ACM");

			// code under test - QuantityUnit and CompanyName are requested
			oRowContext = oTable.getItems()[0].getBindingContext();
			that.oView.byId("unit1").setBindingContext(oRowContext);
			that.oView.byId("bp").setBindingContext(oRowContext);

			return Promise.all([
				// the additional late property request for a *different* row
				// JIRA: CPOUI5ODATAV4-1746
				oTable.getItems()[1].getBindingContext()
					.requestProperty("SOITEM_2_PRODUCT/PRODUCT_2_BP/CompanyName"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(iDataRequested, 2);
			assert.strictEqual(iDataReceived, 2);

			// BCP 1980517597
			that.expectChange("unit1", "t")
				.expectRequest({
					method : "PATCH",
					headers : {"If-Match" : "etag0"},
					url : "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')"
						+ "?sap-client=123",
					payload : {QuantityUnit : "t"}
				}, {
					"@odata.etag" : "etag23",
					AGE : 18,
					Messages : [{
						code : "1",
						message : "Are you sure?",
						numericSeverity : 3,
						target : "QuantityUnit",
						transition : false
					}]
				})
				.expectMessages([{
					code : "1",
					message : "Are you sure?",
					target : "/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')"
						+ "/QuantityUnit",
					type : "Warning"
				}]);

			// code under test
			that.oView.byId("unit1").getBinding("value").setValue("t");

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, "unit1", "Warning", "Are you sure?");
		}).then(function () {
			that.expectChange("bp", "changed")
				.expectRequest({
					method : "PATCH",
					headers : {"If-Match" : "ETag"},
					url : "BusinessPartnerList('4')?sap-client=123",
					payload : {CompanyName : "changed"}
				});

			// code under test
			that.oView.byId("bp").getBinding("value").setValue("changed");

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(iDataRequested, 2);
			assert.strictEqual(iDataReceived, 2);

			that.expectChange("unit2", "t");

			// code under test - QuantityUnit is cached now
			that.oView.byId("unit2").setBindingContext(oRowContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?sap-client=123&$search=foo"
					+ "&$select=ItemPosition,Messages,Note,SalesOrderID"
					+ "&$expand=SOITEM_2_SCHDL($select=ScheduleKey)&$skip=2&$top=2", {
					value : [{
						ItemPosition : "30",
						Messages : [],
						Note : "Note #30",
						SalesOrderID : "1",
						SOITEM_2_SCHDL : {ScheduleKey : "Key #30"}
					}]
				})
				.expectChange("note", [,, "Note #30"])
				.expectChange("scheduleKey", [,, "Key #30"]);

			// code under test - QuantityUnit must not be requested when paging
			oTable.requestItems();

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(iDataRequested, 3, "bubbled up from the binding");
			assert.strictEqual(iDataReceived, 3, "bubbled up from the binding");

			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?sap-client=123"
					+ "&$select=ItemPosition,Note,QuantityUnit,SalesOrderID"
					+ "&$filter=SalesOrderID eq '1' and ItemPosition eq '10' or SalesOrderID eq '1'"
					+ " and ItemPosition eq '20' or SalesOrderID eq '1' and ItemPosition eq '30'"
					+ "&$top=3", {
					value : [
						{ItemPosition : "10", Note : "#1", QuantityUnit : "g", SalesOrderID : "1"},
						{ItemPosition : "20", Note : "#2", QuantityUnit : "dz", SalesOrderID : "1"},
						{ItemPosition : "30", Note : "#3", QuantityUnit : "g", SalesOrderID : "1"}
					]
				})
				.expectChange("unit1", "g")
				.expectChange("unit2", "g")
				.expectChange("note", ["#1", "#2", "#3"]);

			// see that requestSideEffects updates QuantityUnit, too
			return Promise.all([
				oTable.getBinding("items").getHeaderContext()
					.requestSideEffects(["Note", "QuantityUnit"]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(iDataRequested, 3);
			assert.strictEqual(iDataReceived, 3);

			that.expectChange("unit2", "dz");

			// change one Text to the second row - must be cached from requestSideEffects
			oRowContext = oTable.getItems()[1].getBindingContext();
			that.oView.byId("unit2").setBindingContext(oRowContext);

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(iDataRequested, 3);
			assert.strictEqual(iDataReceived, 3);

			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?sap-client=123"
					+ "&$select=ItemPosition,Note,QuantityUnit,SalesOrderID"
					+ "&$filter=SalesOrderID eq '1' and ItemPosition eq '10' or SalesOrderID eq '1'"
					+ " and ItemPosition eq '20' or SalesOrderID eq '1' and ItemPosition eq '30'"
					+ "&$top=3", {
					value : [
						{ItemPosition : "10", Note : "$1", QuantityUnit : "ou", SalesOrderID : "1"},
						{ItemPosition : "20", Note : "$2", QuantityUnit : "t", SalesOrderID : "1"},
						{ItemPosition : "30", Note : "$3", QuantityUnit : "?", SalesOrderID : "1"}
					]
				})
				.expectChange("unit1", "ou")
				.expectChange("unit2", "t")
				.expectChange("note", ["$1", "$2", "$3"]);

			return Promise.all([
				// code under test: requestSideEffects on ODCB w/o data
				that.oView.byId("form").getBindingContext().requestSideEffects([
					{$PropertyPath : "SO_2_SOITEM/QuantityUnit"},
					{$PropertyPath : "SO_2_SOITEM/Note"}
				]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(iDataRequested, 3);
			assert.strictEqual(iDataReceived, 3);

			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')"
				+ "?sap-client=123&$select=CurrencyCode",
				{"@odata.etag" : "etag0", CurrencyCode : "USD"});

			return Promise.all([
				oRowContext.requestProperty("CurrencyCode").then(function (sCurrencyCode) {
					assert.strictEqual(sCurrencyCode, "USD");
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(iDataRequested, 4);
			assert.strictEqual(iDataReceived, 4);
		});
	});

	//*********************************************************************************************
	// Scenario: Context binding as root binding has dependent bindings w/o own cache which result
	// in a nested $expand. Side effects affect this nested $expand. Expect no error message about
	// changed key predicate for TEAM_2_MANAGER.
	// JIRA: CPOUI5ODATAV4-362
	QUnit.test("ODCB: requestSideEffects for nested expand", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/EMPLOYEES(\'1\')}">\
	<Text id="employee_id" text="{ID}"/>\
	<Text id="team_id" text="{EMPLOYEE_2_TEAM/Team_Id}"/>\
	<Text id="manager_id" text="{EMPLOYEE_2_TEAM/TEAM_2_MANAGER/ID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')?$select=ID&$expand=EMPLOYEE_2_TEAM($select=Team_Id;"
				+ "$expand=TEAM_2_MANAGER($select=ID))", {
				ID : "1",
				EMPLOYEE_2_TEAM : {
					Team_Id : "2",
					TEAM_2_MANAGER : {ID : "3"}
				}
			})
			.expectChange("employee_id", "1")
			.expectChange("team_id", "2")
			.expectChange("manager_id", "3");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("EMPLOYEES('1')?$select=EMPLOYEE_2_TEAM&$expand=EMPLOYEE_2_TEAM"
					+ "($select=Team_Id;$expand=TEAM_2_MANAGER($select=ID))", {
					EMPLOYEE_2_TEAM : {
						Team_Id : "2*",
						TEAM_2_MANAGER : {ID : "3*"}
					}
				})
				.expectChange("team_id", "2*")
				.expectChange("manager_id", "3*");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([
					{$NavigationPropertyPath : "EMPLOYEE_2_EQUIPMENT"}, // must be ignored
					{$NavigationPropertyPath : "EMPLOYEE_2_TEAM"}
				]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: List binding as root binding has dependent bindings w/o own cache which result
	// in a nested $expand. Side effects affect this nested $expand. Expect no error message about
	// changed key predicate for TEAM_2_MANAGER.
	// JIRA: CPOUI5ODATAV4-362
	QUnit.test("ODLB: requestSideEffects for nested expand", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Text id="employee_id" text="{ID}"/>\
	<Text id="team_id" text="{EMPLOYEE_2_TEAM/Team_Id}"/>\
	<Text id="manager_id" text="{EMPLOYEE_2_TEAM/TEAM_2_MANAGER/ID}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID&$expand=EMPLOYEE_2_TEAM($select=Team_Id;"
				+ "$expand=TEAM_2_MANAGER($select=ID))&$skip=0&$top=100", {
				value : [{
					ID : "1",
					EMPLOYEE_2_TEAM : {
						Team_Id : "2",
						TEAM_2_MANAGER : {ID : "3"}
					}
				}]
			})
			.expectChange("employee_id", ["1"])
			.expectChange("team_id", ["2"])
			.expectChange("manager_id", ["3"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("EMPLOYEES?$select=ID&$expand=EMPLOYEE_2_TEAM($select=Team_Id;"
					+ "$expand=TEAM_2_MANAGER($select=ID))&$filter=ID eq '1'", {
					value : [{
						ID : "1",
						EMPLOYEE_2_TEAM : {
							Team_Id : "2*",
							TEAM_2_MANAGER : {ID : "3*"}
						}
					}]
				})
				.expectChange("team_id", ["2*"])
				.expectChange("manager_id", ["3*"]);

			return Promise.all([
				// code under test
				that.oView.byId("table").getItems()[0].getBindingContext()
					.requestSideEffects([
						{$NavigationPropertyPath : "EMPLOYEE_2_EQUIPMENT"}, // must be ignored
						{$NavigationPropertyPath : "EMPLOYEE_2_TEAM"}
					]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: requestSideEffects with absolute paths.
	// Create a list binding on contacts with a dependent context binding on a business partner
	// and a context binding on a sales order with a dependent list binding on the line items. The
	// dependent bindings have their own caches, because this is the most interesting case.
	// 1. Request side effects on the business partner for the company name with relative path and
	//    the web address with absolute path (they should be merged to one request), and for the
	//    note of sales order line items with absolute path.
	// 2. Request side effects on the business partner for sales orders with absolute path and
	//    expect refreshes for orders and items.
	// 3. Request side effects on a sales order line item for the gross amount and the quantity for
	//    all line items.
	// 4. Request side effects on sales order line items with an absolute path to refresh the whole
	//    collection. BCP: 2180132755
	// JIRA: CPOUI5ODATAV4-398
	QUnit.test("requestSideEffects: absolute paths", function (assert) {
		var oBusinessPartnerContext,
			oModel = this.createSalesOrdersModel123({autoExpandSelect : true}),
			sEntityContainer = "/com.sap.gateway.default.zui5_epm_sample.v0002.Container",
			oItemsTable,
			sView = '\
<Table id="contacts" items="{/ContactList}">\
	<Text id="lastName" text="{LastName}"/>\
</Table>\
<FlexBox id="partner" binding="{path : \'CONTACT_2_BP\', parameters : {$$ownRequest : true}}">\
	<Text id="companyName" text="{CompanyName}"/>\
	<Text id="webAddress" text="{WebAddress}"/>\
</FlexBox>\
<FlexBox id="order" binding="{/SalesOrderList(\'SO1\')}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="grossAmount" text="{GrossAmount}"/>\
		<Text id="note" text="{Note}"/>\
		<Text id="quantity" text="{Quantity}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("ContactList?sap-client=123&$select=ContactGUID,LastName"
				+ "&$skip=0&$top=100", {
				value : [{ContactGUID : "guid", LastName : "Doe"}]
			})
			.expectChange("lastName", ["Doe"])
			.expectRequest("SalesOrderList('SO1')?sap-client=123&$select=SalesOrderID", {
				SalesOrderID : "SO1"
			})
			.expectChange("id", "SO1")
			.expectRequest("SalesOrderList('SO1')/SO_2_SOITEM?sap-client=123"
				+ "&$select=GrossAmount,ItemPosition,Note,Quantity,SalesOrderID"
				+ "&$skip=0&$top=100", {
				value : [{
					GrossAmount : "42",
					ItemPosition : "0010",
					Note : "Note 0010",
					Quantity : "3",
					SalesOrderID : "SO1"
				}, {
					GrossAmount : "23",
					ItemPosition : "0020",
					Note : "Note 0020",
					Quantity : "1",
					SalesOrderID : "SO1"
				}]
			})
			.expectChange("grossAmount", ["42", "23"])
			.expectChange("note", ["Note 0010", "Note 0020"])
			.expectChange("quantity", ["3.000", "1.000"])
			.expectChange("companyName")
			.expectChange("webAddress");

		return this.createView(assert, sView, oModel).then(function () {
			var oBusinessPartner = that.oView.byId("partner");

			that.expectRequest("ContactList(guid)/CONTACT_2_BP?sap-client=123"
					+ "&$select=BusinessPartnerID,CompanyName,WebAddress", {
					BusinessPartnerID : "BP1",
					CompanyName : "TECUM",
					WebAddress : "www.tecum.com"
				})
				.expectChange("companyName", "TECUM")
				.expectChange("webAddress", "www.tecum.com");

			oBusinessPartner.setBindingContext(
				that.oView.byId("contacts").getItems()[0].getBindingContext());
			oBusinessPartnerContext = oBusinessPartner.getBindingContext();

			return that.waitForChanges(assert, "get business partner");
		}).then(function () {
			that.expectRequest("ContactList(guid)/CONTACT_2_BP?sap-client=123"
					+ "&$select=BusinessPartnerID,CompanyName,WebAddress", {
					BusinessPartnerID : "BP1",
					CompanyName : "TECUM*",
					WebAddress : "www.tecum.com*"
				})
				.expectChange("companyName", "TECUM*")
				.expectChange("webAddress", "www.tecum.com*")
				.expectRequest("SalesOrderList('SO1')/SO_2_SOITEM?sap-client=123"
					+ "&$select=ItemPosition,Note,SalesOrderID"
					+ "&$filter=SalesOrderID eq 'SO1' and ItemPosition eq '0010'"
					+ " or SalesOrderID eq 'SO1' and ItemPosition eq '0020'&$top=2", {
					value : [{
						ItemPosition : "0010",
						Note : "Note 0010*",
						SalesOrderID : "SO1"
					}, {
						ItemPosition : "0020",
						Note : "Note 0020*",
						SalesOrderID : "SO1"
					}]
				})
				.expectChange("note", ["Note 0010*", "Note 0020*"]);

			return Promise.all([
				// code under test
				oBusinessPartnerContext.requestSideEffects([
					{$PropertyPath : "CompanyName"},
					{$PropertyPath : sEntityContainer + "/ContactList/CONTACT_2_BP/WebAddress"},
					{$PropertyPath : sEntityContainer + "/SalesOrderList/SO_2_SOITEM/Note"}
				]),
				that.waitForChanges(assert, "(1)")
			]);
		}).then(function () {
			that.expectRequest("ContactList(guid)/CONTACT_2_BP?sap-client=123"
					+ "&$select=BusinessPartnerID,CompanyName", {
					BusinessPartnerID : "BP1",
					CompanyName : "TECUM*2"
				})
				.expectChange("companyName", "TECUM*2")
				.expectRequest("SalesOrderList('SO1')?sap-client=123&$select=SalesOrderID", {
					SalesOrderID : "SO1"
				})
				.expectRequest("SalesOrderList('SO1')/SO_2_SOITEM?sap-client=123"
					+ "&$select=GrossAmount,ItemPosition,Note,Quantity,SalesOrderID"
					+ "&$skip=0&$top=100", {
					value : [{
						GrossAmount : "42.1",
						ItemPosition : "0010",
						Note : "Note 0010*2",
						Quantity : "4",
						SalesOrderID : "SO1"
					}, {
						GrossAmount : "23.1",
						ItemPosition : "0020",
						Note : "Note 0020*2",
						Quantity : "2",
						SalesOrderID : "SO1"
					}]
				})
				.expectChange("grossAmount", ["42.1", "23.1"])
				.expectChange("note", ["Note 0010*2", "Note 0020*2"])
				.expectChange("quantity", ["4.000", "2.000"]);

			return Promise.all([
				// code under test
				oBusinessPartnerContext.requestSideEffects([
					{$PropertyPath : "CompanyName"},
					{$NavigationPropertyPath : sEntityContainer + "/SalesOrderList"},
					{$NavigationPropertyPath : sEntityContainer + "/ProductList"}
				]),
				that.waitForChanges(assert, "(2)")
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('SO1')/SO_2_SOITEM?sap-client=123"
					+ "&$select=GrossAmount,ItemPosition,SalesOrderID"
					+ "&$filter=SalesOrderID eq 'SO1' and ItemPosition eq '0010'", {
					value : [{
						GrossAmount : "42.2",
						ItemPosition : "0010",
						SalesOrderID : "SO1"
					}]
				})
				.expectChange("grossAmount", ["42.2"])
				.expectRequest("SalesOrderList('SO1')/SO_2_SOITEM?sap-client=123"
					+ "&$select=ItemPosition,Note,Quantity,SalesOrderID"
					+ "&$filter=SalesOrderID eq 'SO1' and ItemPosition eq '0010'"
					+ " or SalesOrderID eq 'SO1' and ItemPosition eq '0020'&$top=2", {
					value : [{
						ItemPosition : "0010",
						Quantity : "5",
						SalesOrderID : "SO1"
					}, {
						ItemPosition : "0020",
						Quantity : "3",
						SalesOrderID : "SO1"
					}]
				})
				.expectChange("quantity", ["5.000", "3.000"]);

			oItemsTable = that.oView.byId("items");

			return Promise.all([
				// code under test
				oItemsTable.getItems()[0].getBindingContext().requestSideEffects([
					{$PropertyPath : "GrossAmount"},
					{$PropertyPath : "SOITEM_2_SO/SO_2_SOITEM/Note"},
					{$PropertyPath : sEntityContainer + "/SalesOrderList/SO_2_SOITEM/Quantity"}
				]),
				that.waitForChanges(assert, "(3)")
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('SO1')/SO_2_SOITEM?sap-client=123"
					+ "&$select=GrossAmount,ItemPosition,Note,Quantity,SalesOrderID"
					+ "&$skip=0&$top=100", {
					value : [{
						GrossAmount : "42.4",
						ItemPosition : "0010",
						Note : "Note 0010*4",
						Quantity : "6",
						SalesOrderID : "SO1"
					}, {
						GrossAmount : "23.4",
						ItemPosition : "0020",
						Note : "Note 0020*4",
						Quantity : "4",
						SalesOrderID : "SO1"
					}]
				})
				.expectChange("grossAmount", ["42.4", "23.4"])
				.expectChange("note", ["Note 0010*4", "Note 0020*4"])
				.expectChange("quantity", ["6.000", "4.000"]);

			return Promise.all([
				// code under test
				oItemsTable.getItems()[0].getBindingContext().requestSideEffects([
					"GrossAmount",
					sEntityContainer + "/SalesOrderList/SO_2_SOITEM"
				]),
				that.waitForChanges(assert, "(4)")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: requestSideEffects refreshes one complete row and fails. See that the cache data
	// remains, even in a nested list. (In the incident an action in the same batch failed.)
	// BCP: 2380011682
	QUnit.test("BCP: 2380011682", function (assert) {
		var oEmployeeContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTeamContext,
			sView = '\
<Table id="outer" items="{/TEAMS}">\
	<Text id="team" text="{Team_Id}"/>\
</Table>\
<Table id="inner" items="{TEAM_2_EMPLOYEES}">\
	<Text id="employee" text="{ID}"/>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=100", {value : [{Team_Id : "T1"}]})
			.expectChange("team", ["T1"])
			.expectChange("employee", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("TEAMS('T1')/TEAM_2_EMPLOYEES?$select=ID&$skip=0&$top=100",
					{value : [{ID : "E1"}]})
				.expectChange("employee", ["E1"]);

			oTeamContext = that.oView.byId("outer").getBinding("items").getCurrentContexts()[0];
			that.oView.byId("inner").setBindingContext(oTeamContext);

			return that.waitForChanges(assert, "inner");
		}).then(function () {
			oEmployeeContext = that.oView.byId("inner").getBinding("items").getCurrentContexts()[0];

			that.expectRequest("TEAMS('T1')?$select=Team_Id,__CT__FAKE__Message/__FAKE__Messages",
					createErrorInsideBatch())
				.expectRequest("TEAMS('T1')/TEAM_2_EMPLOYEES?$select=ID&$skip=0&$top=100")
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withArgs("Failed to refresh entity: /TEAMS('T1')[0]",
					sinon.match("Request intentionally failed"));
			that.oLogMock.expects("error")
				.withArgs(sinon.match("Failed to get contexts"), sinon.match(sPreviousFailed));

			return Promise.all([
				// code under test
				oTeamContext.requestSideEffects([""]).then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, "Request intentionally failed");
				}),
				that.waitForChanges(assert, "requestSideEffects")
			]);
		}).then(function () {
			assert.strictEqual(oTeamContext.getProperty("Team_Id"), "T1");
			assert.strictEqual(oEmployeeContext.getProperty("ID"), "E1");
		});
	});

	//*********************************************************************************************
	// Scenario: deferred delete & requestSideEffects.
	// - requestSideEffects fails on the deleted context
	// - If delete runs in a different group, requestSideEffects...
	//    - succeeds on an undeleted context (property and full refresh)
	//    - fails on the header context (here: for a single property)
	//    - fails via absolute path
	//
	// JIRA: CPOUI5ODATAV4-1639
[{
	name : "deleted context",
	run : function (assert, _oUndeletedContext, oDeletedContext) {
		assert.throws(function () {
			oDeletedContext.requestSideEffects(["Note"]);
		}, new Error("Unsupported context: " + oDeletedContext));
	}
}, {
	name : "property of undeleted context",
	run : function (_assert, oUndeletedContext) {
		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$filter=SalesOrderID eq '2'",
				{value : [{Note : "Note 2", SalesOrderID : "2"}]});

		return oUndeletedContext.requestSideEffects(["Note"]);
	}
}, {
	name : "refresh undeleted context",
	run : function (_assert, oUndeletedContext) {
		this.expectRequest("SalesOrderList('2')?$select=Messages,Note,SalesOrderID",
				{Messages : [], Note : "Note 2", SalesOrderID : "2"});

		return oUndeletedContext.requestSideEffects([""]);
	}
}, {
	name : "header context",
	run : function (assert, oUndeletedContext) {
		return oUndeletedContext.getBinding().getHeaderContext().requestSideEffects(["Note"])
			.then(mustFail(assert), function (oError) {
				assert.strictEqual(oError.message, "Must not request side effects when there is"
					+ " a pending delete in a different batch group");
			});
	}
}, {
	name : "absolute path",
	run : function (assert, oUndeletedContext) {
		return oUndeletedContext.requestSideEffects([
			"/com.sap.gateway.default.zui5_epm_sample.v0002.Container/SalesOrderList"
		]).then(mustFail(assert), function (oError) {
			assert.strictEqual(oError.message, "Must not request side effects when there is"
				+ " a pending delete in a different batch group");
		});
	}
}].forEach(function (oFixture) {
	var sTitle = "CPOUI5ODATAV4-1639: deferred delete & requestSideEffects, " + oFixture.name;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oDeletedContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oUndeletedContext,
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
				value : [
					{Note : "Note 1", SalesOrderID : "1"},
					{Note : "Note 2", SalesOrderID : "2"}
				]
			})
			.expectChange("id", ["1", "2"])
			.expectChange("note", ["Note 1", "Note 2"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("id", ["2"])
				.expectChange("note", ["Note 2"]);

			oBinding = that.oView.byId("table").getBinding("items");
			oDeletedContext = oBinding.getCurrentContexts()[0];
			oUndeletedContext = oBinding.getCurrentContexts()[1];
			oDeletedContext.delete("doNotSubmit"); // promise remains unresolved

			return that.waitForChanges(assert, "deferred delete");
		}).then(function () {
			return Promise.all([
				// code under test
				oFixture.run.call(that, assert, oUndeletedContext, oDeletedContext),
				that.waitForChanges(assert, "requestSideEffects")
			]);
		});
		// do not clean up; leave the pending delete open
	});
});

	//*********************************************************************************************
	// Scenario: Delete & requestSideEffects in one $batch.
	// BCP: 2380019004
	QUnit.test("BCP: 2380019004", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"}
				]
			})
			.expectChange("id", ["1", "2"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("table").getBinding("items");

			that.expectChange("id", ["2"])
				.expectRequest("DELETE SalesOrderList('1')")
				.expectRequest("SalesOrderList?$select=SalesOrderID"
					+ "&$filter=not (SalesOrderID eq '1')&$skip=0&$top=100", {
					value : [{SalesOrderID : "2"}]
				});

			return Promise.all([
				oBinding.getCurrentContexts()[0].delete(),
				oBinding.getHeaderContext().requestSideEffects([""]),
				that.waitForChanges(assert, "delete & requestSideEffects")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: ODLB, late property at an entity within $expand.
	// JIRA: CPOUI5ODATAV4-23
	QUnit.test("ODLB: late property at nested entity", function (assert) {
		var oModel = this.createSalesOrdersModel123({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList(\'1\')/SO_2_SOITEM}">\
	<Text id="product" text="{SOITEM_2_PRODUCT/Name}"/>\
</Table>\
<Text id="businessPartner" text="{SOITEM_2_PRODUCT/PRODUCT_2_BP/CompanyName}"/>',
			that = this;

		this.expectRequest("SalesOrderList('1')/SO_2_SOITEM?sap-client=123"
				+ "&$select=ItemPosition,SalesOrderID"
				+ "&$expand=SOITEM_2_PRODUCT($select=Name,ProductID)&$skip=0&$top=100", {
				value : [{
					"@odata.etag" : "etag0",
					ItemPosition : "0010",
					SalesOrderID : "1",
					SOITEM_2_PRODUCT : {
						"@odata.etag" : "etag1",
						Name : "Notebook Basic 15",
						ProductID : "HT-1000"
					}
				}]
			})
			.expectChange("product", ["Notebook Basic 15"])
			.expectChange("businessPartner");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')"
					+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')"
					+ "/SOITEM_2_PRODUCT?sap-client=123&$select=ProductID"
					+ "&$expand=PRODUCT_2_BP($select=BusinessPartnerID,CompanyName)", {
					"@odata.etag" : "etag1",
					ProductID : "HT-1000",
					PRODUCT_2_BP : {
						"@odata.etag" : "etag2",
						BusinessPartnerID : "0100000005",
						CompanyName : "TECUM"
					}
				})
				.expectChange("businessPartner", "TECUM");

			// code under test
			that.oView.byId("businessPartner").setBindingContext(
				that.oView.byId("table").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: ODCB, late property at an entity within $expand.
	// JIRA: CPOUI5ODATAV4-23
	QUnit.test("ODCB: late property at nested entity", function (assert) {
		var oModel = this.createSalesOrdersModel123({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')/SO_2_SOITEM(\'0010\')}">\
	<Text id="product" text="{SOITEM_2_PRODUCT/Name}"/>\
</FlexBox>\
<Text id="businessPartner" text="{SOITEM_2_PRODUCT/PRODUCT_2_BP/CompanyName}"/>',
			that = this;

		this.expectRequest("SalesOrderList('1')/SO_2_SOITEM('0010')?sap-client=123"
				+ "&$select=ItemPosition,SalesOrderID"
				+ "&$expand=SOITEM_2_PRODUCT($select=Name,ProductID)", {
				ItemPosition : "0010",
				SalesOrderID : "1",
				SOITEM_2_PRODUCT : {
					"@odata.etag" : "ETag",
					Name : "Notebook Basic 15",
					ProductID : "HT-1000"
				}
			})
			.expectChange("product", "Notebook Basic 15")
			.expectChange("businessPartner");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM('0010')/SOITEM_2_PRODUCT"
					+ "?sap-client=123&$select=ProductID"
					+ "&$expand=PRODUCT_2_BP($select=BusinessPartnerID,CompanyName)", {
					"@odata.etag" : "ETag",
					ProductID : "HT-1000",
					PRODUCT_2_BP : {
						BusinessPartnerID : "0100000005",
						CompanyName : "TECUM"
					}
				})
				.expectChange("businessPartner", "TECUM");

			// code under test
			that.oView.byId("businessPartner").setBindingContext(
				that.oView.byId("form").getBindingContext());

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: ODCB, late property at an entity within $expand fails because ETag or key predicate
	// changed.
	// JIRA: CPOUI5ODATAV4-23
	// See that the 'dataReceived' event is containing the context's path in case of error. There
	// are two late property requests. Every GET request is causing a 'dataReceived' event,
	// providing the error and the binding path in case of error.
	// are provided.
	// JIRA: CPOUI5ODATAV4-1746
[{
	error : "ETag changed",
	lateETag : "changedETag",
	lateID : "HT-1000"
}, {
	error : "Key predicate changed from ('HT-1000') to ('HT-2000')",
	lateETag : "ETag",
	lateID : "HT-2000"
}].forEach(function (oFixture) {
	QUnit.test("ODCB: late property at nested entity fails: " + oFixture.error, function (assert) {
		var iDataReceivedCount = 0,
			oModel = this.createSalesOrdersModel123({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')/SO_2_SOITEM(\'0010\')}">\
	<Text id="product" text="{SOITEM_2_PRODUCT/Name}"/>\
</FlexBox>\
<Text id="businessPartner" text="{SOITEM_2_PRODUCT/PRODUCT_2_BP/CompanyName}"/>\
<Text id="itemKey" text="{SOITEM_2_SCHDL/ItemKey}"/>',
			that = this;

		this.expectRequest("SalesOrderList('1')/SO_2_SOITEM('0010')?sap-client=123"
				+ "&$select=ItemPosition,SalesOrderID"
				+ "&$expand=SOITEM_2_PRODUCT($select=Name,ProductID)", {
				"@odata.etag" : "ETag",
				ItemPosition : "0010",
				SalesOrderID : "1",
				SOITEM_2_PRODUCT : {
					"@odata.etag" : "ETag",
					Name : "Notebook Basic 15",
					ProductID : "HT-1000"
				}
			})
			.expectChange("product", "Notebook Basic 15")
			.expectChange("businessPartner");

		return this.createView(assert, sView, oModel).then(function () {
			var oFormContext = that.oView.byId("form").getBindingContext(),
				sMessage4CompanyName
					= "GET SalesOrderList('1')/SO_2_SOITEM('0010')/SOITEM_2_PRODUCT"
						+ "?$select=ProductID&$expand=PRODUCT_2_BP($select=BusinessPartnerID,"
						+ "CompanyName): " + oFixture.error;

			oModel.attachDataReceived(function (oEvent) { // CPOUI5ODATAV4-1746
				// code under test
				if (iDataReceivedCount === 0) {
					assert.strictEqual(
						oEvent.getParameter("path"),
						"/SalesOrderList('1')/SO_2_SOITEM('0010')/SOITEM_2_PRODUCT");
					assert.strictEqual(
						oEvent.getParameter("error").message, sMessage4CompanyName);
				} else if (iDataReceivedCount === 1) {
					assert.strictEqual(
						oEvent.getParameter("path"),
						"/SalesOrderList('1')/SO_2_SOITEM('0010')");
					assert.strictEqual(
						oEvent.getParameter("error").message, "Request intentionally failed");
				}

				iDataReceivedCount += 1;
			});

			that.oLogMock.expects("error")
				.withArgs("Failed to read path /SalesOrderList('1')/SO_2_SOITEM('0010')/"
					+ "SOITEM_2_PRODUCT/PRODUCT_2_BP/CompanyName");
			that.oLogMock.expects("error")
				.withArgs("Failed to read path /SalesOrderList('1')/SO_2_SOITEM('0010')/"
					+ "SOITEM_2_SCHDL/ItemKey");

			that.expectRequest({
					batchNo : 2,
					url : "SalesOrderList('1')/SO_2_SOITEM('0010')/SOITEM_2_PRODUCT"
						+ "?sap-client=123&$select=ProductID"
						+ "&$expand=PRODUCT_2_BP($select=BusinessPartnerID,CompanyName)"
				}, {
					"@odata.etag" : oFixture.lateEtag,
					ProductID : oFixture.lateID,
					PRODUCT_2_BP : {
						BusinessPartnerID : "0100000005",
						CompanyName : "TECUM"
					}
				})
				.expectRequest({
					batchNo : 2,
					url : "SalesOrderList('1')/SO_2_SOITEM('0010')?sap-client=123"
						+ "&$select=SOITEM_2_SCHDL"
						+ "&$expand=SOITEM_2_SCHDL($select=ItemKey,ScheduleKey)"
				}, createErrorInsideBatch())
				.expectChange("businessPartner", null) // initialization due to #setContext
				.expectMessages([{
					message : sMessage4CompanyName,
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			// code under test
			that.oView.byId("businessPartner").setBindingContext(oFormContext);
			that.oView.byId("itemKey").setBindingContext(oFormContext);

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(iDataReceivedCount, 2);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Create a new entity without using a UI and reset it immediately via ODataModel.
	// No request is added to the queue and ODataModel#hasPendingChanges and
	// ODataListBinding#hasPendingChanges work as expected.
	// JIRA: CPOUI5ODATAV4-36
	//
	// Selecting a context does not interfere with reset (JIRA: CPOUI5ODATAV4-1944).
	QUnit.test("create an entity and immediately reset changes (no UI) V4-36", function (assert) {
		var // use autoExpandSelect so that the cache is created asynchronously
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oListBindingWithoutUI = oModel.bindList("/SalesOrderList"),
				oContext = oListBindingWithoutUI.create({}, true),
				oCreatedPromise = oContext.created();

			oContext.setSelected(true);

			// This error is unavoidable as #fetchValue runs right after creating the context, but
			// fails as the context is deleted already.
			that.oLogMock.expects("error")
				.withArgs(sinon.match("Failed to drill-down into ($uid="),
					sSalesOrderService + "SalesOrderList", "sap.ui.model.odata.v4.lib._Cache");

			assert.ok(oModel.hasPendingChanges());
			assert.ok(oListBindingWithoutUI.hasPendingChanges());
			assert.strictEqual(oListBindingWithoutUI.getLength(), 1 + 10/*length is not final*/);

			oModel.resetChanges();

			// the changes must disappear synchronously
			assert.notOk(oModel.hasPendingChanges());
			assert.notOk(oListBindingWithoutUI.hasPendingChanges());
			assert.strictEqual(oListBindingWithoutUI.getLength(), 0);

			return oCreatedPromise.then(mustFail(assert), function (oError) {
				// create (which ran asynchronously) must not have changed anything
				assert.ok(oError.canceled);

				assert.notOk(oModel.hasPendingChanges());
				assert.notOk(oListBindingWithoutUI.hasPendingChanges());
				assert.strictEqual(oListBindingWithoutUI.getLength(), 0);

				return Promise.all([
					checkCanceled(assert, oCreatedPromise),
					that.waitForChanges(assert) // to get all group locks unlocked
				]);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: ODCB, late property at a binding for a complex type, so that no entity can be found
	// in the cache.
	// JIRA: CPOUI5ODATAV4-23
	QUnit.test("ODCB: late property at complex type", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/BusinessPartnerList(\'1\')/Address}">\
	<Text id="city" text="{City}"/>\
</FlexBox>\
<Text id="postalCode" text="{PostalCode}"/>',
			that = this;

		// Note: ETag is contained in the response header, but _Requestor copies it to the payload
		this.expectRequest("BusinessPartnerList('1')/Address?$select=City", {
				"@odata.etag" : "etag",
				City : "Heidelberg"
			})
			.expectChange("city", "Heidelberg")
			.expectChange("postalCode");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("BusinessPartnerList('1')/Address?$select=PostalCode", {
					"@odata.etag" : "etag",
					PostalCode : "69190"
				})
				.expectChange("postalCode", "69190");

			// code under test
			that.oView.byId("postalCode").setBindingContext(
				that.oView.byId("form").getBindingContext());

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Failure to read from an ODataContextBinding returning a bound message
	// BCP: 2070436327: the data state is updated if unbindProperty is called
	// "sap-cancel-on-close" header for $direct GET request (JIRA: CPOUI5ODATAV4-2506)
	QUnit.test("ODCB: read failure & message", function (assert) {
		var oError = createError({
				message : "Could not read",
				target : "Name"
			}),
			oModel = this.createTeaBusiModel({groupId : "$direct"}),
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'42\')}">\
	<Input id="text" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.oLogMock.expects("error")
			.withExactArgs("Failed to read path /EMPLOYEES('42')", sinon.match(oError.message),
				sODCB);
		this.oLogMock.expects("error")
			.withExactArgs("Failed to read path /EMPLOYEES('42')/Name", sinon.match(oError.message),
				sODPrB);
		this.expectRequest({
				headers : {"sap-cancel-on-close" : "true"},
				url : "EMPLOYEES('42')"
			}, oError)
			.expectMessages([{
				code : "CODE",
				message : "Could not read",
				persistent : true,
				target : "/EMPLOYEES('42')/Name",
				technical : true,
				technicalDetails : {
					httpStatus : 500, // CPOUI5ODATAV4-428
					originalMessage : {
						code : "CODE",
						message : "Could not read",
						target : "Name"
					}
				},
				type : "Error"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			return that.checkValueState(assert, "text", "Error", "Could not read");
		}).then(function () {
			// code under test
			that.oView.byId("text").unbindProperty("value");

			return Promise.all([
				that.checkValueState(assert, "text", "None", ""),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(that.oView.byId("text").getValue(), "");
		});
	});

	//*********************************************************************************************
	// Scenario: Failure to read from an ODataPropertyBinding returning a bound message
	QUnit.test("ODPB: read failure & message", function (assert) {
		var oError = createError({
				message : "Could not read",
				target : ""
			}),
			oModel = this.createTeaBusiModel({groupId : "$direct"}),
			sView = '<Input id="text" value="{/EMPLOYEES(\'42\')/Name}"/>',
			that = this;

		this.oLogMock.expects("error")
			.withExactArgs("Failed to read path /EMPLOYEES('42')/Name", sinon.match(oError.message),
				sODPrB);
		this.expectRequest("EMPLOYEES('42')/Name", oError)
			.expectMessages([{
				code : "CODE",
				message : "Could not read",
				persistent : true,
				target : "/EMPLOYEES('42')/Name",
				technical : true,
				type : "Error"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			return that.checkValueState(assert, "text", "Error", "Could not read");
		});
	});

	//*********************************************************************************************
	// Scenario: inherit query options (see ListBinding sample application)
	// If there is a relative binding without an own cache and the parent binding defines $orderby
	// or $filter for that binding, then these values need to be considered if that binding gets
	// dynamic filters or sorters.
	// See ListBinding sample application:
	// * Start the application; the employee list of the team is initially sorted by "City"
	// * Sort by any other column (e.g. "Employee Name" or "Age") and check that the "City" is taken
	//   as a secondary sort criterion
	// In this test dynamic filters are used instead of dynamic sorters
	//
	// Additionally ODLB#getDownloadUrl is tested
	// JIRA: CPOUI5ODATAV4-12
	//
	// Data binding for selection (JIRA: CPOUI5ODATAV4-1944).
	QUnit.test("Relative ODLB inherits parent ODCB's query options on filter", function (assert) {
		var oBinding,
			oHeaderContext,
			oModel,
			sView = '\
<FlexBox binding="{path : \'/EMPLOYEES(\\\'42\\\')\',\
	parameters : {$expand : {EMPLOYEE_2_EQUIPMENTS : {$orderby : \'ID\', $select : \'Name\'}}}}">\
	<Table id="table" items="{EMPLOYEE_2_EQUIPMENTS}">\
		<Text id="text" text="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		oModel = this.createModel(sTeaBusi + "?c1=a&c2=b", {}, {
			"/sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001/$metadata?c1=a&c2=b"
				: {source : "odata/v4/data/metadata.xml"},
			"/sap/opu/odata4/IWBEP/TEA/default/iwbep/tea_busi_product/0001/$metadata?c1=a&c2=b"
				: {source : "odata/v4/data/metadata_tea_busi_product.xml"}
		});

		this.expectRequest("EMPLOYEES('42')?c1=a&c2=b&$expand=EMPLOYEE_2_EQUIPMENTS($orderby=ID"
				+ ";$select=Name)", {
				EMPLOYEE_2_EQUIPMENTS : [
					{Name : "Notebook Basic 15"},
					{Name : "Monitor Basic 24"},
					{Name : "Monitor Basic 28"}
				]
			})
			.expectChange("text", ["Notebook Basic 15", "Monitor Basic 24", "Monitor Basic 28"]);

		return this.createView(assert, sView, oModel).then(function () {
			var sExpectedDownloadUrl = sTeaBusi
					+ "EMPLOYEES('42')/EMPLOYEE_2_EQUIPMENTS?c1=a&c2=b&$orderby=ID&$select=Name";

			oBinding = that.oView.byId("table").getBinding("items");
			assert.strictEqual(oBinding.getDownloadUrl(), sExpectedDownloadUrl);
			return oBinding.requestDownloadUrl().then(function (sDownloadUrl) {
				assert.strictEqual(sDownloadUrl, sExpectedDownloadUrl);
			});
		}).then(function () {
			var sResourceUrl = "EMPLOYEES('42')/EMPLOYEE_2_EQUIPMENTS?$orderby=ID&$select=Name&c1=a"
					+ "&c2=b&$filter=EQUIPMENT_2_PRODUCT/SupplierIdentifier%20eq%202";

			oHeaderContext = oBinding.getHeaderContext();
			assert.deepEqual(oHeaderContext.getObject(), {
				"@$ui5.context.isSelected" : false,
				$count : 3
			}, "JIRA: CPOUI5ODATAV4-1944");
			checkSelected(assert, oHeaderContext, false);

			oHeaderContext.setSelected(true); // "select all"

			assert.deepEqual(oHeaderContext.getObject(), {
				"@$ui5.context.isSelected" : true,
				$count : 3
			}, "JIRA: CPOUI5ODATAV4-1944");
			checkSelected(assert, oHeaderContext, true);

			that.expectRequest(sResourceUrl + "&$skip=0&$top=100", {
					value : [
						{Name : "Monitor Basic 24"},
						{Name : "Monitor Basic 28"}
					]
				})
				.expectChange("text", ["Monitor Basic 24", "Monitor Basic 28"]);

			// code under test - filter becomes async because product metadata has to be loaded
			oBinding.filter(
				new Filter("EQUIPMENT_2_PRODUCT/SupplierIdentifier", FilterOperator.EQ, 2));

			checkSelected(assert, oHeaderContext, true);
			assert.throws(function () {
				oBinding.getDownloadUrl();
			}, new Error("Result pending"));

			return Promise.all([
				oBinding.requestDownloadUrl().then(function (sDownloadUrl) {
					assert.strictEqual(sDownloadUrl, sTeaBusi + sResourceUrl);
					assert.strictEqual(oBinding.getDownloadUrl(), sTeaBusi + sResourceUrl);
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.deepEqual(oHeaderContext.getObject(""), {
				"@$ui5.context.isSelected" : true,
				$count : 2
			}, "JIRA: CPOUI5ODATAV4-1944");
		});
	});

	//*********************************************************************************************
	// Refresh single row after it has been updated with a value which doesn't match the table's
	// filter anymore. In this case we expect the single row to disappear.
	QUnit.test("Context#refresh(undefined, true)", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table"\
		items="{\
			path : \'/EMPLOYEES\',\
			filters : {path : \'AGE\', operator : \'GT\', value1 : \'42\'},\
			sorter : {path : \'AGE\'},\
			parameters : {foo : \'bar\'}\
		}">\
	<Text id="text" text="{Name}"/>\
	<Input id="age" value="{AGE}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?foo=bar&$orderby=AGE&$filter=AGE gt 42"
				+ "&$select=AGE,ID,Name&$skip=0&$top=100", {
				value : [
					{"@odata.etag" : "ETag0", ID : "0", Name : "Frederic Fall", AGE : 70},
					{ID : "1", Name : "Jonathan Smith", AGE : 50},
					{ID : "2", Name : "Peter Burke", AGE : 77}
				]
			})
			.expectChange("text", ["Frederic Fall", "Jonathan Smith", "Peter Burke"])
			.expectChange("age", ["70", "50", "77"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('0')?foo=bar",
					headers : {"If-Match" : "ETag0"},
					payload : {AGE : 10}
				}) // 204 No Content
				.expectChange("age", ["10"]); // caused by setValue

			oTable.getItems()[0].getCells()[1].getBinding("value").setValue(10);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("EMPLOYEES?foo=bar&$filter=(AGE gt 42) and ID eq '0'"
					+ "&$select=AGE,ID,Name", {value : []})
				.expectChange("text", ["Jonathan Smith", "Peter Burke"])
				.expectChange("age", ["50", "77"]);

			// code under test
			oTable.getItems()[0].getBindingContext().refresh(undefined, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("EMPLOYEES?foo=bar&$filter=(AGE gt 42) and ID eq '1'"
					+ "&$select=AGE,ID,Name", {
					value : [{
						ID : "1",
						Name : "Jonathan Smith",
						AGE : 51
					}]
				})
				.expectChange("age", ["51"]);

			// code under test
			oTable.getItems()[0].getBindingContext().refresh(undefined, true);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Refresh a single row with a bound message and check that the message is not duplicated.
	// Refreshing a single line in a collection must not remove messages for other lines.
	QUnit.test("Context#refresh() with messages", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oMessage1 = {
				code : "2",
				message : "Another Text",
				target : "/EMPLOYEES('1')/ID",
				type : "Warning"
			},
			oResponseMessage0 = {
				code : "1",
				message : "Text",
				numericSeverity : 3,
				target : "ID",
				transition : false
			},
			oResponseMessage0AfterRefresh = {
				code : "1",
				message : "Text after refresh",
				numericSeverity : 3,
				target : "ID",
				transition : false
			},
			oResponseMessage1 = {
				code : "2",
				message : "Another Text",
				numericSeverity : 3,
				target : "ID",
				transition : false
			},
			oTable,
			sView = '\
<Table id="table"\
		items="{\
			path : \'/EMPLOYEES\',\
			parameters : {$select : \'__CT__FAKE__Message/__FAKE__Messages\'}\
		}">\
	<Input id="id" value="{ID}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID,__CT__FAKE__Message/__FAKE__Messages"
				+ "&$skip=0&$top=100", {
				value : [{
					ID : "0",
					__CT__FAKE__Message : {
						__FAKE__Messages : [oResponseMessage0]
					}
				}, {
					ID : "1",
					__CT__FAKE__Message : {
						__FAKE__Messages : [oResponseMessage1]
					}
				}]
			})
			.expectChange("id", ["0", "1"])
			.expectMessages([{
				code : "1",
				message : "Text",
				target : "/EMPLOYEES('0')/ID",
				technicalDetails : {
					originalMessage : oResponseMessage0
				},
				type : "Warning"
			}, oMessage1]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			return Promise.all([
				that.checkValueState(assert, oTable.getItems()[0].getCells()[0],
					"Warning", "Text"),
				that.checkValueState(assert, oTable.getItems()[1].getCells()[0],
					"Warning", "Another Text")
			]);
		}).then(function () {
			var oContext = oTable.getItems()[0].getBindingContext();

			that.expectRequest("EMPLOYEES('0')?$select=ID,__CT__FAKE__Message/__FAKE__Messages", {
					ID : "0",
					__CT__FAKE__Message : {
						__FAKE__Messages : [oResponseMessage0AfterRefresh]
					}
				})
				.expectMessages([{
					code : "1",
					message : "Text after refresh",
					target : "/EMPLOYEES('0')/ID",
					type : "Warning"
				}, oMessage1]);

			// code under test
			oContext.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, oTable.getItems()[0].getCells()[0],
				"Warning", "Text after refresh");
		}).then(function () {
			return that.checkValueState(assert, oTable.getItems()[1].getCells()[0],
				"Warning", "Another Text");
		});
	});

	//*********************************************************************************************
	// Refresh a single row that has been removed in between. Check the bound message of the error
	// response.
	QUnit.test("Context#refresh() error messages", function (assert) {
		var oError = createError({
				message : "Not found",
				target : "ID"
			}, 404),
			oModel = this.createTeaBusiModel({autoExpandSelect : true, groupId : "$direct"}),
			oTable,
			sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Input value="{ID}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID&$skip=0&$top=100", {
				value : [{ID : "0"}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.oLogMock.expects("error")
				.withExactArgs("Failed to refresh entity: /EMPLOYEES('0')[0]",
					sinon.match(oError.message), sODLB);
			that.expectRequest("EMPLOYEES('0')?$select=ID", oError)
				.expectMessages([{
					code : "CODE",
					message : "Not found",
					persistent : true,
					target : "/EMPLOYEES('0')/ID",
					technical : true,
					type : "Error"
				}]);

			// code under test
			oTable.getItems()[0].getBindingContext().refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				oTable.getItems()[0].getCells()[0], "Error", "Not found");
		});
	});

	//*********************************************************************************************
	// Scenario: A row is deleted. Afterwards, but before the rendering the list is refreshed. The
	// list has a nested list.
	//
	// BCP: 002075129500005176612021
	QUnit.test("Nested ODLB: contexts deleted too early", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="rootTable" items="{/SalesOrderList}">\
	<Text text="{SalesOrderID}"/>\
	<Table items="{path : \'SO_2_SOITEM\', templateShareable : false}">\
		<Text text="{ItemPosition}"/>\
		<Text text="{SOITEM_2_SO/CurrencyCode}"/>\
	</Table>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=CurrencyCode,SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)&$skip=0&$top=100", {
				value : [{
					CurrencyCode : "EUR",
					SalesOrderID : "1",
					SO_2_SOITEM : []
				}, {
					CurrencyCode : "EUR",
					SalesOrderID : "2",
					SO_2_SOITEM : [
						{ItemPosition : "0010", SalesOrderID : "2"}
					]
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			var oRootTable = that.oView.byId("rootTable");

			that.expectRequest("DELETE SalesOrderList('1')")
				.expectRequest("SalesOrderList?$select=CurrencyCode,SalesOrderID"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)&$skip=0&$top=100", {
					value : [{
						CurrencyCode : "EUR",
						SalesOrderID : "2",
						SO_2_SOITEM : [
							{ItemPosition : "0010", SalesOrderID : "2"}
						]
					}]
				});

			return Promise.all([
				oRootTable.getItems()[0].getBindingContext().delete().then(function () {
					// refresh before the prerendering task caused by #getContexts after #delete
					// has run, so that in that task _all_ contexts are parked
					return oRootTable.getBinding("items").requestRefresh();
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A table is destroyed while its list binding is not yet finished with
	// auto-$expand/$select.
	//
	// BCP: 2380052347
	QUnit.test("BCP: 2380052347", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/SalesOrderList\', suspended : true}">\
	<Text text="{SalesOrderID}"/>\
</Table>',
			that = this;

		return this.createView(assert, sView, oModel).then(function () {
			var oTable = that.oView.byId("table");

			oTable.getBinding("items").resume();

			that.expectCanceledError("Cache discarded as a new cache has been created")
				.expectCanceledError(sODLB + ": /SalesOrderList: Failed to enhance query options"
					+ " for auto-$expand/$select for child SalesOrderID",
				"Cache discarded as a new cache has been created");

			return Promise.all([
				Promise.resolve().then(function () {
					// code under test
					// Note: oTable.destroy(); not allowed for direct children of XMLView!
					that.oView.destroy();
					delete that.oView;
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh single row in a list below a return value context. Ensure that
	// refreshSingle is able to calculate the key predicates in its response and a subsequent PATCH
	// is possible.
	// BCP: 2070137560
	QUnit.test("Context.refresh() in a list relative to a return value context", function (assert) {
		var oTable,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<FlexBox id="action" binding="{\
			path : \'com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm(...)\',\
			parameters : {$expand : {SO_2_SOITEM : {$expand : {SOITEM_2_PRODUCT : null}}}}\
		}"/>\
</FlexBox>\
<FlexBox id="rvc">\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Input id="name" value="{SOITEM_2_PRODUCT/Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')", {SalesOrderID : "1"})
			.expectChange("id", "1")
			.expectChange("name", []);

		return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('1')/"
						+ "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm"
						+ "?$expand=SO_2_SOITEM($expand=SOITEM_2_PRODUCT)",
					payload : {}
				}, {
					SalesOrderID : "1",
					SO_2_SOITEM : [{
						ItemPosition : "0010",
						SalesOrderID : "1",
						SOITEM_2_PRODUCT : {
							Name : "Notebook Basic 15",
							ProductID : "HT-1000"
						}
					}]
			});

			return Promise.all([
				that.oView.byId("action").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			that.expectChange("name", ["Notebook Basic 15"]);

			that.oView.byId("rvc").setBindingContext(aResults[0]);

			return that.waitForChanges(assert);
		}).then(function () {
			oTable = that.oView.byId("table");

			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',"
					+ "ItemPosition='0010')?$expand=SOITEM_2_PRODUCT", {
					ItemPosition : "0010",
					SalesOrderID : "1",
					SOITEM_2_PRODUCT : {
						Name : "Notebook Basic 15.1",
						ProductID : "HT-1000"
					}
				})
				.expectChange("name", ["Notebook Basic 15.1"]);

			oTable.getItems()[0].getBindingContext().refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("name", ["Notebook Basic 15.2"])
				.expectRequest({
					method : "PATCH",
					url : "ProductList('HT-1000')",
					payload : {Name : "Notebook Basic 15.2"}
				});

			oTable.getItems()[0].getCells()[0].getBinding("value").setValue("Notebook Basic 15.2");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Refreshing (a single entry of) a table must not cause "failed to drill-down" errors
	// if data of a dependent binding has been deleted in between.
	// This scenario is similar to the deletion of a sales order line item in the SalesOrders
	// application. Deleting a sales order line item also deletes the corresponding schedule. After
	// the deletion the application automatically refreshes the sales order which the item has
	// belonged to.
	[function (oTable) {
		this.expectRequest("EMPLOYEES('0')?$select=AGE,ID,Name",
				{ID : "0", Name : "Frederic Fall", AGE : 70})
			.expectRequest("EMPLOYEES('0')/EMPLOYEE_2_EQUIPMENTS"
				+ "?$select=Category,ID,Name&$skip=0&$top=100", {
				value : [{
					Category : "Electronics",
					ID : "1",
					Name : "Office PC"
				}]
			});

		oTable.getItems()[0].getBindingContext().refresh();
	}, function (oTable) {
		this.expectRequest("EMPLOYEES?$select=AGE,ID,Name&$skip=0&$top=100", {
				value : [{ID : "0", Name : "Frederic Fall", AGE : 70}]
			})
			.expectRequest("EMPLOYEES('0')/EMPLOYEE_2_EQUIPMENTS"
				+ "?$select=Category,ID,Name&$skip=0&$top=100", {
				value : [{
					Category : "Electronics",
					ID : "1",
					Name : "Office PC"
				}]
			});
		oTable.getBinding("items").refresh();
	}].forEach(function (fnRefresh, i) {
		QUnit.test("refresh: No drill-down error for deleted data #" + i, function (assert) {
			var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
				oTable,
				sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Text id="text" text="{Name}"/>\
	<Text id="age" text="{AGE}"/>\
</Table>\
<Table id="detailTable" items="{path : \'EMPLOYEE_2_EQUIPMENTS\',\
		parameters : {$$ownRequest : true}}">\
	<Text id="equipmentName" text="{Name}"/>\
</Table>',
				that = this;

			this.expectRequest("EMPLOYEES?$select=AGE,ID,Name&$skip=0&$top=100", {
					value : [{
						ID : "0",
						Name : "Frederic Fall",
						AGE : 70
					}]
				})
				.expectChange("text", ["Frederic Fall"])
				.expectChange("age", ["70"])
				.expectChange("equipmentName", []);

			return this.createView(assert, sView, oModel).then(function () {
				oTable = that.oView.byId("table");

				that.expectRequest("EMPLOYEES('0')/EMPLOYEE_2_EQUIPMENTS"
						+ "?$select=Category,ID,Name&$skip=0&$top=100", {
						value : [{
							Category : "Electronics",
							ID : "1",
							Name : "Office PC"
						}, {
							Category : "Electronics",
							ID : "2",
							Name : "Tablet X"
						}]
					})
					.expectChange("equipmentName", ["Office PC", "Tablet X"]);
				that.oView.byId("detailTable").setBindingContext(
					oTable.getItems()[0].getBindingContext());

				return that.waitForChanges(assert);
			}).then(function () {
				fnRefresh.call(that, oTable);

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Sort a list and select a list entry to see details
	// See SalesOrders application:
	// * Start the application with realOData=true so that sorting by "Gross Amount" is enabled
	// * Sort by "Gross Amount"
	// * Select a sales order and see that sales order details are fitting to the selected sales
	//   order
	// This test is a simplification of that scenario with a different service.
	QUnit.test("Absolute ODLB with sort, relative ODCB resolved on selection", function (assert) {
		var oForm,
			oTable,
			oTableBinding,
			sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\', parameters : {$expand : \'EMPLOYEE_2_MANAGER\'}}">\
	<Text id="name" text="{Name}"/>\
</Table>\
<FlexBox id="form" binding="{EMPLOYEE_2_MANAGER}">\
	<Text id="id" text="{ID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES?$expand=EMPLOYEE_2_MANAGER&$skip=0&$top=100", {
				value : [
					{Name : "Jonathan Smith", EMPLOYEE_2_MANAGER : {ID : "2"}},
					{Name : "Frederic Fall", EMPLOYEE_2_MANAGER : {ID : "1"}}
				]
			})
			.expectChange("id")
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"]);

		return this.createView(assert, sView).then(function () {
			oTable = that.oView.byId("table");
			oTableBinding = oTable.getBinding("items");

			that.expectRequest("EMPLOYEES?$expand=EMPLOYEE_2_MANAGER&$orderby=Name"
					+ "&$skip=0&$top=100", {
					value : [
						{Name : "Frederic Fall", EMPLOYEE_2_MANAGER : {ID : "1"}},
						{Name : "Jonathan Smith", EMPLOYEE_2_MANAGER : {ID : "2"}}
					]
				})
				.expectChange("name", ["Frederic Fall", "Jonathan Smith"]);

			// code under test
			oTableBinding.sort(new Sorter("Name"));

			return that.waitForChanges(assert);
		}).then(function () {
			oForm = that.oView.byId("form");

			that.expectChange("id", "2");

			// code under test
			oForm.setBindingContext(oTableBinding.getCurrentContexts()[1]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("id", "1");

			// code under test
			oForm.setBindingContext(oTableBinding.getCurrentContexts()[0]);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh an ODataListBinding
	// See SalesOrders application:
	// * Start the application
	// * Click on "Refresh sales orders" button
	// This test is a simplification of that scenario with a different service.
	QUnit.test("Absolute ODLB refresh", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\', \
		parameters : {$select : \'__CT__FAKE__Message/__FAKE__Messages\'}}">\
	<dependents><plugins:DataStateIndicator/></dependents>\
	<Input id="name" value="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages"
				+ "&$skip=0&$top=100", {
				value : [{
					ID : "1",
					Name : "Jonathan Smith",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Text",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				}, {
					ID : "2",
					Name : "Frederic Fall",
					__CT__FAKE__Message : {__FAKE__Messages : []}
				}]
			})
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"])
			.expectMessages([{
				code : "1",
				message : "Text",
				target : "/EMPLOYEES('1')/Name",
				type : "Warning"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			return that.checkValueState(assert, oTable.getItems()[0].getCells()[0], "Warning",
				"Text");
		}).then(function () { // it takes some time until the sap.m.MessageStrip is there
			return resolveLater(function () {
				assert.strictEqual(oTable.getAggregation("_messageStrip").getType(), "Warning",
					"JIRA: CPOUI5ODATAV4-460");
			});
		}).then(function () {
			that.expectRequest("EMPLOYEES?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages"
					+ "&$skip=0&$top=100", {
					value : [{
						Name : "Frederic Fall",
						__CT__FAKE__Message : {__FAKE__Messages : []}
					}, {
						Name : "Peter Burke",
						__CT__FAKE__Message : {__FAKE__Messages : []}
					}]
				})
				.expectChange("name", ["Frederic Fall", "Peter Burke"])
				.expectMessages([]);

			// code under test
			oTable.getBinding("items").refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(oTable.getAggregation("_messageStrip").getVisible(), false,
				"JIRA: CPOUI5ODATAV4-460");

			return that.checkValueState(assert, oTable.getItems()[0].getCells()[0], "None", "");
		});
	});

	//*********************************************************************************************
	// Scenario: Messages for collection entries without key properties
	QUnit.test("Absolute ODLB: messages for entries without key properties", function (assert) {
		var oMessage1 = {
				code : "1",
				message : "Text",
				target : "/EMPLOYEES/1/Name",
				type : "Warning"
			},
			oMessage2 = {
				code : "2",
				message : "Text2",
				target : "/EMPLOYEES/2/Name",
				type : "Warning"
			},
			oTable,
			sView = '\
<t:Table id="table" rows="{\
			path : \'/EMPLOYEES\',\
			parameters : {$select : \'Name,__CT__FAKE__Message/__FAKE__Messages\'}\
		}"\ threshold="0" visibleRowCount="2">\
	<Input id="name" value="{Name}"/>\
</t:Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=Name,__CT__FAKE__Message/__FAKE__Messages"
				+ "&$skip=0&$top=2", {
				value : [{
					Name : "Jonathan Smith",
					__CT__FAKE__Message : {__FAKE__Messages : []}
				}, {
					Name : "Frederic Fall",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Text",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				}]
			})
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"])
			.expectMessages([oMessage1]);

		return this.createView(assert, sView).then(function () {
			oTable = that.oView.byId("table");

			return that.checkValueState(assert, oTable.getRows()[1].getCells()[0],
				"Warning", "Text");
		}).then(function () {
			that.expectRequest("EMPLOYEES?$select=Name,__CT__FAKE__Message/__FAKE__Messages"
					+ "&$skip=2&$top=1", {
					value : [{
						Name : "Peter Burke",
						__CT__FAKE__Message : {
							__FAKE__Messages : [{
								code : "2",
								message : "Text2",
								numericSeverity : 3,
								target : "Name",
								transition : false
							}]
						}
					}]
				})
				.expectChange("name", [, "Frederic Fall", "Peter Burke"])
				.expectMessages([oMessage1, oMessage2]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, oTable.getRows()[0].getCells()[0],
				"Warning", "Text");
		}).then(function () {
			return that.checkValueState(assert, oTable.getRows()[1].getCells()[0],
				"Warning", "Text2");
		});
		//TODO: using an index for a bound message leads to a wrong target if for example
		//      an entity with a lower index gets deleted, see CPOUI5UISERVICESV3-413
	});

	//*********************************************************************************************
	// Scenario: Refresh an ODataContextBinding with a message, the entity is deleted in between
	QUnit.test("Absolute ODCB refresh & message", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true, groupId : "$direct"}),
			sView = '\
<FlexBox id="form" binding="{path : \'/EMPLOYEES(\\\'2\\\')\', \
	parameters : {$select : \'__CT__FAKE__Message/__FAKE__Messages\'}}">\
	<Input id="text" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages", {
				ID : "1",
				Name : "Jonathan Smith",
				__CT__FAKE__Message : {
					__FAKE__Messages : [{
						code : "1",
						message : "Text",
						numericSeverity : 3,
						target : "Name",
						transition : false
					}]
				}
			})
			.expectChange("text", "Jonathan Smith")
			.expectMessages([{
				code : "1",
				message : "Text",
				target : "/EMPLOYEES('2')/Name",
				type : "Warning"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			return that.checkValueState(assert, "text", "Warning", "Text");
		}).then(function () {
			var oError = createError({message : "Employee does not exist"});

			that.oLogMock.expects("error").withExactArgs("Failed to read path /EMPLOYEES('2')",
				sinon.match(oError.message), sODCB);
			that.oLogMock.expects("error").withExactArgs("Failed to read path /EMPLOYEES('2')/Name",
				sinon.match(oError.message), sODPrB);
			that.expectRequest(
					"EMPLOYEES('2')?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages", oError)
				.expectChange("text", null)
				.expectMessages([{
					code : "CODE",
					message : "Employee does not exist",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			// code under test
			that.oView.byId("form").getObjectBinding().refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh an ODataContextBinding
	// The SalesOrders application does not have such a scenario.
	[false, true].forEach(function (bViaContext) {
		QUnit.test("Absolute ODCB refresh, via bound context " + bViaContext, function (assert) {
			var sView = '\
<FlexBox id="form" binding="{/EMPLOYEES(\'2\')}">\
	<Text id="text" text="{Name}"/>\
</FlexBox>',
				that = this;

			this.expectRequest("EMPLOYEES('2')", {Name : "Jonathan Smith"})
				.expectChange("text", "Jonathan Smith");

			return this.createView(assert, sView).then(function () {
				var oBinding = that.oView.byId("form").getObjectBinding();

				that.expectRequest("EMPLOYEES('2')", {Name : "Jonathan Smith"});

				// code under test
				if (bViaContext) {
					oBinding.getBoundContext().refresh();
				} else {
					oBinding.refresh();
				}

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh an ODataPropertyBinding
	// See SalesOrders application:
	// * Start the application
	// * Click on "Refresh favorite product" button
	// This test is a simplification of that scenario with a different service.
	QUnit.test("Absolute ODPB refresh", function (assert) {
		var sView = '<Text id="name" text="{/EMPLOYEES(\'2\')/Name}"/>',
			that = this;

		this.expectRequest("EMPLOYEES('2')/Name", {value : "Jonathan Smith"})
			.expectChange("name", "Jonathan Smith");

		return this.createView(assert, sView).then(function () {
			that.expectRequest("EMPLOYEES('2')/Name", {value : "Jonathan Schmidt"})
				.expectChange("name", "Jonathan Schmidt");

			// code under test
			that.oView.byId("name").getBinding("text").refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh an ODataContextBinding and wait for the result.
	// BCP: 2180064076
	QUnit.test("ODCB: requestRefresh", function (assert) {
		var oBinding,
			oContext,
			sView = '\
<FlexBox id="form" binding="{/EMPLOYEES(\'1\')}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')", {ID : "1", Name : "Jonathan Smith"})
			.expectChange("name", "Jonathan Smith");

		return this.createView(assert, sView).then(function () {
			oBinding = that.oView.byId("form").getObjectBinding();
			oContext = oBinding.getBoundContext();

			that.expectRequest("EMPLOYEES('1')", {ID : "1", Name : "Jonathan Smith *"})
				.expectChange("name", "Jonathan Smith *");

			return Promise.all([
				oBinding.requestRefresh().then(function () {
					assert.strictEqual(oContext.getProperty("Name"), "Jonathan Smith *");
				}),
				that.waitForChanges(assert, "requestRefresh on binding")
			]);
		}).then(function () {
			that.expectRequest("EMPLOYEES('1')", {ID : "1", Name : "Jonathan Smith **"})
				.expectChange("name", "Jonathan Smith **");

			return Promise.all([
				oContext.requestRefresh().then(function () {
					assert.strictEqual(oContext.getProperty("Name"), "Jonathan Smith **");
				}),
				that.waitForChanges(assert, "requestRefresh on context")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh an ODataListBinding and wait for the result.
	// BCP: 2180064076
	QUnit.test("ODLB: requestRefresh", function (assert) {
		var oBinding,
			oContext,
			sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$skip=0&$top=100",
				{value : [{ID : "1", Name : "Jonathan Smith"}]})
			.expectChange("name", ["Jonathan Smith"]);

		return this.createView(assert, sView).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");
			oContext = oBinding.getCurrentContexts()[0];

			that.expectRequest("EMPLOYEES?$skip=0&$top=100",
					{value : [{ID : "1", Name : "Jonathan Smith *"}]})
				.expectChange("name", ["Jonathan Smith *"]);

			return Promise.all([
				oBinding.requestRefresh().then(function () {
					assert.strictEqual(oContext.getProperty("Name"), "Jonathan Smith *");
				}),
				that.waitForChanges(assert, "requestRefresh on binding")
			]);
		}).then(function () {
			that.expectRequest("EMPLOYEES('1')", {ID : "1", Name : "Jonathan Smith **"})
				.expectChange("name", ["Jonathan Smith **"]);

			return Promise.all([
				oContext.requestRefresh().then(function () {
					assert.strictEqual(oContext.getProperty("Name"), "Jonathan Smith **");
				}),
				oContext.requestProperty("Name").then(function (sName) {
					assert.strictEqual(sName, "Jonathan Smith *", "still the old value");
				}),
				that.waitForChanges(assert, "requestRefresh on context")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Action Imports
	// See ListBinding application:
	// * Start the application
	// * Click on "Budget" button
	// * In the "Change Team Budget" dialog enter a "Budget" and press "Change" button
	QUnit.test("ActionImport", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{/ChangeTeamBudgetByID(...)}">\
	<Input id="name" value="{Name}"/>\
</FlexBox>',
			oModelMessage = {
				code : "1",
				message : "Warning Text",
				target : "/ChangeTeamBudgetByID(...)/Name",
				type : "Warning"
			},
			oResponseMessage = {
				code : "1",
				message : "Warning Text",
				numericSeverity : 3,
				target : "Name",
				transition : false
			},
			that = this;

		this.expectChange("name", null);

		return this.createView(assert, sView).then(function () {
			that.expectRequest({
					method : "POST",
					url : "ChangeTeamBudgetByID",
					payload : {
						Budget : "1234.1234",
						TeamID : "TEAM_01"
					}
				}, {
					Name : "Business Suite",
					__CT__FAKE__Message : {
						__FAKE__Messages : [oResponseMessage]
					}
				})
				.expectMessages([oModelMessage])
				.expectChange("name", "Business Suite");

			return Promise.all([
				// code under test
				that.oView.byId("form").getObjectBinding()
					.setParameter("TeamID", "TEAM_01")
					.setParameter("Budget", "1234.1234")
					.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "name", "Warning", "Warning Text");
		});
	});

	//*********************************************************************************************
	// Scenario: Allow binding of operation parameters (see ListBinding application)
	// - automatic type determination
	// JIRA: CPOUI5UISERVICESV3-2010
	QUnit.test("Allow binding of operation parameters: type determination", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{/ChangeTeamBudgetByID(...)}">\
	<Input id="budget" value="{$Parameter/Budget}"/>\
	<Input id="teamId" value="{$Parameter/TeamID}"/>\
</FlexBox>',
			that = this;

		this.expectChange("budget", null)
			.expectChange("teamId", "");

		return this.createView(assert, sView).then(function () {
			var oBudgetType = that.oView.byId("budget").getBinding("value").getType(),
				oTeamIdType = that.oView.byId("teamId").getBinding("value").getType();

			// verify automatic type determination
			assert.strictEqual(oBudgetType.getName(), "sap.ui.model.odata.type.Decimal");
			assert.deepEqual(oBudgetType.oConstraints, {
				nullable : false,
				precision : 16,
				scale : Infinity
			});
			assert.strictEqual(oTeamIdType.getName(), "sap.ui.model.odata.type.String");
			assert.deepEqual(oTeamIdType.oConstraints, {
				maxLength : 10,
				nullable : false
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Allow binding of operation parameters (see ListBinding application)
	// - parameters appear on UI via binding
	// JIRA: CPOUI5UISERVICESV3-2010
	QUnit.test("Allow binding of operation parameters: OneTime", function (assert) {
		var sView = '\
<FlexBox id="form">\
	<Input id="budget" value="{Budget}"/>\
	<Input id="teamId" value="{TeamID}"/>\
</FlexBox>',
			that = this;

		this.expectChange("budget")
			.expectChange("teamId");

		return this.createView(assert, sView).then(function () {
			var oOperationBinding = that.oModel.bindContext("/ChangeTeamBudgetByID(...)"),
				oParameterContext = oOperationBinding.getParameterContext();

			oOperationBinding
				.setParameter("Budget", "1234.1234")
				.setParameter("TeamID", "TEAM_01");

			that.expectChange("budget", "1,234.1234")
				.expectChange("teamId", "TEAM_01");

			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-2014)
				oParameterContext.resetChanges();
			}, new Error("Cannot reset: " + oParameterContext));

			that.oView.byId("form").setBindingContext(oParameterContext);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Allow binding of operation parameters (see ListBinding application)
	// - parameters appear on UI via binding
	// JIRA: CPOUI5UISERVICESV3-2010
	QUnit.test("Allow binding of operation parameters: OneWay", function (assert) {
		var oOperationBinding,
			sView = '\
<FlexBox id="form" binding="{/ChangeTeamBudgetByID(...)}">\
	<Input id="budget" value="{$Parameter/Budget}"/>\
	<Input id="teamId" value="{$Parameter/TeamID}"/>\
</FlexBox>',
			that = this;

		this.expectChange("budget", null)
			.expectChange("teamId", "");

		return this.createView(assert, sView).then(function () {
			oOperationBinding = that.oView.byId("form").getObjectBinding();

			that.expectChange("budget", "1,234.1234")
				.expectChange("teamId", "TEAM_01");

			oOperationBinding
				.setParameter("Budget", "1234.1234")
				.setParameter("TeamID", "TEAM_01");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "ChangeTeamBudgetByID",
					payload : {
						Budget : "1234.1234",
						TeamID : "TEAM_01"
					}
				}); // response does not matter here

			oOperationBinding.invoke();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("budget", "56,789");

			oOperationBinding.setParameter("Budget", "56789");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("budget", "98,765");

			return Promise.all([
				oOperationBinding.getParameterContext().setProperty("Budget", "98765"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("budget", "12,345");

			that.oView.byId("budget").getBinding("value").setValue("12345");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("budget", "54,321");

			return Promise.all([
				that.oView.byId("form").getBindingContext()
					.setProperty("$Parameter/Budget", "54321"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("teamId", null);

			// #deregisterChangeListener
			that.oView.byId("teamId").getBinding("value").setContext(null);

			return that.waitForChanges(assert);
		}).then(function () {
			oOperationBinding.setParameter("TeamID", "n/a");
		});
	});

	//*********************************************************************************************
	// Scenario: Allow setting parameters of operations via control property binding
	// - parameters change because of change in property binding
	// JIRA: CPOUI5UISERVICESV3-2010
	// JIRA: CPOUI5ODATAV4-29, check message target for unbound action
	// JIRA: CPOUI5ODATAV4-852, support multiple targets in messages
	QUnit.test("Allow binding of operation parameters: Changing with controls", function (assert) {
		var oModel = this.createTeaBusiModel({groupId : "$direct"}),
			oOperation,
			oParameterContext,
			sView = '\
<FlexBox id="operation" binding="{/ChangeTeamBudgetByID(...)}">\
	<FlexBox id="parameter" binding="{$Parameter}">\
		<Input id="budget" value="{Budget}"/>\
		<Input id="teamId" value="{TeamID}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectChange("budget", null)
			.expectChange("teamId", "");

		return this.createView(assert, sView, oModel).then(function () {
			oOperation = that.oView.byId("operation").getObjectBinding();
			oParameterContext = oOperation.getParameterContext();

			that.expectChange("budget", "1,234.1234");

			// code under test - setting the parameter via value binding
			that.oView.byId("budget").getBinding("value").setValue("1234.1234");
			assert.strictEqual(oParameterContext.getProperty("Budget"), "1234.1234");

			return that.waitForChanges(assert);
		}).then(function () {
			var oPromise;

			that.expectChange("budget", "4,321.1234");

			// code under test - setting the parameter via operation
			oPromise = oOperation.getBoundContext().setProperty("$Parameter/Budget", "4321.1234");

			assert.strictEqual(oParameterContext.getProperty("Budget"), "4321.1234");

			return Promise.all([oPromise, that.waitForChanges(assert)]);
		}).then(function () {
			that.expectChange("teamId", "TEAM_01");

			return Promise.all([
				// also test the API for property setting w/o PATCH (CPOUI5ODATAV4-14)
				that.oView.byId("parameter").getBindingContext()
					.setProperty("TeamID", "TEAM_01", /*no PATCH*/null),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest({
				method : "POST",
				url : "ChangeTeamBudgetByID",
				payload : {
					Budget : "4321.1234",
					TeamID : "TEAM_01"
				}
			}, {/* response does not matter here */});

			// code under test
			oOperation.invoke();

			return that.waitForChanges(assert);
		}).then(function () {
			// JIRA: CPOUI5ODATAV4-29
			var oError = createError({
					message : "Invalid Budget",
					target : "Foo",
					"@Common.additionalTargets" : ["Budget", "Bar", "TeamID"]
				});

			that.oLogMock.expects("error")
				.withExactArgs("Failed to invoke /ChangeTeamBudgetByID(...)",
					sinon.match(oError.message), sODCB);
			that.expectRequest({
					method : "POST",
					url : "ChangeTeamBudgetByID",
					payload : {
						Budget : "-42",
						TeamID : "TEAM_01"
					}
				}, oError) // simulates failure
				.expectMessages([{
					code : "CODE",
					message : "Invalid Budget",
					persistent : true,
					targets : [
						"/ChangeTeamBudgetByID(...)/$Parameter/Budget",
						"/ChangeTeamBudgetByID(...)/$Parameter/TeamID"
					],
					technical : true,
					type : "Error"
				}])
				.expectChange("budget", "-42");

			return Promise.all([
				oOperation.setParameter("Budget", "-42").invoke()
					.then(mustFail(assert), function (oError0) {
						assert.strictEqual(oError0, oError);
					}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "budget", "Error", "Invalid Budget");
		});
	});

	//*********************************************************************************************
	// Scenario: Within an application an operation dialog is templated. AnnotationHelper.format is
	// used bind the parameters so that you have the type information already available before the
	// controls are created.
	// JIRA: CPOUI5ODATAV4-28
	//
	// Format options and binding parameters are passed to @@format and @@value.
	// JIRA: CPOUI5ODATAV4-121
	testXMLTemplating("Operation parameters with sap.ui.model.odata.v4.AnnotationHelper.format",
		"createTeaBusiModel",
' template:require="{\'AnnotationHelper\':\'sap/ui/model/odata/v4/AnnotationHelper\'}">\
<template:alias name="format" value="AnnotationHelper.format">\
<template:alias name="value" value="AnnotationHelper.value">\
	<FlexBox id="form" binding="{/ChangeTeamBudgetByID(...)}">\
		<FlexBox binding="{$Parameter}">\
			<template:repeat list="{meta>/ChangeTeamBudgetByID/$Action/0/$Parameter}" var="param">\
				<Input id="{param>$Name}" value="{param>@@format}"/>\
			</template:repeat>\
			<Input\
				value="{meta>/ChangeTeamBudgetByID/TeamID@@format({$$noPatch : true$))}"/>\
			<Input\
				value="{meta>/ChangeTeamBudgetByID/Budget@@format({$$noPatch : true$), null)}"/>\
			<Text text="{meta>/ChangeTeamBudgetByID/Budget@@format(null, $(shortLimit : 1000,\
				style : \'short\'$))}"/>\
			<Input value="{meta>/ChangeTeamBudgetByID/TeamID@@value}"/>\
			<Input value="{meta>/ChangeTeamBudgetByID/TeamID@@value($($$noPatch : true$))}"/>\
		</FlexBox>\
	</FlexBox>\
</template:alias>\
</template:alias>',
'<FlexBox id="form" binding="{/ChangeTeamBudgetByID(...)}">\
	<FlexBox binding="{$Parameter}">\
		<Input id="TeamID" value="{path:\'TeamID\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':10,\'nullable\':false},\
			formatOptions:{\'parseKeepsEmptyString\':true}}"/>\
		<Input id="Budget" value="{path:\'Budget\',type:\'sap.ui.model.odata.type.Decimal\',\
			constraints:{\'precision\':16,\'scale\':\'variable\',\'nullable\':false}}"/>\
		<Input value="{path:\'TeamID\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':10,\'nullable\':false},\
			formatOptions:{\'parseKeepsEmptyString\':true},\
			parameters:{\'$$noPatch\':true}}"/>\
		<Input value="{path:\'Budget\',type:\'sap.ui.model.odata.type.Decimal\',\
			constraints:{\'precision\':16,\'scale\':\'variable\',\'nullable\':false},\
			parameters:{\'$$noPatch\':true}}"/>\
		<Text text="{path:\'Budget\',type:\'sap.ui.model.odata.type.Decimal\',\
			constraints:{\'precision\':16,\'scale\':\'variable\',\'nullable\':false},\
			formatOptions:{\'shortLimit\':1000,\'style\':\'short\'}}"/>\
		<Input value="{TeamID}"/>\
		<Input value="{path:\'TeamID\',parameters:{\'$$noPatch\':true}}"/>\
	</FlexBox>\
</FlexBox>');

	//*********************************************************************************************
	// Scenario: Within an application an operation dialog is templated. AnnotationHelper.format is
	// used to control the visibility of the action dialog to send artist's autographs (via
	// _it/sendsAutographs) and to determine the placeholder of the operation parameter 'Channel'
	// (via _it/defaultChannel). Additionally the parameter's input field has a value help which is
	// prefilled with the last used channel of the artist (via _it/lastUsedChannel).
	// JIRA: CPOUI5ODATAV4-132
	testXMLTemplating(
		"Annotations on operations and parameters sap.ui.model.odata.v4.AnnotationHelper.format",
		"createSpecialCasesModel",
' template:require="{\'AnnotationHelper\':\'sap/ui/model/odata/v4/AnnotationHelper\'}">\
<template:alias name="format" value="AnnotationHelper.format">\
	<FlexBox binding="{special.cases.SendAutograph(...)}"\
		visible="{meta>/Artists/special.cases.SendAutograph\
@Org.OData.Core.V1.OperationAvailable@@format}">\
		<FlexBox binding="{$Parameter}">\
			<template:with path="meta>/Artists/special.cases.SendAutograph/$Parameter/Channel"\
				var="param">\
					<Input id="param" value="{Channel}"\
						placeholder="{param>@com.sap.vocabularies.Common.v1.Text/@@format}"/>\
					<template:with path="param>@com.sap.vocabularies.Common.v1.ValueListMapping"\
						var="vh">\
							<FlexBox id="valueHelp">\
								<SearchField \
									value="{vh>Parameters/0/LocalDataProperty@@format}"/>\
							</FlexBox>\
					</template:with>\
			</template:with>\
		</FlexBox>\
	</FlexBox>\
</template:alias>',
'<FlexBox binding="{special.cases.SendAutograph(...)}" \
	visible="{path:\'sendsAutographs\',type:\'sap.ui.model.odata.type.Boolean\'}">\
	<FlexBox binding="{$Parameter}">\
		<Input id="param" value="{Channel}" placeholder="{path:\'_it/defaultChannel\'\
			,type:\'sap.ui.model.odata.type.String\'\
			,formatOptions:{\'parseKeepsEmptyString\':true}}"/>\
		<FlexBox id="valueHelp">\
			<SearchField value="{path:\'_it/lastUsedChannel\'\
				,type:\'sap.ui.model.odata.type.String\'\
				,formatOptions:{\'parseKeepsEmptyString\':true}}"/>\
		</FlexBox>\
	</FlexBox>\
</FlexBox>');

	//*********************************************************************************************
	// Scenario: Allow setting complex type parameters of operations via property binding
	// - parameters change because of change in the binding.
	// Follow-up on JIRA: CPOUI5ODATAV4-15 (read/write primitive type parameters)
	// JIRA: CPOUI5ODATAV4-52
	QUnit.test("Allow binding of complex operation parameters", function (assert) {
		var oOperation,
			oModel = this.createSpecialCasesModel(),
			sView = '\
<FlexBox id="operation" binding="{/HirePerson(...)}">\
	<FlexBox id="parameter" binding="{$Parameter}">\
		<FlexBox binding="{Person}">\
			<Input id="name" value="{Name}"/>\
			<Input id="salary" value="{Salary}"/>\
			<FlexBox binding="{Address}">\
				<Input id="city" value="{City}"/>\
				<Input id="zip" value="{ZIP}"/>\
			</FlexBox>\
		</FlexBox>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectChange("city", "")
			.expectChange("name", "")
			.expectChange("salary", null)
			.expectChange("zip", "");

		return this.createView(assert, sView, oModel).then(function () {
			oOperation = that.oView.byId("operation").getObjectBinding();

			that.expectChange("city", "Tatooine")
				.expectChange("name", "R2D2")
				.expectChange("salary", "12,345,678")
				.expectChange("zip", "12345");

			// code under test - reading parameter values
			oOperation.setParameter("Person", {
				Address : {
					City : "Tatooine",
					ZIP : "12345"
				},
				Name : "R2D2",
				Salary : 12345678
			});

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("city", "")
				.expectChange("name", "")
				.expectChange("salary", "12,345")
				.expectChange("zip", "67890");

			// code under test - set parameter complex value
			oOperation.setParameter("Person", {
				Address : {
					ZIP : "67890"
				},
				Salary : 12345
			});

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("salary", "54,321")
				.expectChange("zip", "");

			// code under test - set parameter complex value
			oOperation.setParameter("Person", {
				Salary : 54321
			});

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("name", "C3PO");

			// code under test - Person/Name
			that.oView.byId("name").getBinding("value").setValue("C3PO");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("city", "Kashyyk");

			// code under test - Person/Address/City
			that.oView.byId("city").getBinding("value").setValue("Kashyyk");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("zip", "12345");

			// code under test - Person/Address/ZIP
			that.oView.byId("zip").getBinding("value").setValue("12345");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
				method : "POST",
				url : "HirePerson",
				payload : {
					Person : {
						Address : {
							City : "Kashyyk",
							ZIP : "12345"
						},
						Name : "C3PO",
						Salary : 54321
					}
				}
			}, {/* response does not matter here */});

			// code under test
			return Promise.all([oOperation.invoke(), that.waitForChanges(assert)]);
		});
	});

	//*********************************************************************************************
	QUnit.test("ODCB#setParameter with complex type holds the reference", function (assert) {
		var oModel = this.createSpecialCasesModel(),
			oOperation = oModel.bindContext("/HirePerson(...)"),
			oPerson = {
				Address : {
					City : "Tatooine",
					ZIP : "12345",
					"@$ui5.foo" : "foo0"
				},
				Name : "R2D2",
				Salary : 12345678,
				"@$ui5.foo" : "foo1"
			},
			sPerson,
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			oOperation.setParameter("Person", oPerson);
			oPerson.Salary = 54321;
			oPerson.Address.City = "Kashyyk";
			sPerson = JSON.stringify(oPerson);

			that.expectRequest({
				method : "POST",
				url : "HirePerson",
				payload : {
					Person : {
						Address : {
							City : "Kashyyk",
							ZIP : "12345"
						},
						Name : "R2D2",
						Salary : 54321
					}
				}
			}, {/* response does not matter here */});

			return Promise.all([
				// code under test
				oOperation.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// verify that the original object remains unchanged
			assert.strictEqual(JSON.stringify(oPerson), sPerson);
			// verify that the private annotations in the parameter remain unchanged
			assert.strictEqual(JSON.stringify(oOperation.getParameterContext().getObject("Person")),
				sPerson);
		});
	});

	//*********************************************************************************************
	// Scenario: Changing the binding parameters causes a refresh of the table
	// The SalesOrders application does not have such a scenario.
	//
	// Additionally, show that "sap-valid-*" query options are allowed.
	// JIRA: CPOUI5ODATAV4-461
	//
	// Ignore unchanged binding-specific parameters ("$$*").
	// JIRA: CPOUI5ODATAV4-939
	QUnit.test("Absolute ODLB changing parameters; sap-valid-*", function (assert) {
		var sView = '\
<Table id="table" items="{\
	path : \'/EMPLOYEES\',\
	parameters : {\
		$$ownRequest : true,\
		$select : \'Name\',\
		foo : \'bar\',\
		\'sap-valid-at\' : \'now\'\
	}}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=Name&foo=bar&sap-valid-at=now&$skip=0&$top=100", {
				value : [
					{Name : "Jonathan Smith"},
					{Name : "Frederic Fall"}
				]
			})
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"]);

		return this.createView(assert, sView).then(function () {
			that.expectRequest("EMPLOYEES?$select=ID,Name&foo=bar"
					+ "&$expand=EMPLOYEE_2_MANAGER($select=ID)&$search=Fall"
					+ "&sap-valid-from=2016-01-01&sap-valid-to=2016-12-31T23:59:59.9Z"
					+ "&$skip=0&$top=100", {
					value : [{
						EMPLOYEE_2_MANAGER : {ID : "0"},
						ID : "2",
						Name : "Frederic Fall"
					}]
				})
				.expectChange("name", ["Frederic Fall"]);

			// code under test
			that.oView.byId("table").getBinding("items").changeParameters({
				$$ownRequest : true,
				$$sharedRequest : undefined,
				$expand : {EMPLOYEE_2_MANAGER : {$select : "ID"}},
				$search : "Fall",
				$select : ["ID", "Name"],
				// foo : "bar",
				"sap-valid-at" : undefined,
				"sap-valid-from" : "2016-01-01",
				"sap-valid-to" : "2016-12-31T23:59:59.9Z"
			});

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Changing the binding parameters causes a refresh of the form
	// The SalesOrders application does not have such a scenario.
	QUnit.test("Absolute ODCB changing parameters", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{/EMPLOYEES(\'2\')}">\
	<Text id="text" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')", {Name : "Jonathan Smith"})
			.expectChange("text", "Jonathan Smith");

		return this.createView(assert, sView).then(function () {
			that.expectRequest("EMPLOYEES('2')?$apply=foo", {Name : "Jonathan Schmidt"})
				.expectChange("text", "Jonathan Schmidt");

			// code under test
			that.oView.byId("form").getObjectBinding().changeParameters({$apply : "foo"});

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario:
	// A table uses the list binding with extended change detection, but not all key properties of
	// the displayed entity are known on the client, so that the key predicate cannot be determined.
	// In 1.44 this caused the problem that the table did not show any row. (Not reproducible with
	// Gateway services, because they always deliver all key properties, selected or not.)
	QUnit.test("Absolute ODLB with ECD, missing key column", function (assert) {
		// Note: The key property of the EMPLOYEES set is 'ID'
		var sView = '\
<Table growing="true" items="{path : \'/EMPLOYEES\', parameters : {$select : \'Name\'}}">\
	<Text id="name" text="{Name}"/>\
</Table>';

		this.expectRequest("EMPLOYEES?$select=Name&$skip=0&$top=20", {
				value : [
					{Name : "Jonathan Smith"},
					{Name : "Frederic Fall"}
				]
			})
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"]);

		return this.createView(assert, sView);
	});

	//*********************************************************************************************
	// Scenario: SalesOrders app
	// * Select a sales order so that items are visible
	// * Filter in the items, so that there are less
	// * See that the count decreases
	// The test simplifies it: It filters in the sales orders list directly
	//
	// Test ODLB#getCount
	// JIRA: CPOUI5ODATAV4-958
	//
	// Test oHeaderContext.getObject() and oHeaderContext.setProperty("$count")
	// JIRA: CPOUI5ODATAV4-1404
	// Data binding for selection (JIRA: CPOUI5ODATAV4-1944).
	QUnit.test("ODLB: $count and filter()", function (assert) {
		var oHeaderContext,
			oTable,
			oTableBinding,
			sView = '\
<Text id="count" text="{$count}"/>\
<Table id="table" items="{path : \'/SalesOrderList\', parameters : {$select : \'SalesOrderID\'}}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "0500000001"},
					{SalesOrderID : "0500000002"}
				]
			})
			.expectChange("count")
			.expectChange("id", ["0500000001", "0500000002"]);

		return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
			oTable = that.oView.byId("table");
			oTableBinding = oTable.getBinding("items");
			oHeaderContext = oTableBinding.getHeaderContext();

			// JIRA: CPOUI5ODATAV4-1404
			assert.strictEqual(oHeaderContext.getProperty("$count"), 2);
			assert.deepEqual(oHeaderContext.getObject(),
				{"@$ui5.context.isSelected" : false, $count : 2}, "JIRA: CPOUI5ODATAV4-1944");
			assert.deepEqual(oHeaderContext.getObject(""),
				{"@$ui5.context.isSelected" : false, $count : 2}, "JIRA: CPOUI5ODATAV4-1944");

			that.expectChange("count", "2");
			assert.strictEqual(oTableBinding.getCount(), 2);
			assert.strictEqual(oTableBinding.getLength(), 2);

			// code under test
			that.oView.byId("count").setBindingContext(oHeaderContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.oLogMock.expects("error").withArgs("Not a (navigation) property: $count");
			that.oLogMock.expects("error").withArgs("Failed to update path /SalesOrderList/$count");
			that.expectMessages([{
					message : "/SalesOrderList/$count: Not a (navigation) property: $count",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				oHeaderContext.setProperty("$count", 5).then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message,
						"/SalesOrderList/$count: Not a (navigation) property: $count");
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID"
					+ "&$filter=SalesOrderID gt '0500000001'&$skip=0&$top=100",
					{value : [{SalesOrderID : "0500000002"}]}
				)
				.expectChange("count", "1")
				.expectChange("id", ["0500000002"]);

			// code under test
			oTableBinding.filter(new Filter("SalesOrderID", FilterOperator.GT, "0500000001"));

			return Promise.all([
				// code under test - request the header data while filter is still running
				oHeaderContext.requestObject().then(function (oResult) {
					assert.deepEqual(oResult, {"@$ui5.context.isSelected" : false, $count : 1});
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario case-insensitive filtering
	// JIRA: CPOUI5UISERVICESV3-1263
	QUnit.test("OLDB: case insensitive filtering", function (assert) {
		var oListBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/ProductList\'}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("ProductList?$select=Name,ProductID&$skip=0&$top=100", {
				value : [{
					ProductID : "1",
					Name : "Pommes"
				}, {
					ProductID : "2",
					Name : "Salat"
				}]
			})
			.expectChange("name", ["Pommes", "Salat"]);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("ProductList?$select=Name,ProductID"
					+ "&$filter=tolower(Name) eq tolower('salat')&$skip=0&$top=100", {
					value : [{
						ProductID : "2",
						Name : "Salat"
					}]
				})
				.expectChange("name", ["Salat"]);

			// code under test
			oListBinding.filter(new Filter({
				filters : [
					new Filter({
						caseSensitive : false,
						operator : FilterOperator.EQ,
						path : "Name",
						value1 : "salat"
					})
				]
			}));

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: SalesOrders app
	// * Sort the sales orders
	// * Delete a sales order
	// * See that the count decreases
	// The delete is used to change the count (to see that it is still updated)
	//
	// Call ODLB#sort with the same Sorter as before. This should not invoke a request.
	// JIRA: CPOUI5ODATAV4-942
	QUnit.test("ODLB: $count and sort()", function (assert) {
		var oTable,
			oTableBinding,
			sView = '\
<Text id="count" text="{$count}"/>\
<Table id="table" items="{path : \'/SalesOrderList\', parameters : {$select : \'SalesOrderID\'}}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "0500000001"},
					{SalesOrderID : "0500000002"}
				]
			})
			.expectChange("count") // ensures that count is observed
			.expectChange("id", ["0500000001", "0500000002"]);

		return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
			oTable = that.oView.byId("table");
			oTableBinding = oTable.getBinding("items");

			that.expectChange("count", "2");

			// code under test
			that.oView.byId("count").setBindingContext(oTableBinding.getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$orderby=SalesOrderID desc"
					+ "&$skip=0&$top=100", {
					value : [
						{SalesOrderID : "0500000002"},
						{SalesOrderID : "0500000001"}
					]
				})
				.expectChange("id", ["0500000002", "0500000001"]);

			// code under test
			oTableBinding.sort(new Sorter("SalesOrderID", true));
			oTableBinding.sort(new Sorter("SalesOrderID", true));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('0500000002')")
				.expectChange("count", "1")
				.expectChange("id", ["0500000001"]);

			return Promise.all([
				// code under test
				oTable.getItems()[0].getBindingContext().delete(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: (not possible with the SalesOrders app)
	// * Add a filter to the sales orders list using changeParameters(), so that there are less
	// * See that the count decreases
	//
	// Also check that unchanged $expand/$select is tolerated by #changeParameters
	// JIRA: CPOUI5ODATAV4-1098
	//
	// Data binding for selection (JIRA: CPOUI5ODATAV4-1944).
	QUnit.test("ODLB: $count and changeParameters()", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			oTableBinding,
			sView = '\
<Text id="count" text="{$count}"/>\
<Table id="table" items="{path : \'/SalesOrderList\',\
		parameters : {$expand : \'SO_2_BP\', $select : \'SalesOrderID\'}}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$expand=SO_2_BP&$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "0500000001", SO_2_BP : null},
					{SalesOrderID : "0500000002", SO_2_BP : null}
				]
			})
			.expectChange("count")
			.expectChange("id", ["0500000001", "0500000002"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oTableBinding = oTable.getBinding("items");

			that.expectChange("count", "2");

			// code under test
			that.oView.byId("count").setBindingContext(oTableBinding.getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			const oHeaderContext = oTableBinding.getHeaderContext();
			oHeaderContext.setSelected(true); // "select all"

			that.expectRequest("SalesOrderList?$expand=SO_2_BP&$select=SalesOrderID"
					+ "&$filter=SalesOrderID gt '0500000001'&$skip=0&$top=100",
					{value : [{SalesOrderID : "0500000002", SO_2_BP : null}]}
				)
				.expectChange("count", "1")
				.expectChange("id", ["0500000002"]);

			// code under test
			oTableBinding.changeParameters({
				$expand : "SO_2_BP",
				$filter : "SalesOrderID gt '0500000001'",
				$select : "SalesOrderID"
			});

			checkSelected(assert, oHeaderContext, true);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete multiple entities in a table. Ensure that the request to fill the gap uses
	// the correct index.
	// JIRA: CPOUI5UISERVICESV3-1769
	// BCP: 1980007571
	QUnit.test("multiple delete: index for gap-filling read requests", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" growing="true" growingThreshold="3" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=3", {
				value : [
					{SalesOrderID : "0500000001"},
					{SalesOrderID : "0500000002"},
					{SalesOrderID : "0500000003"}
				]
			})
			.expectChange("id", ["0500000001", "0500000002", "0500000003"]);

		return this.createView(assert, sView, oModel).then(function () {
			var aItems = that.oView.byId("table").getItems();

			that.expectRequest({
					batchNo : 2,
					method : "DELETE",
					url : "SalesOrderList('0500000002')"
				})
				.expectRequest({
					batchNo : 2,
					method : "DELETE",
					url : "SalesOrderList('0500000003')"
				})
				.expectRequest({
					batchNo : 2,
					url : "SalesOrderList?$select=SalesOrderID"
						+ "&$filter=not (SalesOrderID eq '0500000002'"
							+ " or SalesOrderID eq '0500000003')"
						+ "&$skip=1&$top=2"
				}, {
					value : [{SalesOrderID : "0500000004"}]
				})
				.expectChange("id", [, "0500000004"]);

			// code under test
			return Promise.all([
				aItems[1].getBindingContext().delete(),
				aItems[2].getBindingContext().delete(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete in a growing table and then let it grow. Ensure that the gap caused by the
	// delete is filled.
	// JIRA: CPOUI5UISERVICESV3-1769
	// BCP: 1980007571
	QUnit.test("growing while deleting: index for gap-filling read request", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" growing="true" growingThreshold="3" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=3", {
				value : [
					{SalesOrderID : "0500000001"},
					{SalesOrderID : "0500000002"},
					{SalesOrderID : "0500000003"}
				]
			})
			.expectChange("id", ["0500000001", "0500000002", "0500000003"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oDeletePromise;

			that.expectRequest({
					batchNo : 2,
					method : "DELETE",
					url : "SalesOrderList('0500000002')"
				})
				.expectRequest({
					batchNo : 2,
					url : "SalesOrderList?$select=SalesOrderID"
						+ "&$filter=not (SalesOrderID eq '0500000002')&$skip=2&$top=4"
				}, {
					value : [{SalesOrderID : "0500000004"}]
				})
				.expectChange("id", [,, "0500000004"]);

			oTable = that.oView.byId("table");

			// code under test
			oDeletePromise = oTable.getItems()[1].getBindingContext().delete();
			oTable.requestItems();

			return Promise.all([
				oDeletePromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.deepEqual(oTable.getBinding("items").getCurrentContexts().map(getPath), [
				"/SalesOrderList('0500000001')",
				"/SalesOrderList('0500000003')",
				"/SalesOrderList('0500000004')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete in a growing table and at the same time refresh a row with higher index.
	// JIRA: CPOUI5UISERVICESV3-1829
	QUnit.test("refreshing row while deleting", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "0500000001"},
					{SalesOrderID : "0500000002"},
					{SalesOrderID : "0500000003"}
				]
			})
			.expectChange("id", ["0500000001", "0500000002", "0500000003"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oDeletePromise;

			that.expectRequest("DELETE SalesOrderList('0500000002')")
				.expectRequest("SalesOrderList('0500000003')?$select=SalesOrderID", {
					SalesOrderID : "0500000003"
				})
				.expectChange("id", [, "0500000003"]);

			oTable = that.oView.byId("table");

			// code under test
			oDeletePromise = oTable.getItems()[1].getBindingContext().delete();
			oTable.getItems()[2].getBindingContext().refresh();

			return Promise.all([
				oDeletePromise,
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A relative list binding's context is changed. Additionally a refresh (via
	// requestSideEffects) is invoked after the binding has recreated its cache, but before the
	// dependent property bindings have been destroyed. In the incident, the list table contains
	// the items and the detail table the schedules (with 1:n, which we don't have here).
	// BCP: 2080123400
	//
	// "Select all" is reset by #setContext (JIRA: CPOUI5ODATAV4-1943).
	QUnit.test("BCP: 2080123400", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="list" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>\
<Table id="detail" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}" \
		growing="true"> <!-- ensures that the rows and child bindings are kept alive -->\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"}
				]
			})
			.expectChange("id", ["1", "2"])
			.expectChange("note", []);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("detail");

			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=20", {
					value : [
						{ItemPosition : "10", Note : "Note 1", SalesOrderID : "1"}
					]
				})
				.expectChange("note", ["Note 1"]);

			oTable.setBindingContext(that.oView.byId("list").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			var fnResolve,
				oRowContext = that.oView.byId("list").getItems()[1].getBindingContext();

			const oHeaderContext = oTable.getBinding("items").getHeaderContext();
			oHeaderContext.setSelected(true);

			that.expectRequest("SalesOrderList('2')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=20",
					new Promise(function (resolve) {
						fnResolve = resolve.bind(null, {
							value : [
								{ItemPosition : "10", Note : "n/a", SalesOrderID : "2"}
							]
						});
					})
				)
				.expectCanceledError("Failed to get contexts for " + sSalesOrderService
						+ "SalesOrderList('2')/SO_2_SOITEM with start index 0 and length 20",
					sODLB + ": /SalesOrderList('2')[1]|SO_2_SOITEM"
						+ " is ignoring response from inactive cache: " + sSalesOrderService
						+ "SalesOrderList('2')/SO_2_SOITEM?$select=ItemPosition,Note,SalesOrderID")
				.expectRequest("SalesOrderList('2')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=20", {
						value : [
							{ItemPosition : "10", Note : "Note 2", SalesOrderID : "2"}
						]
					})
				.expectChange("note", ["Note 2"]);

			return Promise.all([
				oTable.setBindingContext(oRowContext),
				resolveLater(function () {
					checkSelected(assert, oHeaderContext, false);

					resolveLater(fnResolve); // must not respond before requestSideEffects
					return oRowContext.requestSideEffects(["SO_2_SOITEM"]);
				}, 0),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity in a growing table via refresh and let the table grow at the same
	// time.
	// JIRA: CPOUI5UISERVICESV3-1795
	QUnit.test("growing while deleting: adjust the pending read request", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" growing="true" growingThreshold="3" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=3", {
				value : [
					{SalesOrderID : "0500000001"},
					{SalesOrderID : "0500000002"},
					{SalesOrderID : "0500000003"}
				]
			})
			.expectChange("id", ["0500000001", "0500000002", "0500000003"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID"
					+ "&$filter=SalesOrderID eq '0500000002'", {
					value : []
				})
				.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=3&$top=3", {
					value : [{SalesOrderID : "0500000004"}]
				})
				// this request is sent because the length is not yet known when the change event
				// for the delete is fired (it wouldn't come with $count)
				.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=5&$top=1", {value : []})
				.expectChange("id", [,, "0500000004"]);

			oTable = that.oView.byId("table");

			// code under test
			oTable.getItems()[1].getBindingContext().refresh(undefined, true);
			oTable.requestItems();

			return that.waitForChanges(assert);
		}).then(function () {
			assert.deepEqual(oTable.getBinding("items").getCurrentContexts().map(getPath), [
				"/SalesOrderList('0500000001')",
				"/SalesOrderList('0500000003')",
				"/SalesOrderList('0500000004')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete multiple entities in a table w/o own cache.
	QUnit.test("Delete multiple entities in a table w/o own cache", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}" id="form">\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text id="position" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)", {
				// SalesOrderId : "1,
				SO_2_SOITEM : [
					{SalesOrderID : "1", ItemPosition : "0010"},
					{SalesOrderID : "1", ItemPosition : "0020"},
					{SalesOrderID : "1", ItemPosition : "0030"},
					{SalesOrderID : "1", ItemPosition : "0040"}
				]
			})
			.expectChange("position", ["0010", "0020", "0030", "0040"]);

		return this.createView(assert, sView, oModel).then(function () {
			var aItems = that.oView.byId("table").getItems();

			that.expectRequest(
					"DELETE SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0020')")
				.expectRequest(
					"DELETE SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0030')")
				.expectChange("position", [, "0040"]);

			// code under test
			return Promise.all([
				aItems[1].getBindingContext().delete(),
				aItems[2].getBindingContext().delete(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: SalesOrders app
	// * Select a sales order
	// * Refresh the sales order list
	// * See that the count of the items is still visible
	// The key point is that the parent of the list is a ContextBinding.
	QUnit.test("ODLB: refresh via parent context binding, shared cache", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{path :\'/SalesOrderList(\\\'0500000001\\\')\', \
		parameters : {$expand : {SO_2_SOITEM : {$select : \'ItemPosition\'}}}}">\
	<Text id="count" text="{headerContext>$count}"/>\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text id="item" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('0500000001')?$expand=SO_2_SOITEM($select=ItemPosition)",
			{
				SalesOrderID : "0500000001",
				SO_2_SOITEM : [
					{ItemPosition : "0000000010"},
					{ItemPosition : "0000000020"},
					{ItemPosition : "0000000030"}
				]
			})
			.expectChange("count")
			.expectChange("item", ["0000000010", "0000000020", "0000000030"]);

		return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
			that.expectChange("count", "3");

			// code under test
			that.oView.setModel(that.oView.getModel(), "headerContext");
			that.oView.byId("count").setBindingContext(
				that.oView.byId("table").getBinding("items").getHeaderContext(),
					"headerContext");

			return that.waitForChanges(assert);
		}).then(function () {
			// Respond with one employee less to show that the refresh must destroy the bindings for
			// the last row. Otherwise the property binding for that row will cause a "Failed to
			// drill down".
			that.expectRequest("SalesOrderList('0500000001')"
					+ "?$expand=SO_2_SOITEM($select=ItemPosition)", {
					SalesOrderID : "0500000001",
					SO_2_SOITEM : [
						{ItemPosition : "0000000010"},
						{ItemPosition : "0000000030"}
					]
				})
				.expectChange("count", "2")
				.expectChange("item", [, "0000000030"]);

			// code under test
			that.oView.byId("form").getObjectBinding().refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Change parent context of ODLB and see what happens to {headerContext>$count} binding.
	QUnit.test("BCP: 2180148277", function (assert) {
		var oTable,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'0\')}">\
	<Text id="count" text="{headerContext>$count}"/>\
	<Text id="oldCount" text="{headerContext>$count}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="item" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('0')/SO_2_SOITEM?$skip=0&$top=100", {
				value : [{ItemPosition : "10"}, {ItemPosition : "20"}]
			})
			.expectChange("count")
			.expectChange("oldCount")
			.expectChange("item", ["10", "20"]);

		return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
			oTable = that.oView.byId("table");

			that.expectChange("count", "2")
				.expectChange("oldCount", "2");

			that.oView.setModel(that.oView.getModel(), "headerContext");
			that.oView.setBindingContext(oTable.getBinding("items").getHeaderContext(),
				"headerContext");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$skip=0&$top=100", {
					value : [{ItemPosition : "11"}]
				})
				.expectChange("count", "1")
				.expectChange("item", ["11"])
				.expectChange("oldCount", null);

			// does not yet destroy header context, but makes ODLB unresolved!
			oTable.setBindingContext(null);

			// code under test
			oTable.bindObject("/SalesOrderList('1')");

			// update only "count" to see that old header context used by "oldCount" is destroyed
			that.oView.byId("count").setBindingContext(
				oTable.getBinding("items").getHeaderContext(), "headerContext");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh a suspended ODCB with a dependent ODLB having a cache. See that both caches
	// are refreshed when resuming. See CPOUI5UISERVICESV3-1179
	QUnit.test("Refresh a suspended binding hierarchy", function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true, groupId : "$direct"}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'0500000001\')}">\
	<Text id="note" text="{Note}"/>\
	<Text id="count" text="{headerContext>$count}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="item" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('0500000001')?$select=Note,SalesOrderID",
				{SalesOrderID : "0500000001", Note : "initial"})
			.expectRequest("SalesOrderList('0500000001')/SO_2_SOITEM?$select=ItemPosition,"
				+ "SalesOrderID&$skip=0&$top=100", {
					value : [
						{ItemPosition : "0000000010"},
						{ItemPosition : "0000000020"}
					]
			})
			.expectChange("count")
			.expectChange("note", "initial")
			.expectChange("item", ["0000000010", "0000000020"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oCount = that.oView.byId("count");

			that.expectChange("count", "2");

			oCount.setModel(that.oView.getModel(), "headerContext");
			oCount.setBindingContext(
				that.oView.byId("table").getBinding("items").getHeaderContext(),
				"headerContext");

			return that.waitForChanges(assert);
		}).then(function () {
			oBinding = that.oView.byId("form").getObjectBinding();

			// code under test
			oBinding.suspend();
			oBinding.refresh();

			// Do not immediately resume to see that no requests are invoked by refresh
			return resolveLater();
		}).then(function () {
			that.expectEvents(assert, "sap.ui.model.odata.v4.OData", [
					["ListBinding: /SalesOrderList('0500000001')|SO_2_SOITEM", "refresh",
						{reason : "refresh"}],
					["ContextBinding: /SalesOrderList('0500000001')", "change",
						{reason : "refresh"}],
					["ListBinding: /SalesOrderList('0500000001')|SO_2_SOITEM", "dataRequested"],
					["ContextBinding: /SalesOrderList('0500000001')", "dataRequested"],
					["ContextBinding: /SalesOrderList('0500000001')", "dataReceived", {data : {}}],
					["ListBinding: /SalesOrderList('0500000001')|SO_2_SOITEM", "change",
						{reason : "change"}],
					["ListBinding: /SalesOrderList('0500000001')|SO_2_SOITEM", "dataReceived",
						{data : {}}],
					["PropertyBinding: /SalesOrderList('0500000001')/SO_2_SOITEM|$count", "change",
						{reason : "change"}],
					["PropertyBinding: /SalesOrderList('0500000001')|Note", "change",
						{reason : "refresh"}],
					["PropertyBinding: /SalesOrderList('0500000001')/SO_2_SOITEM/2[2]|ItemPosition",
						"change", {reason : "change"}]
				])
				.expectRequest("SalesOrderList('0500000001')?$select=Note,SalesOrderID",
					{SalesOrderID : "0500000001", Note : "refreshed"})
				.expectRequest("SalesOrderList('0500000001')/SO_2_SOITEM?$select=ItemPosition,"
					+ "SalesOrderID&$skip=0&$top=100", {
					value : [
						{ItemPosition : "0000000010"},
						{ItemPosition : "0000000020"},
						{ItemPosition : "0000000030"}
					]
				})
				.expectChange("count", "3")
				.expectChange("note", "refreshed")
				.expectChange("item", [,, "0000000030"]);

			// code under test
			oBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A table shows a number of cells and is then filtered inside a suspend/resume
	// bracket. See that no ODPrB#resumeInternal takes place *before* the $batch is sent (and not
	// even afterwards).
	// BCP: 2270183841
	QUnit.test("BCP: 2270183841 - improve performance of ODLB#resume", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			fnSpy = this.spy(ODataPropertyBinding.prototype, "resumeInternal"),
			sView = '\
<t:Table id="table" rows="{/EMPLOYEES}" threshold="0" visibleRowCount="3">\
	<Text id="id" text="{ID}"/>\
	<Text id="name" text="{Name}"/>\
	<Text id="age" text="{AGE}"/>\
</t:Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=AGE,ID,Name&$skip=0&$top=3", {
				value : [{
					AGE : 70,
					ID : "0",
					Name : "Frederic Fall"
				}, {
					AGE : 60,
					ID : "1",
					Name : "Jonathan Smith"
				}, {
					AGE : 50,
					ID : "2",
					Name : "Peter Burke"
				}]
			})
			.expectChange("id", ["0", "1", "2"])
			.expectChange("name", ["Frederic Fall", "Jonathan Smith", "Peter Burke"])
			.expectChange("age", ["70", "60", "50"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("table").getBinding("rows");

			that.expectRequest("EMPLOYEES?$select=AGE,ID,Name&$filter=AGE lt 42&$skip=0&$top=3", {
					value : []
				});

			oBinding.suspend();
			oBinding.filter(new Filter("AGE", FilterOperator.LT, 42));
			// code under test
			oBinding.resume();

			return that.waitForChanges(assert, "resume");
		}).then(function () {
			assert.strictEqual(fnSpy.callCount, 0, "no #resumeInternal at all :-)");
		});
	});

	//*********************************************************************************************
	// Scenario: A table shows a number of cells and then we scroll down. See that property bindings
	// do not recompute "static" information in vain.
	// BCP: 156484 / 2023 (002075129500001564842023)
	QUnit.test("BCP: 156484 / 2023 - improve performance of ODPrB#setContext", function (assert) {
		var fnSpy_ODMM_fetchUI5Type = this.spy(ODataMetaModel.prototype, "fetchUI5Type"),
			fnSpy_ODMM_getReducedPath = this.spy(ODataMetaModel.prototype, "getReducedPath"),
			fnSpy_ODLB_doFetchOrGetQueryOptions
				= this.spy(ODataListBinding.prototype, "doFetchOrGetQueryOptions"),
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<t:Table id="table" rows="{/EMPLOYEES}" visibleRowCount="3">\
	<Text id="id" text="{ID}"/>\
	<Text id="name" text="{Name}"/>\
	<Text id="age" text="{path:\'AGE\',type:\'sap.ui.model.odata.type.Int16\'\
		,formatOptions:{\'minIntegerDigits\':3}}"/>\
</t:Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=AGE,ID,Name&$skip=0&$top=103", {
				value : [{
					AGE : 70,
					ID : "0",
					Name : "Frederic Fall"
				}, {
					AGE : 60,
					ID : "1",
					Name : "Jonathan Smith"
				}, {
					AGE : 50,
					ID : "2",
					Name : "Peter Burke"
				}, {
					AGE : 40,
					ID : "3",
					Name : "Carla Blue"
				}, {
					AGE : 30,
					ID : "4",
					Name : "John Field"
				}, {
					AGE : 20,
					ID : "5",
					Name : "Susan Bay"
				}]
			})
			.expectChange("id", ["0", "1", "2"])
			.expectChange("name", ["Frederic Fall", "Jonathan Smith", "Peter Burke"])
			.expectChange("age", ["070", "060", "050"])
			.expectChange("lastModifiedAt", []);

		return this.createView(assert, sView, oModel).then(function () {
			assert.strictEqual(fnSpy_ODMM_fetchUI5Type.callCount, 6, // was: 12
				"initial #fetchUI5Type");
			assert.strictEqual(fnSpy_ODMM_getReducedPath.callCount, 3); // was: 12
			assert.strictEqual(fnSpy_ODLB_doFetchOrGetQueryOptions.callCount, 4); // was: 13

			that.expectChange("id", [, "1", "2", "3"])
				.expectChange("name", [, "Jonathan Smith", "Peter Burke", "Carla Blue"])
				.expectChange("age", [, "060", "050", "040"]);

			that.oView.byId("table").setFirstVisibleRow(1);

			return that.waitForChanges(assert, "scroll down 1x");
		}).then(function () {
			assert.strictEqual(fnSpy_ODMM_fetchUI5Type.callCount, 6, "no more #fetchUI5Type");
			assert.strictEqual(fnSpy_ODMM_getReducedPath.callCount, 3); // was: 21
			assert.strictEqual(fnSpy_ODLB_doFetchOrGetQueryOptions.callCount, 4); // was: 22

			that.expectChange("id", [,,, "3", "4", "5"])
				.expectChange("name", [,,, "Carla Blue", "John Field", "Susan Bay"])
				.expectChange("age", [,,, "040", "030", "020"]);

			that.oView.byId("table").setFirstVisibleRow(3);

			return that.waitForChanges(assert, "scroll down 2x");
		}).then(function () {
			assert.strictEqual(fnSpy_ODMM_fetchUI5Type.callCount, 6, "no more #fetchUI5Type");
			assert.strictEqual(fnSpy_ODMM_getReducedPath.callCount, 3); // was: 31
			assert.strictEqual(fnSpy_ODLB_doFetchOrGetQueryOptions.callCount, 4); // was: 30
		});
	});

	//*********************************************************************************************
	// Scenario: A field shows a property where the exact type depends on the parent entity.
	// BCP: 156484 / 2023 (002075129500001564842023)
[false, true, 1].forEach(function (bUnresolved) {
	var sTitle = "BCP: 156484 / 2023 - type depends on parent entity; unresolved in between: "
			+ bUnresolved;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTeamContext = oModel.createBindingContext("/TEAMS('1')"),
			fnSpy = this.spy(ODataMetaModel.prototype, "fetchUI5Type"),
			oText,
			sView = '\
<Text id="name" text="{Name}"/>', //TODO binding="{}"
			that = this;

		this.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			oText = that.oView.byId("name");

			assert.strictEqual(fnSpy.callCount, 0, "no #fetchUI5Type yet");

			that.expectRequest("TEAMS('1')/Name", {value : "Team #1"})
				.expectChange("name", "Team #1");

			oText.setBindingContext(oTeamContext);

			return that.waitForChanges(assert, "TEAMS/Name");
		}).then(function () {
			if (bUnresolved) {
				that.expectChange("name", null);

				oText.setBindingContext(null);

				return that.waitForChanges(assert, "unresolved");
			}
		}).then(function () {
			if (bUnresolved === 1) {
				that.expectChange("name", "Team #1");

				oText.setBindingContext(oTeamContext);

				return that.waitForChanges(assert, "TEAMS/Name again");
			}
		}).then(function () {
			var oType = oText.getBinding("text").getType();

			assert.strictEqual(fnSpy.callCount, 1, "1st #fetchUI5Type");
			assert.strictEqual(oType.getConstraints().maxLength, 40,
				"Don't try this at home, kids!");
			TestUtils.withNormalizedMessages(function () {
				assert.throws(function () {
					oType.validateValue("0123456789012345678901234567890123456789+");
				}, /EnterTextMaxLength 40/);
			});

			that.expectRequest("EMPLOYEES('0')/Name", {value : "Frederic Fall"})
				.expectChange("name", "Frederic Fall");

			oText.setBindingContext(oModel.createBindingContext("/EMPLOYEES('0')"));

			return that.waitForChanges(assert, "EMPLOYEES/Name");
		}).then(function () {
			var oType = oText.getBinding("text").getType();

			assert.strictEqual(fnSpy.callCount, 2, "2nd #fetchUI5Type");
			assert.strictEqual(oType.getConstraints().maxLength, 16,
				"Don't try this at home, kids!");
			TestUtils.withNormalizedMessages(function () {
				assert.throws(function () {
					oType.validateValue("0123456789ABCDEF+");
				}, /EnterTextMaxLength 16/);
			});
		});
	});
});

	//*********************************************************************************************
	// Scenario: Show properties of various entities in a collection-valued navigation property. The
	// application in the incident even used different navigation properties via dynamically created
	// paths based on data it loaded before.
	// BCP: 2370133257
	QUnit.test("BCP: 2370133257", async function (assert) {
		const oModel = this.createSalesOrdersModel({autoExpandSelect : true});
		const sView = `
<FlexBox id="order" binding="{/SalesOrderList('1')}">
	<Text id="id" text="{SalesOrderID}"/>
</FlexBox>
<FlexBox id="item">
	<Text id="note10" text="{SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')/Note}"/>
	<Text id="note20" text="{SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')/Note}"/>
</FlexBox>`;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID", {SalesOrderID : "1"})
			.expectChange("id", "1")
			.expectChange("note10")
			.expectChange("note20");

		await this.createView(assert, sView, oModel);

		this.expectRequest(
				"SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')/Note",
				{value : "Note #10"})
			.expectRequest(
				"SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')/Note",
				{value : "Note #20"})
			.expectChange("note10", "Note #10")
			.expectChange("note20", "Note #20");

		this.oView.byId("item").setBindingContext(this.oView.byId("order").getBindingContext());

		await this.waitForChanges(assert);
	});

	//*********************************************************************************************
	// Scenario: Modify a property which does not belong to the parent binding's entity, but is
	// related via a navigation property.
	//
	// Additionally, observe the "propertyChange" event (JIRA: CPOUI5ODATAV4-1919)
	QUnit.test("JIRA: CPOUI5ODATAV4-1919", function (assert) {
		var oContext,
			iCount = 0,
			bDone,
			oPromise,
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Input id="item" value="{SO_2_BP/CompanyName}"/>\
</Table>',
			oModel = this.createSalesOrdersModel({
					autoExpandSelect : true,
					updateGroupId : "update"
				}),
			that = this;

		// code under test
		oModel.attachPropertyChange(function (oEvent) {
			var mParameters = oEvent.getParameters();

			iCount += 1;
			assert.strictEqual(oEvent.getSource(), oModel);
			oPromise = mParameters.promise;
			delete mParameters.promise; // hide from deepEqual
			assert.deepEqual(mParameters, {
				context : oContext,
				path : "SO_2_BP/CompanyName",
				reason : ChangeReason.Binding,
				resolvedPath : "/SalesOrderList('0500000002')/SO_2_BP/CompanyName",
				value : "Bar"
			}, "JIRA: CPOUI5ODATAV4-1919");

			oPromise.then(function () {
				bDone = true;
			});
		});

		this.expectRequest("SalesOrderList?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)&$skip=0&$top=100", {
				value : [{
					SalesOrderID : "0500000002",
					SO_2_BP : {
						"@odata.etag" : "ETag",
						BusinessPartnerID : "42",
						CompanyName : "Foo"
					}
				}]
			})
			.expectChange("item", ["Foo"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oCell = that.oView.byId("table").getItems()[0].getCells()[0];

			oContext = oCell.getBindingContext();

			that.expectChange("item", ["Bar"]);

			// code under test
			oCell.getBinding("value").setValue("Bar");

			assert.strictEqual(iCount, 1, "propertyChange fired sync");

			return that.waitForChanges(assert, "setValue");
		}).then(function () {
			assert.notOk(bDone, "not yet PATCHed");

			that.expectRequest({
					method : "PATCH",
					url : "BusinessPartnerList('42')",
					headers : {"If-Match" : "ETag"},
					payload : {CompanyName : "Bar"}
				}, {CompanyName : "Bar"});

			return Promise.all([
				oPromise,
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert, "submitBatch")
			]);
		}).then(function () {
			assert.ok(bDone);
			assert.strictEqual(iCount, 1, "propertyChange fired once");
		});
	});

	//*********************************************************************************************
	// Scenario: Modify a property, the server responds with 204 (No Content) on the PATCH request.
	// Sample for this behavior: OData V4 TripPin service from odata.org
	//
	// Tell the model to ignore the ETag, but no If-Match:* must be sent unless an ETag was present
	// JIRA: CPOUI5ODATAV4-1894
	//
	// No "sap-cancel-on-close" header in PATCH request (JIRA: CPOUI5ODATAV4-2506)
["$auto", "$direct"].forEach(function (sGroupId) {
	[false, true].forEach(function (bETag) {
	var sTitle = "Modify a property, server responds with 204 (No Content), group = " + sGroupId
			+ ", w/ ETag = " + bETag;

	QUnit.test(sTitle, function (assert) {
		var fnResolve,
			oPromise = new Promise(function (resolve) {
				fnResolve = resolve;
			}),
			oModel = this.createModel(sTeaBusi, {groupId : sGroupId}, {
				$metadata : {source : "odata/v4/data/metadata.xml"},
				"EMPLOYEES('2')" : {
					message : bETag
					? {"@odata.etag" : "ETag", Name : "Jonathan Smith"}
					: {Name : "Jonathan Smith"}
				},
				"PATCH EMPLOYEES('2')" : {
					ifMatch : function (oRequest) {
						if (bETag) {
							assert.strictEqual(oRequest.requestHeaders["If-Match"], "*");
							delete oRequest.requestHeaders["If-Match"];
						}
						assert.deepEqual(Object.keys(oRequest.requestHeaders).sort(),
							sGroupId === "$direct"
							? ["Accept", "Accept-Language", "Content-Type", "OData-MaxVersion",
								"OData-Version", "X-CSRF-Token", "X-Requested-With"]
							: ["Accept", "Accept-Language", "Content-Type"],
							"no If-Match");
						assert.strictEqual(oRequest.requestBody,
							JSON.stringify({Name : "Jonathan Schmidt"}), "payload");
						fnResolve();
						return true;
					}
					// 204 No Content
				}
			}),
			sView = '<FlexBox binding="{/EMPLOYEES(\'2\')}">\
						<Input id="text" value="{Name}"/>\
					</FlexBox>',
			that = this;

		oModel.$keepSend = true; // do not stub sendBatch/-Request

		// this.expectRequest("EMPLOYEES('2')", {Name : "Jonathan Smith"});
		this.expectChange("text", "Jonathan Smith");

		return this.createView(assert, sView, oModel).then(function () {
			// that.expectRequest({
			//         method : "PATCH",
			//         url : "EMPLOYEES('2')",
			//         payload : {Name : "Jonathan Schmidt"}
			//     }) // 204 No Content
			that.expectChange("text", "Jonathan Schmidt");

			// code under test
			that.oModel.setIgnoreETag(true);

			// code under test
			that.oView.byId("text").getBinding("value").setValue("Jonathan Schmidt");

			return Promise.all([
				oPromise,
				that.waitForChanges(assert)
			]);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: Modify two properties in a single change set; tell the model to ignore the ETag.
	// JIRA: CPOUI5ODATAV4-1894
	QUnit.test("Modify two properties in a single change set, If-Match:*", function (assert) {
		var fnResolve,
			oPromise = new Promise(function (resolve) {
				fnResolve = resolve;
			}),
			oModel = this.createModel(sTeaBusi, {}, {
				$metadata : {source : "odata/v4/data/metadata.xml"},
				"EMPLOYEES?$skip=0&$top=100" : {
					message : {value : [{
						"@odata.etag" : "etag0",
						ID : "0",
						Name : "Frederic Fall"
					}, {
						"@odata.etag" : "etag1",
						ID : "1",
						Name : "Jonathan Smith"
					}]}
				},
				"PATCH EMPLOYEES('0')" : {
					ifMatch : function (oRequest) {
						assert.strictEqual(oRequest.requestHeaders["If-Match"], "*");
						assert.strictEqual(oRequest.requestBody,
							JSON.stringify({Name : "Frederick Fall"}), "payload");
						return true;
					}
					// 204 No Content
				},
				"PATCH EMPLOYEES('1')" : {
					ifMatch : function (oRequest) {
						assert.strictEqual(oRequest.requestHeaders["If-Match"], "*");
						assert.strictEqual(oRequest.requestBody,
							JSON.stringify({Name : "Jonathan Schmidt"}), "payload");
						fnResolve();
						return true;
					}
					// 204 No Content
				}
			}),
			sView = '<Table id="table" items="{/EMPLOYEES}">\
						<Text id="name" text="{Name}"/>\
					</Table>',
			that = this;

		oModel.$keepSend = true; // do not stub sendBatch/-Request

		this.expectChange("name", ["Frederic Fall", "Jonathan Smith"]);

		return this.createView(assert, sView, oModel).then(function () {
			var aContexts = that.oView.byId("table").getBinding("items").getCurrentContexts();

			// code under test
			that.oModel.setIgnoreETag(true);

			that.expectChange("name", ["Frederick Fall", "Jonathan Schmidt"]);

			// code under test
			aContexts[0].setProperty("Name", "Frederick Fall");
			aContexts[1].setProperty("Name", "Jonathan Schmidt");

			return Promise.all([
				oPromise,
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Read and modify an entity with key aliases
	// CPOUI5ODATAV4-1580: show usage of ODataModel#getKeyPredicate
	QUnit.test("Entity with key aliases", function (assert) {
		var sView = '\
<Table id="table" items="{/EntitiesWithComplexKey}">\
	<Input id="item" value="{Value}"/>\
</Table>',
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			that = this;

		this.expectRequest("EntitiesWithComplexKey?$select=Key/P1,Key/P2,Value&$skip=0&$top=100", {
				value : [{
					Key : { // reverse key ordering
						P2 : 42,
						P1 : "foo"
					},
					Value : "Old",
					"@odata.etag" : "ETag"
				}]
			})
			.expectChange("item", ["Old"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "EntitiesWithComplexKey(Key1='foo',Key2=42)",
					headers : {"If-Match" : "ETag"},
					payload : {Value : "New"}
				}, {
					Key : {
						P1 : "foo",
						P2 : 42
					},
					Value : "New"
				})
				.expectChange("item", ["New"]);

			that.oView.byId("table").getItems()[0].getCells()[0].getBinding("value")
				.setValue("New");

			return that.waitForChanges(assert);
		}).then(function () {
			var oEntity = that.oView.byId("table").getItems()[0].getBindingContext().getObject();

			assert.strictEqual(
				// code under test
				oModel.getKeyPredicate("/EntitiesWithComplexKey", oEntity),
				"(Key1='foo',Key2=42)"
			);
		});
	});

	//*********************************************************************************************
	// Scenario: Filter entities by messages
	// Show that entities w/o messages are filtered out correctly with the filter returned by
	// ODataListBinding#requestFilterForMessages and that entities with transient key predicates are
	// ignored.
	// JIRA: CPOUI5ODATAV4-679
	QUnit.test("Filter entities by messages", function (assert) {
		var oBinding,
			oContext,
			sView = '\
<Table id="table" items="{path : \'/EntitiesWithComplexKey\', \
		parameters : {$select : \'Messages\'}}">\
	<Input id="item" value="{Value}"/>\
</Table>',
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			that = this;

		this.expectRequest("EntitiesWithComplexKey?$select=Key/P1,Key/P2,Messages,Value"
				+ "&$skip=0&$top=100", {
				value : [{
					Key : { // entity w/o messages
						P1 : "baz",
						P2 : 44
					},
					Messages : [],
					Value : "Baz"
				}, {
					Key : {
						P1 : "f/o'o", // to check that inner+outer quotes and encode/decode work
						P2 : 42
					},
					Messages : [{
						message : "Foo error",
						numericSeverity : 4,
						target : "Value"
					}, {
						message : "Foo warning",
						numericSeverity : 3,
						target : "Value"
					}],
					Value : "Foo"
				}, {
					Key : {
						P1 : "bar",
						P2 : 43
					},
					Messages : [{
						message : "Bar error",
						numericSeverity : 4,
						target : "Value"
					}],
					Value : "Bar"
				}]
			})
			.expectChange("item", ["Baz", "Foo", "Bar"])
			.expectMessages([{
				message : "Foo error",
				target : "/EntitiesWithComplexKey(Key1='f%2Fo''o',Key2=42)/Value",
				type : "Error"
			}, {
				message : "Foo warning",
				target : "/EntitiesWithComplexKey(Key1='f%2Fo''o',Key2=42)/Value",
				type : "Warning"
			}, {
				message : "Bar error",
				target : "/EntitiesWithComplexKey(Key1='bar',Key2=43)/Value",
				type : "Error"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");

			that.oLogMock.expects("error")
				.withExactArgs("POST on 'EntitiesWithComplexKey' failed; "
					+ "will be repeated automatically",
					sinon.match("Request intentionally failed"), sODLB);
			that.expectChange("item", ["", "Baz", "Foo", "Bar"])
				.expectRequest({
					method : "POST",
					url : "EntitiesWithComplexKey",
					payload : {}
				}, createErrorInsideBatch({target : "Value"}))
				.expectMessages([{
					message : "Foo error",
					target : "/EntitiesWithComplexKey(Key1='f%2Fo''o',Key2=42)/Value",
					type : "Error"
				}, {
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					target : "/EntitiesWithComplexKey($uid=...)/Value",
					technical : true,
					type : "Error"
				}, {
					message : "Foo warning",
					target : "/EntitiesWithComplexKey(Key1='f%2Fo''o',Key2=42)/Value",
					type : "Warning"
				}, {
					message : "Bar error",
					target : "/EntitiesWithComplexKey(Key1='bar',Key2=43)/Value",
					type : "Error"
				}]);

			// code under test
			oContext = oBinding.create({}, true);

			return that.waitForChanges(assert, "produce error message for transient entity");
		}).then(function () {
			// code under test
			return oBinding.requestFilterForMessages().then(function (oFilter) {
				that.expectChange("item", ["Baz", "Foo", "Bar"]);

				oContext.delete(); // clean up to be able to call filter API

				return Promise.all([
					checkCanceled(assert, oContext.created()),
					that.waitForChanges(assert, "Clean up")
				]).then(function () {
					return oFilter;
				});
			});
		}).then(function (oFilter) {
			that.expectRequest("EntitiesWithComplexKey?$select=Key/P1,Key/P2,Messages,Value"
				+ "&$filter=Key/P1 eq 'f/o''o' and Key/P2 eq 42"
				+ " or Key/P1 eq 'bar' and Key/P2 eq 43&$skip=0&$top=100", {
					value : [{
						Key : {
							P1 : "f/o'o",
							P2 : 42
						},
						Messages : [{
							message : "Foo error",
							numericSeverity : 4,
							target : "Value"
						}, {
							message : "Foo warning",
							numericSeverity : 3,
							target : "Value"
						}],
						Value : "Foo"
					}, {
						Key : {
							P1 : "bar",
							P2 : 43
						},
						Messages : [{
							message : "Bar error",
							numericSeverity : 4,
							target : "Value"
						}],
						Value : "Bar"
					}]
				})
				.expectChange("item", ["Foo", "Bar"]);

			// code under test
			oBinding.filter(oFilter);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Select messages for business object scope via a root binding, i.e. the messages for
	// a dependent binding are selected via the root binding.
	// Use #requestFilterForMessages on the dependent list binding, filter the list binding, and
	// check that no messages in the message model are touched.
	//
	// JIRA: CPOUI5ODATAV4-717
	//
	// Optionally create a new item beforehand, with the POST response containing a (possibly empty)
	// messages array. This must not confuse the following message handling.
	// BCP: 2380140928
[0, 1, 2].forEach((iCase) => { // 0: no POST // 1: POST w/o messages // 2: POST w/ messages
	const sTitle = "requestFilterForMessages on a relative list binding #" + iCase;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{path : \'/SalesOrderList(\\\'42\\\')\', \
		parameters : {$select : \'Messages\'}}">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="quantity" text="{Quantity}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=Messages,SalesOrderID", {
				Messages : [{
					code : "23",
					message : "Enter a minimum quantity of 2",
					numericSeverity : 3,
					target : "SO_2_SOITEM(SalesOrderID='42',ItemPosition='0010')/Quantity"
				}, {
					code : "1",
					message : "Some message for the whole item collection",
					numericSeverity : 3,
					target : "SO_2_SOITEM"
				}],
				SalesOrderID : "42"
			})
			.expectRequest("SalesOrderList('42')/SO_2_SOITEM"
				+ "?$select=ItemPosition,Quantity,SalesOrderID&$skip=0&$top=100", {
				value : [{
					ItemPosition : "0010",
					SalesOrderID : "42",
					Quantity : "1"
				}, {
					ItemPosition : "0020",
					SalesOrderID : "42",
					Quantity : "3"
				}]
			})
			.expectChange("salesOrderID", "42")
			.expectChange("quantity", ["1.000", "3.000"])
			.expectMessages([{
				code : "23",
				message : "Enter a minimum quantity of 2",
				target : "/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0010')"
					+ "/Quantity",
				type : "Warning"
			}, {
				code : "1",
				message : "Some message for the whole item collection",
				target : "/SalesOrderList('42')/SO_2_SOITEM",
				type : "Warning"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");

			if (iCase > 0) {
				that.expectChange("quantity", [,, "5.000"])
					.expectRequest({
						method : "POST",
						url : "SalesOrderList('42')/SO_2_SOITEM",
						payload : {Quantity : "5"}
					}, {
						ItemPosition : "0030",
						Messages : iCase > 1 ? [{
							message : "Well done!",
							numericSeverity : 1,
							target : "Quantity"
						}] : [],
						SalesOrderID : "42",
						Quantity : "5"
					});
				if (iCase > 1) {
					that.expectMessage({
						message : "Well done!",
						target : "/SalesOrderList('42')"
							+ "/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0030')/Quantity",
						type : "Success"
					});
				}

				return Promise.all([
					// code under test
					oBinding.create({Quantity : "5"}, /*bSkipRefresh*/true, /*bAtEnd*/true)
						.created(),
					that.waitForChanges(assert, "create new item")
				]);
			}
		}).then(function () {
			// code under test
			return oBinding.requestFilterForMessages();
		}).then(function (oFilter) {
			that.expectRequest("SalesOrderList('42')/SO_2_SOITEM"
				+ "?$select=ItemPosition,Quantity,SalesOrderID"
				+ "&$filter=SalesOrderID eq '42' and ItemPosition eq '0010'"
				+ (iCase > 1 ? " or SalesOrderID eq '42' and ItemPosition eq '0030'" : "")
				+ "&$skip=0&$top=100", {
				value : [{
					ItemPosition : "0010",
					Quantity : "1",
					SalesOrderID : "42"
				}]
			});

			// code under test
			oBinding.filter(oFilter);

			return that.waitForChanges(assert);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Request Late property with navigation properties in entity with key aliases
	// JIRA: CPOUI5ODATAV4-122
	QUnit.test("Late property in entity with key aliases", function (assert) {
		var oBinding,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/As(1)}">\
	<Text id="avalue" text="{AValue}"/>\
</FlexBox>\
<Input id="value" value="{AtoEntityWithComplexKey/Value}"/>',
			that = this;

		this.expectRequest("As(1)?$select=AID,AValue", {
				AID : 1,
				AValue : 23 // Edm.Int16
			})
			.expectChange("avalue", "23")
			.expectChange("value");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("As(1)?$select=AtoEntityWithComplexKey"
					+ "&$expand=AtoEntityWithComplexKey($select=Key/P1,Key/P2,Value)", {
					AtoEntityWithComplexKey : {
						Key : {
							P1 : "p1",
							P2 : 2
						},
						Value : "42"
					}
				})
				.expectChange("value", "42");

			oBinding = that.oView.byId("value").getBinding("value");
			oBinding.setContext(
				that.oView.byId("form").getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("value", "changed")
				.expectRequest({
					method : "PATCH",
					url : "EntitiesWithComplexKey(Key1='p1',Key2=2)",
					payload : {Value : "changed"}
				}, {
					Key : {
						P1 : "p1",
						P2 : 2
					},
					Value : "changed"
				});

			oBinding.setValue("changed");

			assert.ok(oBinding.hasPendingChanges());
			assert.ok(oBinding.hasPendingChanges(true), "JIRA: CPOUI5ODATAV4-1382");
			assert.throws(function () {
				oBinding.refresh();
			}, new Error("Refresh on this binding is not supported"));

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Test events createSent and createCompleted for success and error cases
	// JIRA: CPOUI5UISERVICESV3-1761
	//
	// JSON error response for $batch contains target (which cannot be resolved)
	// BCP: 2180171988
	QUnit.test("createSent and createCompleted", function (assert) {
		var oBinding,
			oCreatedContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true, groupId : "$direct"}),
			fnRejectPost,
			fnResolvePost,
			fnResolveCreateCompleted,
			fnResolveCreateSent,
			oTable,
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
	<Input id="note" value="{Note}"/>\
</Table>',
			that = this;

		/*
		 * Event handler for createCompleted event. Checks that "context" and "success" parameters
		 * are as expected and resolves the promise for the createCompleted event.
		 */
		function onCreateCompleted(oEvent) {
			assert.ok(fnResolveCreateCompleted, "expect createCompleted");
			assert.strictEqual(oEvent.getParameter("context"), oCreatedContext);
			assert.strictEqual(oEvent.getParameter("success"), fnResolveCreateCompleted.bSuccess);
			fnResolveCreateCompleted();
			fnResolveCreateCompleted = undefined;
		}

		/*
		 * Event handler for createSent event. Checks that the "context" parameter is as expected
		 * and resolves the promise for the createSent event.
		 */
		function onCreateSent(oEvent) {
			assert.ok(fnResolveCreateSent, "expect createSent");
			assert.strictEqual(oEvent.getParameter("context"), oCreatedContext);
			fnResolveCreateSent();
			fnResolveCreateSent = undefined;
		}

		/*
		 * Creates a pending promise for the createCompleted event. It is resolved when the event
		 * handler for createCompleted is called.
		 * @param {boolean} bSuccess The expected success flag in the createCompleted event payload
		 */
		function expectCreateCompleted(bSuccess) {
			return new Promise(function (resolve) {
				fnResolveCreateCompleted = resolve;
				fnResolveCreateCompleted.bSuccess = bSuccess;
			});
		}

		/*
		 * Creates a pending promise for the createSent event. It is resolved when the event handler
		 * for createSent is called.
		 */
		function expectCreateSent() {
			return new Promise(function (resolve) {
				fnResolveCreateSent = resolve;
			});
		}

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
				value : [{
					Note : "foo",
					SalesOrderID : "42"
				}]
			})
			.expectChange("note", ["foo"])
			.expectChange("salesOrderID", ["42"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oCreateSentPromise = expectCreateSent();

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			oBinding.attachCreateCompleted(onCreateCompleted);
			oBinding.attachCreateSent(onCreateSent);

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "bar"}
				}, new Promise(function (_resolve, reject) {
					fnRejectPost = reject;
				}))
				.expectChange("note", ["bar", "foo"])
				.expectChange("salesOrderID", ["", "42"]);

			oCreatedContext = oBinding.create({Note : "bar"}, /*bSkipRefresh*/ true);

			return Promise.all([
				oCreateSentPromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oCreateCompletedPromise = expectCreateCompleted(false),
				oError = createError({ // BCP: 2180171988
					"@SAP__common.ExceptionCategory" : "Framework_Error",
					code : "SYNTAX_ERROR",
					message : "ABAP Runtime error 'SYNTAX_ERROR'",
					target : "cannot/be/resolved"
				});

			that.expectMessages([{
					code : "SYNTAX_ERROR",
					message : "cannot/be/resolved: ABAP Runtime error 'SYNTAX_ERROR'",
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withExactArgs("POST on 'SalesOrderList' failed; will be repeated automatically",
					sinon.match(oError.message), sODLB);

			fnRejectPost(oError);

			return Promise.all([
				oCreateCompletedPromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oCreateSentPromise = expectCreateSent();

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "baz"}
				}, new Promise(function (resolve) {
					fnResolvePost = resolve;
				}))
				.expectChange("note", ["baz"]);

			oTable.getItems()[0].getCells()[1].getBinding("value").setValue("baz");

			return Promise.all([
				oCreateSentPromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oCreateCompletedPromise = expectCreateCompleted(true);

			that.expectChange("salesOrderID", ["43"]);

			fnResolvePost({
				Note : "baz",
				SalesOrderID : "43"
			});

			return Promise.all([
				oCreateCompletedPromise,
				oCreatedContext.created(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A creation POST fails and the "createCompleted" event handler is used to
	// immediately delete the transient row.
	// BCP: 2280183921
	QUnit.test("BCP: 2280183921: use createCompleted to delete after failure", function (assert) {
		var oPromise,
			that = this;

		return this.createView(assert).then(function () {
			var oBinding = that.oModel.bindList("/EMPLOYEES"),
				oContext;

			oBinding.attachCreateCompleted(function (oEvent) {
				assert.strictEqual(oEvent.getParameter("success"), false);

				// code under test
				oPromise = oEvent.getParameter("context").delete();
			});

			that.expectRequest({
					method : "POST",
					url : "EMPLOYEES",
					payload : {Name : "Anonymous"}
				}, createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withExactArgs("POST on 'EMPLOYEES' failed; will be repeated automatically",
					sinon.match("Request intentionally failed"), sODLB);

			oContext = oBinding.create({Name : "Anonymous"});

			return Promise.all([
				checkCanceled(assert, oContext.created()),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return oPromise;
		});
	});

	//*********************************************************************************************
	// Scenario: Table creating new entities and rejected requestSideEffects for the complete table
	// within the same $batch.
	// Steps:
	// 1. Successfully create 2 new entities.
	// 2. Create 3 further entities. one of them inactive, request side effects afterwards for the
	//    complete list; one POST request fails hence the GET request for side effects also fails
	//    and the binding is restored.
	// 3. Check that the list binding has properly restored the created contexts (already saved +
	//    still transient ones).
	// 4. A deletion of a still transient context afterwards must NOT result in a DELETE request,
	//    -> BCP 2070287827.
	QUnit.test("BCP: 2070287827: restore created entities after failed refresh", function (assert) {
		var oBinding,
			aCreatedContexts = [],
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
				value : [{
					Note : "#42",
					SalesOrderID : "42"
				}]
			})
			.expectChange("note", ["#42"]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");

			that.expectChange("note", ["new2", "new1", "#42"])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "new1"}
				}, {
					Note : "new1",
					SalesOrderID : "43"
				})
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "new2"}
				}, {
					Note : "new2",
					SalesOrderID : "44"
				});

			aCreatedContexts.push(oBinding.create({Note : "new1"}, /*bSkipRefresh*/true));
			aCreatedContexts.push(oBinding.create({Note : "new2"}, /*bSkipRefresh*/true));

			return Promise.all([
				aCreatedContexts[0].created(),
				aCreatedContexts[1].created(),
				that.waitForChanges(assert, "1. creating and saving new entities")
			]);
		}).then(function () {
			var sCreateError = "Entity can not be created",
				oError = createErrorInsideBatch({
					message : sCreateError,
					"@Common.longtextUrl" : "longtext"
				});

			assertIndices(assert, oBinding.getCurrentContexts(), [-2, -1, 0]);

			that.expectChange("note", ["new5"]) // Note: inline creation row is kept
				// Note: The #create calls cause "change" events on the ODLB and then the table
				// fetches the current contexts again, calling #setContext on ODPrB in the end.
				// #checkUpdateInternal becomes async and then fires a "change" event to the
				// formatter, so to say. At that point in time, ODLB#reset has been called
				// (affecting iCreatedContexts) but bKeepCacheOnError's restore did not yet happen.
				// Thus indices are off by 4 (no. of created which were never inactive)!
				.expectChange("note", "new4", -3)
				.expectChange("note", "new3", -2)
				.expectChange("note", "new2", -1)
				.expectChange("note", ["new1", "#42"])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "new3"}
				}, oError)
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "new4"}
				}/* response does not matter here */)
				.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=99"
					/* response does not matter here */)
				.expectMessages([{
					code : "CODE",
					descriptionUrl : sSalesOrderService + "longtext",
					message : sCreateError,
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error").twice()
				.withExactArgs("POST on 'SalesOrderList' failed; will be repeated automatically",
					sinon.match(oError.error.message), sODLB);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to get contexts for " + sSalesOrderService + "SalesOrderList"
					+ " with start index 0 and length 100", sinon.match(sPreviousFailed), sODLB);

			aCreatedContexts.push(oBinding.create({Note : "new3"}, /*bSkipRefresh*/true));
			aCreatedContexts.push(oBinding.create({Note : "new4"}, /*bSkipRefresh*/true));
			aCreatedContexts.push(oBinding.create({Note : "new5"}, /*bSkipRefresh*/true,
				/*bAtEnd*/false, /*bInactive*/true));

			assert.strictEqual(oBinding.getCount(), 5);

			return Promise.all([
				oBinding.getHeaderContext().requestSideEffects([""])
					.then(mustFail(assert), function (oError0) {
						assert.strictEqual(oError0.message, sPreviousFailed);
						assert.strictEqual(oError0.cause.message, sCreateError);
					}),
				that.waitForChanges(assert,
					"2. creation of further entities fails and requested side effects rejected")
			]);
		}).then(function () {
			var aCurrentContexts = oBinding.getCurrentContexts();

			assert.strictEqual(oBinding.getCount(), 5);
			assert.strictEqual(oBinding.getLength(), 6);
			assert.strictEqual(oBinding.isLengthFinal(), true);
			assert.deepEqual(aCurrentContexts.map(getNormalizedPath), [
				"/SalesOrderList($uid=...)",
				"/SalesOrderList($uid=...)",
				"/SalesOrderList($uid=...)",
				"/SalesOrderList('44')",
				"/SalesOrderList('43')",
				"/SalesOrderList('42')"
			]);
			assertIndices(assert, aCurrentContexts, [-5, -4, -3, -2, -1, 0]);

			// 3. the list binding is properly restored
			// still 3x transient
			assert.ok(aCurrentContexts[0].isTransient());
			assert.strictEqual(aCurrentContexts[0].getProperty("Note"), "new5");
			assert.ok(aCurrentContexts[1].isTransient());
			assert.strictEqual(aCurrentContexts[1].getProperty("Note"), "new4");
			assert.ok(aCurrentContexts[2].isTransient());
			assert.strictEqual(aCurrentContexts[2].getProperty("Note"), "new3");
			// still 2x created but already saved
			assert.ok(aCurrentContexts[3].created());
			assert.notOk(aCurrentContexts[3].isTransient());
			assert.strictEqual(aCurrentContexts[3].getProperty("Note"), "new2");
			assert.ok(aCurrentContexts[4].created());
			assert.notOk(aCurrentContexts[4].isTransient());
			assert.strictEqual(aCurrentContexts[4].getProperty("Note"), "new1");
			// still 1x NOT created
			assert.notOk(aCurrentContexts[5].created());
			assert.strictEqual(aCurrentContexts[5].getProperty("Note"), "#42");

			that.expectChange("note", [, "new3", "new2", "new1", "#42"]);

			return Promise.all([
				// delete 2nd transient one ("new4")
				aCreatedContexts[3].delete(),
				// handle rejection of created promise
				aCreatedContexts[3].created().then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message,
						"Request canceled: POST SalesOrderList; group: $parked.$auto"
					);
					assert.ok(oError.canceled);
				}),
				that.waitForChanges(assert, "4. deletion of second transient context")
			]);
		}).then(function () {
			var aCurrentContexts = oBinding.getCurrentContexts();

			assert.strictEqual(oBinding.getCount(), 4);
			assert.strictEqual(oBinding.getLength(), 5);
			assert.strictEqual(oBinding.isLengthFinal(), true);
			assert.deepEqual(aCurrentContexts.map(getNormalizedPath), [
				"/SalesOrderList($uid=...)",
				"/SalesOrderList($uid=...)",
				"/SalesOrderList('44')",
				"/SalesOrderList('43')",
				"/SalesOrderList('42')"
			]);
			assertIndices(assert, oBinding.getCurrentContexts(), [-4, -3, -2, -1, 0]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create a sales order w/o key properties, enter a note, then submit the batch
	//
	// When using bSkipRefresh, the created() promise must not wait for that GET (BCP: 2270083632)
	[false, true].forEach(function (bSkipRefresh) {
		QUnit.test("Create with user input - bSkipRefresh: " + bSkipRefresh, function (assert) {
			var oCreatedContext,
				oModel = this.createSalesOrdersModel({
					autoExpandSelect : true,
					updateGroupId : "update"
				}),
				fnResolve,
				sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Input id="note" value="{Note}"/>\
	<Text id="companyName" binding="{SO_2_BP}" text="{CompanyName}"/>\
	<Text id="buyerID" text="{BuyerID}"/>\
</Table>',
				that = this;

			this.expectRequest("SalesOrderList?$select=BuyerID,Note,SalesOrderID"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)&$skip=0&$top=100", {
					value : [{
						BuyerID : "23",
						Note : "foo",
						SalesOrderID : "42",
						SO_2_BP : {
							BusinessPartnerID : "123",
							CompanyName : "SAP"
						}
					}]
				})
				.expectChange("note", ["foo"])
				.expectChange("companyName", ["SAP"])
				.expectChange("buyerID", ["23"]);

			return this.createView(assert, sView, oModel).then(function () {
				var oTable = that.oView.byId("table");

				that.expectChange("note", ["baz", "foo"]) // "bar" overtaken by update
					.expectChange("companyName", ["", "SAP"])
					.expectChange("buyerID", ["24", "23"]);

				oCreatedContext = oTable.getBinding("items")
					.create({BuyerID : "24", Note : "bar"}, bSkipRefresh);
				oTable.getItems()[0].getCells()[0].getBinding("value").setValue("baz");

				return that.waitForChanges(assert);
			}).then(function () {
				that.expectRequest({
						method : "POST",
						url : "SalesOrderList",
						payload : {BuyerID : "24", Note : "baz"}
					}, {
						// no BuyerID (JIRA: CPOUI5ODATAV4-1503)
						Note : "from server",
						SalesOrderID : "43"
					})
					.expectChange("note", ["from server"]);
				if (bSkipRefresh) {
					// late property request for CompanyName
					that.expectRequest("SalesOrderList('43')?$select=SO_2_BP"
							+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)",
							new Promise(function (resolve) {
								fnResolve = resolve.bind(null, {
									SO_2_BP : {
										BusinessPartnerID : "456",
										CompanyName : "ACM"
									}
								});
							})
						);
				} else {
					that.expectRequest("SalesOrderList('43')?$select=BuyerID,Note,SalesOrderID"
							+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
							BuyerID : "24",
							Note : "fresh from server",
							SalesOrderID : "43",
							SO_2_BP : {
								BusinessPartnerID : "456",
								CompanyName : "ACM"
							}
						})
						.expectChange("note", ["fresh from server"])
						.expectChange("companyName", ["ACM"]);
				}

				return Promise.all([
					oCreatedContext.created(),
					that.oModel.submitBatch("update"),
					that.waitForChanges(assert)
				]);
			}).then(function () {
				assert.strictEqual(oCreatedContext.getProperty("BuyerID"), "24");
				// Note: w/ bSkipRefresh, this is not available synchronously as soon as #created()
				// is fulfilled (just like "createCompleted" event)
				assert.strictEqual(oCreatedContext.getProperty("SO_2_BP/BusinessPartnerID"),
					bSkipRefresh ? undefined : "456");

				if (bSkipRefresh) {
					that.expectChange("companyName", ["ACM"]);

					fnResolve();

					return that.waitForChanges(assert);
				}
			}).then(function () {
				assert.strictEqual(oCreatedContext.getProperty("SO_2_BP/BusinessPartnerID"), "456");
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Create multiple w/o refresh: (2) Create two new entities without save in between,
	// save (CPOUI5UISERVICESV3-1759)
	//
	// Scenario: All contexts of a bound list available on the client are returned, including
	// transient and created contexts.
	// JIRA: CPOUI5MODELS-741
	QUnit.test("Create multiple w/o refresh, with $count: (2)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			sView = '\
<Text id="count" text="{$count}"/>\
<Table id="table" items="{path : \'/SalesOrderList\', parameters : {$count : true}}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID&$skip=0&$top=100",
			{
				"@odata.count" : "1",
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("count")
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");

			// code under test (CPOUI5MODELS-741)
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getPath), [
				"/SalesOrderList('42')"
			]);

			assert.strictEqual(oBinding.getLength(), 1);

			that.expectChange("count", "1");

			that.oView.byId("count").setBindingContext(oBinding.getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("count", "2")
				.expectChange("id", ["", "42"])
				.expectChange("note", ["New 1", "First SalesOrder"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);

			assert.strictEqual(oBinding.getLength(), 2);

			// code under test (CPOUI5MODELS-741)
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getPath), [
				oCreatedContext0.getPath(),
				"/SalesOrderList('42')"
			]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("count", "3")
				.expectChange("id", [, "", "42"])
				.expectChange("note", ["New 2", "New 1", "First SalesOrder"]);

			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);

			assert.strictEqual(oBinding.getLength(), 3);

			// code under test (CPOUI5MODELS-741)
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getPath), [
				oCreatedContext1.getPath(),
				oCreatedContext0.getPath(),
				"/SalesOrderList('42')"
			]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectChange("id", ["44", "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getLength(), 3);
		});
	});

	//*********************************************************************************************
	// Scenario: Create multiple w/o refresh: (3) Start with (2), Create third entity, save, delete
	// third created entity, save (CPOUI5UISERVICESV3-1759)
	QUnit.test("Create multiple w/o refresh: (3)", function (assert) {
		var oCreatedContext,
			that = this;

		return this.createTwiceSaveInBetween(assert).then(function () {
			oCreatedContext = that.createThird();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 3"}
				}, {
					Note : "New 3",
					SalesOrderID : "45"
				})
				.expectChange("id", ["45"]);

			return Promise.all([
				oCreatedContext.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('45')")
				.expectChange("count", "3")
				.expectChange("id", ["44", "43", "42"])
				.expectChange("note", ["New 2", "New 1", "First SalesOrder"]);

			return Promise.all([
				oCreatedContext.delete("$auto"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create multiple w/o refresh: create thrice, then delete last
	// (4a) Start with (2), Create third entity, no save, reset changes via binding, save
	// (4b) Start with (2), Create third entity, no save, reset changes via model, save
	// (5) Start with (2), Create third entity, no save, delete third created entity
	// CPOUI5UISERVICESV3-1759
[
	"Create multiple w/o refresh: (4a)",
	"Create multiple w/o refresh: (4b)",
	"Create multiple w/o refresh: (5)"
].forEach(function (sTitle, i) {
	QUnit.test(sTitle, function (assert) {
		var oCreatedContext,
			that = this;

		function deleteSalesOrder() {
			if (i === 0) {
				that.oView.byId("table").getBinding("items").resetChanges();
			} else if (i === 1) {
				that.oModel.resetChanges();
			} else if (i === 2) {
				const oHeaderContext = oCreatedContext.getBinding().getHeaderContext();

				assert.throws(function () {
					// code under test (JIRA: CPOUI5ODATAV4-2014)
					oHeaderContext.resetChanges();
				}, new Error("Cannot reset: " + oHeaderContext));

				assert.throws(function () {
					// code under test (JIRA: CPOUI5ODATAV4-1880)
					oCreatedContext.resetChanges();
				}, new Error("Cannot reset: " + oCreatedContext));

				return oCreatedContext.delete();
			}
		}

		return this.createTwiceSaveInBetween(assert).then(function () {
			oCreatedContext = that.createThird();

			return that.waitForChanges(assert);
		}).then(function () {
			// no request
			that.expectChange("count", "3")
				.expectChange("id", ["44", "43", "42"])
				.expectChange("note", ["New 2", "New 1", "First SalesOrder"]);

			return Promise.all([
				checkCanceled(assert, oCreatedContext.created()),
				deleteSalesOrder(),
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Create multiple w/o refresh: (6) Start with (2), create third entity, save, delete
	// second entity (CPOUI5UISERVICESV3-1759)
	QUnit.test("Create multiple w/o refresh: (6)", function (assert) {
		var oCreatedContext,
			that = this;

		return this.createTwiceSaveInBetween(assert).then(function () {
			oCreatedContext = that.createThird();

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 3"}
				}, {
					Note : "New 3",
					SalesOrderID : "45"
				})
				.expectChange("id", ["45"]);

			return Promise.all([
				oCreatedContext.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('44')")
				.expectChange("count", "3")
				.expectChange("id", [, "43", "42"])
				.expectChange("note", [, "New 1", "First SalesOrder"]);

			return Promise.all([
				that.oView.byId("table").getItems()[1].getBindingContext().delete("$auto"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create multiple w/o refresh: (7) Create thrice without save, delete second entity,
	// check remaining contexts are still transient and reference the expected data. Read next
	// elements from server.
	// CPOUI5UISERVICESV3-1759, CPOUI5UISERVICESV3-1784
	QUnit.test("Create multiple w/o refresh, with $count: (7)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<Table id="table" growing="true" growingThreshold="2"\
		items="{path : \'/SalesOrderList\', parameters : {$count : true}}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID&$skip=0&$top=2", {
				"@odata.count" : "3",
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}, {
					Note : "Second SalesOrder",
					SalesOrderID : "43"
				}]
			})
			.expectChange("count")
			.expectChange("id", ["42", "43"])
			.expectChange("note", ["First SalesOrder", "Second SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("count", "3");

			that.oView.byId("count").setBindingContext(oBinding.getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("count", "4")
				.expectChange("id", [""])
				.expectChange("note", ["New 1"]);

			// never persisted or deleted
			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("count", "5")
				.expectChange("id", [""])
				.expectChange("note", ["New 2"]);

			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("count", "6")
				.expectChange("id", [""])
				.expectChange("note", ["New 3"]);

			// never persisted or deleted
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("count", "5")
				.expectChange("note", [, "New 1"]);

			return Promise.all([
				checkCanceled(assert, oCreatedContext1.created()),
				oCreatedContext1.delete(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(oCreatedContext2.getProperty("Note"), "New 3");
			// ensure consistency of cached data;
			// when using key predicate, it does not matter, if the object is contained in the array
			// of the collection or not, as long as it is contained in $byPredicate map, that object
			// is used. Only with index path it is possible to see a potential mismatch between
			// the array of contexts in the ODataListBinding and the collection in the cache.
			assert.strictEqual(oCreatedContext2.getProperty("/SalesOrderList/-2/Note"), "New 3");

			assert.strictEqual(oCreatedContext0.isTransient(), true);
			assert.strictEqual(oCreatedContext0.getProperty("Note"), "New 1");
			assert.strictEqual(oCreatedContext0.getProperty("/SalesOrderList/-1/Note"), "New 1");

			that.expectChange("id", [,, "42", "43"])
				.expectChange("note", [,, "First SalesOrder", "Second SalesOrder"]);

			// show more items
			oTable.requestItems();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
					+ "&$skip=2&$top=1", {
					"@odata.count" : "3",
					value : [{
						Note : "Third SalesOrder",
						SalesOrderID : "44"
					}]
				})
				.expectChange("id", "44", 4)
				.expectChange("note", "Third SalesOrder", 4);

			// show more items - ensure correct server side index for reading more elements
			oTable.requestItems();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (1)
	//  List binding: relative without cache
	//  Number of transient: 0
	//  Delete: Context.delete as Context.refresh(bAllowRemoval=true) is not possible
	//  Table control: sap.m.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (1)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				groupId : "$direct",
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" growing="true" items="{BP_2_SO}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID"
				+ "&$expand=BP_2_SO($select=Note,SalesOrderID)", {
				BusinessPartnerID : "4711",
				BP_2_SO : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", ["", "", ""])
				.expectChange("note", ["New 3", "New 2", "New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 3"}
				}, {
					Note : "New 3",
					SalesOrderID : "45"
				})
				.expectChange("id", ["45", "44", "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				oCreatedContext2.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('44')");

			return Promise.all([
				oTable.getItems()[1].getBindingContext().delete("$auto"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (2)
	//  List binding: absolute
	//  Number of transient: 2
	//  Delete: Context.delete
	//  Table control: sap.ui.table.Table
	//  Additional tests: update last, transient: update of POST payload expected
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (2)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<t:Table id="table" rows="{/SalesOrderList}" visibleRowCount="2">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Input id="note" value="{Note}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=102", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("id", ["", "42"])
				.expectChange("note", ["New 1", "First SalesOrder"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectChange("id", ["43"]);

			return Promise.all([
				oCreatedContext0.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 3", "New 2"]);

			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			var aRows = oTable.getRows();

			// check row here because table calls getContexts for event ChangeReason.Add async.
			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext1);

			that.expectChange("id", [, "43"])
				.expectChange("note", [, "New 1"]);

			return Promise.all([
				checkCanceled(assert, oCreatedContext1.created()),
				oCreatedContext1.delete(),
				that.waitForChanges(assert, "")
			]);
		}).then(function () {
			that.expectChange("id", [, "43", "42"])
				.expectChange("note", [, "New 1", "First SalesOrder"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("id", ["", "43"])
				.expectChange("note", ["New 3", "New 1"]);

			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert);
		}).then(function () {
			var aRows = oTable.getRows();

			// table calls getContexts after setFirstVisibleRow asynchronously
			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext2, "1");
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext0, "2");
			assert.strictEqual(oCreatedContext0.isTransient(), false);

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 3 - Changed"}
				}, {
					Note : "New 3 - Changed",
					SalesOrderID : "44"
				})
				.expectChange("id", ["44"])
				.expectChange("note", ["New 3 - Changed"]);

			aRows[0].getCells()[1].getBinding("value").setValue("New 3 - Changed");

			return Promise.all([
				oCreatedContext2.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext2, "1");
			assert.strictEqual(oCreatedContext2.isTransient(), false);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext0, "2");
			assert.strictEqual(oCreatedContext0.isTransient(), false);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (3)
	//  List binding: relative with cache
	//  Number of transient: 0
	//  Delete: Context.delete
	//  Table control: sap.ui.table.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (3)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<t:Table id="table" rows="{path : \'BP_2_SO\', parameters : {$$ownRequest : true}}"\
			threshold="0" visibleRowCount="2">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</t:Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')/BP_2_SO?$select=Note,SalesOrderID"
				+ "&$skip=0&$top=2", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 3", "New 2"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 3"}
				}, {
					Note : "New 3",
					SalesOrderID : "45"
				})
				.expectChange("id", ["45", "44"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				oCreatedContext2.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oTable.getRows()[1].getBindingContext(), oCreatedContext1);

			that.expectRequest("DELETE SalesOrderList('44')")
				.expectChange("id", [, "43"])
				.expectChange("note", [, "New 1"]);

			return Promise.all([
				oCreatedContext1.delete("$auto"),
				that.waitForChanges(assert, "")
			]);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), false);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);

			that.expectChange("id", [, "43", "42"])
				.expectChange("note", [, "New 1", "First SalesOrder"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aRows[1].getBindingContext().isTransient(), undefined);
		}).then(function () {
			that.expectChange("id", ["45", "43"])
				.expectChange("note", ["New 3", "New 1"]);

			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), false);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (4)
	//  List binding: relative with cache
	//  Number of transient: 1
	//  Delete: Context.delete
	//  Table control: sap.m.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (4)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" growing="true"\
			items="{path : \'BP_2_SO\', parameters : {$$ownRequest : true}}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')/BP_2_SO?$select=Note,SalesOrderID"
				+ "&$skip=0&$top=20", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 2", "New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectChange("id", ["44", "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", [""])
				.expectChange("note", ["New 3"]);

			// never persisted or deleted
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('44')");
			// no change event: getContexts with E.C.D. returns a diff containing one delete only

			oCreatedContext1.delete("$auto");

			return that.waitForChanges(assert);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 3);
			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aItems[2].getBindingContext().isTransient(), undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (5)
	//  List binding: absolute
	//  Number of transient: 0
	//  Delete: Context.delete
	//  Table control: sap.m.Table
	//  Additional tests: update last, persisted: PATCH expected
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (5)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				groupId : "$direct",
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<Table id="table" growing="true" growingThreshold="2"\
		items="{parameters : {$filter : \'contains(Note,\\\'SalesOrder\\\')\'},\
			path : \'/SalesOrderList\'}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Input id="note" value="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$filter=contains(Note,'SalesOrder')"
				+ "&$select=Note,SalesOrderID&$skip=0&$top=2", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}, {
					Note : "Second SalesOrder",
					SalesOrderID : "43"
				}]
			})
			.expectChange("id", ["42", "43"])
			.expectChange("note", ["First SalesOrder", "Second SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 3", "New 2"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "44"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "45"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 3"}
				}, {
					Note : "New 3",
					SalesOrderID : "46"
				})
				.expectChange("id", ["46", "45"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				oCreatedContext2.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('45')")
				// next row "scrolls into view"
				.expectChange("id", [, "44"])
				.expectChange("note", [, "New 1"]);

			return Promise.all([
				oCreatedContext1.delete("$auto"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('46')",
					payload : {Note : "New 3 - Changed"}
				}, {
					Note : "New 3 - Changed",
					SalesOrderID : "46"
				})
				.expectChange("note", ["New 3 - Changed"]);

			oTable.getItems()[0].getCells()[1].getBinding("value").setValue("New 3 - Changed");

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 2, "growingThreshold=2");
			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), false);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
		}).then(function () {
			that.expectChange("id", [,, "42", "43"])
				.expectChange("note", [,, "First SalesOrder", "Second SalesOrder"]);

			oTable.requestItems();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$filter=(contains(Note,'SalesOrder'))"
					+ " and not (SalesOrderID eq '44' or SalesOrderID eq '46')"
					+ "&$select=Note,SalesOrderID&$skip=2&$top=2", {value : []});

			oTable.requestItems();

			return that.waitForChanges(assert);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 4);
			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), false);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aItems[2].getBindingContext().isTransient(), undefined);
			assert.strictEqual(aItems[3].getBindingContext().isTransient(), undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (6)
	//  List binding: absolute
	//  Number of transient: 1
	//  Delete: Context.refresh(bAllowRemoval=true)
	//  Table control: sap.ui.table.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (6)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				groupId : "$direct",
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<t:Table id="table" rows="{/SalesOrderList}" visibleRowCount="2">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=102", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("note", ["New 2", "New 1"])
				.expectChange("id", ["", ""]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectChange("id", ["44", "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", ["", "44"])
				.expectChange("note", ["New 3", "New 2"]);

			// never persisted or deleted
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(oTable.getRows()[1].getBindingContext(), oCreatedContext1);

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$filter=SalesOrderID eq '44'", {value : []})
				.expectChange("id", [, "43"])
				.expectChange("note", [, "New 1"]);

			return Promise.all([
				oCreatedContext1.requestRefresh("$auto", true/*bAllowRemoval*/),
				that.waitForChanges(assert, "")
			]);
		}).then(function () {
			that.expectChange("id", [, "43", "42"])
				.expectChange("note", [, "New 1", "First SalesOrder"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("id", ["", "43"])
				.expectChange("note", ["New 3", "New 1"]);

			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (7)
	//  List binding: relative without cache
	//  Number of transient: 3
	//  Delete: ODataModel.resetChanges
	//  Table control: sap.ui.table.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (7)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<t:Table id="table" rows="{BP_2_SO}" visibleRowCount="2">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</t:Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID"
				+ "&$expand=BP_2_SO($select=Note,SalesOrderID)", {
				BusinessPartnerID : "4711",
				BP_2_SO : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}, { // Second sales order to avoid an empty row in table after resetChanges();
					// an empty row results in not deterministic change event, e.g. id[null] = null
					Note : "Second SalesOrder",
					SalesOrderID : "43"
				}]
			})
			.expectChange("id", ["42", "43"])
			.expectChange("note", ["First SalesOrder", "Second SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 3", "New 2"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("id", ["42", "43"])
				.expectChange("note", ["First SalesOrder", "Second SalesOrder"]);

			oModel.resetChanges();

			return Promise.all([
				checkCanceled(assert, oCreatedContext0.created()),
				checkCanceled(assert, oCreatedContext1.created()),
				checkCanceled(assert, oCreatedContext2.created()),
				that.waitForChanges(assert, "")
			]);
			// scrolling not possible: only one entry
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (8)
	//  List binding: relative with cache
	//  Number of transient: 2
	//  Delete: ODataListBinding.resetChanges
	//  Table control: sap.m.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (8)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" growing="true"\
			items="{path : \'BP_2_SO\', parameters : {$$ownRequest : true}}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')/BP_2_SO?$select=Note,SalesOrderID"
				+ "&$skip=0&$top=20", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", [""])
				.expectChange("note", ["New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectChange("id", ["43"]);

			return Promise.all([
				oCreatedContext0.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 3", "New 2"]);

			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 4);
			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext1);
			assert.strictEqual(oCreatedContext1.isTransient(), true);
			assert.strictEqual(aItems[2].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aItems[3].getBindingContext().isTransient(), undefined);

			// no change event: getContexts with E.C.D. returns a diff containing one delete only

			return Promise.all([
				oBinding.resetChanges(),
				checkCanceled(assert, oCreatedContext1.created()),
				checkCanceled(assert, oCreatedContext2.created()),
				that.waitForChanges(assert) // to get all group locks unlocked
			]);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 2);
			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aItems[1].getBindingContext().isTransient(), undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (9)
	//  List binding: relative without cache
	//  Number of transient: 3
	//  Delete: Context.delete
	//  Table control: sap.m.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (9)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" growing="true" items="{BP_2_SO}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID"
				+ "&$expand=BP_2_SO($select=Note,SalesOrderID)", {
				BusinessPartnerID : "4711",
				BP_2_SO : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", ["", "", ""])
				.expectChange("note", ["New 3", "New 2", "New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			// no change event: getContexts with E.C.D. returns a diff containing one delete only

			return Promise.all([
				checkCanceled(assert, oCreatedContext1.created()),
				oCreatedContext1.delete(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), true);
			assert.strictEqual(aItems[2].getBindingContext().isTransient(), undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (10)
	//  List binding: absolute
	//  Number of transient: 3
	//  Delete: ODataListBinding.resetChanges
	//  Table control: sap.ui.table.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (10)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<t:Table id="table" rows="{/SalesOrderList}" visibleRowCount="2">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=102", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}, { // Second sales order to avoid an empty row in table after resetChanges();
					// an empty row results in not deterministic change event, e.g. id[null] = null
					Note : "Second SalesOrder",
					SalesOrderID : "41"
				}]
			})
			.expectChange("id", ["42", "41"])
			.expectChange("note", ["First SalesOrder", "Second SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("note", ["New 3", "New 2"])
				.expectChange("id", ["", ""]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("id", ["42", "41"])
				.expectChange("note", ["First SalesOrder", "Second SalesOrder"]);

			return Promise.all([
				oBinding.resetChanges(),
				checkCanceled(assert, oCreatedContext0.created()),
				checkCanceled(assert, oCreatedContext1.created()),
				checkCanceled(assert, oCreatedContext2.created()),
				that.waitForChanges(assert, "")
			]);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext().isTransient(), undefined);
			assert.strictEqual(aRows[1].getBindingContext().isTransient(), undefined);
		});
		// scrolling not possible: only one entry
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (11)
	//  List binding: relative without cache
	//  Number of transient: 2
	//  Delete: ODataListBinding.resetChanges
	//  Table control: sap.m.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (11)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" growing="true" items="{BP_2_SO}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID"
				+ "&$expand=BP_2_SO($select=Note,SalesOrderID)", {
				BusinessPartnerID : "4711",
				BP_2_SO : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", [""])
				.expectChange("note", ["New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectChange("id", ["43"]);

			return Promise.all([
				oCreatedContext0.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 3", "New 2"]);

			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			// no change event: getContexts with E.C.D. returns a diff containing two deletes only

			return Promise.all([
				oBinding.resetChanges(),
				checkCanceled(assert, oCreatedContext1.created()),
				checkCanceled(assert, oCreatedContext2.created()),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aItems[1].getBindingContext().isTransient(), undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (12)
	//  List binding: relative with cache
	//  Number of transient: 3
	//  Delete: ODataModel.resetChanges
	//  Table control: sap.m.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (12)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" growing="true"\
			items="{path : \'BP_2_SO\', parameters : {$$ownRequest : true}}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')/BP_2_SO?$select=Note,SalesOrderID"
				+ "&$skip=0&$top=20", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", ["", "", ""])
				.expectChange("note", ["New 3", "New 2", "New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 4);
			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext1);
			assert.strictEqual(oCreatedContext1.isTransient(), true);
			assert.strictEqual(aItems[2].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), true);
			assert.strictEqual(aItems[3].getBindingContext().isTransient(), undefined);

			// no change event: getContexts with E.C.D. returns a diff containing three deletes only
			oModel.resetChanges();

			return Promise.all([
				checkCanceled(assert, oCreatedContext0.created()),
				checkCanceled(assert, oCreatedContext1.created()),
				checkCanceled(assert, oCreatedContext2.created())
			]);
		}).then(function () {
			assert.strictEqual(oTable.getItems()[0].getBindingContext().isTransient(), undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (13)
	//  List binding: absolute
	//  Number of transient: 2
	//  Delete: ODataModel.resetChanges
	//  Table control: sap.ui.table.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (13)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<t:Table id="table" rows="{/SalesOrderList}" visibleRowCount="2">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=102", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("note", ["New 1", "First SalesOrder"])
				.expectChange("id", ["", "42"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectChange("id", ["43"]);

			return Promise.all([
				oCreatedContext0.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 3", "New 2"]);

			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", ["New 1", "First SalesOrder"])
				.expectChange("id", ["43", "42"]);

			oModel.resetChanges();

			return Promise.all([
				checkCanceled(assert, oCreatedContext1.created()),
				checkCanceled(assert, oCreatedContext2.created()),
				that.waitForChanges(assert, "")
			]);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aRows[1].getBindingContext().isTransient(), undefined);
		});
		// scrolling not possible: only two entries
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (14)
	//  List binding: relative without cache
	//  Number of transient: 1
	//  Delete: Context.delete
	//  Table control: sap.ui.table.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (14)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<t:Table id="table" rows="{BP_2_SO}" visibleRowCount="2">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</t:Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID"
				+ "&$expand=BP_2_SO($select=Note,SalesOrderID)", {
				BusinessPartnerID : "4711",
				BP_2_SO : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("id", ["", ""])
				.expectChange("note", ["New 2", "New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectChange("id", ["44"])
				.expectChange("id", [, "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", ["", "44"])
				.expectChange("note", ["New 3", "New 2"]);

			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('44')")
				.expectChange("id", [, "43"])
				.expectChange("note", [, "New 1"]);

			return Promise.all([
				oCreatedContext1.delete("$auto"),
				that.waitForChanges(assert, "")
			]);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
		}).then(function () {
			that.expectChange("id", [, "43", "42"])
				.expectChange("note", [, "New 1", "First SalesOrder"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aRows[1].getBindingContext().isTransient(), undefined);
		}).then(function () {
			that.expectChange("id", ["", "43"])
				.expectChange("note", ["New 3", "New 1"]);

			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), true);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (15)
	//  List binding: absolute
	//  Number of transient: 0
	//  Delete: Context.refresh(bAllowRemoval=true)
	//  Table control: sap.m.Table
	//  Create at: start
	// CPOUI5UISERVICESV3-1792
	QUnit.test("All pairs test for multi create (15)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				groupId : "$direct",
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<Table id="table" growing="true" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=20", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", ["", "", ""])
				.expectChange("note", ["New 3", "New 2", "New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 3"}
				}, {
					Note : "New 3",
					SalesOrderID : "45"
				})
				.expectChange("id", ["45", "44", "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				oCreatedContext2.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$filter=SalesOrderID eq '44'", {
					value : []
				});

			return Promise.all([
				oCreatedContext1.requestRefresh("$auto", true/*bAllowRemoval*/),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 3);
			assert.strictEqual(aItems[0].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), false);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aItems[2].getBindingContext().isTransient(), undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (16)
	//  List binding: absolute
	//  Number of transient: 3
	//  Delete: Context.delete
	//  Table control: sap.ui.table.Table
	//  Create at: end
	// CPOUI5UISERVICESV3-1818
	QUnit.test("All pairs test for multi create (16)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/SalesOrderList\', parameters : {$count : true}}"\
		visibleRowCount="3">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList"
				+ "?$count=true&$select=Note,SalesOrderID&$skip=0&$top=103", {
				"@odata.count" : "1",
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("id", [, "", ""])
				.expectChange("note", [, "New 1", "New 2"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", [,, "New 3"]);

			return Promise.all([
				checkCanceled(assert, oCreatedContext1.created()),
				oCreatedContext1.delete(),
				that.waitForChanges(assert, "")
			]);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(aRows.length, 3);
			assert.strictEqual(aRows[0].getBindingContext().isTransient(), undefined);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(aRows[2].getBindingContext(), oCreatedContext2);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (17)
	//  List binding: relative without cache
	//  Number of transient: 2
	//  Delete: ODataModel.resetChanges
	//  Table control: sap.m.Table
	//  Create at: end
	// CPOUI5UISERVICESV3-1818
	QUnit.test("All pairs test for multi create (17)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" growing="true" items="{path : \'BP_2_SO\', parameters : {$count : true}}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID"
				+ "&$expand=BP_2_SO($count=true;$select=Note,SalesOrderID)", {
				BusinessPartnerID : "4711",
				"BP_2_SO@odata.count" : "1",
				BP_2_SO : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", [, ""])
				.expectChange("note", [, "New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectChange("id", [, "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", [,, "", ""])
				.expectChange("note", [,, "New 2", "New 3"]);

			oCreatedContext1 = oBinding.create({Note : "New 2"}, true, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true, true);

			return that.waitForChanges(assert);
		}).then(function () {
			// no change event: getContexts with E.C.D. returns a diff containing two deletes only
			that.oModel.resetChanges();

			return Promise.all([
				checkCanceled(assert, oCreatedContext1.created()),
				checkCanceled(assert, oCreatedContext2.created()),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems[0].getBindingContext().isTransient(), undefined);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext1.isTransient(), false);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (18)
	//  List binding: absolute
	//  Number of transient: 0
	//  Delete: Context.refresh(bAllowRemoval=true)
	//  Table control: sap.m.Table
	//  Create at: end
	// CPOUI5UISERVICESV3-1818
	QUnit.test("All pairs test for multi create (18)", function (assert) {
		var oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				groupId : "$direct",
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<Table id="table" growing="true" items="{path : \'/SalesOrderList\',\
		parameters : {$count : true}}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList"
				+ "?$count=true&$select=Note,SalesOrderID&$skip=0&$top=20", {
				"@odata.count" : "1",
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding;

			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", [, "", "", ""])
				.expectChange("note", [, "New 1", "New 2", "New 3"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 3"}
				}, {
					Note : "New 3",
					SalesOrderID : "45"
				})
				.expectChange("id", [, "43", "44", "45"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				oCreatedContext2.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oTable.getItems()[2].getBindingContext(), oCreatedContext1);

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$filter=SalesOrderID eq '44'", {value : []});

			return Promise.all([
				oCreatedContext1.requestRefresh("$auto", true/*bAllowRemoval*/),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 3);
			assert.strictEqual(aItems[0].getBindingContext().isTransient(), undefined);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(aItems[2].getBindingContext(), oCreatedContext2);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (19)
	//  List binding: relative with cache
	//  Number of transient: 2
	//  Delete: ODataListBinding.resetChanges
	//  Table control: sap.m.Table
	//  Create at: end
	// CPOUI5UISERVICESV3-1818
	QUnit.test("All pairs test for multi create (19)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				groupId : "$direct",
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<FlexBox binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" growing="true"\
		items="{path : \'BP_2_SO\', parameters : {$$ownRequest : true, $count : true}}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')/BP_2_SO?$count=true"
				+ "&$select=Note,SalesOrderID&$skip=0&$top=20", {
				"@odata.count" : "1",
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("items");

			that.expectChange("id", [, ""])
				.expectChange("note", [, "New 1"]);

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "BusinessPartnerList('4711')/BP_2_SO",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectChange("id", [, "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("id", [,, "", ""])
				.expectChange("note", [,, "New 2", "New 3"]);

			oCreatedContext1 = oBinding.create({Note : "New 2"}, true, true);
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true, true);

			return that.waitForChanges(assert);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 4);
			assert.strictEqual(aItems[0].getBindingContext().isTransient(), undefined);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);
			assert.strictEqual(aItems[2].getBindingContext(), oCreatedContext1);
			assert.strictEqual(oCreatedContext1.isTransient(), true);
			assert.strictEqual(aItems[3].getBindingContext(), oCreatedContext2);
			assert.strictEqual(oCreatedContext2.isTransient(), true);

			// no change event: getContexts with E.C.D. returns a diff containing three deletes only

			return Promise.all([
				oBinding.resetChanges(),
				checkCanceled(assert, oCreatedContext1.created()),
				checkCanceled(assert, oCreatedContext2.created())
			]);
		}).then(function () {
			var aItems = oTable.getItems();

			assert.strictEqual(aItems.length, 2);
			assert.strictEqual(aItems[0].getBindingContext().isTransient(), undefined);
			assert.strictEqual(aItems[1].getBindingContext(), oCreatedContext0);
		});
	});

	//*********************************************************************************************
	// Scenario: All pairs test for multi create (20)
	//  List binding: absolute
	//  Number of transient: 1
	//  Delete: Context.refresh(bAllowRemoval=true)
	//  Table control: sap.ui.table.Table
	//  Create at: end
	// CPOUI5UISERVICESV3-1818
	QUnit.test("All pairs test for multi create (20)", function (assert) {
		var oBinding,
			oCreatedContext0,
			oCreatedContext1,
			oCreatedContext2,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				groupId : "$direct",
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/SalesOrderList\', parameters : {$count : true}}"\
		visibleRowCount="2">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList"
				+ "?$count=true&$select=Note,SalesOrderID&$skip=0&$top=102", {
				"@odata.count" : "1",
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", ["42"])
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("id", [, ""])
				.expectChange("note", [, "New 1"]); // "New 2" is invisible as visibleRowCount is 2

			oCreatedContext0 = oBinding.create({Note : "New 1"}, true, true);
			oCreatedContext1 = oBinding.create({Note : "New 2"}, true, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 1"}
				}, {
					Note : "New 1",
					SalesOrderID : "43"
				})
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "New 2"}
				}, {
					Note : "New 2",
					SalesOrderID : "44"
				})
				.expectChange("id", [, "43"]);

			return Promise.all([
				oCreatedContext0.created(),
				oCreatedContext1.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// never persisted or deleted, new entry not visible
			oCreatedContext2 = oBinding.create({Note : "New 3"}, true, true);

			assert.strictEqual(oTable.getRows()[0].getBindingContext().isTransient(), undefined);
			assert.strictEqual(oTable.getRows()[1].getBindingContext(), oCreatedContext0);
			assert.strictEqual(oCreatedContext0.isTransient(), false);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("id", [, "43", "44"])
				.expectChange("note", [, "New 1", "New 2"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('44')")
				.expectChange("id", [,, ""])
				.expectChange("note", [,, "New 3"]);

			return Promise.all([
				oCreatedContext1.delete("$auto"),
				that.waitForChanges(assert, "")
			]);
		}).then(function () {
			var aRows = oTable.getRows();

			assert.strictEqual(oTable.getFirstVisibleRow(), 1);
			assert.strictEqual(aRows.length, 2);
			assert.strictEqual(aRows[0].getBindingContext(), oCreatedContext0);
			assert.strictEqual(aRows[1].getBindingContext(), oCreatedContext2);
		});
	});

	//*********************************************************************************************
	// Scenario: Create a business partner w/o key properties, enter an address (complex property),
	// then submit the batch
	QUnit.test("Create with default value in a complex property", function (assert) {
		var oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<Table id="table" items="{/BusinessPartnerList}">\
	<Input id="city" value="{Address/City}"/>\
	<Input id="longitude" value="{Address/GeoLocation/Longitude}"/>\
</Table>',

			that = this;

		this.expectRequest("BusinessPartnerList?$select=Address/City,Address/GeoLocation/Longitude"
				+ ",BusinessPartnerID&$skip=0&$top=100", {
				value : [{
					Address : {
						City : "Walldorf",
						GeoLocation : null
					},
					BusinessPartnerID : "42"
				}]
			})
			.expectChange("city", ["Walldorf"])
			.expectChange("longitude", ["0.000000000000"]); // default value

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("city", ["", "Walldorf"])
				.expectChange("longitude", [, "0.000000000000"]);

			oTable = that.oView.byId("table");
			oTable.getBinding("items").create();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("city", ["Heidelberg"])
				.expectChange("longitude", ["8.700000000000"]);

			oTable.getItems()[0].getCells()[0].getBinding("value").setValue("Heidelberg");
			oTable.getItems()[0].getCells()[1].getBinding("value").setValue("8.7");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "BusinessPartnerList",
					payload : {
						Address : {
							City : "Heidelberg",
							GeoLocation : {Longitude : "8.7"}
						}
					}
				}, {
					Address : {
						City : "Heidelberg",
						GeoLocation : {Longitude : "8.69"}
					},
					BusinessPartnerID : "43"
				})
				// Note: This additional request will be eliminated by CPOUI5UISERVICESV3-1436
				.expectRequest("BusinessPartnerList('43')?$select=Address/City"
						+ ",Address/GeoLocation/Longitude,BusinessPartnerID", {
					Address : {
						City : "Heidelberg",
						GeoLocation : {Longitude : "8.69"}
					},
					BusinessPartnerID : "43"
				})
				.expectChange("longitude", ["8.690000000000"]);

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create a sales order line item, enter a quantity, then submit the batch. Expect the
	// quantity unit to be sent, too.
	QUnit.test("Create with default value in a currency/unit", function (assert) {
		var oListBinding,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<Table id="table" items="{/SalesOrderList(\'42\')/SO_2_SOITEM}">\
	<Input id="quantity" value="{Quantity}"/>\
	<Text id="unit" text="{QuantityUnit}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$select=ItemPosition,Quantity"
				+ ",QuantityUnit,SalesOrderID&$skip=0&$top=100", {
				value : [{
					SalesOrderID : "42",
					ItemPosition : "0010",
					Quantity : "1.000",
					QuantityUnit : "DZ"
				}]
			})
			.expectChange("quantity", ["1.000"])
			.expectChange("unit", ["DZ"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("quantity", [null, "1.000"])
				.expectChange("unit", ["EA", "DZ"]);

			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("items");
			oListBinding.create();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("quantity", ["2.000"]);

			oTable.getItems()[0].getCells()[0].getBinding("value").setValue("2.000");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('42')/SO_2_SOITEM",
					payload : {
						Quantity : "2.000",
						QuantityUnit : "EA"
					}
				}, {
					SalesOrderID : "42",
					ItemPosition : "0020",
					Quantity : "2.000",
					QuantityUnit : "EA"
				})
				// Note: This additional request will be eliminated by CPOUI5UISERVICESV3-1436
				.expectRequest("SalesOrderList('42')"
					+ "/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0020')"
					+ "?$select=ItemPosition,Quantity,QuantityUnit,SalesOrderID", {
					SalesOrderID : "42",
					ItemPosition : "0020",
					Quantity : "2.000",
					QuantityUnit : "EA"
				});

			return Promise.all([
				that.oModel.submitBatch("update").then(
					function () {
						assert.notOk(oModel.hasPendingChanges("update"),
							"Model: No pending changes when submitBatch promise resolves");
						assert.notOk(oListBinding.hasPendingChanges(),
							"Binding: No pending changes when submitBatch promise resolves");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Failure when creating a sales order line item. Observe the message.
	//
	// No "sap-cancel-on-close" header in POST request (JIRA: CPOUI5ODATAV4-2506)
	QUnit.test("Create error", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true, groupId : "$direct"}),
			oTable,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'42\')}">\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text text="{ItemPosition}"/>\
		<Input value="{ProductID}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,ProductID,SalesOrderID)", {
				SalesOrderID : "42",
				SO_2_SOITEM : []
			});

		return this.createView(assert, sView, oModel).then(function () {
			var oError = createError({
					message : "Enter a product ID",
					target : "ProductID"
				});

			oTable = that.oView.byId("table");
			that.oLogMock.expects("error")
				.withExactArgs("POST on 'SalesOrderList('42')/SO_2_SOITEM' failed; "
					+ "will be repeated automatically", sinon.match(oError.message), sODLB);
			that.expectRequest({
					method : "POST",
					headers : {/*NO "sap-cancel-on-close"*/},
					url : "SalesOrderList('42')/SO_2_SOITEM",
					payload : {}
				}, oError)
				.expectMessages([{
					code : "CODE",
					message : "Enter a product ID",
					persistent : true,
					target : "/SalesOrderList('42')/SO_2_SOITEM($uid=...)/ProductID",
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				oTable.getBinding("items").create(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, oTable.getItems()[0].getCells()[1], "Error",
				"Enter a product ID");
		});
	});

	//*********************************************************************************************
	// Scenario: Read a sales order line item via a navigation property, enter an invalid quantity.
	// Expect an error response with a bound and unbound error in the details, and that existing
	// messages are not deleted.
	// The navigation property is necessary so that read path and patch path are different.
	QUnit.test("Read a sales order line item, enter an invalid quantity", function (assert) {
		var oError = createError({
				code : "top",
				message : "Error occurred while processing the request",
				details : [{
					"@Common.longtextUrl" : "../Messages(1)/LongText",
					"@Common.numericSeverity" : 4,
					code : "bound",
					message : "Value must be greater than 0",
					target : "Quantity"
				}, {
					"@Common.longtextUrl" : "", // must be ignored
					"@Common.numericSeverity" : 3,
					code : "unbound",
					message : "Some unbound warning"
				}]
			}),
			oExpectedMessage = {
				code : "23",
				message : "Enter a minimum quantity of 2",
				target : "/BusinessPartnerList('1')/BP_2_SO('42')/SO_2_SOITEM('0010')/Quantity",
				type : "Warning"
			},
			oModel = this.createSalesOrdersModel({autoExpandSelect : true, groupId : "$direct"}),
			sView = '\
<FlexBox binding="{\
		path : \'/BusinessPartnerList(\\\'1\\\')/BP_2_SO(\\\'42\\\')/SO_2_SOITEM(\\\'0010\\\')\',\
		parameters : {$select : \'Messages\'}}">\
	<Input id="quantity" value="{Quantity}"/>\
	<Text id="unit" text="{QuantityUnit}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('1')/BP_2_SO('42')/SO_2_SOITEM('0010')"
				+ "?$select=ItemPosition,Messages,Quantity,QuantityUnit,SalesOrderID", {
				SalesOrderID : "42",
				ItemPosition : "0010",
				Quantity : "1.000",
				QuantityUnit : "DZ",
				Messages : [{
					code : "23",
					message : "Enter a minimum quantity of 2",
					numericSeverity : 3,
					target : "Quantity"
				}]
			})
			.expectChange("quantity", "1.000")
			.expectChange("unit", "DZ")
			.expectMessages([oExpectedMessage]);

		return this.createView(assert, sView, oModel).then(function () {
			return that.checkValueState(assert, "quantity", "Warning",
				"Enter a minimum quantity of 2");
		}).then(function () {
			that.oLogMock.expects("error").twice() // Note: twice, w/ different class name :-(
				.withArgs("Failed to update path /BusinessPartnerList('1')/BP_2_SO('42')"
					+ "/SO_2_SOITEM('0010')/Quantity", sinon.match(oError.message));
			that.expectChange("quantity", "0.000")
				.expectRequest({
						method : "PATCH",
						url : "SalesOrderList('42')/SO_2_SOITEM('0010')",
						payload : {
							Quantity : "0.000",
							QuantityUnit : "DZ"
						}
					}, oError)
				.expectMessages([
					oExpectedMessage, {
						code : "top",
						message : "Error occurred while processing the request",
						persistent : true,
						technical : true,
						technicalDetails : {
							httpStatus : 500, // CPOUI5ODATAV4-428
							originalMessage : {
								code : "top",
								details : [{
									"@Common.longtextUrl" : "../Messages(1)/LongText",
									"@Common.numericSeverity" : 4,
									code : "bound",
									message : "Value must be greater than 0",
									target : "Quantity"
								}, {
									"@Common.longtextUrl" : "",
									"@Common.numericSeverity" : 3,
									code : "unbound",
									message : "Some unbound warning"
								}],
								message : "Error occurred while processing the request"
							}
						},
						type : "Error"
					}, {
						code : "unbound",
						message : "Some unbound warning",
						persistent : true,
						technicalDetails : {
							httpStatus : 500, // CPOUI5ODATAV4-428
							originalMessage : {
								"@Common.longtextUrl" : "",
								"@Common.numericSeverity" : 3,
								code : "unbound",
								message : "Some unbound warning"
							}
						},
						type : "Warning"
					}, {
						code : "bound",
						descriptionUrl : sSalesOrderService + "Messages(1)/LongText",
						message : "Value must be greater than 0",
						persistent : true,
						target :
							"/BusinessPartnerList('1')/BP_2_SO('42')/SO_2_SOITEM('0010')/Quantity",
						technicalDetails : {
							httpStatus : 500, // CPOUI5ODATAV4-428
							originalMessage : {
								"@Common.longtextUrl" : "../Messages(1)/LongText",
								"@Common.numericSeverity" : 4,
								code : "bound",
								message : "Value must be greater than 0",
								target : "Quantity"
							}
						},
						type : "Error"
					}
				]);

			that.oView.byId("quantity").getBinding("value").setValue("0.000");

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, "quantity", "Error",
				"Value must be greater than 0");
		});
	});

	//*********************************************************************************************
	// Scenario: Modify two properties of a sales order, then submit the batch
	QUnit.test("Merge PATCHes", function (assert) {
		var sEtag = "ETag",
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			sView = '\
<FlexBox binding="{/SalesOrderList(\'42\')}">\
	<Input id="note" value="{Note}"/>\
	<Input id="amount" value="{GrossAmount}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=GrossAmount,Note,SalesOrderID", {
				"@odata.etag" : sEtag,
				GrossAmount : "1000.00",
				Note : "Note",
				SalesOrderID : "42"
			})
			.expectChange("note", "Note")
			.expectChange("amount", "1,000.00");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : sEtag},
					payload : {
						GrossAmount : "1234.56",
						Note : "Changed Note"
					}
				}, {
					GrossAmount : "1234.56",
					Note : "Changed Note From Server"
				})
				.expectChange("amount", "1,234.56")
				.expectChange("note", "Changed Note")
				.expectChange("note", "Changed Note From Server");

			that.oView.byId("amount").getBinding("value").setValue("1234.56");
			that.oView.byId("note").getBinding("value").setValue("Changed Note");

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Merge PATCHes for different entities even if there are other changes in between
	// JIRA: CPOUI5UISERVICESV3-1450
	QUnit.test("Merge PATCHes for different entities", function (assert) {
		var oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Input id="amount" value="{GrossAmount}"/>\
	<Input id="note" value="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest(
			"SalesOrderList?$select=GrossAmount,Note,SalesOrderID&$skip=0&$top=100", {
				value : [{
					"@odata.etag" : "ETag0",
					GrossAmount : "1000.00",
					Note : "Note0",
					SalesOrderID : "41"
				}, {
					"@odata.etag" : "ETag1",
					GrossAmount : "150.00",
					Note : "Note1",
					SalesOrderID : "42"
				}]
			})
			.expectChange("amount", ["1,000.00", "150.00"])
			.expectChange("note", ["Note0", "Note1"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oTable = that.oView.byId("table"),
				aTableItems = oTable.getItems(),
				oBindingAmount0 = aTableItems[0].getCells()[0].getBinding("value"),
				oBindingAmount1 = aTableItems[1].getCells()[0].getBinding("value"),
				oBindingNote0 = aTableItems[0].getCells()[1].getBinding("value"),
				oBindingNote1 = aTableItems[1].getCells()[1].getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('41')",
					headers : {"If-Match" : "ETag0"},
					payload : {
						GrossAmount : "123.45",
						Note : "Note02"
					}
				}, {
					GrossAmount : "123.45",
					Note : "Note02"
				})
				.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag1"},
					payload : {
						GrossAmount : "456.78",
						Note : "Note12"
					}
				}, {
					GrossAmount : "456.78",
					Note : "Note12"
				})
				.expectChange("amount", ["123.45", "456.78"])
				.expectChange("note", ["Note01", "Note11"])
				.expectChange("note", ["Note02", "Note12"]);

			// Code under test
			oBindingAmount0.setValue("123.45");
			oBindingAmount1.setValue("456.78");
			oBindingNote0.setValue("Note01");
			oBindingNote1.setValue("Note11");
			oBindingNote1.setValue("Note12");
			oBindingNote0.setValue("Note02");

			return Promise.all([
				oModel.submitBatch("update").then(
					function () {
						assert.notOk(oModel.hasPendingChanges("update"),
							"No pending changes when submitBatch promise resolves");
						assert.notOk(oTable.getBinding("items").hasPendingChanges(),
							"No pending changes when submitBatch promise resolves");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Error response for a change set without content-ID
	// Without target $<content-ID> in the error response we can not assign the error to the
	// right request -> all requests in the change set are rejected with the same error;
	// the error is logged for each request in the change set, but it is reported only once to
	// the message model
	QUnit.test("Error response for a change set w/o content-ID", function (assert) {
		var oError = createErrorInsideBatch({message : "Value 4.22 not allowed"}),
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Input id="amount" value="{GrossAmount}"/>\
</Table>',
			that = this;

		this.expectRequest(
			"SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=0&$top=100", {
				value : [{
					"@odata.etag" : "ETag0",
					GrossAmount : "4.1",
					SalesOrderID : "41"
				}, {
					"@odata.etag" : "ETag1",
					GrossAmount : "4.2",
					SalesOrderID : "42"
				}]
			})
			.expectChange("amount", ["4.10", "4.20"]);

		return this.createView(assert, sView, oModel).then(function () {
			var aTableItems = that.oView.byId("table").getItems(),
				oBindingAmount0 = aTableItems[0].getCells()[0].getBinding("value"),
				oBindingAmount1 = aTableItems[1].getCells()[0].getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('41')",
					headers : {"If-Match" : "ETag0"},
					payload : {GrossAmount : "4.11"}
				}) // no response required since the 2nd request fails
				.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag1"},
					payload : {GrossAmount : "4.22"}
				}, oError)
				.expectChange("amount", ["4.11", "4.22"])
				.expectMessages([{
					code : "CODE",
					message : "Value 4.22 not allowed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			that.oLogMock.expects("error")
				.withExactArgs("Failed to update path /SalesOrderList('41')/GrossAmount",
					sinon.match("Value 4.22 not allowed"), sContext);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to update path /SalesOrderList('42')/GrossAmount",
					sinon.match("Value 4.22 not allowed"), sContext);

			// Code under test
			oBindingAmount0.setValue("4.11");
			oBindingAmount1.setValue("4.22");

			return Promise.all([
				oModel.submitBatch("update").then(
					function () {
						assert.ok(oModel.hasPendingChanges("update"),
							"Pending changes when submitBatch promise resolves as PATCH failed");
						assert.ok(that.oView.byId("table").getBinding("items").hasPendingChanges(),
							"Pending changes when submitBatch promise resolves as PATCH failed");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: One error for a change set with (un)bound error messages for the various requests.
	// ContentID on root level, but missing for one message in details. Check the value state for
	// the related input controls.
	// JIRA: CPOUI5ODATAV4-729
	QUnit.test("CPOUI5ODATAV4-729: @Core.ContentID", function (assert) {
		var aItems,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<ColumnListItem>\
		<Input id="amount" value="{GrossAmount}"/>\
	</ColumnListItem>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=0&$top=100", {
				value : [{
					GrossAmount : "4.1",
					SalesOrderID : "41"
				}, {
					GrossAmount : "4.2",
					SalesOrderID : "42"
				}]
			})
			.expectChange("amount", ["4.10", "4.20"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oError = createErrorInsideBatch({
					"@SAP__common.longtextUrl" : "Messages(1)/LongText",
					"@SAP__core.ContentID" : "0.0",
					target : "",
					details : [{
						code : "CODE0",
						message : "Value 4.11 not allowed",
						"@SAP__core.ContentID" : "0.0",
						target : "GrossAmount",
						"@SAP__common.numericSeverity" : 3
					}, {
						code : "CODE1",
						message : "Value 4.22 not allowed",
						"@SAP__core.ContentID" : "1.0",
						target : "GrossAmount",
						"@SAP__common.numericSeverity" : 4
					}, {
						code : "CODE2",
						message : "Error cannot be assigned to a request",
						target : "n/a", // must be ignored because of missing ContentID
						"@SAP__common.numericSeverity" : 2
					}]
				});

			aItems = that.oView.byId("table").getItems();

			that.expectChange("amount", ["4.11", "4.22"])
				.expectRequest({
					changeSetNo : 1,
					$ContentID : "0.0",
					method : "PATCH",
					url : "SalesOrderList('41')",
					payload : {GrossAmount : "4.11"}
				}, oError)
				.expectRequest({
					changeSetNo : 1,
					$ContentID : "1.0",
					method : "PATCH",
					url : "SalesOrderList('42')",
					payload : {GrossAmount : "4.22"}
				}) // no response required
				.expectMessages([{
					code : "CODE",
					descriptionUrl : sSalesOrderService + "Messages(1)/LongText",
					message : "Request intentionally failed",
					persistent : true,
					target : "/SalesOrderList('41')",
					technical : true,
					type : "Error"
				}, {
					code : "CODE0",
					message : "Value 4.11 not allowed",
					persistent : true,
					target : "/SalesOrderList('41')/GrossAmount",
					type : "Warning"
				}, {
					code : "CODE1",
					message : "Value 4.22 not allowed",
					persistent : true,
					target : "/SalesOrderList('42')/GrossAmount",
					type : "Error"
				}, {
					code : "CODE2",
					message : "n/a: Error cannot be assigned to a request",
					persistent : true,
					type : "Information"
				}]);

			that.oLogMock.expects("error")
				.withExactArgs("Failed to update path /SalesOrderList('41')/GrossAmount",
					sinon.match("Request intentionally failed"), sContext);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to update path /SalesOrderList('42')/GrossAmount",
					sinon.match("Request intentionally failed"), sContext);

			// code under test
			aItems[0].getCells()[0].getBinding("value").setValue("4.11");
			aItems[1].getCells()[0].getBinding("value").setValue("4.22");

			return that.waitForChanges(assert);
		}).then(function () {
			return Promise.all([
				that.checkValueState(assert, aItems[0].getCells()[0], "Warning",
					"Value 4.11 not allowed"),
				that.checkValueState(assert, aItems[1].getCells()[0], "Error",
					"Value 4.22 not allowed")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Modify a property while an update request is not yet resolved. Determine the ETag
	// as late as possible
	// JIRA: CPOUI5UISERVICESV3-1450
	QUnit.test("Lazy determination of ETag while PATCH", function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			fnRespond,
			oSubmitBatchPromise,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'42\')}">\
	<Input id="note" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID", {
				"@odata.etag" : "ETag0",
				Note : "Note",
				SalesOrderID : "42"
			})
			.expectChange("note", "Note");

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("note").getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag0"},
					payload : {Note : "Changed Note"}
				}, new Promise(function (resolve) {
					fnRespond = resolve.bind(null, {
						"@odata.etag" : "ETag1",
						Note : "Changed Note From Server"
					});
				}))
				.expectChange("note", "Changed Note");

			oBinding.setValue("Changed Note");
			oSubmitBatchPromise = that.oModel.submitBatch("update");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag1"},
					payload : {Note : "Changed Note while $batch is running"}
				}, {
					"@odata.etag" : "ETag2",
					Note : "Changed Note From Server - 2"
				})
				.expectChange("note", "Changed Note while $batch is running")
				// TODO as long as there are PATCHes in the queue, don't overwrite user input
				.expectChange("note", "Changed Note From Server")
				.expectChange("note", "Changed Note From Server - 2");

			oBinding.setValue("Changed Note while $batch is running");

			fnRespond();

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert),
				oSubmitBatchPromise
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Invoke a bound action while an update request for the entity is not yet
	// resolved. Determine the ETag as late as possible.
	// JIRA: CPOUI5UISERVICESV3-1450
	//
	// Do not update binding parameter when both key predicates are missing.
	// JIRA: CPOUI5ODATAV4-1683
	QUnit.test("Lazy determination of ETag while ODataContextBinding#invoke", function (assert) {
		var sAction = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
			oBinding,
			oInvokePromise,
			oModel = this.createTeaBusiModel({updateGroupId : "update"}),
			fnRespond,
			oSubmitBatchPromise,
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'1\')}">\
	<Input id="name" value="{Name}"/>\
	<FlexBox id="action" \
			binding="{' + sAction + '(...)}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="teamId" text="{TEAM_ID}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')", {
				// ID : "1", // no key predicate here!
				Name : "Jonathan Smith",
				"@odata.etag" : "ETag0"
			})
			.expectChange("name", "Jonathan Smith")
			.expectChange("teamId", null);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("name").getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('1')",
					headers : {"If-Match" : "ETag0"},
					payload : {Name : "Jonathan Mueller"}
				}, new Promise(function (resolve) {
					fnRespond = resolve.bind(null, {
						"@odata.etag" : "ETag1",
						Name : "Jonathan Mller"
					});
				}))
				.expectChange("name", "Jonathan Mueller"); // invoked by setValue

			oBinding.setValue("Jonathan Mueller");

			oSubmitBatchPromise = that.oModel.submitBatch("update");

			return that.waitForChanges(assert);
		}).then(function () {
			oInvokePromise = that.oView.byId("action").getObjectBinding()
				.setParameter("TeamID", "42").invoke("update");

			that.expectChange("name", "Jonathan Mller"); // invoked by PATCH response
			fnRespond();

			return Promise.all([
				oSubmitBatchPromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					headers : {"If-Match" : "ETag1"},
					url : "EMPLOYEES('1')/" + sAction,
					payload : {TeamID : "42"}
				}, {
					// ID : "1", // no key predicate here!
					TEAM_ID : "42",
					Name : "n/a" // Note: w/o key predicate, do not update binding parameter!
				})
				.expectChange("teamId", "42");

			return Promise.all([
				that.oModel.submitBatch("update"),
				oInvokePromise.then(function (oReturnValueContext) {
					assert.strictEqual(oReturnValueContext, undefined,
						"no R.V.C. w/o key predicate");
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Invoke a bound action a 2nd time while the 1st POST is still "in flight"
	// BCP: 2380023421
	QUnit.test("Lazy determination of ETag by ODataContextBinding#invoke", function (assert) {
		var sAction = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
			oContext,
			oInvokePromise1,
			oInvokePromise2,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			fnRespond,
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'1\')}">\
	<Text id="name" text="{Name}"/>\
	<Text id="teamId" text="{TEAM_ID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')?$select=ID,Name,TEAM_ID", {
				"@odata.etag" : "ETag0",
				ID : "1",
				Name : "Jonathan Smith",
				TEAM_ID : "01"
			})
			.expectChange("name", "Jonathan Smith")
			.expectChange("teamId", "01");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("name").getBindingContext();

			that.expectRequest({
					method : "POST",
					headers : {"If-Match" : "ETag0"},
					url : "EMPLOYEES('1')/" + sAction,
					payload : {TeamID : "42"}
				}, new Promise(function (resolve) {
					fnRespond = resolve.bind(null, {
						"@odata.etag" : "ETag1",
						ID : "1",
						Name : "Jonathan Smith junior",
						TEAM_ID : "42"
					});
				}));

			oInvokePromise1 = oModel.bindContext(sAction + "(...)", oContext)
				.setParameter("TeamID", "42")
				.invoke();

			return that.waitForChanges(assert, "1st #invoke");
		}).then(function () {
			// expect no 2nd POST yet!

			oInvokePromise2 = oModel.bindContext(sAction + "(...)", oContext)
				.setParameter("TeamID", "23")
				.invoke();

			return that.waitForChanges(assert, "2nd #invoke");
		}).then(function () {
			that.expectChange("name", "Jonathan Smith junior")
				.expectChange("teamId", "42")
				.expectRequest({
					method : "POST",
					headers : {"If-Match" : "ETag1"},
					url : "EMPLOYEES('1')/" + sAction,
					payload : {TeamID : "23"}
				}, {
					"@odata.etag" : "ETag2",
					ID : "1",
					Name : "Jonathan Smith senior",
					TEAM_ID : "23"
				})
				.expectChange("name", "Jonathan Smith senior")
				.expectChange("teamId", "23");

			fnRespond();

			return Promise.all([
				oInvokePromise1,
				oInvokePromise2.then(function () {
					assert.strictEqual(oContext.getProperty("@odata.etag"), "ETag2");
				}),
				that.waitForChanges(assert, "1st response invokes 2nd request")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Modify a property while an update request is not yet resolved. The second PATCH
	// request must wait for the first one to finish and use the eTag returned in its response.
	// JIRA: CPOUI5UISERVICESV3-1450
	//
	// A third PATCH request which also waits goes into a separate change set when submitBatch
	// has been called before it was created (CPOUI5UISERVICESV3-1531).
	QUnit.test("PATCH entity, two subsequent PATCHes on this entity wait", function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({
				updateGroupId : "update"
			}),
			aPromises = [],
			fnRespond,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'42\')}">\
	<Input id="note" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')", {
				"@odata.etag" : "ETag0",
				Note : "Note",
				SalesOrderID : "42"
			})
			.expectChange("note", "Note");

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("note").getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag0"},
					payload : {Note : "Changed Note"}
				}, new Promise(function (resolve) {
					fnRespond = resolve.bind(null, {
						"@odata.etag" : "ETag1",
						Note : "Changed Note From Server"
					});
				}))
				.expectChange("note", "Changed Note");

			oBinding.setValue("Changed Note");
			aPromises.push(that.oModel.submitBatch("update"));

			return that.waitForChanges(assert);
		}).then(function () {
			var oMetaModel = oModel.getMetaModel(),
				fnFetchObject = oMetaModel.fetchObject,
				oMetaModelMock = that.mock(oMetaModel);

			that.expectChange("note", "(1) Changed Note while $batch is running");

			// enforce delayed creation of PATCH request for setValue: submitBatch is called
			// *before* this request is created, but the request is in the change set which is
			// the current one before the submitBatch
			oMetaModelMock.expects("fetchObject")
				.withExactArgs("/SalesOrderList/Note")
				.callsFake(function () {
					return resolveLater(fnFetchObject.bind(oMetaModel, "/SalesOrderList/Note"));
				});

			oBinding.setValue("(1) Changed Note while $batch is running");
			aPromises.push(that.oModel.submitBatch("update"));

			oMetaModelMock.restore();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", "(2) Changed Note while $batch is running");

			oBinding.setValue("(2) Changed Note while $batch is running");
			aPromises.push(that.oModel.submitBatch("update"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", "Changed Note From Server")
				.expectRequest({
					changeSetNo : 1,
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag1"},
					payload : {Note : "(1) Changed Note while $batch is running"}
				}, {
					"@odata.etag" : "ETag2",
					Note : "(1) Changed Note From Server - 2"
				})
				.expectRequest({
					changeSetNo : 2,
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag1"},
					payload : {Note : "(2) Changed Note while $batch is running"}
				}, {
					"@odata.etag" : "ETag2",
					Note : "(2) Changed Note From Server - 2"
				})
				.expectChange("note", "(1) Changed Note From Server - 2")
				.expectChange("note", "(2) Changed Note From Server - 2");

			fnRespond();
			aPromises.push(that.waitForChanges(assert));

			return Promise.all(aPromises);
		});
	});

	//*********************************************************************************************
	// Scenario: While update for entity1 is on the wire (request1), update both entity1 and entity2
	// in one batch (request2). Then update entity2 (request3).
	// request2 and request3 wait for request1 to return *and* apply the response to the cache;
	// the PATCHes of request2 and request3 are merged and use the ETag from the response to
	// request1.
	// JIRA: CPOUI5UISERVICESV3-1450
	QUnit.test("1=PATCH e1, 2=PATCH(e1,e2), 3=PATCH e2: request sequence 1,2,3", function (assert) {
		var oBinding42,
			oBinding77,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			aPromises = [],
			fnRespond42,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'42\')}">\
	<Input id="note42" value="{Note}"/>\
</FlexBox>\
<FlexBox binding="{/SalesOrderList(\'77\')}">\
	<Input id="note77" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID", {
				"@odata.etag" : "42ETag0",
				Note : "Note42",
				SalesOrderID : "42"
			})
			.expectChange("note42", "Note42")
			.expectRequest("SalesOrderList('77')?$select=Note,SalesOrderID", {
				"@odata.etag" : "77ETag0",
				Note : "Note77",
				SalesOrderID : "77"
			})
			.expectChange("note77", "Note77");

		return this.createView(assert, sView, oModel).then(function () {
			oBinding42 = that.oView.byId("note42").getBinding("value");
			oBinding77 = that.oView.byId("note77").getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "42ETag0"},
					payload : {Note : "42Changed Note"}
				}, new Promise(function (resolve) {
					fnRespond42 = resolve.bind(null, {
						"@odata.etag" : "42ETag1",
						Note : "42Changed Note From Server"
					});
				}))
				.expectChange("note42", "42Changed Note");

			oBinding42.setValue("42Changed Note");
			aPromises.push(that.oModel.submitBatch("update"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note42", "(1) 42Changed Note while $batch is running")
				.expectChange("note77", "(1) 77Changed Note while $batch is running");

			oBinding42.setValue("(1) 42Changed Note while $batch is running");
			oBinding77.setValue("(1) 77Changed Note while $batch is running");
			aPromises.push(that.oModel.submitBatch("update"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note77", "77Changed Note");

			oBinding77.setValue("77Changed Note");
			aPromises.push(that.oModel.submitBatch("update"));

			return that.waitForChanges(assert);
		}).then(function () {
			//TODO suppress change event for outdated value "42Changed Note From Server"
			that.expectChange("note42", "42Changed Note From Server")
				.expectRequest({
					changeSetNo : 1,
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "42ETag1"},
					payload : {Note : "(1) 42Changed Note while $batch is running"}
				}, {
					"@odata.etag" : "42ETag2",
					Note : "42Changed Note From Server - 1"
				})
				.expectRequest({
					changeSetNo : 1,
					method : "PATCH",
					url : "SalesOrderList('77')",
					headers : {"If-Match" : "77ETag0"},
					payload : {Note : "(1) 77Changed Note while $batch is running"}
				}, {
					"@odata.etag" : "77ETag1",
					Note : "(1) 77Changed Note From Server - 1"
				})
				.expectRequest({
					changeSetNo : 2,
					method : "PATCH",
					url : "SalesOrderList('77')",
					headers : {"If-Match" : "77ETag0"},
					payload : {Note : "77Changed Note"}
				}, {
					"@odata.etag" : "77ETag1",
					Note : "(2) 77Changed Note From Server - 1"
				})
				.expectChange("note42", "42Changed Note From Server - 1")
				.expectChange("note77", "(1) 77Changed Note From Server - 1")
				.expectChange("note77", "(2) 77Changed Note From Server - 1");

			fnRespond42();
			aPromises.push(that.waitForChanges(assert));

			return Promise.all(aPromises);
		});
	});

	//*********************************************************************************************
	// Scenario: Support of Draft: Test eventing for PATCH requests
	["update", "$auto"].forEach(function (sUpdateGroupId) {
		var sTitle = "Support of Draft: Test eventing for PATCH requests; updateGroupId = "
				+ sUpdateGroupId;

		QUnit.test(sTitle, function (assert) {
			var fnAfterPatchCompleted,
				oBatchPromise0,
				oBatchPromise1,
				oModel = this.createSalesOrdersModel({
					autoExpandSelect : true,
					updateGroupId : sUpdateGroupId
				}),
				oParentBinding,
				iPatchCompleted = 0,
				iPatchSent = 0,
				fnReject,
				fnRespond,
				sView = '\
<FlexBox binding="{/SalesOrderList(\'42\')}" id="parent">\
	<Input id="lifecycleStatus" value="{LifecycleStatus}"/>\
	<Input id="note" value="{Note}"/>\
</FlexBox>',
				that = this;

			function getWaitForPatchCompletedPromise() {
				return new Promise(function (resolve) {
					fnAfterPatchCompleted = resolve;
				});
			}

			this.expectRequest("SalesOrderList('42')?$select=LifecycleStatus,Note,SalesOrderID", {
					"@odata.etag" : "ETag0",
					LifecycleStatus : "N",
					Note : "Note",
					SalesOrderID : "42"
				})
				.expectChange("lifecycleStatus", "N")
				.expectChange("note", "Note");

			return this.createView(assert, sView, oModel).then(function () {
				oParentBinding = that.oView.byId("parent").getElementBinding();

				oParentBinding.attachPatchCompleted(function (oEvent) {
					assert.strictEqual(oEvent.getSource(), oParentBinding);
					iPatchCompleted += 1;
					if (fnAfterPatchCompleted) {
						fnAfterPatchCompleted();
						fnAfterPatchCompleted = undefined;
					}
				});
				oParentBinding.attachPatchSent(function (oEvent) {
					assert.strictEqual(oEvent.getSource(), oParentBinding);
					iPatchSent += 1;
				});

				that.expectRequest({
						method : "PATCH",
						url : "SalesOrderList('42')",
						headers : {"If-Match" : "ETag0"},
						payload : {Note : "Changed Note"}
					}, new Promise(function (_resolve, reject) {
						fnReject = reject;
					}))
					.expectChange("note", "Changed Note");

				that.oView.byId("note").getBinding("value").setValue("Changed Note");
				if (sUpdateGroupId === "update") {
					oBatchPromise0 = that.oModel.submitBatch(sUpdateGroupId);
				}

				return that.waitForChanges(assert);
			}).then(function () {
				var oPromise = getWaitForPatchCompletedPromise();

				assert.strictEqual(iPatchSent, 1, "patchSent 1");
				assert.strictEqual(iPatchCompleted, 0, "patchCompleted 0");

				that.oLogMock.expects("error")
					.withArgs("Failed to update path /SalesOrderList('42')/Note");

				fnReject(createErrorInsideBatch({message : "Patch failed"}));

				return oPromise;
			}).then(function () {
				assert.strictEqual(iPatchSent, 1, "patchSent 1");
				assert.strictEqual(iPatchCompleted, 1, "patchCompleted 1");

				that.expectMessages([{
						code : "CODE",
						message : "Patch failed",
						persistent : true,
						technical : true,
						technicalDetails : {
							httpStatus : 500, // CPOUI5ODATAV4-428
							originalMessage : {
								code : "CODE",
								message : "Patch failed"
							}
						},
						type : "Error"
					}])
					.expectChange("lifecycleStatus", "P")
					.expectRequest({
						method : "PATCH",
						url : "SalesOrderList('42')",
						headers : {"If-Match" : "ETag0"},
						payload : {
							LifecycleStatus : "P",
							Note : "Changed Note"
						}
					}, new Promise(function (resolve) {
						fnRespond = resolve.bind(null, {
							"@odata.etag" : "ETag1",
							LifecycleStatus : "P",
							Note : "Changed Note From Server"
						});
					}));

				that.oView.byId("lifecycleStatus").getBinding("value").setValue("P");

				if (sUpdateGroupId === "update") {
					oBatchPromise1 = that.oModel.submitBatch(sUpdateGroupId);
				}

				return that.waitForChanges(assert);
			}).then(function () {
				var oPromise = getWaitForPatchCompletedPromise();

				assert.strictEqual(iPatchSent, 2, "patchSent 2");
				assert.strictEqual(iPatchCompleted, 1, "patchCompleted 1");

				that.expectChange("note", "Changed Note From Server");

				fnRespond();
				return Promise.all([
					oBatchPromise0,
					oBatchPromise1,
					oPromise,
					that.waitForChanges(assert)
				]);
			}).then(function () {
				assert.strictEqual(iPatchSent, 2, "patchSent 2");
				assert.strictEqual(iPatchCompleted, 2, "patchCompleted 2");
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Enable autoExpandSelect mode for an ODataContextBinding with relative
	// ODataPropertyBindings
	// Additionally add a path with navigation properties to $select which must be converted to a
	// $expand and a qualified operation name which must stay in $select.
	// JIRA: CPOUI5ODATAV4-112
	// BCP: 2080084634
	QUnit.test("Auto-$expand/$select: Absolute ODCB with relative ODPB", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{path : \'/EMPLOYEES(\\\'2\\\')\', \
		parameters : {$select : \'AGE,ROOM_ID,EMPLOYEE_2_TEAM/Name\
,com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee\'}}">\
	<Text id="name" text="{Name}"/>\
	<Text id="city" text="{LOCATION/City/CITYNAME}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')?$select=AGE,ID,LOCATION/City/CITYNAME,Name,ROOM_ID"
				+ ",com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee"
				+ "&$expand=EMPLOYEE_2_TEAM($select=Name,Team_Id)", {
				Name : "Frederic Fall",
				LOCATION : {City : {CITYNAME : "Walldorf"}},
				EMPLOYEE_2_TEAM : {
					Name : "Team #1",
					Team_Id : "1"
				}
				// action advertisement
				// "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee" : {}
			})
			.expectChange("name", "Frederic Fall")
			.expectChange("city", "Walldorf");

		return this.createView(assert, sView, oModel).then(function () {
			assert.strictEqual(
				that.oView.byId("form").getBindingContext().getProperty("EMPLOYEE_2_TEAM/Name"),
				"Team #1");
		});
	});

	//*********************************************************************************************
	// Scenario: A context binding contains a $select with a navigation property which must be
	// converted to $expand, but this conversion is asynchronous.
	// BCP: 2070020773
	QUnit.test("ODCB: asynchronous $select to $expand", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{path : \'/Equipments(Category=\\\'C\\\',ID=1)\',\
		parameters : {$select : \'EQUIPMENT_2_PRODUCT/SupplierIdentifier\'}}">\
	<Text id="id" text="{ID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Equipments(Category='C',ID=1)?$select=Category,ID"
				+ "&$expand=EQUIPMENT_2_PRODUCT($select=ID,SupplierIdentifier)", {
				Category : "C",
				ID : 1, // Edm.Int32
				EQUIPMENT_2_PRODUCT : {
					ID : 1010, // Edm.Int32
					SupplierIdentifier : 42 // Edm.Int32
				}
			})
			.expectChange("id", "1");

		return this.createView(assert, sView, oModel).then(function () {
			assert.strictEqual(
				that.oView.byId("form").getBindingContext()
					.getProperty("EQUIPMENT_2_PRODUCT/SupplierIdentifier"),
				42);
		});
	});

	//*********************************************************************************************
	// Scenario: A list binding contains a dynamic filter and a $select with a navigation property
	// which must be converted to $expand. (The scenario from the incident.)
	// BCP: 2070020773
	QUnit.test("ODLB: dynamic filter and $select to $expand", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\',\
		parameters : {$select : \'EMPLOYEE_2_TEAM/Name\'},\
		filters : {path : \'AGE\', operator : \'GT\', value1 : 42}}">\
	<Text text="{ID}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID&$expand=EMPLOYEE_2_TEAM($select=Name,Team_Id)"
				+ "&$filter=AGE gt 42&$skip=0&$top=100", {
				value : [{
					ID : "1",
					EMPLOYEE_2_TEAM : {
						Name : "Team #01",
						Team_Id : "01"
					}
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			assert.strictEqual(
				that.oView.byId("table").getItems()[0].getBindingContext()
					.getProperty("EMPLOYEE_2_TEAM/Name"),
				"Team #01");
		});
	});

	//*********************************************************************************************
	// Scenario: Enable autoExpandSelect mode for an ODataContextBinding with relative
	// ODataPropertyBindings. Refreshing the view is also working.
	// The SalesOrders application does not have such a scenario.
	QUnit.test("Auto-$expand/$select: Absolute ODCB, refresh", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{path : \'/EMPLOYEES(\\\'2\\\')\', parameters : {$select : \'AGE\'}}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')?$select=AGE,ID,Name", {Name : "Jonathan Smith"})
			.expectChange("name", "Jonathan Smith");

		return this.createView(
			assert, sView, this.createTeaBusiModel({autoExpandSelect : true})
		).then(function () {
			that.expectRequest("EMPLOYEES('2')?$select=AGE,ID,Name", {Name : "Jonathan Schmidt"})
				.expectChange("name", "Jonathan Schmidt");

			// code under test
			that.oView.byId("form").getObjectBinding().refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Enter an invalid value for worker-age for an ODataPropertyBinding and check that
	// ODatePropertyBinding.resetChanges() restores the value before.
	// The Types application does NOT have such a scenario.
	//*********************************************************************************************
	QUnit.test("reset invalid data state via property binding", function (assert) {
		return this.checkResetInvalidDataState(assert, function (oView) {
			return oView.byId("age").getBinding("text");
		});
	});

	//*********************************************************************************************
	// Scenario: Enter an invalid value for worker-age for an ODataPropertyBinding and check that
	// parent ODataContextBinding.resetChanges() restores the value before.
	// The Types application does have such a scenario (within the V4 view).
	//*********************************************************************************************
	QUnit.test("reset invalid data state via context binding", function (assert) {
		return this.checkResetInvalidDataState(assert, function (oView) {
			return oView.byId("form").getObjectBinding();
		});
	});

	//*********************************************************************************************
	// Scenario: Enter an invalid value for worker-age for an ODataPropertyBinding and check that
	// parent Context.resetChanges() restores the value before.
	//*********************************************************************************************
	QUnit.test("reset invalid data state via context", function (assert) {
		return this.checkResetInvalidDataState(assert, function (oView) {
			return oView.byId("form").getBindingContext();
		});
	});

	//*********************************************************************************************
	// Scenario: Enter an invalid value for worker-age for an ODataPropertyBinding and check that
	// ODataModel.resetChanges() restores the value before.
	// The Types application does have such a scenario (within the V4 view).
	//*********************************************************************************************
	QUnit.test("reset invalid data state via model", function (assert) {
		return this.checkResetInvalidDataState(assert, function (oView) {
			return oView.getModel();
		});
	});

	//*********************************************************************************************
	// Scenario: (7) Test whether an invalid data state is properly reset once #resetChanges for its
	// row context is called, other contexts remain unchanged.
	// JIRA: CPOUI5ODATAV4-1817
	QUnit.test("CPOUI5ODATAV4-1817: reset invalid data state via context", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Input id="age" value="{AGE}"/>\
</Table>',
			that = this;

		function setInvalidValue(oPropertyBinding) {
			var fnFormatter = oPropertyBinding.fnFormatter;

			delete oPropertyBinding.fnFormatter;
			assert.throws(function () {
				oPropertyBinding.setExternalValue("bad");
			});
			assert.ok(oPropertyBinding.getDataState().isControlDirty());
			oPropertyBinding.fnFormatter = fnFormatter;
		}

		this.expectRequest("EMPLOYEES?$select=AGE,ID&$skip=0&$top=100",
				{value : [{AGE : 24, ID : "0"}, {AGE : 42, ID : "1"}]})
			.expectChange("age", ["24", "42"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oTable = that.oView.byId("table"),
				oPropertyBinding0 = oTable.getItems()[0].getCells()[0].getBinding("value"),
				oPropertyBinding1 = oTable.getItems()[1].getCells()[0].getBinding("value");

			setInvalidValue(oPropertyBinding0);
			setInvalidValue(oPropertyBinding1);

			that.expectChange("age", ["24"]);

			// code under test
			oPropertyBinding0.getContext().resetChanges().then(function () {
					assert.notOk(oPropertyBinding0.getDataState().isControlDirty());
					assert.ok(oPropertyBinding1.getDataState().isControlDirty());
			});

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Metadata access to MANAGERS which is not loaded yet.
	QUnit.test("Metadata access to MANAGERS which is not loaded yet", function (assert) {
		var sView = '\
<Table id="table" items="{/MANAGERS}">\
	<Text id="item" text="{@sapui.name}"/>\
</Table>',
			oModel = this.createTeaBusiModel().getMetaModel();

		this.expectChange("item", "ID", "/MANAGERS/ID")
			.expectChange("item", "TEAM_ID", "/MANAGERS/TEAM_ID")
			.expectChange("item", "Manager_to_Team", "/MANAGERS/Manager_to_Team");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Metadata property access to product name. It should be updated via one change
	// event.
	// JIRA: CPOUI5UISERVICESV3-582
	QUnit.test("Metadata: Product name", function (assert) {
		var sView = '<Text id="product" text="{/Equipments/EQUIPMENT_2_PRODUCT/@sapui.name}"/>',
			oModel = this.createTeaBusiModel().getMetaModel();

		this.expectChange("product",
			"com.sap.gateway.default.iwbep.tea_busi_product.v0001.Product");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Metadata property access to product name. It should be updated via one change
	// event.
	// JIRA: CPOUI5UISERVICESV3-582
	QUnit.test("Metadata: Product name via form", function (assert) {
		var sView = '\
<FlexBox binding="{/Equipments/EQUIPMENT_2_PRODUCT/}">\
	<Text id="product" text="{@sapui.name}"/>\
</FlexBox>',
			oModel = this.createTeaBusiModel().getMetaModel();

		this.expectChange("product",
			"com.sap.gateway.default.iwbep.tea_busi_product.v0001.Product");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Metadata access to Managers which is not loaded yet. The binding is unresolved
	// initially and gets a context later. Then switch to Products (becoming asynchronous again).
	QUnit.test("Metadata: Manager -> Product", function (assert) {
		var oTable,
			sView = '\
<Table id="table" items="{}">\
	<Text id="item" text="{@sapui.name}"/>\
</Table>',
			oModel = this.createTeaBusiModel().getMetaModel(),
			that = this;

		this.expectChange("item", []);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectChange("item", "ID", "/MANAGERS/ID")
				.expectChange("item", "TEAM_ID", "/MANAGERS/TEAM_ID")
				.expectChange("item", "Manager_to_Team", "/MANAGERS/Manager_to_Team");

			oTable.setBindingContext(oModel.getContext("/MANAGERS"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("item", "ID", "/Equipments/EQUIPMENT_2_PRODUCT/ID")
				.expectChange("item", "Name", "/Equipments/EQUIPMENT_2_PRODUCT/Name")
				.expectChange("item", "SupplierIdentifier",
					"/Equipments/EQUIPMENT_2_PRODUCT/SupplierIdentifier")
				.expectChange("item", "ProductPicture",
					"/Equipments/EQUIPMENT_2_PRODUCT/ProductPicture")
				.expectChange("item", "PRODUCT_2_CATEGORY",
					"/Equipments/EQUIPMENT_2_PRODUCT/PRODUCT_2_CATEGORY")
				.expectChange("item", "PRODUCT_2_SUPPLIER",
					"/Equipments/EQUIPMENT_2_PRODUCT/PRODUCT_2_SUPPLIER");

			oTable.setBindingContext(oModel.getContext("/Equipments/EQUIPMENT_2_PRODUCT"));

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Avoid duplicate call to computed annotation (via global path)
	/** @deprecated as of version 1.120 */
	QUnit.test("Avoid duplicate call to computed annotation, global path", function (assert) {
		var oModel = this.createTeaBusiModel().getMetaModel(),
			sView = '\
<Text id="text"\
	text="{/MANAGERS/TEAM_ID@@sap.ui.model.odata.v4.AnnotationHelper.getValueListType}"/>';

		this.mock(AnnotationHelper).expects("getValueListType").returns("foo");
		this.expectChange("text", "foo");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Avoid duplicate call to computed annotation via core:require (simple binding
	// syntax)
	// JIRA: CPOUI5ODATAV4-2398
	QUnit.test("Avoid duplicate call to computed annotation, core:require", function (assert) {
		const oModel = this.createTeaBusiModel().getMetaModel();
		const sView = ` core:require="{AH : 'sap/ui/model/odata/v4/AnnotationHelper'}">
<Text id="text" text="{/MANAGERS/TEAM_ID@@AH.getValueListType}"/>`;

		this.mock(AnnotationHelper).expects("getValueListType").returns("foo");
		this.expectChange("text", "foo");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Avoid duplicate call to computed annotation via model and core:require (complex
	// binding syntax). Now ODataPropertyBinding must get the scope from core:require and transfer
	// it to the meta model.
	// JIRA: CPOUI5ODATAV4-2398
	QUnit.test("Avoid duplicate call to computed annotation from model", function (assert) {
		const sView = ` core:require="{AH : 'sap/ui/model/odata/v4/AnnotationHelper'}">
<Text id="text" text="{path : '/MANAGERS(\\'1\\')TEAM_ID/Name##@@AH.getValueListType'}"/>`;

		this.mock(AnnotationHelper).expects("getValueListType").returns("foo");
		this.expectChange("text", "foo");

		return this.createView(assert, sView);
	});

	//*********************************************************************************************
	// Scenario: The same simple binding syntax with named model and a computed annotation is used
	// twice in an expression binding with scope via core:require. It must be computed only once.
	// JIRA: CPOUI5ODATAV4-2398
	QUnit.test("Computed annotation in expression binding", async function (assert) {
		const sView = ` core:require="{AH : 'sap/ui/model/odata/v4/AnnotationHelper'}">
<Text id="text" text="{= \${meta>/MANAGERS/TEAM_ID@@AH.getValueListType}
	+ \${meta>/MANAGERS/TEAM_ID@@AH.getValueListType} }"/>`;

		this.expectChange("text");

		await this.createView(assert, sView);

		this.mock(AnnotationHelper).expects("getValueListType").returns("foo");
		this.expectChange("text", "foofoo");

		this.oView.setModel(this.oModel.getMetaModel(), "meta");

		await this.waitForChanges(assert);
	});

	//*********************************************************************************************
	// Scenario: Computed annotation via ODMM#requestObject with scope
	// JIRA: CPOUI5ODATAV4-2398
	QUnit.test("Computed annotation via ODMM#requestObject with scope", async function (assert) {
		const oModel = this.createTeaBusiModel().getMetaModel();

		await this.createView(assert, "", oModel);

		this.mock(AnnotationHelper).expects("getValueListType").returns("foo");

		const sResult = await oModel.requestObject("/MANAGERS/TEAM_ID@@AH.getValueListType",
			undefined, {scope : {AH : AnnotationHelper}}
		);
		assert.strictEqual(sResult, "foo");
	});

	//*********************************************************************************************
	// Scenario: Enable autoExpandSelect mode for an ODataContextBinding with relative
	// ODataPropertyBindings where the paths of the relative bindings lead to a $expand
	// The SalesOrders application does not have such a scenario.
	QUnit.test("Auto-$expand/$select: Absolute ODCB with relative ODPB, $expand required",
			function (assert) {
		var sView = '\
<FlexBox id="form" binding="{path : \'/EMPLOYEES(\\\'2\\\')\',\
			parameters : {\
				$expand : {\
					EMPLOYEE_2_TEAM : {$select : \'Team_Id\'}\
				},\
				$select : \'AGE\'\
			}\
		}">\
	<Text id="name" text="{EMPLOYEE_2_TEAM/Name}"/>\
	<Text id="TEAM_ID" text="{EMPLOYEE_2_TEAM/TEAM_2_MANAGER/TEAM_ID}"/>\
</FlexBox>';

		this.expectRequest("EMPLOYEES('2')?$expand=EMPLOYEE_2_TEAM($select=Name,Team_Id"
				+ ";$expand=TEAM_2_MANAGER($select=ID,TEAM_ID))&$select=AGE,ID", {
				AGE : 32,
				EMPLOYEE_2_TEAM : {
					Name : "SAP NetWeaver Gateway Content",
					Team_Id : "TEAM_03",
					TEAM_2_MANAGER : {TEAM_ID : "TEAM_03"}
				}
			})
			.expectChange("name", "SAP NetWeaver Gateway Content")
			.expectChange("TEAM_ID", "TEAM_03");

		return this.createView(assert, sView, this.createTeaBusiModel({autoExpandSelect : true}));
	});

	//*********************************************************************************************
	// Scenario: Enable autoExpandSelect mode for dependent ODataContextBindings. The inner
	// ODataContextBinding can use its parent binding's cache => it creates no own request.
	QUnit.test("Auto-$expand/$select: Dependent ODCB",
			function (assert) {
		var sView = '\
<FlexBox binding="{path : \'/EMPLOYEES(\\\'2\\\')\',\
			parameters : {\
				$expand : {\
					EMPLOYEE_2_MANAGER : {$select : \'ID\'}\
				},\
				$select : \'AGE\'\
			}\
		}">\
	<FlexBox binding="{EMPLOYEE_2_TEAM}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="name" text="{Name}"/>\
	</FlexBox>\
</FlexBox>';

		this.expectRequest("EMPLOYEES('2')?$expand=EMPLOYEE_2_MANAGER"
				+ "($select=ID),EMPLOYEE_2_TEAM($select=Name,Team_Id)&$select=AGE,ID", {
				AGE : 32,
				EMPLOYEE_2_MANAGER : {ID : "2"},
				EMPLOYEE_2_TEAM : {Name : "SAP NetWeaver Gateway Content"}
			})
			.expectChange("name", "SAP NetWeaver Gateway Content");

		return this.createView(assert, sView, this.createTeaBusiModel({autoExpandSelect : true}));
	});

	//*********************************************************************************************
	// Scenario: create an entity on a relative binding without an own cache and check that
	// hasPendingChanges is working
	// None of our applications has such a scenario.
	QUnit.test("Create on a relative binding; check hasPendingChanges()", function (assert) {
		var oTeam2EmployeesBinding,
			oTeamBinding,
			that = this;

		return this.prepareTestForCreateOnRelativeBinding(assert).then(function () {
			oTeam2EmployeesBinding = that.oView.byId("table").getBinding("items");
			oTeamBinding = that.oView.byId("form").getObjectBinding();
			// insert new employee at first row
			that.expectChange("id", ["", "2"])
				.expectChange("text", ["John Doe", "Frederic Fall"]);
			oTeam2EmployeesBinding.create({ID : null, Name : "John Doe"});

			// code under test
			assert.ok(oTeam2EmployeesBinding.hasPendingChanges(), "pending changes; new entity");
			assert.ok(oTeam2EmployeesBinding.hasPendingChanges(true), "JIRA: CPOUI5ODATAV4-1409");
			assert.ok(oTeamBinding.hasPendingChanges(), "pending changes; new entity");
			assert.ok(oTeamBinding.hasPendingChanges(true), "JIRA: CPOUI5ODATAV4-1409");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "TEAMS('42')/TEAM_2_EMPLOYEES",
					payload : {
						ID : null,
						Name : "John Doe"
					}
				}, {
					ID : "7",
					Name : "John Doe"
				})
				.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES('7')?$select=ID,Name", {
					ID : "7",
					Name : "The real John Doe"
				})
				.expectChange("id", ["7"])
				.expectChange("text", ["The real John Doe"]);

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// code under test
			assert.notOk(oTeam2EmployeesBinding.hasPendingChanges(), "no more pending changes");
			assert.notOk(oTeamBinding.hasPendingChanges(), "no more pending changes");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: create an entity on a relative binding without an own cache and reset changes or
	// delete the newly created entity again
	// None of our applications has such a scenario.
	[true, false].forEach(function (bUseReset) {
		var sTitle = "Create on a relative binding; " + (bUseReset ? "resetChanges()" : "delete");

		QUnit.test(sTitle, function (assert) {
			var oNewContext,
				oTeam2EmployeesBinding,
				oTeamBinding,
				that = this;

			return this.prepareTestForCreateOnRelativeBinding(assert).then(function () {
				oTeam2EmployeesBinding = that.oView.byId("table").getBinding("items");
				oTeamBinding = that.oView.byId("form").getObjectBinding();

				that.expectChange("id", ["", "2"])
					.expectChange("text", ["John Doe", "Frederic Fall"]);

				oNewContext = oTeam2EmployeesBinding.create({ID : null, Name : "John Doe"});
				oNewContext.created().then(mustFail(assert), function (oError) {
					assert.ok(true, oError); // promise rejected because request is canceled below
				});
				assert.ok(oTeam2EmployeesBinding.hasPendingChanges(),
					"binding has pending changes");
				assert.ok(oTeam2EmployeesBinding.hasPendingChanges(true),
					"JIRA: CPOUI5ODATAV4-1409");
				assert.ok(oTeamBinding.hasPendingChanges(), "parent has pending changes");
				assert.ok(oTeamBinding.hasPendingChanges(true), "JIRA: CPOUI5ODATAV4-1409");

				return that.waitForChanges(assert);
			}).then(function () {
				var oPromise;

				that.expectChange("id", ["2"])
					.expectChange("text", ["Frederic Fall"]);

				// code under test
				oPromise = bUseReset
					? oTeam2EmployeesBinding.resetChanges()
					: oNewContext.delete();

				assert.notOk(oTeam2EmployeesBinding.hasPendingChanges(), "no pending changes");
				assert.notOk(oTeamBinding.hasPendingChanges(), "parent has no pending changes");

				return Promise.all([
					oPromise,
					checkCanceled(assert, oNewContext.created()),
					that.waitForChanges(assert)
				]);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: bound action (success and failure)
	// JIRA: CPOUI5ODATAV4-29 (bound action parameter and error with message target)
	// JIRA: CPOUI5ODATAV4-132 (bind property of binding parameter relative to $Parameter)
	// No "sap-cancel-on-close" header in POST request (JIRA: CPOUI5ODATAV4-2506)
	QUnit.test("Bound action", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true, groupId : "$direct"}),
			sView = '\
<FlexBox id="form" binding="{/EMPLOYEES(\'1\')}">\
	<Text id="name" text="{Name}"/>\
	<Input id="status" value="{STATUS}"/>\
</FlexBox>\
<FlexBox id="action" \
		binding="{com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee(...)}">\
	<Text id="parameterName" text="{$Parameter/EMPLOYEE/Name}"/>\
	<Text id="parameterAge" text="{$Parameter/EMPLOYEE/AGE}"/>\
	<Input id="parameterTeamId" value="{$Parameter/TeamID}"/>\
	<Text id="teamId" text="{TEAM_ID}"/>\
</FlexBox>',
			sUrl = "EMPLOYEES('1')/com.sap.gateway.default.iwbep.tea_busi.v0001"
				+ ".AcChangeTeamOfEmployee",
			that = this;

		this.expectRequest("EMPLOYEES('1')?$select=ID,Name,STATUS", {
				ID : "1",
				Name : "Jonathan Smith",
				STATUS : "",
				"@odata.etag" : "ETag"
			})
			.expectChange("name", "Jonathan Smith")
			.expectChange("status", "")
			.expectChange("parameterAge")
			.expectChange("parameterName")
			.expectChange("parameterTeamId")
			.expectChange("teamId");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("EMPLOYEES('1')?$select=AGE", {
					AGE : 23,
					"@odata.etag" : "ETag"
				})
				.expectChange("parameterName", "Jonathan Smith")
				.expectChange("parameterTeamId", "")
				.expectChange("parameterAge", "23")
				.expectChange("teamId", null); // initialization due to #setContext

			that.oView.byId("action").setBindingContext(
				that.oView.byId("form").getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("parameterTeamId", "42");

			that.oView.byId("parameterTeamId").getBinding("value").setValue("42");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					headers : {"If-Match" : "ETag"/*, NO "sap-cancel-on-close"*/},
					url : sUrl,
					payload : {TeamID : "42"}
				}, {TEAM_ID : "42"})
				.expectChange("teamId", "42");

			return Promise.all([
				that.oView.byId("action").getObjectBinding().invoke()
					.then(function (oReturnValueContext) {
						assert.strictEqual(oReturnValueContext, undefined,
							"no R.V.C. w/o key predicate");
					}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oError = createError({
					message : "Missing team ID",
					target : "TeamID", // error targeting a parameter
					details : [{
						message : "Illegal Status",
						"@Common.numericSeverity" : 4,
						target : "EMPLOYEE/STATUS" // error targeting part of binding parameter
					}, {
						message : "Target resolved to ''",
						"@Common.numericSeverity" : 4,
						target : "EMPLOYEE" // error targeting the complete binding parameter
					}, {
						message : "Unexpected Error w/o target",
						"@Common.numericSeverity" : 4
					}]
				});

			that.oLogMock.expects("error").withExactArgs("Failed to invoke /" + sUrl + "(...)",
				sinon.match(oError.message), sODCB);
			that.oLogMock.expects("error").withExactArgs(//TODO: prevent log -> CPOUI5ODATAV4-127
				"Failed to read path /" + sUrl + "(...)/TEAM_ID", sinon.match(oError.message),
				sODPrB);
			that.expectRequest({
					method : "POST",
					headers : {"If-Match" : "ETag"/*, NO "sap-cancel-on-close"*/},
					url : sUrl,
					payload : {TeamID : ""}
				}, oError) // simulates failure
				.expectMessages([{
					code : "CODE",
					message : "Missing team ID",
					persistent : true,
					target : "/EMPLOYEES('1')/com.sap.gateway.default.iwbep.tea_busi.v0001"
						+ ".AcChangeTeamOfEmployee(...)/$Parameter/TeamID",
					technical : true,
					type : "Error"
				}, {
					message : "Illegal Status",
					persistent : true,
					target : "/EMPLOYEES('1')/STATUS",
					type : "Error"
				}, {
					message : "Target resolved to ''",
					persistent : true,
					// Note: checkValueState not possible for whole entity, but it is nice to know
					// how this target : "EMPLOYEE" is meant to be handled
					target : "/EMPLOYEES('1')",
					type : "Error"
				}, {
					message : "Unexpected Error w/o target",
					persistent : true,
					type : "Error"
				}])
				.expectChange("parameterTeamId", "")
				.expectChange("teamId", null); // reset to initial state

			return Promise.all([
				that.oView.byId("action").getObjectBinding().setParameter("TeamID", "").invoke()
					.then(mustFail(assert), function (oError0) {
						assert.strictEqual(oError0, oError);
					}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return Promise.all([
				that.checkValueState(assert, "status", "Error", "Illegal Status"),
				that.checkValueState(assert, "parameterTeamId", "Error", "Missing team ID")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Call an overloaded bound function to get defaults (CPOUI5UISERVICESV3-1873)
	// then call a bound action on a collection and check that return value context has right path
	// and messages are reported as expected. Refreshing the return value context updates also
	// messages properly. (CPOUI5UISERVICESV3-1674)
	// Return value context can be used with v4.Context#setProperty (CPOUI5UISERVICESV3-1874).
	QUnit.test("Bound action on collection", function (assert) {
		var oHeaderContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oReturnValueContext,
			sView = '\
<Table id="table" items="{path : \'/Artists\', parameters : {$select : \'Messages\'}}">\
	<Text id="name" text="{Name}"/>\
</Table>\
<Input id="nameCreated" value="{Name}"/>',
			that = this;

		this.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Messages,Name&$skip=0&$top=100",
			{
				value : [{
					"@odata.etag" : "ETag",
					ArtistID : "XYZ",
					IsActiveEntity : true,
					Messages : [],
					Name : "Missy Eliot"
				}]
			})
			.expectChange("name", ["Missy Eliot"])
			.expectChange("nameCreated");

		return this.createView(assert, sView, oModel).then(function () {
			oHeaderContext = that.oView.byId("table").getBinding("items").getHeaderContext();
			that.expectRequest("Artists/special.cases.GetDefaults()", {
					ArtistID : "ABC",
					IsActiveEntity : false,
					Name : "DefaultName"
				});

			return Promise.all([
				// code under test
				that.oModel.bindContext("special.cases.GetDefaults(...)", oHeaderContext).invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			var oAction,
				oDefaults = aResults[0];

			that.expectRequest({
					method : "POST",
					url : "Artists/special.cases.Create"
						+ "?$select=ArtistID,IsActiveEntity,Messages,Name",
					payload : {
						ArtistID : "ABC",
						IsActiveEntity : false,
						Name : "DefaultName"
					}
				}, {
					"@odata.etag" : "ETagAfterCreate",
					ArtistID : "ABC",
					IsActiveEntity : false,
					Messages : [{
						code : "23",
						message : "Just A Message",
						numericSeverity : 1,
						target : "Name",
						transition : false
					}],
					Name : "Queen"
				})
				.expectMessages([{
					code : "23",
					message : "Just A Message",
					target : "/Artists(ArtistID='ABC',IsActiveEntity=false)/Name",
					type : "Success"
				}]);

			oAction = that.oModel.bindContext("special.cases.Create(...)", oHeaderContext,
					{$$inheritExpandSelect : true})
				.setParameter("ArtistID", oDefaults.getObject("ArtistID"))
				.setParameter("IsActiveEntity", oDefaults.getObject("IsActiveEntity"))
				.setParameter("Name", oDefaults.getObject("Name"));

			return Promise.all([
				oAction.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aPromiseResults) {
			oReturnValueContext = aPromiseResults[0];

			that.expectChange("nameCreated", "Queen");

			that.oView.byId("nameCreated").setBindingContext(oReturnValueContext);

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, "nameCreated", "Success", "Just A Message");
		}).then(function () {
			var sResourcePath = "Artists(ArtistID='ABC',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Messages,Name",
				sErrorMessage = "sap.ui.model.odata.v4.ODataContextBinding:"
					+ " /Artists|special.cases.Create(...)"
					+ " is ignoring response from inactive cache: /special/cases/"
					+ sResourcePath;

			that.expectRequest(sResourcePath, {
					// CPOUI5ODATAV4-980: this response is ignored anyway
					ArtistID : "ABC",
					IsActiveEntity : false,
					Name : "n/a"
				})
				// Note: this is caused by "nameCreated" via R.V.C., path is a bit misleading
				.expectCanceledError("Failed to read path /Artists/special.cases.Create(...)",
					sErrorMessage)
				.expectCanceledError("Failed to read path"
					+ " /Artists(ArtistID='ABC',IsActiveEntity=false)/Name", sErrorMessage)
				.expectRequest(sResourcePath, {
					"@odata.etag" : "ETagAfterRefresh",
					ArtistID : "ABC",
					IsActiveEntity : false,
					Messages : [{
						code : "23",
						message : "Just Another Message",
						numericSeverity : 1,
						target : "Name",
						transition : false
					}],
					Name : "After Refresh"
				})
				.expectChange("nameCreated", "After Refresh")
				// Note: this proves that "Just A Message" is gone
				.expectMessages([{
					code : "23",
					message : "Just Another Message",
					target : "/Artists(ArtistID='ABC',IsActiveEntity=false)/Name",
					type : "Success"
				}]);

			return Promise.all([
				oReturnValueContext.requestRefresh(), // will be canceled, must not fail
				oReturnValueContext.requestRefresh(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "nameCreated", "Success", "Just Another Message");
		}).then(function () {
			that.expectChange("nameCreated", "TAFKAP")
				.expectRequest({
					headers : {"If-Match" : "ETagAfterRefresh"},
					method : "PATCH",
					payload : {Name : "TAFKAP"},
					url : "Artists(ArtistID='ABC',IsActiveEntity=false)"
				}, {
					// "@odata.etag" : "ETagAfterPatch",
					ArtistID : "ABC",
					IsActiveEntity : false,
					Messages : [{
						code : "CODE",
						message : "What a nice acronym!",
						numericSeverity : 1,
						target : "Name",
						transition : false
					}],
					Name : "T.A.F.K.A.P."
				})
				.expectChange("nameCreated", "T.A.F.K.A.P.")
				.expectMessages([{
					code : "CODE",
					message : "What a nice acronym!",
					target : "/Artists(ArtistID='ABC',IsActiveEntity=false)/Name",
					type : "Success"
				}]);

			return Promise.all([
				// code under test
				oReturnValueContext.setProperty("Name", "TAFKAP"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "nameCreated", "Success", "What a nice acronym!");
		});
	});

	//*********************************************************************************************
	// Scenario: Call bound action on a context of a relative ListBinding.
	//
	// Ensure that no Return Value Context is created, because the back end does not return the
	// needed key properties.
	// SNOW: DINC0010118
[{ID : "2"}, {EMPLOYEE_2_TEAM : {Team_Id : "TEAM_02"}}].forEach(function (oPredicates, i) {
	var sTitle = "Read entity for a relative ListBinding, call bound action, key for the "
		+ (i ? "first" : "second") + " segment is missing";

	QUnit.test(sTitle, function (assert) {
		var that = this,
			sView = '\
<FlexBox id="form" binding="{path : \'/TEAMS(\\\'42\\\')\',\
	parameters : {\
		$expand : {TEAM_2_EMPLOYEES : {$select : \'ID,__CT__FAKE__Message/__FAKE__Messages\'}}}}">\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Text id="id" text="{ID}"/>\
	</Table>\
</FlexBox>';

		this.expectRequest("TEAMS('42')"
			+ "?$expand=TEAM_2_EMPLOYEES($select=ID,__CT__FAKE__Message/__FAKE__Messages)", {
				TEAM_2_EMPLOYEES : [{ID : "2"}]
			})
			.expectChange("id", ["2"]);

		return this.createView(assert, sView).then(function () {
			var oEmployeeContext = that.oView.byId("table").getItems()[0].getBindingContext(),
				sAction = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
				oAction = that.oModel.bindContext(sAction + "(...)",
					oEmployeeContext, {$$inheritExpandSelect : true}),
				oResponse = Object.assign({
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Text",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				}, oPredicates);

			that.expectRequest({
					method : "POST",
					url : "TEAMS('42')/TEAM_2_EMPLOYEES('2')/"
						+ "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee"
						+ "?$select=ID,__CT__FAKE__Message/__FAKE__Messages"
						+ "&$expand=EMPLOYEE_2_TEAM($select=Team_Id)",
					payload : {TeamID : "TEAM_02"}
				}, oResponse)
				.expectMessages([{
					code : "1",
					message : "Text",
					target : "/TEAMS('42')/TEAM_2_EMPLOYEES('2')/" + sAction + "(...)/Name",
					type : "Warning"
				}]);
			oAction.setParameter("TeamID", "TEAM_02");

			return Promise.all([
				// code under test
				oAction.invoke().then(function (oResult) {
					assert.strictEqual(oResult, undefined,
						"no R.V.C. because EMPLOYEE_2_TEAM is missing");
				}),
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Invoke a bound action for an entity in a list binding and afterwards call refresh
	// with bAllowRemoval=true for the context the entity is pointing to. If the entity is gone from
	// the list binding no error should happen because of the just deleted context.
	// TODO Test with a created binding parameter, too. This failed in an OPA test previously.
	QUnit.test("Bound action with context refresh which removes the context", function (assert) {
		var oAction,
			oContext,
			oInvocationPromise,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table"\
		items="{\
			path : \'/EMPLOYEES\',\
			filters : {path : \'TEAM_ID\', operator : \'EQ\', value1 : \'77\'},\
			parameters : {$count : true}\
		}">\
	<Text id="text" text="{Name}"/>\
	<Text id="teamId" text="{TEAM_ID}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$count=true&$filter=TEAM_ID eq '77'&$select=ID,Name,TEAM_ID"
				+ "&$skip=0&$top=100", {
				"@odata.count" : "3",
				value : [
					{ID : "0", Name : "Frederic Fall", TEAM_ID : "77"},
					{ID : "1", Name : "Jonathan Smith", TEAM_ID : "77"},
					{ID : "2", Name : "Peter Burke", TEAM_ID : "77"}
				]
			})
			.expectChange("text", ["Frederic Fall", "Jonathan Smith", "Peter Burke"])
			.expectChange("teamId", ["77", "77", "77"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "POST",
					url : "EMPLOYEES('0')/com.sap.gateway.default.iwbep.tea_busi.v0001"
						+ ".AcChangeTeamOfEmployee",
					payload : {TeamID : "42"}
				}, {TEAM_ID : "42"})
				.expectRequest("EMPLOYEES?$filter=(TEAM_ID eq '77') and ID eq '0'"
					+ "&$select=ID,Name,TEAM_ID", {value : []})
				.expectChange("text", ["Jonathan Smith", "Peter Burke"]);

			oContext = that.oView.byId("table").getItems()[0].getBindingContext();
			oAction = oModel.bindContext("com.sap.gateway.default.iwbep.tea_busi.v0001"
				+ ".AcChangeTeamOfEmployee(...)", oContext);

			// code under test
			oInvocationPromise = oAction.setParameter("TeamID", "42").invoke();

			return Promise.all([
				oContext.requestRefresh(undefined, true),
				oInvocationPromise.then(function (oReturnValueContext) {
					assert.strictEqual(oReturnValueContext, undefined,
						"no R.V.C. w/o key predicate");
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: overloaded bound action
	// Note: there are 3 binding types for __FAKE__AcOverload, but only Worker has Is_Manager
	//
	// If-Match:* is sent (JIRA: CPOUI5ODATAV4-869)
	// If-Match:* is not sent if there's no ETag (JIRA: CPOUI5ODATAV4-1067)
[false, true].forEach(function (bHasETag) {
	QUnit.test("Bound action w/ overloading, has ETag: " + bHasETag, function (assert) {
		var oEmployee = bHasETag
			? {
				Name : "Jonathan Smith",
				"@odata.etag" : "ETag"
			}
			: {Name : "Jonathan Smith"},
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'1\')}">\
	<Text id="name" text="{Name}"/>\
	<FlexBox id="action" \
			binding="{com.sap.gateway.default.iwbep.tea_busi.v0001.__FAKE__AcOverload(...)}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="isManager" text="{Is_Manager}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')", oEmployee)
			.expectChange("name", "Jonathan Smith")
			.expectChange("isManager", null);

		return this.createView(assert, sView).then(function () {
			that.expectRequest({
					method : "POST",
					headers : bHasETag ? {"If-Match" : "*"} : {},
					url : "EMPLOYEES('1')/com.sap.gateway.default.iwbep.tea_busi.v0001"
						+ ".__FAKE__AcOverload",
					payload : {Message : "The quick brown fox jumps over the lazy dog"}
				}, {Is_Manager : true})
				.expectChange("isManager", "Yes");

			return Promise.all([
				// code under test
				that.oView.byId("action").getObjectBinding()
					.setParameter("Message", "The quick brown fox jumps over the lazy dog")
					.invoke(undefined, true), // CPOUI5ODATAV4-869
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Enable autoExpandSelect on an operation
	QUnit.test("Auto-$expand/$select: Function import", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="function" binding="{/GetEmployeeByID(...)}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("name", null);
		return this.createView(assert, sView, oModel).then(function () {
			//TODO the query options for the function import are not enhanced
			// that.expectRequest("GetEmployeeByID(EmployeeID='1')?$select=ID,Name", {
			that.expectRequest("GetEmployeeByID(EmployeeID='1')", {
					ID : "1",
					Name : "Jonathan Smith"
				})
				.expectChange("name", "Jonathan Smith");

			return Promise.all([
				// code under test
				that.oView.byId("function").getObjectBinding()
					.setParameter("EmployeeID", "1")
					.invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Instance annotation in child path
	QUnit.test("Auto-$expand/$select: Instance annotation in child path", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'2\')}">\
	<Text id="ETag" text="{\
		path : \'@odata.etag\',\
		type : \'sap.ui.model.odata.type.String\'}"/>\
</FlexBox>';

		this.expectRequest("EMPLOYEES('2')?$select=ID", {
				"@odata.etag" : "ETagValue",
				ID : "2"
			})
			.expectChange("ETag", "ETagValue");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Enable autoExpandSelect mode for dependent ODataContextBindings. The inner
	// ODataContextBinding *cannot* use its parent binding's cache due to conflicting query options
	// => it creates an own cache and request.
	QUnit.test("Auto-$expand/$select: Dependent ODCB with own request", function (assert) {
		var sView = '\
<FlexBox binding="{path : \'/EMPLOYEES(\\\'2\\\')\',\
			parameters : {\
				$expand : {\
					EMPLOYEE_2_MANAGER : {$select : \'ID\'},\
					EMPLOYEE_2_TEAM : {\
						$expand : {\
							TEAM_2_EMPLOYEES : {\
								$orderby : \'AGE\'\
							}\
						}\
					}\
				}\
			}\
		}">\
	<FlexBox binding="{path : \'EMPLOYEE_2_TEAM\',\
				parameters : {\
					$expand : {\
						TEAM_2_EMPLOYEES : {\
							$orderby : \'AGE desc\'\
						}\
					}\
				}\
			}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="name" text="{Name}"/>\
	</FlexBox>\
	<Text id="age" text="{AGE}"/>\
</FlexBox>';

		this.expectRequest("EMPLOYEES('2')/EMPLOYEE_2_TEAM"
				+ "?$expand=TEAM_2_EMPLOYEES($orderby=AGE desc)&$select=Name,Team_Id", {
				Name : "SAP NetWeaver Gateway Content",
				TEAM_2_EMPLOYEES : [
					{AGE : 32},
					{AGE : 29}
				]
			})
			.expectRequest("EMPLOYEES('2')?$expand=EMPLOYEE_2_MANAGER($select=ID),"
				+ "EMPLOYEE_2_TEAM($expand=TEAM_2_EMPLOYEES($orderby=AGE))&$select=AGE,ID", {
				AGE : 32,
				EMPLOYEE_2_MANAGER : {ID : "2"},
				EMPLOYEE_2_TEAM : {
					TEAM_2_EMPLOYEES : [
						{AGE : 29},
						{AGE : 32}
					]
				}
			})
			.expectChange("name", "SAP NetWeaver Gateway Content")
			.expectChange("age", "32");

		return this.createView(assert, sView, this.createTeaBusiModel({autoExpandSelect : true}));
	});

	//*********************************************************************************************
	// Scenario: Auto-$expand/$select: Absolute ODataListBinding considers $filter set via API,
	// i.e. it changes the initially aggregated query options. Note: It is also possible to remove
	// a filter which must lead to removal of the $filter option.
	//
	// Call ODLB#filter with the same Filter as before. this should not invoke a request.
	// CPOUI5ODATAV4-942
	QUnit.test("Absolute ODLB with auto-$expand/$select: filter via API", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oListBinding,
			sView = '\
<Table id="table"\
		items="{\
			path : \'/EMPLOYEES\',\
			filters : {path : \'AGE\', operator : \'LT\', value1 : \'77\'},\
			parameters : {$orderby : \'Name\', $select : \'AGE\'}\
		}">\
	<Text id="text" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$orderby=Name&$select=AGE,ID,Name&$filter=AGE lt 77"
				+ "&$skip=0&$top=100", {
				value : [
					{Name : "Frederic Fall"},
					{Name : "Jonathan Smith"},
					{Name : "Peter Burke"}
				]
			})
			.expectChange("text", ["Frederic Fall", "Jonathan Smith", "Peter Burke"]);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("EMPLOYEES?$orderby=Name&$select=AGE,ID,Name"
					+ "&$filter=AGE gt 42&$skip=0&$top=100", {
					value : [
						{Name : "Frederic Fall"},
						{Name : "Peter Burke"}
					]
				})
				.expectChange("text", [, "Peter Burke"]);

			// code under test
			oListBinding.filter(new Filter("AGE", FilterOperator.GT, 42));
			oListBinding.filter(new Filter("AGE", FilterOperator.GT, 42));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("EMPLOYEES?$orderby=Name&$select=AGE,ID,Name&$skip=0&$top=100", {
					value : [
						{Name : "Frederic Fall"},
						{Name : "Jonathan Smith"},
						{Name : "Peter Burke"}
					]
				})
				.expectChange("text", [, "Jonathan Smith", "Peter Burke"]);

			// code under test
			oListBinding.filter(/*no filter*/);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Auto-$expand/$select: Relative ODataListBinding considers $filter set via API, i.e.
	// it changes the initially aggregated query options and creates a separate cache/request.
	//
	// P.S.: Sync data access is possible although oCachePromise becomes pending again.
	// JIRA: CPOUI5ODATAV4-204
	QUnit.test("ODLB with auto-$expand/$select below ODCB: filter via API", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/TEAMS(\'2\')}">\
	<Table id="table" items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$orderby : \'Name\'}}">\
		<Text id="text" text="{Name}"/>\
	</Table>\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('2')?$select=Name,Team_Id"
				+ "&$expand=TEAM_2_EMPLOYEES($orderby=Name;$select=ID,Name)", {
				Name : "Team 2",
				Team_Id : "2",
				TEAM_2_EMPLOYEES : [
					{Name : "Frederic Fall"},
					{Name : "Jonathan Smith"},
					{Name : "Peter Burke"}
				]
			})
			.expectChange("name", "Team 2")
			.expectChange("text", ["Frederic Fall", "Jonathan Smith", "Peter Burke"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oListBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("TEAMS('2')/TEAM_2_EMPLOYEES?$orderby=Name&$select=ID,Name"
					+ "&$filter=AGE gt 42&$skip=0&$top=100", {
					value : [
						{Name : "Frederic Fall"},
						{Name : "Peter Burke"}
					]
				})
				.expectChange("text", [, "Peter Burke"]);

			// code under test
			oListBinding.filter(new Filter("AGE", FilterOperator.GT, 42));

			// code under test: sync data access...
			assert.strictEqual(oListBinding.getContext().getProperty("Team_Id"), "2");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: child binding has $apply and would need $expand therefore it cannot use its
	// parent binding's cache
	testViewStart("Auto-$expand/$select: no $apply inside $expand", '\
<FlexBox binding="{/TEAMS(\'42\')}">\
	<Table items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$apply : \'filter(AGE lt 42)\'}}">\
		<Text id="text" text="{Name}"/>\
	</Table>\
</FlexBox>', {
		"TEAMS('42')/TEAM_2_EMPLOYEES?$apply=filter(AGE lt 42)&$select=ID,Name&$skip=0&$top=100" : {
			value : [
				{Name : "Frederic Fall"},
				{Name : "Peter Burke"}
			]
		}
	}, {text : ["Frederic Fall", "Peter Burke"]}, function () {
		return this.createTeaBusiModel({autoExpandSelect : true});
	});

	//*********************************************************************************************
	// Scenario: child binding cannot use its parent list binding's cache (for whatever reason)
	// but must not compute the canonical path for the virtual context
	QUnit.test("Auto-$expand/$select: no canonical path for virtual context", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table items="{/TEAMS}">\
	<List items="{path : \'TEAM_2_EMPLOYEES\',\
		parameters : {$apply : \'filter(AGE lt 42)\'}, templateShareable : false}">\
		<CustomListItem>\
			<Text id="text" text="{Name}"/>\
		</CustomListItem>\
	</List>\
</Table>';

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=100", {
				value : [{Team_Id : "TEAM_01"}]
			})
			.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$apply=filter(AGE lt 42)"
				+ "&$select=ID,Name&$skip=0&$top=100", {
				value : [
					{Name : "Frederic Fall"},
					{Name : "Peter Burke"}
				]
			})
			.expectChange("text", ["Frederic Fall", "Peter Burke"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: list/detail where the detail does not need additional $expand/$select and thus
	// should reuse its parent's cache
	QUnit.test("Auto-$expand/$select: simple list/detail", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="list" items="{/TEAMS}">\
	<Text id="text0" text="{Team_Id}"/>\
</Table>\
<FlexBox id="detail" binding="{}">\
	<Text id="text1" text="{Team_Id}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=100", {
				value : [{Team_Id : "TEAM_01"}]
			})
			.expectChange("text0", ["TEAM_01"])
			.expectChange("text1"); // expect a later change

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("list").getItems()[0].getBindingContext();

			that.expectChange("text1", "TEAM_01");

			that.oView.byId("detail").setBindingContext(oContext);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: list/detail where the detail needs additional $expand/$select and thus causes
	// late property requests
	// JIRA: CPOUI5ODATAV4-27 see that two late property requests are merged
	//
	// Afterwards set an invalid value in the input field for the budget currency. Expect messages
	// on the UI and an invalid data state. When changing the binding context of the form the
	// invalid value shall be removed and the model value shall be visible (esp. also if this value
	// is the previous binding value).
	// JIRA: CPOUI5ODATAV4-459
	//
	// Afterwards, refresh the list and see that no late properties from the context binding are
	// requested for all rows.
	// JIRA: CPOUI5ODATAV4-544
	//
	// Ensure that $expand/$select at the detail page's context binding are included into the late
	// property request when the detail page is bound and when the list is refreshed (even if the
	// refresh is done within suspend/resume).
	// BCP: 2270178472
[false, true].forEach(function (bRefreshSuspended) {
	var sTitle = "Auto-$expand/$select: list/detail with separate requests,"
			+ " bRefreshSuspended=" + bRefreshSuspended;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="list" items="{/TEAMS}">\
	<Text id="currency" text="{BudgetCurrency}"/>\
	<Text id="id" text="{Team_Id}"/>\
</Table>\
<FlexBox id="detail" binding="{path : \'\', \
		parameters : {\
			$select : \'MANAGER_ID\',\
			$expand : {TEAM_2_MANAGER : {$select : \'TEAM_ID\'}}\
		}}">\
	<Text id="name" text="{Name}"/>\
	<Text id="budget" text="{Budget}"/>\
	<Input id="budgetCurrency" value="{BudgetCurrency}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS?$select=BudgetCurrency,Team_Id&$skip=0&$top=100", {
				value : [
					{BudgetCurrency : "EUR", Team_Id : "TEAM_01"},
					{BudgetCurrency : "EUR", Team_Id : "TEAM_02"}
				]
			})
			.expectChange("currency", ["EUR", "EUR"])
			.expectChange("id", ["TEAM_01", "TEAM_02"])
			.expectChange("name") // expect a later change
			.expectChange("budget");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext;

			oTable = that.oView.byId("list");
			oContext = oTable.getItems()[0].getBindingContext();

			// 'Budget' and 'Name' are added to the table row
			that.expectRequest("TEAMS('TEAM_01')?$select=Budget,MANAGER_ID,Name"
					+ "&$expand=TEAM_2_MANAGER($select=ID,TEAM_ID)", {
					Budget : "456",
					MANAGER_ID : "Manager_01",
					Name : "Team #1",
					TEAM_2_MANAGER : {MANAGER_ID : "Manager_01", TEAM_ID : "Team_01"}
				})
				.expectChange("name", "Team #1")
				.expectChange("budget", "456");

			that.oView.byId("detail").setBindingContext(oContext);

			return that.waitForChanges(assert);
		}).then(function () {
			// JIRA: CPOUI5ODATAV4-459
			return that.setInvalidBudgetCurrency(assert);
		}).then(function () {
			that.expectRequest("TEAMS('TEAM_02')?$select=Budget,MANAGER_ID,Name"
					+ "&$expand=TEAM_2_MANAGER($select=ID,TEAM_ID)", {
					Budget : "789",
					MANAGER_ID : "Manager_02",
					Name : "Team #2",
					TEAM_2_MANAGER : {MANAGER_ID : "Manager_02", TEAM_ID : "Team_02"}
				})
				.expectChange("name", "Team #2")
				.expectChange("budget", "789");

			that.expectMessages([]); // validation error has gone

			// 2. Change the context of the control but let the data be same as the binding value
			that.oView.byId("detail").setBindingContext(oTable.getItems()[1].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(that.oView.byId("budgetCurrency").getValue(), "EUR");

			return that.checkValueState(assert, "budgetCurrency", "None", "");
		}).then(function () {
			var oBinding = oTable.getBinding("items"),
				oRefreshPromise;

			that.expectRequest("TEAMS?$select=BudgetCurrency,Team_Id&$skip=0&$top=100", {
					value : [
						{BudgetCurrency : "UAH", Team_Id : "TEAM_01"},
						{BudgetCurrency : "UAH", Team_Id : "TEAM_02"}
					]
				})
				.expectChange("currency", ["UAH", "UAH"])
				.expectRequest("TEAMS('TEAM_02')?$select=Budget,MANAGER_ID,Name"
					+ "&$expand=TEAM_2_MANAGER($select=ID,TEAM_ID)", {
					Budget : "123",
					MANAGER_ID : "Manager_02",
					Name : "Nftgz",
					TEAM_2_MANAGER : {MANAGER_ID : "Manager_02", TEAM_ID : "Team_02"}
				})
				.expectChange("name", "Nftgz")
				.expectChange("budget", "123");

			// code under test (JIRA: CPOUI5ODATAV4-544, BCP: 2270178472)
			if (bRefreshSuspended) {
				oBinding.suspend();
				oRefreshPromise = oBinding.requestRefresh();
				oBinding.resume();
			} else {
				oRefreshPromise = oBinding.requestRefresh();
			}
			return Promise.all([
				oRefreshPromise,
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: list/detail where the detail needs additional $expand/$select, but contains a
	// $expand with a collection-valued navigation property. The detail page cannot use the list
	// binding's cache.
	// BCP: 2270178472
	QUnit.test("Auto-$expand/$select: no cache sharing possible", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oRowContext,
			sView = '\
<Table id="list" items="{/TEAMS}">\
	<Text id="id" text="{Team_Id}"/>\
</Table>\
<FlexBox id="detail" binding="{path : \'\', \
		parameters : {\
			$expand : {TEAM_2_EMPLOYEES : {$select : \'ID,Name\'}}\
		}}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=100",
				{value : [{Team_Id : "TEAM_01"}]})
			.expectChange("id", ["TEAM_01"])
			.expectChange("name"); // expect a later change

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("TEAMS('TEAM_01')?$expand=TEAM_2_EMPLOYEES($select=ID,Name)"
					+ "&$select=Name,Team_Id", {
					Name : "Team #1",
					TEAM_2_EMPLOYEES : []
				})
				.expectChange("name", "Team #1");

			oRowContext = that.oView.byId("list").getItems()[0].getBindingContext();
			that.oView.byId("detail").setBindingContext(oRowContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.oLogMock.expects("error")
				.withArgs("Failed to drill-down into ('TEAM_01')/Name, invalid segment: Name");

			assert.strictEqual(oRowContext.getProperty("Name"), undefined,
				"'Name' not in the list's cache because the detail has its own");
		});
	});

	//*********************************************************************************************
	// Scenario: Enable autoExpandSelect mode for use with factory function to create a listBinding
	// BCP: 2280173776: Do not fail if E.C.D. with bDetectUpdates is active and a context is
	// created.
	QUnit.test("Auto-$expand/$select: use factory function", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<Table id="table" growing="true" growingThreshold="5" items="{\
		factory : \'.employeesListFactory\',\
		parameters : {\
			$select : \'AGE,ID\'\
		},\
		path : \'/EMPLOYEES\'\
	}">\
	<columns><Column/></columns>\
</Table>',
			that = this,

			oController = {
				employeesListFactory : function (sID, oContext) {
					var sAge,
						oListItem;

					sAge = oContext.getProperty("AGE");
					if (sAge > 30) {
						oListItem = new Text(sID, {text : "{AGE}"});
					} else {
						oListItem = new Text(sID, {text : "{ID}"});
					}
					that.setFormatter(assert, oListItem, "text", true);

					return new ColumnListItem({cells : [oListItem]});
				}
			};

		this.expectRequest("EMPLOYEES?$select=AGE,ID&$skip=0&$top=5", {
				value : [
					{AGE : 29, ID : "R2D2"},
					{AGE : 36, ID : "C3PO"}
				]
			})
			.expectChange("text", ["R2D2", "36"]);

		return this.createView(assert, sView, oModel, oController).then(function () {
			that.expectChange("text", ["42"]);

			that.oView.byId("table").getBinding("items").create({AGE : 42});

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh a form with an invalid value
	// JIRA: CPOUI5ODATAV4-459
	QUnit.test("CPOUI5ODATAV4-459: Context binding with invalid value", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/TEAMS(\'TEAM_01\')}">\
	<Text id="budget" text="{Budget}"/>\
	<Input id="budgetCurrency" value="{BudgetCurrency}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('TEAM_01')?$select=Budget,BudgetCurrency,Team_Id",
				{Budget : "456", BudgetCurrency : "EUR", Team_Id : "Team_01"})
			.expectChange("budget", "456");

		return this.createView(assert, sView, oModel).then(function () {
			return that.setInvalidBudgetCurrency(assert);
		}).then(function () {
			that.expectRequest("TEAMS('TEAM_01')?$select=Budget,BudgetCurrency,Team_Id",
					{Budget : "789", BudgetCurrency : "EUR", Team_Id : "Team_01"})
				.expectChange("budget", "789");

			that.expectMessages([]); // validation error has gone

			// code under test
			that.oView.byId("form").getObjectBinding().refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(that.oView.byId("budgetCurrency").getValue(), "EUR");

			return that.checkValueState(assert, "budgetCurrency", "None", "");
		});
	});

	//*********************************************************************************************
	// Scenario: An input field is bound to a transient context which is never persisted. It gets
	// an invalid value which is removed when the binding context is removed.
	// BCP: 2180177518
	QUnit.test("BCP: 2180177518", function (assert) {
		var oInput,
			oModel = this.createTeaBusiModel({updateGroupId : "doNotSubmit"}),
			oTransientContext,
			sView = '<Input id="budgetCurrency" value="{BudgetCurrency}"/>',
			that = this;

		function waitForChange(oBinding) {
			return new Promise(function (resolve) {
				oBinding.attachEventOnce("change", function () {
					resolve();
				});
			});
		}

		// Note: Because the invalid value has to be set via control, changes for that control
		// cannot be observed via expectChange

		return this.createView(assert, sView, oModel).then(function () {
			oInput = that.oView.byId("budgetCurrency");
			assert.strictEqual(oInput.getValue(), "");

			oTransientContext = oModel.bindList("/TEAMS").create();
			oInput.setBindingContext(oTransientContext);

			return waitForChange(oInput.getBinding("value")); // wait for auto-type detection
		}).then(function () {
			assert.strictEqual(oInput.getValue(), "");

			return that.setInvalidBudgetCurrency(assert, /*sModelBudgetCurrency*/null);
		}).then(function () {
			oInput.setBindingContext(null);

			// #checkUpdateInternal says "an unresolved binding only fires if it had a value before"
			// - and NULL also counts as a value here, only UNDEFINED doesn't!
			return waitForChange(oInput.getBinding("value"));
		}).then(function () {
			assert.strictEqual(oInput.getValue(), "");

			return that.checkValueState(assert, oInput, "None", "");
		});
	});

	//*********************************************************************************************
	// Scenario: trying to call submitBatch() synchronously after delete(), but there is no way...
	QUnit.test("submitBatch() after delete()", function (assert) {
		var sView = '\
<FlexBox binding="{/TEAMS(\'42\')}" id="form">\
	<Text id="text" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('42')", {
				Team_Id : "TEAM_01",
				Name : "Team #1"
			})
			.expectChange("text", "Team #1");

		return this.createView(assert, sView).then(function () {
			var oContext = that.oView.byId("form").getBindingContext(),
				oPromise;

			that.expectRequest("DELETE TEAMS('42')")
				.expectChange("text", null);

			// Note: "the resulting group ID must be '$auto' or '$direct'"
			// --> no way to call submitBatch()!
			oPromise = oContext.delete(/*sGroupId*/);
			assert.throws(function () {
				oContext.getModel().submitBatch("$direct");
			});

			return Promise.all([
				oPromise,
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: call submitBatch() synchronously after changeParameters (BCP 1770236987)
	[false, true].forEach(function (bAutoExpandSelect) {
		var sTitle = "submitBatch after changeParameters, autoExpandSelect = " + bAutoExpandSelect;

		QUnit.test(sTitle, function (assert) {
			var mFrederic = {
					ID : "2",
					Name : "Frederic Fall"
				},
				mJonathan = {
					ID : "3",
					Name : "Jonathan Smith"
				},
				oModel = this.createTeaBusiModel({autoExpandSelect : bAutoExpandSelect}),
				sUrlPrefix = bAutoExpandSelect
					? "EMPLOYEES?$select=ID,Name&"
					: "EMPLOYEES?",
				sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\', parameters : {$$groupId : \'group\'}}">\
	<Text id="text" text="{Name}"/>\
</Table>',
				that = this;

			this.expectChange("text", []);

			return this.createView(assert, sView, oModel).then(function () {
				that.expectRequest(sUrlPrefix + "$skip=0&$top=100",
						{value : [mFrederic, mJonathan]})
					.expectChange("text", ["Frederic Fall", "Jonathan Smith"]);

				return Promise.all([
					oModel.submitBatch("group"),
					that.waitForChanges(assert)
				]);
			}).then(function () {
				var oListBinding = that.oView.byId("table").getBinding("items");

				that.expectRequest(sUrlPrefix + "$orderby=Name desc&$skip=0&$top=100",
						{value : [mJonathan, mFrederic]})
					.expectChange("text", ["Jonathan Smith", "Frederic Fall"]);

				oListBinding.changeParameters({$orderby : "Name desc"});

				return Promise.all([
					oModel.submitBatch("group"),
					that.waitForChanges(assert)
				]);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: While the list binding has a size limit > 1024 and a read group lock (initially or
	// due to some kind of refresh), requestContexts is called. Ensure that not both requests (from
	// requestContexts and getContexts) are performed with a lock (requiring them to run in the same
	// batch) because with a read length > 1024 the cache has to serialize the calls.
	// In the test we skip the view and call getContexts directly to make timing easier.
	// BCP: 2370147917
	QUnit.test("BCP: 2370147917", async function (assert) {
		await this.createView(assert);

		this.oModel.setSizeLimit(1025);
		const oBinding = this.oModel.bindList("/EMPLOYEES");

		this.expectRequest("EMPLOYEES?$skip=0&$top=1025", {value : [/*doesn't matter*/]});

		// code under test
		oBinding.requestContexts();
		oBinding.getContexts(0, 20);

		await this.waitForChanges(assert);
	});

	//*********************************************************************************************
	// Scenario: call submitBatch() synchronously after resume w/ auto-$expand/$select
	QUnit.test("submitBatch after resume w/ auto-$expand/$select", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table"\
		items="{path : \'/EMPLOYEES\', parameters : {$$groupId : \'group\'}, suspended : true}">\
	<Text id="text" text="{Name}"/>\
</Table>',
			that = this;

		this.expectChange("text", []);

		return this.createView(assert, sView, oModel).then(function () {
			// avoid that the metadata request disturbs the timing
			return oModel.getMetaModel().requestObject("/");
		}).then(function () {
			that.expectEvents(assert, "sap.ui.model.odata.v4.ODataListBinding: /EMPLOYEES", [
					[, "change", {detailedReason : "AddVirtualContext", reason : "change"}],
					[, "dataRequested"],
					[, "change", {detailedReason : "RemoveVirtualContext", reason : "change"}],
					[, "refresh", {reason : "refresh"}],
					[, "change", {reason : "change"}],
					[, "dataReceived", {data : {}}]
				])
				.expectRequest("EMPLOYEES?$select=ID,Name&$skip=0&$top=100", {
					value : [
						{ID : "2", Name : "Frederic Fall"},
						{ID : "3", Name : "Jonathan Smith"}
					]
				})
				.expectChange("text", ["Frederic Fall", "Jonathan Smith"]);

			that.oView.byId("table").getBinding("items").resume();

			return Promise.all([
				oModel.submitBatch("group"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Change a property in a dependent binding below a list binding with an own cache and
	// change the list binding's row (-> the dependent binding's context)
	// TODO hasPendingChanges does work properly with changes in hidden caches if dependency between
	// bindings get lost e.g. if context of a dependent binding is reset (set to null or undefined).
	QUnit.test("Pending change in hidden cache", function (assert) {
		var oListBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="teamSet" items="{/TEAMS}">\
	<Text id="teamId" text="{Team_Id}"/>\
</Table>\
<Table id="employeeSet" items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$orderby : \'Name\'}}">\
	<Text id="employeeId" text="{ID}"/>\
</Table>\
<FlexBox id="objectPage" binding="{path : \'\', parameters : {$$updateGroupId : \'update\'}}">\
	<Input id="employeeName" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=100", {
				value : [
					{Team_Id : "1"},
					{Team_Id : "2"}
				]
			})
			.expectChange("teamId", ["1", "2"])
			.expectChange("employeeId", [])
			.expectChange("employeeName");

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("teamSet").getBinding("items");

			that.expectRequest(
					"TEAMS('1')/TEAM_2_EMPLOYEES?$orderby=Name&$select=ID&$skip=0&$top=100", {
					value : [
						{ID : "01"},
						{ID : "02"}
					]
				})
				.expectChange("employeeId", ["01", "02"]);

			// "select" the first row in the team table
			that.oView.byId("employeeSet").setBindingContext(
				that.oView.byId("teamSet").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("TEAMS('1')/TEAM_2_EMPLOYEES('01')?$select=ID,Name", {
					ID : "01",
					Name : "Frederic Fall",
					"@odata.etag" : "ETag"
				})
				.expectChange("employeeName", "Frederic Fall");

			// "select" the first row in the employee table
			that.oView.byId("objectPage").setBindingContext(
				that.oView.byId("employeeSet").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("employeeName", "foo");

			// Modify the employee name in the object page
			that.oView.byId("employeeName").getBinding("value").setValue("foo");
			assert.ok(oListBinding.hasPendingChanges());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest(
					"TEAMS('2')/TEAM_2_EMPLOYEES?$orderby=Name&$select=ID&$skip=0&$top=100", {
					value : [
						{ID : "03"},
						{ID : "04"}
					]
				})
				.expectChange("employeeId", ["03", "04"])
				.expectChange("employeeName", null);

			// "select" the second row in the team table
			that.oView.byId("employeeSet").setBindingContext(
				that.oView.byId("teamSet").getItems()[1].getBindingContext());
			assert.notOk(oListBinding.hasPendingChanges(),
				"Binding lost context -> no pending changes");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("TEAMS('2')/TEAM_2_EMPLOYEES('03')?$select=ID,Name", {
					ID : "03",
					Name : "Jonathan Smith",
					"@odata.etag" : "ETag"
				})
				.expectChange("employeeName", "Jonathan Smith");

			// "select" the first row in the employee table
			that.oView.byId("objectPage").setBindingContext(
				that.oView.byId("employeeSet").getItems()[0].getBindingContext());
			assert.ok(oListBinding.hasPendingChanges(),
				"Binding hierarchy restored -> has pending changes");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					headers : {"If-Match" : "ETag"},
					method : "PATCH",
					payload : {Name : "foo"},
					url : "EMPLOYEES('01')"
				});

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// no requests because cache is reused
			that.expectChange("employeeId", ["01", "02"])
				.expectChange("employeeName", null);

			// code under test
			that.oView.byId("employeeSet").setBindingContext(
				that.oView.byId("teamSet").getItems()[0].getBindingContext());

			assert.notOk(oListBinding.hasPendingChanges(), "no pending changes after submitBatch");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("employeeName", "foo");
			that.oView.byId("objectPage").setBindingContext(
				that.oView.byId("employeeSet").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Usage of Any/All filter values on the list binding
	[{
		filter : new Filter({
			condition : new Filter("soitem/GrossAmount", FilterOperator.GT, "1000"),
			operator : FilterOperator.Any,
			path : "SO_2_SOITEM",
			variable : "soitem"
		}),
		request : "SO_2_SOITEM/any(soitem:soitem/GrossAmount gt 1000)"
	}, {
		filter : new Filter({
			condition : new Filter({
				and : true,
				filters : [
					new Filter("soitem/GrossAmount", FilterOperator.GT, "1000"),
					new Filter("soitem/NetAmount", FilterOperator.LE, "3000")
				]
			}),
			operator : FilterOperator.Any,
			path : "SO_2_SOITEM",
			variable : "soitem"
		}),
		request : "SO_2_SOITEM/any(soitem:soitem/GrossAmount gt 1000 and"
			+ " soitem/NetAmount le 3000)"
	}, {
		filter : new Filter({
			condition : new Filter({
				filters : [
					new Filter("soitem/GrossAmount", FilterOperator.GT, "1000"),
					new Filter({operator : FilterOperator.Any, path : "soitem/SOITEM_2_SCHDL"})
				]
			}),
			operator : FilterOperator.Any,
			path : "SO_2_SOITEM",
			variable : "soitem"
		}),
		request : "SO_2_SOITEM/any(soitem:soitem/GrossAmount gt 1000 or"
			+ " soitem/SOITEM_2_SCHDL/any())"
	}, {
		filter : new Filter({
			condition : new Filter({
				filters : [
					new Filter("soitem/GrossAmount", FilterOperator.GT, "1000"),
					new Filter({
						condition : new Filter({
							and : true,
							filters : [
								new Filter("schedule/DeliveryDate", FilterOperator.LT,
									"2017-01-01T05:50Z"),
								new Filter("soitem/GrossAmount", FilterOperator.LT, "2000")
							]
						}),
						operator : FilterOperator.All,
						path : "soitem/SOITEM_2_SCHDL",
						variable : "schedule"
					})
				]
			}),
			operator : FilterOperator.Any,
			path : "SO_2_SOITEM",
			variable : "soitem"
		}),
		request : "SO_2_SOITEM/any(soitem:soitem/GrossAmount gt 1000 or"
			+ " soitem/SOITEM_2_SCHDL/all(schedule:schedule/DeliveryDate lt 2017-01-01T05:50Z"
			+ " and soitem/GrossAmount lt 2000))"
	}].forEach(function (oFixture) {
		QUnit.test("filter all/any on list binding " + oFixture.request, function (assert) {
			var sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="text" text="{SalesOrderID}"/>\
</Table>',
				that = this;

			this.expectRequest("SalesOrderList?$skip=0&$top=100", {
					value : [
						{SalesOrderID : "0"},
						{SalesOrderID : "1"},
						{SalesOrderID : "2"}
					]
				})
				.expectChange("text", ["0", "1", "2"]);

			return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
				that.expectRequest("SalesOrderList?$filter=" + oFixture.request
						+ "&$skip=0&$top=100", {
						value : [
							{SalesOrderID : "0"},
							{SalesOrderID : "2"}
						]
					})
					.expectChange("text", [, "2"]);

				// code under test
				that.oView.byId("table").getBinding("items").filter(oFixture.filter);

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Check that the context paths use key predicates if the key properties are delivered
	// in the response. Check that an expand spanning a complex type does not lead to failures.
	QUnit.test("Context Paths Using Key Predicates", function (assert) {
		var oTable,
			sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\',\
		parameters : {$expand : {\'LOCATION/City/EmployeesInCity\' : {$select : [\'Name\']}}, \
		$select : [\'ID\', \'Name\']}}">\
	<Text id="text" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$expand=LOCATION/City/EmployeesInCity($select=Name)"
				+ "&$select=ID,Name&$skip=0&$top=100", {
				value : [{
					ID : "1",
					Name : "Frederic Fall",
					LOCATION : {
						City : {
							EmployeesInCity : [
								{Name : "Frederic Fall"},
								{Name : "Jonathan Smith"}
							]
						}
					}
				}, {
					ID : "2",
					Name : "Jonathan Smith",
					LOCATION : {
						City : {
							EmployeesInCity : [
								{Name : "Frederic Fall"},
								{Name : "Jonathan Smith"}
							]
						}
					}
				}]
			})
			.expectChange("text", ["Frederic Fall", "Jonathan Smith"]);

		return this.createView(assert, sView).then(function () {
			oTable = that.oView.byId("table");

			assert.deepEqual(oTable.getItems().map(function (oItem) {
				return oItem.getBindingContext().getPath();
			}), ["/EMPLOYEES('1')", "/EMPLOYEES('2')"]);

			// #requestSideEffects w/ multi-segment $expand path
			// Note: this justifies the complicated handling inside _Helper.intersectQueryOptions
			that.expectRequest("EMPLOYEES?$expand=LOCATION/City/EmployeesInCity($select=Name)"
					+ "&$select=ID&$filter=ID eq '1' or ID eq '2'&$top=2", {value : [{
						ID : "1",
						LOCATION : null
					}, {
						ID : "2",
						LOCATION : null
					}]});

			return Promise.all([
				// code under test
				oTable.getBinding("items").getHeaderContext().requestSideEffects(["LOCATION"]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: stream property with @mediaReadLink or @odata.mediaReadLink
	// JIRA: CPOUI5UISERVICESV3-821
	//
	// Property annotations contribute to $select and do not cause a "Failed to drill-down".
	// BCP: 2170245436
	// Setting stream property to undefined leads to implicit value.
	// BCP: 2280039562
["@mediaReadLink", "@odata.mediaReadLink"].forEach(function (sAnnotation) {
	[undefined, null, "image/jpeg"].forEach(function (vMediaContentType) {
		var sTitle = "stream property with " + sAnnotation + "=" + vMediaContentType;

	QUnit.test(sTitle, function (assert) {
		var oContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oResponse = {},
			sView = '\
<FlexBox binding="{/Equipments(\'1\')/EQUIPMENT_2_PRODUCT}">\
	<Text id="url" text="{ProductPicture/Picture}"/>\
	<Text id="contentType"\
		text="{= JSON.stringify(%{ProductPicture/Picture@odata.mediaContentType}) }"/>\
	<Text id="fooBar" text="{= %{SupplierIdentifier@foo.bar} }"/>\
</FlexBox>',
			that = this;

		oResponse["Picture" + sAnnotation] = "ProductPicture('42')";
		if (vMediaContentType !== undefined) {
			oResponse["Picture@odata.mediaContentType"] = vMediaContentType;
		}
		this.expectRequest("Equipments('1')/EQUIPMENT_2_PRODUCT"
				+ "?$select=ID,ProductPicture/Picture,SupplierIdentifier", {
				"@odata.context" : "../$metadata#Equipments('1')/EQUIPMENT_2_PRODUCT",
				ID : "42",
				ProductPicture : oResponse,
				"SupplierIdentifier@foo.bar" : "The answer",
				SupplierIdentifier : 42 // Edm.Int32
			})
			.expectChange("url", sTeaBusi + "ProductPicture('42')")
			// Note: JSON.stringify is used in expression binding to "simulate" a function call
			.expectChange("contentType", JSON.stringify(vMediaContentType))
			.expectChange("fooBar", "The answer");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("contentType").getBindingContext();

			that.expectChange("url", null)
				.expectRequest({
					method : "PATCH",
					// prefixed with container since Products is in a different metadata document
					url : "com.sap.gateway.default.iwbep.tea_busi_product.v0001.Container%2F"
						+ "Products(42)",
					payload : {
						ProductPicture : {
							Picture : null
						}
					}
				}, {/* response does not matter here */});

			oContext.setProperty("ProductPicture/Picture", null);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("url", sTeaBusi + "ProductPicture('42')");

			oContext.setProperty("ProductPicture/Picture", undefined, null);

			return that.waitForChanges(assert);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: requesting a stream property with requestSideEffects always fires a change event
	// even if the returned URL from the "@odata.mediaReadLink" annotation or the URL calculated by
	// the model did not change.
	//
	// (0) Initial URL from "@odata.mediaReadLink" annotation
	// (1) Unchanged URL read via "@odata.mediaReadLink" annotation
	// (2) No URL in response (calculated by model)
	// (3) Again, no URL in response (calculated by model)
	// (4) Switch back to URL read via "@odata.mediaReadLink" annotation
	// (5) New URL read via "@odata.mediaReadLink" annotation
	// (6) TODO: @*
	//
	// JIRA: CPOUI5ODATAV4-1628
	QUnit.test("CPOUI5ODATAV4-1628: re-read Edm.Stream URL & readLink", function (assert) {
		var sArtist = "Artists(ArtistID='42',IsActiveEntity=true)",
			oContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = `
<FlexBox id="form" binding="{/${sArtist}}">
	<Text id="picture" text="{Picture}"/>
	<Text id="link" text="{= %{Picture@odata.mediaReadLink} }"/>
</FlexBox>`,
			sPrefix = "/special/cases/",
			that = this;

		this.expectRequest(sArtist + "?$select=ArtistID,IsActiveEntity,Picture", {
				ArtistID : "42",
				IsActiveEntity : true,
				// Picture (Edm.Stream) missing here
				"Picture@odata.mediaReadLink" : sArtist + "/Picture"
			})
			.expectChange("picture", sPrefix + sArtist + "/Picture")
			.expectChange("link", sPrefix + sArtist + "/Picture")
			.expectEvents(assert, "sap.ui.model.odata.v4.OData", [
				["ContextBinding: /" + sArtist, "change", {reason : "change"}],
				["ContextBinding: /" + sArtist, "dataRequested", undefined],
				["ContextBinding: /" + sArtist, "dataReceived", {data : {}}],
				["PropertyBinding: /" + sArtist + "|Picture", "change", {reason : "change"}],
				["PropertyBinding: /" + sArtist + "|Picture@odata.mediaReadLink", "change",
					{reason : "change"}]
			]);

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("form").getBindingContext();

			that.expectRequest(sArtist + "?$select=Picture", {
					ArtistID : "42",
					IsActiveEntity : true,
					// Picture (Edm.Stream) missing here
					"Picture@odata.mediaReadLink" : sArtist + "/Picture"
				})
				.expectChange("picture", sPrefix + sArtist + "/Picture")
				.expectEvents(assert, "sap.ui.model.odata.v4.OData", [
					["PropertyBinding: /" + sArtist + "|Picture", "change", {reason : "change"}]
				]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects(["Picture"]),
				that.waitForChanges(assert, "(1) unchanged URL via @odata.mediaReadLink annotation")
			]);
		}).then(function () {
			that.expectRequest(sArtist + "?$select=Picture", {
					ArtistID : "42",
					IsActiveEntity : true
					// Picture (Edm.Stream) missing here
				})
				.expectChange("picture", sPrefix + sArtist + "/Picture")
				.expectChange("link", undefined) // no more Picture@odata.mediaReadlink
				.expectEvents(assert, "sap.ui.model.odata.v4.OData", [
					["PropertyBinding: /" + sArtist + "|Picture@odata.mediaReadLink", "change",
						{reason : "change"}],
					["PropertyBinding: /" + sArtist + "|Picture", "change", {reason : "change"}]
				]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects(["Picture"]),
				that.waitForChanges(assert, "(2) no URL in response (calculated by model)")
			]);
		}).then(function () {
			that.expectRequest(sArtist + "?$select=Picture", {
					ArtistID : "42",
					IsActiveEntity : true
					// Picture (Edm.Stream) missing here
				})
				.expectChange("picture", sPrefix + sArtist + "/Picture")
				.expectEvents(assert, "sap.ui.model.odata.v4.OData", [
					["PropertyBinding: /" + sArtist + "|Picture", "change", {reason : "change"}]
				]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects(["Picture"]),
				that.waitForChanges(assert, "(3) again, no URL in response (calculated by model)")
			]);
		}).then(function () {
			that.expectRequest(sArtist + "?$select=Picture", {
					ArtistID : "42",
					IsActiveEntity : true,
					// Picture (Edm.Stream) missing here
					"Picture@odata.mediaReadLink" : sArtist + "/Picture"
				})
				.expectChange("picture", sPrefix + sArtist + "/Picture")
				.expectChange("link", sPrefix + sArtist + "/Picture")
				.expectEvents(assert, "sap.ui.model.odata.v4.OData", [
					["PropertyBinding: /" + sArtist + "|Picture@odata.mediaReadLink", "change",
						{reason : "change"}],
					["PropertyBinding: /" + sArtist + "|Picture", "change", {reason : "change"}]
				]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects(["Picture"]),
				that.waitForChanges(assert, "(4) back to URL via @odata.mediaReadLink")
			]);
		}).then(function () {
			that.expectRequest(sArtist + "?$select=Picture", {
					ID : "42",
					// Picture (Edm.Stream) missing here
					"Picture@odata.mediaReadLink" : sArtist + "/PictureHighRes"
				})
				.expectChange("picture", sPrefix + sArtist + "/PictureHighRes")
				.expectChange("link", sPrefix + sArtist + "/PictureHighRes")
				.expectEvents(assert, "sap.ui.model.odata.v4.OData", [
					["PropertyBinding: /" + sArtist + "|Picture@odata.mediaReadLink", "change",
						{reason : "change"}],
					["PropertyBinding: /" + sArtist + "|Picture", "change", {reason : "change"}]
				]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects(["Picture"]),
				that.waitForChanges(assert, "(5) changed URL via @odata.mediaReadLink annotation")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: We simulate parts of a file upload here. Initially, the Edm.Stream property is
	// missing from the response (of course) and a late property request is sent leading to
	// "Picture@$ui5.noData : true" being set. File upload happens outside the model and only a file
	// name would be PATCHed, this is omitted here. Removal of the file requires the model to PATCH
	// a null value, which ruins the URL. Thus the property is reset to undefined on the client side
	// only. This must not prevent a side effect from setting "Picture@$ui5.noData : true" again!
	// Thus upload and removal can be repeated (endlessly) while a URL is implicitly available for
	// up- and download at all times.
	// SNOW: DINC0088146
	QUnit.test("DINC0088146", async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sView = `
<Table id="list" items="{/Artists}">
	<Text id="id" text="{ArtistID}"/>
</Table>
<FlexBox id="detail">
	<Text id="link" text="{Picture}"/>
</FlexBox>`;
		const sLink = "/special/cases/Artists(ArtistID='42',IsActiveEntity=true)/Picture";

		this.expectRequest("Artists?$select=ArtistID,IsActiveEntity&$skip=0&$top=100", {
				value : [{
					ArtistID : "42",
					IsActiveEntity : true
				}]
			})
			.expectChange("link");

		await this.createView(assert, sView, oModel);

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=Picture", {
				ArtistID : "42",
				// Picture (Edm.Stream) missing here
				"Picture@odata.mediaContentType" : null
			})
			.expectChange("link", sLink);

		const oContext = this.oView.byId("list").getItems()[0].getBindingContext();
		this.oView.byId("detail").setBindingContext(oContext);

		await this.waitForChanges(assert, "detail");

		for (let i = 0; i < 3; i += 1) {
			this.expectChange("link", null)
				.expectChange("link", sLink)
				.expectRequest({
					method : "PATCH",
					url : "Artists(ArtistID='42',IsActiveEntity=true)",
					payload : {Picture : null}
				})
				.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Picture"
					+ "&$filter=ArtistID eq '42' and IsActiveEntity eq true", {
					value : [{
						ArtistID : "42",
						IsActiveEntity : true,
						// Picture (Edm.Stream) missing here
						"Picture@odata.mediaContentType" : null
					}]
				})
				.expectChange("link", sLink); // due to "Picture@$ui5.noData : true" being set

			// eslint-disable-next-line no-await-in-loop
			await Promise.all([
				oContext.setProperty("Picture", null),
				oContext.requestSideEffects(["Picture"]),
				oContext.setProperty("Picture", undefined, /*sGroupId*/null),
				this.waitForChanges(assert, "remove #" + i)
			]);
		}
	});

	//*********************************************************************************************
	// Scenario: Writing instance annotations via create and update.
	// 1. POST: Initial payload containing instance annotations
	// 2. PATCH: Update instance annotations
	// JIRA: CPOUI5ODATAV4-593
	QUnit.test("CPOUI5ODATAV4-593: Writing instance annotations via POST/PATCH", function (assert) {
		var oContext,
			oModel,
			oInitialData = {
				"@annotation" : "baz",
				"@annotation@annotation" : "bazbaz",
				"@complexAnnotation" : {
					sub : "bar"
				},
				ProductPicture : {
					"Picture@odata.mediaEditLink" : "foo"
				}
			},
			oPayload = Object.assign({}, oInitialData, {"@complexAnnotation" : {sub : "bar*"}}),
			that = this;

		oModel = this.createModel(
			"/sap/opu/odata4/IWBEP/TEA/default/iwbep/tea_busi_product/0001/", {}, {
				"/sap/opu/odata4/IWBEP/TEA/default/iwbep/tea_busi_product/0001/$metadata"
					: {source : "odata/v4/data/metadata_tea_busi_product.xml"}
			});

		return this.createView(assert, "", oModel).then(function () {
			var oListBinding = that.oModel.bindList("/Products");

			that.expectRequest({
					method : "POST",
					url : "Products",
					payload : oPayload
				}, Object.assign({ID : "42"}, oPayload));

			// code under test
			oContext = oListBinding.create(oInitialData, true);

			return Promise.all([
				// code under test
				oContext.setProperty("@complexAnnotation/sub", "bar*"),
				oContext.created(),
				that.waitForChanges(assert, "POST")
			]);
		}).then(function () {
			that.expectRequest({
				method : "PATCH",
				url : "Products(42)",
				payload : {
					"@annotation" : "baz*",
					"@annotation@annotation" : "bazbaz*",
					"@complexAnnotation" : {
						sub : "bar**"
					},
					ProductPicture : {
						"Picture@odata.mediaEditLink" : "foo*"
					}
				}
			});

			return Promise.all([
				// code under test
				oContext.setProperty("@annotation", "baz*"),
				oContext.setProperty("@annotation@annotation", "bazbaz*"),
				oContext.setProperty("@complexAnnotation/sub", "bar**"),
				oContext.setProperty("ProductPicture/Picture@odata.mediaEditLink", "foo*"),
				that.waitForChanges(assert, "PATCH")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A new instance is created and the POST returns instance annotations, both for
	// missing and existing properties, w/ and w/o updates. Check that these are properly updated in
	// the client's data.
	//
	// BCP: 2270023075
	QUnit.test("BCP: 2270023075 - creation POST returns instance annotations", function (assert) {
		var oContext,
			oListBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Text id="budget" text="{Budget}"/>\
	<Text id="budgetCurrency" text="{BudgetCurrency}"/>\
	<Text id="name" text="{Name}"/>\
	<Text id="instanceAnnotation" text="{= %{@a.b} }"/>\
	<Text id="propertyAnnotation" text="{= %{BudgetCurrency@foo.bar} }"/>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Budget,BudgetCurrency,Name,Team_Id&$skip=0&$top=100", {
				value : []
			})
			.expectChange("budget", [])
			.expectChange("budgetCurrency", [])
			.expectChange("name", [])
			.expectChange("instanceAnnotation", [])
			.expectChange("propertyAnnotation", []);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("items");

			that.expectChange("budget", ["42.1"])
				.expectChange("budgetCurrency", [""])
				.expectChange("name", ["New Team"])
				.expectChange("instanceAnnotation", [undefined])
				.expectChange("propertyAnnotation", [undefined])
				.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {Budget : "42.1", Name : "New Team"}
				}, {
					"@a.b" : "A & B",
					"@x.y.z" : "X, Y, Z",
					Budget : "42", // update
					"Budget@some.annotation" : "hello, world!",
					BudgetCurrency : "EUR",
					"BudgetCurrency@foo.bar" : "love & peace!",
					MEMBER_COUNT : 0, // MUST be ignored
					"MEMBER_COUNT@n.a" : "n/a",
					Name : "New Team", // no update
					"Name@my.comment" : "Please choose a new name",
					Team_Id : "Team_00"
				})
				.expectChange("budget", ["42"])
				.expectChange("budgetCurrency", ["EUR"])
				.expectChange("instanceAnnotation", ["A & B"])
				.expectChange("propertyAnnotation", ["love & peace!"]);

			// code under test
			oContext = oListBinding.create({Budget : "42.1", Name : "New Team"},
				/*bSkipRefresh*/true);

			return Promise.all([
				oContext.created(),
				that.waitForChanges(assert, "create")
			]);
		}).then(function () {
			assert.deepEqual(oContext.getObject(), {
					"@$ui5.context.isTransient" : false,
					"@a.b" : "A & B",
					"@x.y.z" : "X, Y, Z",
					Budget : "42",
					"Budget@some.annotation" : "hello, world!",
					BudgetCurrency : "EUR",
					"BudgetCurrency@foo.bar" : "love & peace!",
					Name : "New Team",
					"Name@my.comment" : "Please choose a new name",
					Team_Id : "Team_00"
			});
		});
	});

	//*********************************************************************************************
	// Scenario: update a quantity. The corresponding unit of measure must be sent, too.
	//
	// Lock the "$auto" group to delay a PATCH request (JIRA: CPOUI5ODATAV4-2052).
	QUnit.test("Update quantity", function (assert) {
		var oLock,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'42\')/SO_2_SOITEM(\'10\')}">\
	<Input id="quantity" value="{Quantity}"/>\
	<Input id="quantityUnit" value="{QuantityUnit}"/>\
</FlexBox>',
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			that = this;

		this.expectRequest("SalesOrderList('42')/SO_2_SOITEM('10')"
				+ "?$select=ItemPosition,Quantity,QuantityUnit,SalesOrderID", {
				"@odata.etag" : "ETag",
				Quantity : "10.000",
				QuantityUnit : "EA"
			})
			.expectChange("quantity", "10.000")
			.expectChange("quantityUnit", "EA");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')/SO_2_SOITEM('10')",
					headers : {"If-Match" : "ETag"},
					payload : {
						Quantity : "11.000",
						QuantityUnit : "EA"
					}
				}, {
					"@odata.etag" : "changed",
					Quantity : "11.000",
					QuantityUnit : "EA"
				})
				.expectChange("quantity", "11.000");

			that.oView.byId("quantity").getBinding("value").setValue("11.000");

			return that.waitForChanges(assert);
		}).then(function () {
			assert.throws(function () {
				// code under test
				oLock = oModel.lock("$direct");
			}, new Error("Group ID does not use automatic batch requests: $direct"));

			// code under test
			oLock = oModel.lock("$auto");

			assert.strictEqual(oLock.isLocked(), true);

			that.expectChange("quantityUnit", "DZ");

			that.oView.byId("quantityUnit").getBinding("value").setValue("DZ");

			return that.waitForChanges(assert, "no PATCH yet");
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')/SO_2_SOITEM('10')",
					headers : {"If-Match" : "changed"},
					payload : {
						QuantityUnit : "DZ"
					}
				});

			// code under test
			oLock.unlock();

			assert.strictEqual(oLock.isLocked(), undefined);

			return that.waitForChanges(assert, "PATCH sent");
		});
	});

	//*********************************************************************************************
	// Scenario: PATCH an entity which is read via navigation from a complex type
	QUnit.test("PATCH entity below a complex type", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'1\')}">\
	<Table id="table" items="{LOCATION/City/EmployeesInCity}">\
		<Input id="room" value="{ROOM_ID}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')?$select=ID"
				+ "&$expand=LOCATION/City/EmployeesInCity($select=ID,ROOM_ID)", {
				ID : "1",
				LOCATION : {
					City : {
						EmployeesInCity : [{
							ID : "1",
							ROOM_ID : "1.01",
							"@odata.etag" : "ETag"
						}]
					}
				}
			})
			.expectChange("room", ["1.01"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('1')",
					headers : {"If-Match" : "ETag"},
					payload : {ROOM_ID : "1.02"}
				})
				.expectChange("room", ["1.02"]);

			that.oView.byId("table").getItems()[0].getCells()[0].getBinding("value")
				.setValue("1.02");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: test conversion of $select and $expand for V2 Adapter
	// Usage of service: /sap/opu/odata/IWBEP/GWSAMPLE_BASIC/
	QUnit.test("V2 Adapter: select in expand", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{path :\'/SalesOrderSet(\\\'0500000001\\\')\', \
		parameters : {\
			$expand : {ToLineItems : {$select : \'ItemPosition\'}}, \
			$select : \'SalesOrderID\'\
		}}">\
	<Text id="id" text="{path : \'SalesOrderID\', type : \'sap.ui.model.odata.type.String\'}"/>\
	<Table id="table" items="{ToLineItems}">\
		<Text id="item" text="{path : \'ItemPosition\',\
			type : \'sap.ui.model.odata.type.String\'}"/>\
	</Table>\
</FlexBox>',
			oModel = this.createModelForV2SalesOrderService({
				annotationURI : "/sap/opu/odata/IWBEP/GWSAMPLE_BASIC/annotations.xml"
			});

		this.expectRequest("SalesOrderSet('0500000001')?$expand=ToLineItems"
				+ "&$select=ToLineItems/ItemPosition,SalesOrderID", {
				d : {
					__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
					SalesOrderID : "0500000001",
					ToLineItems : {
						results : [{
							__metadata : {type : "GWSAMPLE_BASIC.SalesOrderLineItem"},
							ItemPosition : "0000000010"
						}, {
							__metadata : {type : "GWSAMPLE_BASIC.SalesOrderLineItem"},
							ItemPosition : "0000000020"
						}, {
							__metadata : {type : "GWSAMPLE_BASIC.SalesOrderLineItem"},
							ItemPosition : "0000000030"
						}]
					}
				}
			})
			.expectChange("id", "0500000001")
			.expectChange("item", ["0000000010", "0000000020", "0000000030"]);

		// code under test
		return this.createView(assert, sView, oModel).then(function () {
			assert.deepEqual(
				oModel.getMetaModel().getObject(
					"/SalesOrderSet/NetAmount@Org.OData.Measures.V1.ISOCurrency"),
				{$Path : "CurrencyCode"});
		});
	});

	//*********************************************************************************************
	// Scenario: test conversion of $orderby for V2 Adapter
	// Usage of service: /sap/opu/odata/IWBEP/GWSAMPLE_BASIC/
	// BCP: 2070443387 ($search)
	QUnit.test("V2 Adapter: $orderby & $search", function (assert) {
		var sView = '\
<Table id="table" items="{path :\'/SalesOrderSet\',\
		parameters : {\
			$select : \'SalesOrderID\',\
			$orderby : \'SalesOrderID\',\
			$search : \'foo\'\
		}}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			oModel = this.createModelForV2SalesOrderService({
				annotationURI : "/sap/opu/odata/IWBEP/GWSAMPLE_BASIC/annotations.xml"
			});

		this.expectRequest("SalesOrderSet?$orderby=SalesOrderID&$search=foo&$select=SalesOrderID"
				+ "&$skip=0&$top=100", {
				d : {
					results : [{
						__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
						SalesOrderID : "0500000001"
					}, {
						__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
						SalesOrderID : "0500000002"
					}, {
						__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
						SalesOrderID : "0500000003"
					}]
				}
			})
			.expectChange("id", ["0500000001", "0500000002", "0500000003"]);

		// code under test
		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	[{
		binding : "CreatedAt ge 2017-05-23T00:00:00Z",
		request : "CreatedAt ge datetime'2017-05-23T00:00:00'"
	}, {
		binding : "Note eq null",
		request : "Note eq null"
	}, {
		binding : "2017-05-23T00:00:00Z ge CreatedAt",
		request : "datetime'2017-05-23T00:00:00' ge CreatedAt"
	}, {
		binding : "Note eq null and 2017-05-23T00:00:00Z ge CreatedAt",
		request : "Note eq null and datetime'2017-05-23T00:00:00' ge CreatedAt"
	}, {
		binding : "Note eq null or 2017-05-23T00:00:00Z ge CreatedAt",
		request : "Note eq null or datetime'2017-05-23T00:00:00' ge CreatedAt"
	}, {
		binding : "Note eq null or not (2017-05-23T00:00:00Z ge CreatedAt)",
		request : "Note eq null or not (datetime'2017-05-23T00:00:00' ge CreatedAt)"
	}].forEach(function (oFixture) {
		// Scenario: test conversion of $filter for V2 Adapter
		// Usage of service: /sap/opu/odata/IWBEP/GWSAMPLE_BASIC/
		QUnit.test("V2 Adapter: $filter=" + oFixture.binding, function (assert) {
			var sView = '\
<Table id="table" items="{path :\'/SalesOrderSet\',\
		parameters : {\
			$select : \'SalesOrderID\',\
			$filter : \'' + oFixture.binding + '\'\
		}}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>';

			this.expectRequest("SalesOrderSet?$filter=" + oFixture.request + "&$select=SalesOrderID"
					+ "&$skip=0&$top=100", {
					d : {
						results : [{
							__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
							SalesOrderID : "0500000001"
						}, {
							__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
							SalesOrderID : "0500000002"
						}, {
							__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
							SalesOrderID : "0500000003"
						}]
					}
				})
				.expectChange("id", ["0500000001", "0500000002", "0500000003"]);

			// code under test
			return this.createView(assert, sView, this.createModelForV2SalesOrderService());
		});
	});

	//*********************************************************************************************
	// Scenario: Minimal test for two absolute ODataPropertyBindings using different direct groups.
	//
	// "sap-cancel-on-close" header for SubmitMode.Direct GET request (JIRA: CPOUI5ODATAV4-2506)
	QUnit.test("Absolute ODPBs using different direct groups", function (assert) {
		var sView = '\
<Text id="text1" text="{\
	path : \'/EMPLOYEES(\\\'2\\\')/Name\',\
	parameters : {$$groupId : \'group1\'}}"/>\
<Text id="text2" text="{\
	path : \'/EMPLOYEES(\\\'3\\\')/Name\',\
	parameters : {$$groupId : \'group2\'}}"\
/>';

		this.expectRequest({
				headers : {"sap-cancel-on-close" : "true"},
				url : "EMPLOYEES('2')/Name"
			}, {value : "Frederic Fall"})
			.expectRequest({
				headers : {"sap-cancel-on-close" : "true"},
				url : "EMPLOYEES('3')/Name"
			}, {value : "Jonathan Smith"})
			.expectChange("text1", "Frederic Fall")
			.expectChange("text2", "Jonathan Smith");

		return this.createView(assert, sView,
			this.createTeaBusiModel({
				groupProperties : {
					group1 : {submit : "Direct"},
					group2 : {submit : "Direct"}
				}
			})
		);
	});

	//*********************************************************************************************
	// Scenario: Minimal test for two absolute ODataPropertyBindings using different auto groups.
	// For group Ids starting with name "$auto." the submit mode will be set to auto automatically.
	QUnit.test("Absolute ODPBs using different '$auto.X' groups", function (assert) {
		var sView = '\
<Text id="text1" text="{\
	path : \'/EMPLOYEES(\\\'2\\\')/Name\',\
	parameters : {$$groupId : \'$auto.1\'}}"/>\
<Text id="text2" text="{\
	path : \'/EMPLOYEES(\\\'3\\\')/Name\',\
	parameters : {$$groupId : \'$auto.2\'}}"\
/>';

		this.expectRequest({
				url : "EMPLOYEES('2')/Name",
				batchNo : 1
			}, {value : "Frederic Fall"})
			.expectRequest({
				url : "EMPLOYEES('3')/Name",
				batchNo : 2
			}, {value : "Jonathan Smith"})
			.expectChange("text1", "Frederic Fall")
			.expectChange("text2", "Jonathan Smith");

		return this.createView(assert, sView, this.createTeaBusiModel({}));
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with rowMode="Auto" only calls ODLB.getContexts()
	// after rendering (via setTimeout). This must not lead to separate requests for each table
	// cell resp. console errors due to data access via virtual context.
	// BCP 1770367083
	// Also tests that key properties are $select'ed for a sap.ui.table.Table with query options
	// different from $expand and $select in the binding parameters of the rows aggregation.
	QUnit.test("sap.ui.table.Table with rowMode='Auto'", function (assert) {
		var sView = '\
<t:Table id="table" rows="{path : \'/EMPLOYEES\', parameters : {$filter : \'AGE gt 42\'}}"\
		rowMode="Auto">\
	<t:Column>\
		<t:label>\
			<Label text="Name"/>\
		</t:label>\
		<t:template>\
			<Text id="text" text="{Name}"/>\
		</t:template>\
	</t:Column>\
</t:Table>',
			oModel = this.createTeaBusiModel({autoExpandSelect : true});

		this.expectRequest("EMPLOYEES?$filter=AGE gt 42&$select=ID,Name&$skip=0&$top=140", {
				value : [
					{Name : "Frederic Fall"},
					{Name : "Jonathan Smith"}
				]
			})
			.expectChange("text", ["Frederic Fall", "Jonathan Smith"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: a ManagedObject instance with a relative object binding (using
	// cross-service navigation) and a property binding (maybe even at the same time)
	// Note: ID will not fail, it is also present on EQUIPMENT! SupplierIdentifier is "unique"
	QUnit.test("Relative object binding & property binding: separate control", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oText = new Text(),
			sView = '\
<FlexBox binding="{/Equipments(Category=\'Electronics\',ID=1)}">\
	<FlexBox binding="{EQUIPMENT_2_PRODUCT}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="text" text="{SupplierIdentifier}"/>\
	</FlexBox>\
</FlexBox>';

		this.expectRequest("Equipments(Category='Electronics',ID=1)?$select=Category,ID"
				+ "&$expand=EQUIPMENT_2_PRODUCT($select=ID,SupplierIdentifier)", {
				Category : "Electronics",
				ID : 1,
				EQUIPMENT_2_PRODUCT : {
					ID : 2, // Edm.Int32
					SupplierIdentifier : 42 // Edm.Int32
				}
			})
			// Note: sap.m.Text#text turns value into string!
			.expectChange("text", oText.validateProperty("text", 42));

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	QUnit.test("Relative object binding & property binding: same control", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oText = new Text(),
			sView = '\
<FlexBox binding="{/Equipments(Category=\'Electronics\',ID=1)}">\
	<Text binding="{EQUIPMENT_2_PRODUCT}" id="text" text="{SupplierIdentifier}"/>\
</FlexBox>';

		this.expectRequest("Equipments(Category='Electronics',ID=1)?$select=Category,ID"
				+ "&$expand=EQUIPMENT_2_PRODUCT($select=ID,SupplierIdentifier)", {
				Category : "Electronics",
				ID : 1,
				EQUIPMENT_2_PRODUCT : {
					ID : 2, // Edm.Int32
					SupplierIdentifier : 42 // Edm.Int32
				}
			})
			// Note: sap.m.Text#text turns value into string!
			.expectChange("text", oText.validateProperty("text", 42));

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: a ManagedObject instance with a relative object binding
	// *using cross-service navigation*
	// and a property binding at the same time, inside a list binding
	// Note: ID will not fail, it is also present on EQUIPMENT! SupplierIdentifier is "unique"
	QUnit.test("Relative object binding & property binding within a list (1)", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oText = new Text(),
			sView = '\
<Table items="{/Equipments}">\
	<Text binding="{EQUIPMENT_2_PRODUCT}" id="text" text="{SupplierIdentifier}"/>\
</Table>';

		this.expectRequest("Equipments?$select=Category,ID"
				+ "&$expand=EQUIPMENT_2_PRODUCT($select=ID,SupplierIdentifier)"
				+ "&$skip=0&$top=100", {
				value : [{
					Category : "Electronics",
					ID : 1,
					EQUIPMENT_2_PRODUCT : {
						ID : 2, // Edm.Int32
						SupplierIdentifier : 42 // Edm.Int32
					}
				}]
			})
			.expectChange("text", [oText.validateProperty("text", 42)]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: a ManagedObject instance with a relative object binding
	// *w/o cross-service navigation*
	// and a property binding at the same time, inside a list binding
	// Note: ID will not fail, it is also present on EQUIPMENT! AGE is "unique"
	QUnit.test("Relative object binding & property binding within a list (2)", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oText = new Text(),
			sView = '\
<Table items="{/Equipments}">\
	<Text binding="{EQUIPMENT_2_EMPLOYEE}" id="text" text="{AGE}"/>\
</Table>';

		this.expectRequest("Equipments?$select=Category,ID"
				+ "&$expand=EQUIPMENT_2_EMPLOYEE($select=AGE,ID)"
				+ "&$skip=0&$top=100", {
				value : [{
					Category : "Electronics",
					ID : 1,
					EQUIPMENT_2_EMPLOYEE : {
						ID : "0815", // Edm.String
						AGE : 42 // Edm.Int16
					}
				}]
			})
			.expectChange("text", [oText.validateProperty("text", 42)]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: a ManagedObject instance with a relative object binding (w/o
	// cross-service navigation) and a property binding at the same time, inside a list binding
	// Note: ID will not fail, it is also present on EQUIPMENT! AGE is "unique"
	QUnit.test("Relative object binding & property binding within a list (3)", function (assert) {
		var oText = new Text(),
			sView = '\
<Table items="{/Equipments}">\
	<Text binding="{EQUIPMENT_2_EMPLOYEE}" id="text" text="{AGE}"/>\
</Table>';

		this.expectRequest("Equipments?$skip=0&$top=100", {
				value : [{
					Category : "Electronics",
					ID : 1,
					EQUIPMENT_2_EMPLOYEE : {
						ID : "0815", // Edm.String
						AGE : 42 // Edm.Int16
					}
				}]
			})
			.expectChange("text", [oText.validateProperty("text", 42)]);

		return this.createView(assert, sView);
	});

	//*********************************************************************************************
	// Scenario: Object binding provides access to some collection and you then want to filter on
	//   that collection; inspired by https://github.com/SAP/openui5/issues/1763
	QUnit.test("Filter collection provided via object binding", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{parameters : {$expand : \'TEAM_2_EMPLOYEES\'},\
		path : \'/TEAMS(\\\'42\\\')\'}">\
	<Table items="{TEAM_2_EMPLOYEES}">\
		<Text id="id" text="{ID}"/>\
	</Table>\
</FlexBox>',
			that = this;

		// Note: for simplicity, autoExpandSelect : false but still most properties are omitted
		this.expectRequest("TEAMS('42')?$expand=TEAM_2_EMPLOYEES", {
				TEAM_2_EMPLOYEES : [
					{ID : "1"},
					{ID : "2"},
					{ID : "3"}
				]
			})
			.expectChange("id", ["1", "2", "3"]);

		return this.createView(assert, sView).then(function () {
			that.expectRequest("TEAMS('42')?$expand=TEAM_2_EMPLOYEES($filter=ID eq '2')", {
					TEAM_2_EMPLOYEES : [{ID : "2"}]
				})
				.expectChange("id", ["2"]);

			that.oView.byId("form").getObjectBinding()
				.changeParameters({$expand : "TEAM_2_EMPLOYEES($filter=ID eq '2')"});

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Behaviour of a deferred bound function
	QUnit.test("Bound function", function (assert) {
		var sView = '\
<FlexBox binding="{/EMPLOYEES(\'1\')}">\
	<FlexBox id="function" \
		binding="{com.sap.gateway.default.iwbep.tea_busi.v0001.FuGetEmployeeSalaryForecast(...)}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="status" text="{STATUS}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectChange("status", null);

		return this.createView(assert, sView).then(function () {
			that.expectRequest("EMPLOYEES('1')/com.sap.gateway.default.iwbep.tea_busi.v0001"
					+ ".FuGetEmployeeSalaryForecast()", {
					STATUS : "42"
				})
				.expectChange("status", "42");

			return Promise.all([
				// code under test
				that.oView.byId("function").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Operation binding for a function, first it is deferred, later is has been invoked.
	//   Show interaction of setParameter(), invoke() and refresh().
	QUnit.test("Function binding: setParameter, invoke and refresh", function (assert) {
		var oFunctionBinding,
			sView = '\
<FlexBox id="function" binding="{/GetEmployeeByID(...)}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("name", null);

		return this.createView(assert, sView).then(function () {
			oFunctionBinding = that.oView.byId("function").getObjectBinding();

			oFunctionBinding.refresh(); // MUST NOT invoke a request!

			that.expectRequest("GetEmployeeByID(EmployeeID='1')", {
					ID : "1",
					Name : "Jonathan Smith"
				})
				.expectChange("name", "Jonathan Smith");

			return Promise.all([
				oFunctionBinding.setParameter("EmployeeID", "1").invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("GetEmployeeByID(EmployeeID='1')", {
					ID : "1",
					Name : "Frederic Fall"
				})
				.expectChange("name", "Frederic Fall");
			oFunctionBinding.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			oFunctionBinding.setParameter("EmployeeID", "2");

			oFunctionBinding.refresh(); // MUST NOT invoke a request!

			that.expectRequest("GetEmployeeByID(EmployeeID='2')", {
					ID : "2",
					Name : "Peter Burke"
				})
				.expectChange("name", "Peter Burke");

			return Promise.all([
				oFunctionBinding.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("GetEmployeeByID(EmployeeID='2')", {
					ID : "2",
					Name : "Jonathan Smith"
				})
				.expectChange("name", "Jonathan Smith");
			oFunctionBinding.refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Operation binding for a function, first it is deferred, later is has been invoked.
	//   Show interaction of setParameter(), invoke() and changeParameters().
	QUnit.test("Function binding: setParameter, invoke and changeParameters", function (assert) {
		var oFunctionBinding,
			sView = '\
<FlexBox id="function" binding="{/GetEmployeeByID(...)}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("name", null);

		return this.createView(assert, sView).then(function () {
			oFunctionBinding = that.oView.byId("function").getObjectBinding();

			oFunctionBinding.changeParameters({$select : "Name"}); // MUST NOT invoke a request!

			that.expectRequest("GetEmployeeByID(EmployeeID='1')?$select=Name", {
					Name : "Jonathan Smith"
				})
				.expectChange("name", "Jonathan Smith");

			return Promise.all([
				oFunctionBinding.setParameter("EmployeeID", "1").invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("GetEmployeeByID(EmployeeID='1')?$select=ID,Name", {
					ID : "1",
					Name : "Frederic Fall"
				})
				.expectChange("name", "Frederic Fall");
			oFunctionBinding.changeParameters({$select : "ID,Name"});

			return that.waitForChanges(assert);
		}).then(function () {
			oFunctionBinding.setParameter("EmployeeID", "2");

			// MUST NOT invoke a request!
			oFunctionBinding.changeParameters({$select : "Name"});

			that.expectRequest("GetEmployeeByID(EmployeeID='2')?$select=Name", {
					Name : "Peter Burke"
				})
				.expectChange("name", "Peter Burke");

			return Promise.all([
				oFunctionBinding.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("GetEmployeeByID(EmployeeID='2')?$select=ID,Name", {
					ID : "2",
					Name : "Jonathan Smith"
				})
				.expectChange("name", "Jonathan Smith");
			oFunctionBinding.changeParameters({$select : "ID,Name"});

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: ODataListBinding contains ODataContextBinding contains ODataPropertyBinding;
	//   only one cache; refresh()
	QUnit.test("refresh on dependent bindings", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sUrl = "TEAMS('42')?$select=Team_Id&$expand=TEAM_2_MANAGER($select=ID)",
			sView = '\
<FlexBox binding="{/TEAMS(\'42\')}">\
	<FlexBox binding="{TEAM_2_MANAGER}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="id" text="{ID}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest(sUrl, {
				Team_Id : "42",
				TEAM_2_MANAGER : {ID : "1"}
			})
			.expectChange("id", "1");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest(sUrl, {
					Team_Id : "42",
					TEAM_2_MANAGER : {ID : "2"}
				})
				.expectChange("id", "2");

			oModel.refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: sap.chart.Chart wants to read all data w/o paging
	QUnit.test("no paging", function (assert) {
		var fnGetContexts = ODataListBinding.prototype.getContexts,
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Text id="id" text="{Team_Id}"/>\
</Table>';

		this.mock(ODataListBinding.prototype).expects("getContexts").atLeast(1).callsFake(
			function (iStart, iLength) {
				// this is how the call by sap.chart.Chart should look like --> GET w/o $top!
				return fnGetContexts.call(this, iStart, iLength, Infinity);
			});
		this.expectRequest("TEAMS", {
				value : [{
					Team_Id : "TEAM_00"
				}, {
					Team_Id : "TEAM_01"
				}, {
					Team_Id : "TEAM_02"
				}]
			})
			.expectChange("id", ["TEAM_00", "TEAM_01", "TEAM_02"]);

		return this.createView(assert, sView);
	});

	//*********************************************************************************************
	// Scenario: some custom control wants to read all data, and it gets quite a lot
	QUnit.test("read all data", function (assert) {
		var i,
			n = 5000,
			aIDs = new Array(n),
			aValues = new Array(n),
			sView = '\
<List id="list">\
</List>',
			that = this;

		for (i = 0; i < n; i += 1) {
			aIDs[i] = "TEAM_" + i;
			aValues[i] = {Team_Id : aIDs[i]};
		}

		return this.createView(assert, sView).then(function () {
			var oText = new Text("id", {text : "{Team_Id}"});

			that.setFormatter(assert, oText, "id", true);
			that.expectRequest("TEAMS", {value : aValues})
				.expectChange("id", aIDs);

			that.oView.byId("list").bindItems({
				length : Infinity, // code under test
				path : "/TEAMS",
				template : new CustomListItem({content : [oText]})
			});

			// Increase the timeout for this test to run also in FF
			return that.waitForChanges(assert, "", 25000/*ms*/);
		});
	});

	//*********************************************************************************************
	// Scenario: read all data w/o a control on top
	QUnit.test("read all data w/o a control on top", function (assert) {
		var aIDs = [],
			aValues = [],
			i,
			that = this;

		for (i = 0; i < 10000; i += 1) {
			aIDs[i] = "TEAM_" + i;
			aValues[i] = {Team_Id : aIDs[i]};
		}

		return this.createView(assert).then(function () {
			var fnDone,
				oListBinding = that.oModel.bindList("/TEAMS");

			that.expectRequest("TEAMS", {value : aValues});

			oListBinding.getContexts(0, Infinity);
			oListBinding.attachEventOnce("change", function () {
				oListBinding.getContexts(0, Infinity).forEach(function (oContext, i) {
					var sId = oContext.getProperty("Team_Id");

					// Note: avoid bad performance of assert.strictEqual(), e.g. DOM manipulation
					if (sId !== aIDs[i]) {
						assert.strictEqual(sId, aIDs[i]);
					}
				});
				fnDone();
			});

			return Promise.all([
				// wait until change event is processed
				new Promise(function (resolve) {
					fnDone = resolve;
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: infinite prefetch alone must not make _CollectionCache#read async
	// TODO: We have to skip this test because of 2 BCP incidents (2280024694 && 2180279839).
	// At current state, we are not able to handle this in a synchronous way!
	QUnit.skip("infinite prefetch", function (assert) {
		var oListBinding,
			aValues = [],
			i,
			that = this;

		for (i = 0; i < 12; i += 1) {
			aValues[i] = {Team_Id : "TEAM_" + i};
		}

		return this.createView(assert).then(function () {
			oListBinding = that.oModel.bindList("/TEAMS");

			that.expectRequest("TEAMS?$skip=0&$top=10", {value : aValues.slice(0, 10)});

			return Promise.all([
				oListBinding.requestContexts(0, 10),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("TEAMS?$skip=10", {value : aValues.slice(10)});

			assert.strictEqual(
				// code under test: must not be async (BEWARE: not an API!)
				oListBinding.fetchContexts(0, 10, Infinity).getResult(),
				false, "whether the binding's contexts have been modified");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Paging beyond the magical limit of 1024 must not serialize GET requests (due to
	// $tail being used internally) if only a small number of rows is requested each time.
	//
	// BCP: 2270181455
	QUnit.test("BCP: 2270181455", function (assert) {
		var oListBinding,
			oPromise1,
			oPromise2,
			fnRespond1,
			fnRespond2,
			aValues = [],
			i,
			that = this;

		for (i = 1030; i < 1050; i += 1) {
			aValues[i] = {Team_Id : "TEAM_" + i};
		}

		return this.createView(assert).then(function () {
			oListBinding = that.oModel.bindList("/TEAMS");

			that.expectRequest("TEAMS?$skip=1030&$top=10", new Promise(function (resolve) {
					fnRespond1 = resolve.bind(null, {value : aValues.slice(1030, 1040)});
				}));

			// code under test
			oPromise1 = oListBinding.requestContexts(1030, 10);

			return that.waitForChanges(assert, "1st GET");
		}).then(function () {
			that.expectRequest("TEAMS?$skip=1040&$top=10", new Promise(function (resolve) {
					fnRespond2 = resolve.bind(null, {value : aValues.slice(1040, 1050)});
				}));

			// code under test
			oPromise2 = oListBinding.requestContexts(1040, 10);

			return that.waitForChanges(assert, "2nd GET");
		}).then(function () {
			fnRespond2();

			return oPromise2.then(function (aResult) {
				assert.deepEqual(aResult.map(getObject), aValues.slice(1040, 1050),
					"2nd request may well overtake 1st one");
			});
		}).then(function () {
			fnRespond1();

			return oPromise1.then(function (aResult) {
				assert.deepEqual(aResult.map(getObject), aValues.slice(1030, 1040));
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Retrieve existing data from cache and prefetch further entries. Make sure that a
	// dataReceived event is sent after each dataRequested.
	//
	// BCP: 2180279839
	// BCP: 2280024694
	//
	// Same with prefetch of preceeding entries (SNOW: CS20230006538459)
	QUnit.test("BCP: 2180279839: dataReceived follows each dataRequested", function (assert) {
		var oListBinding,
			aValues = [],
			i,
			that = this;

		for (i = 0; i < 1110; i += 1) {
			if (i < 17 || i >= 1093) {
				aValues[i] = {Team_Id : "TEAM_" + i};
			}
		}

		return this.createView(assert).then(function () {
			oListBinding = that.oModel.bindList("/TEAMS");

			that.expectRequest("TEAMS?$skip=0&$top=7", {value : aValues.slice(0, 7)})
				.expectEvents(assert, oListBinding, [
					[, "dataRequested"],
					[, "change", {reason : "change"}],
					[, "dataReceived", {data : {}}]
				]);

			assert.deepEqual(oListBinding.getContexts(0, 7).map(getPath), []);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("TEAMS?$skip=7&$top=3", {value : aValues.slice(7, 10)})
				.expectEvents(assert, oListBinding, [
					[, "dataRequested"],
					[, "dataReceived", {data : {}}]
				]);

			// code under test
			assert.deepEqual(oListBinding.getContexts(3, 2, 5).map(getPath), [
				"/TEAMS('TEAM_3')",
				"/TEAMS('TEAM_4')"
			]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("TEAMS?$skip=1098&$top=7", {value : aValues.slice(1098, 1105)})
				.expectEvents(assert, oListBinding, [
					[, "dataRequested"],
					[, "change", {reason : "change"}],
					[, "dataReceived", {data : {}}]
				]);

			assert.deepEqual(oListBinding.getContexts(1098, 7).map(getPath), []);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("TEAMS?$skip=1105&$top=5", {value : aValues.slice(1105, 1110)})
				.expectEvents(assert, oListBinding, [
					[, "dataRequested"],
					[, "dataReceived", {data : {}}]
				]);

			// code under test (BCP: 2280024694)
			assert.deepEqual(oListBinding.getContexts(1103, 2, 5).map(getPath), [
				"/TEAMS('TEAM_1103')",
				"/TEAMS('TEAM_1104')"
			]);

			return that.waitForChanges(assert);
		}).then(function () { // prefetch *before* existing data
			that.expectRequest("TEAMS?$skip=1093&$top=5", {value : aValues.slice(1093, 1098)})
				.expectEvents(assert, oListBinding, [
					[, "dataRequested"],
					[, "dataReceived", {data : {}}]
				]);

			assert.deepEqual(oListBinding.getContexts(1098, 7, 5).map(getPath), [
				"/TEAMS('TEAM_1098')",
				"/TEAMS('TEAM_1099')",
				"/TEAMS('TEAM_1100')",
				"/TEAMS('TEAM_1101')",
				"/TEAMS('TEAM_1102')",
				"/TEAMS('TEAM_1103')",
				"/TEAMS('TEAM_1104')"
			]);

			return that.waitForChanges(assert);
		}).then(function () { // iIndex - iPrefetchLength becomes negative here
			that.expectRequest("TEAMS?$skip=10&$top=7", {value : aValues.slice(10, 17)})
				.expectEvents(assert, oListBinding, [
					[, "dataRequested"],
					[, "dataReceived", {data : {}}]
				]);

			assert.deepEqual(oListBinding.getContexts(0, 7, 10).map(getPath), [
				"/TEAMS('TEAM_0')",
				"/TEAMS('TEAM_1')",
				"/TEAMS('TEAM_2')",
				"/TEAMS('TEAM_3')",
				"/TEAMS('TEAM_4')",
				"/TEAMS('TEAM_5')",
				"/TEAMS('TEAM_6')"
			]);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: ODataListBinding contains ODataContextBinding contains ODataPropertyBinding;
	//   only one cache; hasPendingChanges()
	QUnit.test("hasPendingChanges on dependent bindings", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sUrl = "SalesOrderList?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)&$skip=0&$top=100",
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Input binding="{SO_2_BP}" value="{CompanyName}"/>\
</Table>',
			that = this;

		this.expectRequest(sUrl, {
				value : [{
					SalesOrderID : "42",
					SO_2_BP : {
						BusinessPartnerID : "1",
						CompanyName : "Foo, Inc",
						"@odata.etag" : "ETag"
					}
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			var oText = that.oView.byId("table").getItems()[0].getCells()[0];

			that.expectRequest({
					method : "PATCH",
					url : "BusinessPartnerList('1')",
					headers : {"If-Match" : "ETag"},
					payload : {CompanyName : "Bar, Inc"}
				}, {});

			oText.getBinding("value").setValue("Bar, Inc");

			// code under test
			assert.strictEqual(oText.getElementBinding().hasPendingChanges(), true);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Support expression binding in ODataModel.integration.qunit
	testViewStart("Expression binding",
		'<Text id="text" text="{= \'Hello, \' + ${/EMPLOYEES(\'2\')/Name} }"/>',
		{"EMPLOYEES('2')/Name" : {value : "Frederic Fall"}},
		{text : "Hello, Frederic Fall"}
	);

	//*********************************************************************************************
	// Scenario: Support expression binding on a list in ODataModel.integration.qunit
	// Note: Use "$\{Name}" to avoid that Maven replaces "${Name}"
	testViewStart("Expression binding in a list", '\
<Table items="{/EMPLOYEES}">\
	<Text id="text" text="{= \'Hello, \' + $\{Name} }"/>\
</Table>',
		{"EMPLOYEES?$skip=0&$top=100" :
			{value : [{Name : "Frederic Fall"}, {Name : "Jonathan Smith"}]}},
		{text : ["Hello, Frederic Fall", "Hello, Jonathan Smith"]}
	);

	//*********************************************************************************************
	// Scenario: Enable auto-$expand/$select mode for an ODataContextBinding with relative
	// ODataPropertyBindings to a advertised action
	testViewStart("Auto-$expand/$select: relative ODPB to advertised action", '\
<FlexBox binding="{path : \'/EMPLOYEES(\\\'2\\\')\', parameters : {$select : \'AGE\'}}">\
	<Text id="name" text="{Name}"/>\
	<Text id="adAction1"\
		text="{= %{#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsOccupied}\
			? \'set to occupied\' : \'\'}"/>\
	<Text id="adAction2"\
		text="{= %{#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable}\
			? \'set to available\' : \'\'}"/>\
</FlexBox>', {
			"EMPLOYEES('2')?$select=AGE,ID,Name,com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable,com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsOccupied" : {
				"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {},
				AGE : 32,
				Name : "Frederic Fall"
			}
		}, [{
			adAction1 : "",
			adAction2 : "set to available",
			name : "Frederic Fall"
		}], function () {
			return this.createTeaBusiModel({autoExpandSelect : true});
		}
	);

	//*********************************************************************************************
	// Scenario: Nested list bindings with autoExpandSelect. This leads to a list binding with a
	// virtual parent context. Such a binding must not try to read data from the cache because it is
	// immediately destroyed again.
	// BCP: 2080321417
	QUnit.test("BCP: 2080321417: Auto-$expand/$select and nested list bindings", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<List id="select" items="{path : \'SO_2_SOITEM\', templateShareable : false}">\
		<CustomListItem>\
			<Text text="{ItemPosition}"/>\
		</CustomListItem>\
	</List>\
</Table>',
			that = this;

		return oModel.getMetaModel().fetchObject("/SalesOrderList").then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)&$skip=0&$top=100",
					{value : [{SalesOrderID : "1", SO_2_SOITEM : []}]})
				.expectChange("id", ["1"]);

			return that.createView(assert, sView, oModel);
		});
	});

	//*********************************************************************************************
	// Scenario: updates for advertised action's title caused by: refresh, side effect of edit,
	// bound action
	// CPOUI5UISERVICESV3-905, CPOUI5UISERVICESV3-1714
	//
	// TODO automatic type determination cannot handle #com...AcSetIsAvailable/title
	// TODO neither can autoExpandSelect
	QUnit.test("Advertised actions: title updates", function (assert) {
		var oModel = this.createTeaBusiModel(),
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'2\')}" id="form">\
	<Input id="name" value="{Name}"/>\
	<Text id="title" text="{\
		path : \'#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable/title\',\
		type : \'sap.ui.model.odata.type.String\'}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')", {
				"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {
					title : "First Title"
				},
				ID : "2",
				Name : "Frederic Fall"
			})
			.expectChange("name", "Frederic Fall")
			.expectChange("title", "First Title");

		return this.createView(assert, sView, oModel).then(function () {
			var oContextBinding = that.oView.byId("form").getObjectBinding();

			that.expectRequest("EMPLOYEES('2')", {
					"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {
						title : "Second Title"
					},
					ID : "2",
					Name : "Frederic Fall"
				})
				.expectChange("title", "Second Title");

			// code under test
			oContextBinding.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					payload : {Name : "Frederic Spring"},
					url : "EMPLOYEES('2')"
				}, {
					"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {
						title : "Third Title"
					}
					// ID : "2",
					// Name : "Frederic Spring"
				})
				.expectChange("name", "Frederic Spring")
				.expectChange("title", "Third Title");

			// code under test
			that.oView.byId("name").getBinding("value").setValue("Frederic Spring");

			return that.waitForChanges(assert);
		}).then(function () {
			var sActionName = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
				oContext = that.oView.byId("form").getObjectBinding().getBoundContext(),
				oActionBinding = oModel.bindContext(sActionName + "(...)", oContext);

			that.expectRequest({
					method : "POST",
					payload : {TeamID : "TEAM_02"},
					url : "EMPLOYEES('2')/" + sActionName
				}, {
					"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {
						title : "Fourth Title"
					},
					ID : "2",
					Name : "Frederic Winter"
				})
				.expectChange("name", "Frederic Winter")
				.expectChange("title", "Fourth Title");

			return Promise.all([
				// code under test
				oActionBinding.setParameter("TeamID", "TEAM_02").invoke()
					.then(function (oReturnValueContext) {
						assert.strictEqual(oReturnValueContext.getPath(), "/EMPLOYEES('2')");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: updates for advertised action (as an object) caused by: refresh, side effect of
	// edit, bound action
	// CPOUI5UISERVICESV3-905, CPOUI5UISERVICESV3-1714
	QUnit.test("Advertised actions: object updates", function (assert) {
		var oModel = this.createTeaBusiModel(),
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'2\')}" id="form">\
	<Text id="enabled"\
		text="{= %{#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable} ? 1 : 0 }"/>\
	<Input id="name" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')", {
				"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {},
				ID : "2",
				Name : "Frederic Fall"
			})
			.expectChange("enabled", 1)
			.expectChange("name", "Frederic Fall");

		return this.createView(assert, sView, oModel).then(function () {
			var oContextBinding = that.oView.byId("form").getObjectBinding();

			that.expectRequest("EMPLOYEES('2')", {
					"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : null,
					ID : "2",
					Name : "Frederic Fall"
				})
				// Note: "<code>false</code> to enforce listening to a template control" --> use 0!
				.expectChange("enabled", 0);

			// code under test
			oContextBinding.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					payload : {Name : "Frederic Spring"},
					url : "EMPLOYEES('2')"
				}, {
					"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {}
					// ID : "2",
					// Name : "Frederic Spring"
				})
				.expectChange("enabled", 1)
				.expectChange("name", "Frederic Spring");

			// code under test
			that.oView.byId("name").getBinding("value").setValue("Frederic Spring");

			return that.waitForChanges(assert);
		}).then(function () {
			var sActionName = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
				oContext = that.oView.byId("form").getObjectBinding().getBoundContext(),
				oActionBinding = oModel.bindContext(sActionName + "(...)", oContext);

			that.expectRequest({
					method : "POST",
					payload : {TeamID : "TEAM_02"},
					url : "EMPLOYEES('2')/" + sActionName
				}, {
					ID : "2",
					Name : "Frederic Winter"
				})
				.expectChange("enabled", 0)
				.expectChange("name", "Frederic Winter");

			return Promise.all([
				// code under test
				oActionBinding.setParameter("TeamID", "TEAM_02").invoke()
					.then(function (oReturnValueContext) {
						assert.strictEqual(oReturnValueContext.getPath(), "/EMPLOYEES('2')");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: updates for advertised action (as an object) incl. its title caused by bound action
	// (refresh for sure works, side effect of edit works the same as bound action)
	// CPOUI5UISERVICESV3-905, CPOUI5UISERVICESV3-1714
	QUnit.test("Advertised actions: object & title updates", function (assert) {
		var oActionBinding,
			sActionName = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
			oModel = this.createTeaBusiModel(),
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'2\')}" id="form">\
	<Text id="enabled"\
		text="{= %{#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable} ? 1 : 0 }"/>\
	<Text id="title" text="{\
		path : \'#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable/title\',\
		type : \'sap.ui.model.odata.type.String\'}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')", {
				"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {
					title : "First Title"
				},
				ID : "2"
			})
			.expectChange("enabled", 1)
			.expectChange("title", "First Title");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("form").getObjectBinding().getBoundContext();

			oActionBinding = oModel.bindContext(sActionName + "(...)", oContext);
			that.expectRequest({
					method : "POST",
					payload : {},
					url : "EMPLOYEES('2')/" + sActionName
				}, {ID : "2"})
				.expectChange("enabled", 0)
				.expectChange("title", null);

			return Promise.all([
				// code under test
				oActionBinding.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					payload : {},
					url : "EMPLOYEES('2')/" + sActionName
				}, {
					"#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsAvailable" : {
						title : "Second Title"
					},
					ID : "2"
				})
				.expectChange("enabled", 1)
				.expectChange("title", "Second Title");

			return Promise.all([
				// code under test
				oActionBinding.invoke().then(function (oReturnValueContext) {
						assert.strictEqual(oReturnValueContext.getPath(), "/EMPLOYEES('2')");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: list/detail with V2 adapter where the detail URI must be adjusted for V2
	// Additionally properties of a contained complex type are used with auto-$expand/$select
	QUnit.test("V2 adapter: list/detail", function (assert) {
		var oModel = this.createModelForV2FlightService({autoExpandSelect : true}),
			sView = '\
<Table id="list" items="{/FlightCollection}">\
	<Text id="carrid" text="{carrid}"/>\
</Table>\
<FlexBox id="detail" binding="{}">\
	<Text id="cityFrom" text="{flightDetails/cityFrom}"/>\
	<Text id="cityTo" text="{flightDetails/cityTo}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("FlightCollection?$select=carrid,connid,fldate&$skip=0&$top=100", {
				d : {
					results : [{
						__metadata : {type : "RMTSAMPLEFLIGHT.Flight"},
						carrid : "AA",
						connid : "0017",
						fldate : "/Date(1502323200000)/"
					}]
				}
			})
			.expectChange("carrid", ["AA"])
			.expectChange("cityFrom") // expect a later change
			.expectChange("cityTo"); // expect a later change

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("list").getItems()[0].getBindingContext();

			// 'flightDetails' is added to the table row
			that.expectRequest("FlightCollection(carrid='AA',connid='0017',fldate=datetime"
					+ "'2017-08-10T00%3A00%3A00')?$select=flightDetails", {
					d : {
						__metadata : {type : "RMTSAMPLEFLIGHT.Flight"},
						flightDetails : {
							__metadata : {type : "RMTSAMPLEFLIGHT.FlightDetails"},
							cityFrom : "New York",
							cityTo : "Los Angeles"
						}
					}
				})
				.expectChange("cityFrom", "New York")
				.expectChange("cityTo", "Los Angeles");

			that.oView.byId("detail").setBindingContext(oContext);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="GET"> in V2 Adapter
	// Usage of service: /sap/opu/odata/IWFND/RMTSAMPLEFLIGHT/
	QUnit.test("V2 Adapter: FunctionImport", function (assert) {
		var oModel = this.createModelForV2FlightService(),
			that = this;

		// code under test
		return this.createView(assert, "", oModel).then(function () {
			var oContextBinding = oModel.bindContext("/GetAvailableFlights(...)");

			that.expectRequest("GetAvailableFlights?fromdate=datetime'2017-08-10T00:00:00'"
					+ "&todate=datetime'2017-08-10T23:59:59'"
					+ "&cityfrom='new york'&cityto='SAN FRANCISCO'", {
					d : {
						results : [{
							__metadata : {type : "RMTSAMPLEFLIGHT.Flight"},
							carrid : "AA",
							connid : "0017",
							fldate : "/Date(1502323200000)/"
						}, {
							__metadata : {type : "RMTSAMPLEFLIGHT.Flight"},
							carrid : "DL",
							connid : "1699",
							fldate : "/Date(1502323200000)/"
						}, {
							__metadata : {type : "RMTSAMPLEFLIGHT.Flight"},
							carrid : "UA",
							connid : "3517",
							fldate : "/Date(1502323200000)/"
						}]
					}
				});

			return Promise.all([
				oContextBinding
					.setParameter("fromdate", "2017-08-10T00:00:00Z")
					.setParameter("todate", "2017-08-10T23:59:59Z")
					.setParameter("cityfrom", "new york")
					.setParameter("cityto", "SAN FRANCISCO")
					.invoke(),
				that.waitForChanges(assert)
			]).then(function () {
				var oListBinding = oModel.bindList("value", oContextBinding.getBoundContext()),
					aContexts = oListBinding.getContexts(0, Infinity);

				aContexts.forEach(function (oContext, i) {
					// Note: This just illustrates the status quo. It is not meant to say this must
					// be kept stable.
					assert.strictEqual(oContext.getPath(), "/GetAvailableFlights(...)/value/" + i);
					assert.strictEqual(oContext.getProperty("fldate"), "2017-08-10T00:00:00Z");
				});
			});
		});
	});

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="GET" ReturnType="Edm.DateTime"> in V2 Adapter
	QUnit.test("V2 Adapter: bound function returns primitive", function (assert) {
		var oModel = this.createModelForV2FlightService(),
			sView = '\
<FlexBox binding="{/NotificationCollection(\'foo\')}">\
	<Text id="updated" text="{= %{updated} }"/>\
	<FlexBox id="function" binding="{RMTSAMPLEFLIGHT.__FAKE__FunctionImport(...)}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="value" text="{= %{value} }"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("NotificationCollection('foo')", {
				d : {
					__metadata : {type : "RMTSAMPLEFLIGHT.Notification"},
					ID : "foo",
					updated : "/Date(1502323200000)/"
				}
			})
			.expectChange("updated", "2017-08-10T00:00:00Z")
			.expectChange("value", undefined);

		// code under test
		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("__FAKE__FunctionImport?ID='foo'", {
					d : { // Note: DataServiceVersion : 1.0
						__FAKE__FunctionImport : "/Date(1502323200000)/"
					}
				})
				.expectChange("value", "2017-08-10T00:00:00Z");

			return Promise.all([
				that.oView.byId("function").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		});
	});
	//TODO support also "version 2.0 JSON representation of a property"?

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="GET" ReturnType="Collection(Edm.DateTime)"> in V2
	// Adapter
	// Usage of service: /sap/opu/odata/IWFND/RMTSAMPLEFLIGHT/
	QUnit.test("V2 Adapter: FunctionImport returns Collection(Edm.DateTime)", function (assert) {
		var oModel = this.createModelForV2FlightService(),
			that = this;

		// code under test
		return this.createView(assert, "", oModel).then(function () {
			var oContextBinding = oModel.bindContext("/__FAKE__GetAllFlightDates(...)");

			that.expectRequest("__FAKE__GetAllFlightDates", {
					d : { // Note: DataServiceVersion : 2.0
						results : [
							"/Date(1502323200000)/",
							"/Date(1502323201000)/",
							"/Date(1502323202000)/"
						]
					}
				});

			return Promise.all([
				oContextBinding.invoke(),
				that.waitForChanges(assert)
			]).then(function () {
				var oListBinding = oModel.bindList("value", oContextBinding.getBoundContext()),
					aContexts = oListBinding.getContexts(0, Infinity);

				aContexts.forEach(function (oContext, i) {
					// Note: This just illustrates the status quo. It is not meant to say this must
					// be kept stable.
					assert.strictEqual(oContext.getPath(),
						"/__FAKE__GetAllFlightDates(...)/value/" + i);
					assert.strictEqual(oContext.getProperty(""), "2017-08-10T00:00:0" + i + "Z");
				});
			});
		});
	});

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="GET" ReturnType="Collection(FlightDetails)"> in V2
	// Adapter
	// Usage of service: /sap/opu/odata/IWFND/RMTSAMPLEFLIGHT/
	QUnit.test("V2 Adapter: FunctionImport returns Collection(ComplexType)", function (assert) {
		var oModel = this.createModelForV2FlightService(),
			that = this;

		// code under test
		return this.createView(assert, "", oModel).then(function () {
			var oContextBinding = oModel.bindContext("/__FAKE__GetFlightDetailsByCarrier(...)");

			that.expectRequest("__FAKE__GetFlightDetailsByCarrier?carrid='AA'", {
					d : { // Note: DataServiceVersion : 2.0
						results : [{
							__metadata : { // just like result of GetFlightDetails
								type : "RMTSAMPLEFLIGHT.FlightDetails"
							},
							arrivalTime : "PT14H00M00S",
							departureTime : "PT11H00M00S"
						}, {
							__metadata : {type : "RMTSAMPLEFLIGHT.FlightDetails"},
							arrivalTime : "PT14H00M01S",
							departureTime : "PT11H00M01S"
						}, {
							__metadata : {type : "RMTSAMPLEFLIGHT.FlightDetails"},
							arrivalTime : "PT14H00M02S",
							departureTime : "PT11H00M02S"
						}]
					}
				});

			return Promise.all([
				oContextBinding.setParameter("carrid", "AA").invoke(),
				that.waitForChanges(assert)
			]).then(function () {
				var oListBinding = oModel.bindList("value", oContextBinding.getBoundContext()),
					aContexts = oListBinding.getContexts(0, Infinity);

				aContexts.forEach(function (oContext, i) {
					// Note: This just illustrates the status quo. It is not meant to say this must
					// be kept stable.
					assert.strictEqual(oContext.getPath(),
						"/__FAKE__GetFlightDetailsByCarrier(...)/value/" + i);
					assert.strictEqual(oContext.getProperty("arrivalTime"), "14:00:0" + i);
					assert.strictEqual(oContext.getProperty("departureTime"), "11:00:0" + i);
				});
			});
		});
	});

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="GET" sap:action-for="..."> in V2 Adapter
	// Usage of service: /sap/opu/odata/IWFND/RMTSAMPLEFLIGHT/
	//TODO $metadata of <FunctionImport> is broken, key properties and parameters do not match!
	// --> server expects GetFlightDetails?airlineid='AA'&connectionid='0017'&fldate=datetime'...'
	QUnit.test("V2 Adapter: bound function", function (assert) {
		var oModel = this.createModelForV2FlightService(),
			sView = '\
<FlexBox binding="{/FlightCollection(carrid=\'AA\',connid=\'0017\',fldate=2017-08-10T00:00:00Z)}">\
	<Text id="carrid" text="{carrid}"/>\
	<FlexBox id="function" binding="{RMTSAMPLEFLIGHT.GetFlightDetails(...)}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="distance" text="{distance}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("FlightCollection(carrid='AA',connid='0017'"
				+ ",fldate=datetime'2017-08-10T00%3A00%3A00')", {
				d : {
					__metadata : {type : "RMTSAMPLEFLIGHT.Flight"},
					carrid : "AA",
					connid : "0017",
					fldate : "/Date(1502323200000)/"
				}
			})
			.expectChange("carrid", "AA")
			.expectChange("distance", null);

		// code under test
		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("GetFlightDetails?carrid='AA'&connid='0017'"
					+ "&fldate=datetime'2017-08-10T00:00:00'", {
					d : {
						GetFlightDetails : {
							__metadata : {type : "RMTSAMPLEFLIGHT.FlightDetails"},
							countryFrom : "US",
							cityFrom : "new york",
							airportFrom : "JFK",
							countryTo : "US",
							cityTo : "SAN FRANCISCO",
							airportTo : "SFO",
							flightTime : 361,
							departureTime : "PT11H00M00S",
							arrivalTime : "PT14H01M00S",
							distance : "2572.0000",
							distanceUnit : "SMI",
							flightType : "",
							period : 0
						}
					}
				})
				.expectChange("distance", "2,572.0000");

			return Promise.all([
				that.oView.byId("function").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="POST"> in V2 Adapter
	QUnit.test("V2 Adapter: ActionImport", function (assert) {
		var oContextBinding,
			oModel = this.createModelForV2FlightService(),
			that = this;

		// code under test
		return this.createView(assert, "", oModel).then(function () {
			oContextBinding = oModel.bindContext("/__FAKE__ActionImport(...)");

			that.expectRequest({
					method : "POST",
					url : "__FAKE__ActionImport?carrid='AA'"
						+ "&guid=guid'0050568D-393C-1ED4-9D97-E65F0F3FCC23'"
						+ "&fldate=datetime'2017-08-10T00:00:00'&flightTime=42"
				}, {
					d : {
						__metadata : {type : "RMTSAMPLEFLIGHT.Flight"},
						carrid : "AA",
						connid : "0017",
						fldate : "/Date(1502323200000)/",
						PRICE : "2222.00",
						SEATSMAX : 320
					}
				});

			return Promise.all([
				oContextBinding
					.setParameter("carrid", "AA")
					.setParameter("guid", "0050568D-393C-1ED4-9D97-E65F0F3FCC23")
					.setParameter("fldate", "2017-08-10T00:00:00Z")
					.setParameter("flightTime", 42)
					.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oContext = oContextBinding.getBoundContext();

			assert.strictEqual(oContext.getProperty("carrid"), "AA");
			assert.strictEqual(oContext.getProperty("connid"), "0017");
			assert.strictEqual(oContext.getProperty("fldate"), "2017-08-10T00:00:00Z");
			assert.strictEqual(oContext.getProperty("SEATSMAX"), 320);

			// Note: this is async due to type retrieval
			return oContext.requestProperty("PRICE", true).then(function (sValue) {
				assert.strictEqual(sValue, "2,222.00");
			});
		});
	});

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="POST" sap:action-for="..."> in V2 Adapter
	// Usage of service: /sap/opu/odata/IWBEP/GWSAMPLE_BASIC/
	QUnit.test("V2 Adapter: bound action", function (assert) {
		var oModel = this.createModelForV2SalesOrderService(),
			sView = '\
<FlexBox binding="{/SalesOrderSet(\'0815\')}">\
	<Text id="id0" text="{SalesOrderID}"/>\
	<FlexBox id="action" binding="{GWSAMPLE_BASIC.SalesOrder_Confirm(...)}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="id1" text="{SalesOrderID}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderSet('0815')", {
				d : {
					__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
					SalesOrderID : "0815"
				}
			})
			.expectChange("id0", "0815")
			.expectChange("id1", null);

		// code under test
		return this.createView(assert, sView, oModel).then(function () {
			var oContextBinding = that.oView.byId("action").getObjectBinding();

			that.expectRequest({
					method : "POST",
					url : "SalesOrder_Confirm?SalesOrderID='0815'"
				}, {
					d : {
						__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
						SalesOrderID : "08/15",
						CreatedAt : "/Date(1502323200000)/"
					}
				})
				.expectChange("id1", "08/15");

			return Promise.all([
				oContextBinding.invoke(),
				that.waitForChanges(assert)
			]).then(function () {
				assert.strictEqual(
					oContextBinding.getBoundContext().getProperty("CreatedAt"),
					"2017-08-10T00:00:00.0000000Z");
			});
		});
	});

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="POST" sap:action-for="..."> in V2 Adapter (w/o
	// reading binding parameter first!)
	// Usage of service: /sap/opu/odata/IWBEP/GWSAMPLE_BASIC/
	QUnit.skip("V2 Adapter: bound action on context w/o read", function (assert) {
		var oModel = this.createModelForV2SalesOrderService(),
			oParentContext = oModel.bindContext("/SalesOrderLineItemSet(\'0815\',\'10\')/ToHeader")
				.getBoundContext(),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			//TODO In the V2 adapter case a function import is used instead of a bound action. So we
			// need the key predicates which sometimes cannot be parsed from the URL. Invoke this
			// request and wait for the result before calling the function import.
			//TODO What about the ETag which might be got from this fresh request? Really use it?
			that.expectRequest("SalesOrderLineItemSet(\'0815\',\'10\')/ToHeader", {
					d : {
						__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
						SalesOrderID : "0815"
					}
				})
				.expectRequest({
					method : "POST",
					url : "SalesOrder_Confirm?SalesOrderID='0815'"
				}, {
					d : {
						__metadata : {type : "GWSAMPLE_BASIC.SalesOrder"},
						SalesOrderID : "08/15"
					}
				});

			return Promise.all([
				// code under test
				oModel.bindContext("GWSAMPLE_BASIC.SalesOrder_Confirm(...)", oParentContext)
					.invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: <FunctionImport m:HttpMethod="PUT" sap:action-for="..."> in V2 Adapter
	// Usage of service: /sap/opu/odata/IWFND/RMTSAMPLEFLIGHT/
	//TODO $metadata of <FunctionImport> is broken, key properties and parameters do not match!
	// --> server expects UpdateAgencyPhoneNo?agency_id='...'
	QUnit.test("V2 Adapter: bound action w/ PUT", function (assert) {
		var oModel = this.createModelForV2FlightService(),
			sView = '\
<FlexBox binding="{/TravelAgencies(\'00000061\')}">\
	<Text id="oldPhone" text="{TELEPHONE}"/>\
	<FlexBox id="action" binding="{RMTSAMPLEFLIGHT.UpdateAgencyPhoneNo(...)}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="newPhone" text="{TELEPHONE}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("TravelAgencies('00000061')", {
				d : {
					__metadata : {type : "RMTSAMPLEFLIGHT.Travelagency"},
					agencynum : "00000061",
					NAME : "Fly High",
					TELEPHONE : "+49 2102 69555"
				}
			})
			.expectChange("oldPhone", "+49 2102 69555")
			.expectChange("newPhone", null);

		// code under test
		return this.createView(assert, sView, oModel).then(function () {
			var oContextBinding = that.oView.byId("action").getObjectBinding();

			that.expectRequest({
					method : "PUT",
					url : "UpdateAgencyPhoneNo?agencynum='00000061'"
						+ "&telephone='%2B49 (0)2102 69555'"
				}, {
					d : {
						__metadata : {type : "RMTSAMPLEFLIGHT.Travelagency"},
						agencynum : "00000061",
						NAME : "Fly High",
						TELEPHONE : "+49 (0)2102 69555"
					}
				})
				.expectChange("newPhone", "+49 (0)2102 69555");

			return Promise.all([
				oContextBinding.setParameter("telephone", "+49 (0)2102 69555").invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Initially suspended context binding is refreshed before resumed
	QUnit.test("suspend/refresh/resume", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{path : \'/Equipments(Category=\\\'Electronics\\\',ID=1)\', \
		suspended : true}">\
	<Text id="text" text="{Category}"/>\
</FlexBox>',
			that = this;

		this.expectChange("text"); // expect no change initially

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("form").getObjectBinding();

			that.expectRequest("Equipments(Category='Electronics',ID=1)"
					+ "?$select=Category,ID", {
					Category : "Electronics",
					ID : 1
				})
				.expectChange("text", "Electronics");

			oBinding.refresh();
			oBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: FlexBox with initially suspended context binding is changed by adding and removing
	//   a form field. After resume, one request reflecting the changes is sent and the added field
	//   is updated.
	[false, true].forEach(function (bRefresh) {
		var sTitle = "suspend/resume: changes for suspended context binding, refresh=" + bRefresh;

		QUnit.test(sTitle, function (assert) {
			var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
				sView = '\
<FlexBox id="form" binding="{path : \'/Equipments(Category=\\\'Electronics\\\',ID=1)\', \
		suspended : true}">\
	<Text id="idCategory" text="{Category}"/>\
	<Text id="idEmployeeId" text="{EmployeeId}"/>\
</FlexBox>',
				that = this;

			this.expectChange("idCategory"); // expect no change initially

			return this.createView(assert, sView, oModel).then(function () {
				var oForm = that.oView.byId("form"),
					sId;

				sId = that.addToForm(oForm, "Name", assert);
				that.removeFromForm(oForm, "idEmployeeId");
				that.expectRequest("Equipments(Category='Electronics',ID=1)"
						+ "?$select=Category,ID,Name", {
						Category : "Electronics",
						ID : 1,
						Name : "Office PC"
					})
					.expectChange("idCategory", "Electronics")
					.expectChange(sId, "Office PC");

				if (bRefresh) {
					oForm.getObjectBinding().refresh();
				}
				oForm.getObjectBinding().resume();

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Minimal test for an absolute ODataPropertyBinding. This scenario is comparable with
	// "FavoriteProduct" in the SalesOrders application.
	testViewStart("V2 Adapter: Absolute ODataPropertyBinding",
		'<Text id="text" text="{= %{/ProductSet(\'HT-1000\')/CreatedAt} }"/>',
		{"ProductSet('HT-1000')/CreatedAt" : {d : {CreatedAt : "/Date(1502323200000)/"}}},
		{text : "2017-08-10T00:00:00.0000000Z"},
		"createModelForV2SalesOrderService"
	);

	//*********************************************************************************************
	// Scenario: Absolute ODataPropertyBinding with custom query options. CPOUI5UISERVICESV3-1590.
	testViewStart("Absolute ODataPropertyBinding with custom query options",
		'<Text id="text" text="{path : \'/TEAMS(\\\'42\\\')/Name\',\
			parameters : {custom : \'foo\', c2 : \'x\'}}"/>',
		{"TEAMS('42')/Name?c1=a&c2=x&custom=foo" : {value : "Business Suite"}},
		{text : "Business Suite"},
		function () {
			return this.createModel(sTeaBusi + "?c1=a&c2=b", {}, {
					"/sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001/$metadata?c1=a&c2=b"
						: {source : "odata/v4/data/metadata.xml"}
				});
		}
	);

	//*********************************************************************************************
	// Scenario: Relative ODataPropertyBinding with parameters like custom query options or
	// $$groupId never sends own request. CPOUI5UISERVICESV3-1590.
	testViewStart("Relative ODataPropertyBinding with parameters",
		'<FlexBox binding="{/TEAMS(\'42\')}">\
			<Text id="text" text="{path : \'Name\',\
				parameters : {custom : \'foo\', $$groupId : \'binding\'}}"/>\
		</FlexBox>',
		{"TEAMS('42')" : {Name : "Business Suite"}}, {text : "Business Suite"}, "createTeaBusiModel"
	);

	//*********************************************************************************************
	// Scenario: Table with suspended list binding is changed by adding and removing a column. After
	//   resume, a request reflecting the changes is sent.
	[false, true].forEach(function (bRefresh) {
		var sTitle = "suspend/resume: suspended list binding, refresh=" + bRefresh;

		QUnit.test(sTitle, function (assert) {
			var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
				sView = '\
<Table id="table" items="{path : \'/Equipments\', suspended : true}">\
	<Text id="idCategory" text="{Category}"/>\
	<Text id="idEmployeeId" text="{EmployeeId}"/>\
</Table>',
				that = this;

			this.expectChange("idCategory", [])
				.expectChange("idEmployeeId", []);

			return this.createView(assert, sView, oModel).then(function () {
				var sId0,
					sId1,
					oTable = that.oView.byId("table"),
					oTableBinding;

				that.expectCanceledError("Cache discarded as a new cache has been created");

				// Note: each of these is causing a "rebind"
				sId0 = that.addToTable(oTable, "Name", assert);
				sId1 = that.addToTable(oTable, "EQUIPMENT_2_EMPLOYEE/Name", assert);
				that.removeFromTable(oTable, "idEmployeeId");

				that.expectRequest("Equipments?$select=Category,ID,Name"
						+ "&$expand=EQUIPMENT_2_EMPLOYEE($select=ID,Name)&$skip=0&$top=100", {
						value : [{
							Category : "Electronics",
							ID : 1,
							Name : "Office PC",
							EQUIPMENT_2_EMPLOYEE : {
								ID : "2",
								Name : "Frederic Fall"
							}
						}, {
							Category : "Vehicle",
							ID : 2,
							Name : "VW Golf 2.0",
							EQUIPMENT_2_EMPLOYEE : {
								ID : "3",
								Name : "Jonathan Smith"
							}
						}]
					})
					.expectChange("idCategory", ["Electronics", "Vehicle"])
					.expectChange(sId0, ["Office PC", "VW Golf 2.0"])
					.expectChange(sId1, ["Frederic Fall", "Jonathan Smith"]);

				oTableBinding = oTable.getBinding("items");
				if (bRefresh) {
					oTableBinding.refresh();
				}
				oTableBinding.resume();

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: FlexBox with context binding is suspended after initialization and then changed by
	//   adding and removing a form field. After resume, a new request reflecting the changes is
	//   sent and the added field is updated.
	[false, true].forEach(function (bRefresh) {
		var sTitle = "suspend/resume: *not* suspended context binding, refresh=" + bRefresh;

		QUnit.test(sTitle, function (assert) {
			var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
				sView = '\
<FlexBox id="form" binding="{/Equipments(Category=\'Electronics\',ID=1)}">\
	<Text id="idCategory" text="{Category}"/>\
	<Text id="idEmployeeId" text="{EmployeeId}"/>\
</FlexBox>',
				that = this;

			this.expectRequest("Equipments(Category='Electronics',ID=1)"
					+ "?$select=Category,EmployeeId,ID", {
					Category : "Electronics",
					EmployeeId : "0001",
					ID : 1
				})
				.expectChange("idCategory", "Electronics")
				.expectChange("idEmployeeId", "0001");

			return this.createView(assert, sView, oModel).then(function () {
				var oForm = that.oView.byId("form"),
					sId;

				oForm.getObjectBinding().suspend();
				sId = that.addToForm(oForm, "Name", assert);
				that.removeFromForm(oForm, "idEmployeeId");
				that.expectRequest("Equipments(Category='Electronics',ID=1)?$select="
						// late property request does not need keys
						+ (bRefresh ? "Category,ID,Name" : "Name"), {
						Category : "Electronics",
						ID : 1,
						Name : "Office PC"
					})
					.expectChange(sId, "Office PC");

				if (bRefresh) {
					oForm.getObjectBinding().refresh();
				}

				return Promise.all([
					oForm.getObjectBinding().resumeAsync(),
					that.waitForChanges(assert)
				]);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Table with list binding is suspended after initialization and then changed by
	//   adding and removing a column. After resume, a new request reflecting the changes is
	//   sent and the added column is updated.
	[false, true].forEach(function (bRefresh) {
		var sTitle = "suspend/resume: *not* suspended list binding; refresh=" + bRefresh;

		QUnit.test(sTitle, function (assert) {
			var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
				sView = '\
<Table id="table" items="{/Equipments}">\
	<Text id="idCategory" text="{Category}"/>\
	<Text id="idEmployeeId" text="{EmployeeId}"/>\
</Table>',
				that = this;

			this.expectRequest("Equipments?$select=Category,EmployeeId,ID&$skip=0&$top=100", {
					value : [{
						Category : "Electronics",
						EmployeeId : "0001",
						ID : 1
					}, {
						Category : "Vehicle",
						EmployeeId : "0002",
						ID : 2
					}]
				})
				.expectChange("idCategory", ["Electronics", "Vehicle"])
				.expectChange("idEmployeeId", ["0001", "0002"]);

			return this.createView(assert, sView, oModel).then(function () {
				var sId0,
					sId1,
					oTable = that.oView.byId("table"),
					oTableBinding;

				that.expectCanceledError("Cache discarded as a new cache has been created");

				// Note: each of these is causing a "rebind"
				sId0 = that.addToTable(oTable, "Name", assert);
				sId1 = that.addToTable(oTable, "EQUIPMENT_2_EMPLOYEE/Name", assert);
				that.removeFromTable(oTable, "idEmployeeId");

				that.expectRequest("Equipments?$select=Category,ID,Name"
						+ "&$expand=EQUIPMENT_2_EMPLOYEE($select=ID,Name)&$skip=0&$top=100", {
						value : [{
							Category : "Electronics",
							ID : 1,
							Name : "Office PC",
							EQUIPMENT_2_EMPLOYEE : {
								ID : "2",
								Name : "Frederic Fall"
							}
						}, {
							Category : "Vehicle",
							ID : 2,
							Name : "VW Golf 2.0",
							EQUIPMENT_2_EMPLOYEE : {
								ID : "3",
								Name : "Jonathan Smith"
							}
						}]
					})
					.expectChange("idCategory", ["Electronics", "Vehicle"])
					.expectChange(sId0, ["Office PC", "VW Golf 2.0"])
					.expectChange(sId1, ["Frederic Fall", "Jonathan Smith"]);

				oTableBinding = oTable.getBinding("items");
				if (bRefresh) {
					oTableBinding.refresh();
				}
				oTableBinding.resume();

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Outer form with context binding is suspended after initialization; outer form
	//   contains inner form. Both forms are then changed by adding and removing a form field.
	//   After resume, a new request reflecting the changes is sent and the added fields are
	//   updated.
	QUnit.test("suspend/refresh/resume: dependent context bindings", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="outerForm" binding="{/Equipments(Category=\'Electronics\',ID=1)}">\
	<Text id="idEquipmentName" text="{Name}"/>\
	<FlexBox id="innerForm" binding="{EQUIPMENT_2_EMPLOYEE}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="idEmployeeName" text="{Name}"/>\
		<Text id="idManagerId" text="{MANAGER_ID}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("Equipments(Category='Electronics',ID=1)?$select=Category,ID,Name"
				+ "&$expand=EQUIPMENT_2_EMPLOYEE($select=ID,MANAGER_ID,Name)", {
				Category : "Electronics",
				ID : 1,
				Name : "Office PC",
				EQUIPMENT_2_EMPLOYEE : {
					ID : "2",
					MANAGER_ID : "5",
					Name : "Frederic Fall"
				}
			})
			.expectChange("idEquipmentName", "Office PC")
			.expectChange("idEmployeeName", "Frederic Fall")
			.expectChange("idManagerId", "5");

		return this.createView(assert, sView, oModel).then(function () {
			var oOuterForm = that.oView.byId("outerForm"),
				sIdEmployeeId,
				sIdAge,
				oInnerForm = that.oView.byId("innerForm");

			oOuterForm.getObjectBinding().suspend();
			sIdEmployeeId = that.addToForm(oOuterForm, "EmployeeId", assert);
			that.removeFromForm(oOuterForm, "idEquipmentName");
			sIdAge = that.addToForm(oInnerForm, "AGE", assert);
			that.removeFromForm(oInnerForm, "idManagerId");
			that.expectRequest("Equipments(Category='Electronics',ID=1)"
					+ "?$select=Category,EmployeeId,ID"
					+ "&$expand=EQUIPMENT_2_EMPLOYEE($select=AGE,ID,Name)", {
					Category : "Electronics",
					EmployeeId : "0002",
					ID : "1",
					EQUIPMENT_2_EMPLOYEE : {
						AGE : 32,
						ID : "2",
						Name : "Frederic Fall"
					}
				})
				.expectChange(sIdEmployeeId, "0002")
				.expectChange(sIdAge, "32");

			return Promise.all([
				oOuterForm.getObjectBinding().requestRefresh(),
				oOuterForm.getObjectBinding().resumeAsync(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: suspend/resume within the following use cases:
	// 1. suspend/resume without any changes -> no request
	// 2. suspend/resume with removed UI controls -> no requests
	//
	// JIRA: CPOUI5ODATAV4-227
	QUnit.test("suspend/resume: no unneeded requests", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oOuterForm,
			sView = '\
<FlexBox id="outerForm" binding="{/Equipments(Category=\'Electronics\',ID=1)}">\
	<Text id="idEquipmentName" text="{Name}"/>\
	<FlexBox id="innerForm" binding="{EQUIPMENT_2_EMPLOYEE}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="idEmployeeName" text="{Name}"/>\
		<Text id="idManagerId" text="{MANAGER_ID}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("Equipments(Category='Electronics',ID=1)?$select=Category,ID,Name"
				+ "&$expand=EQUIPMENT_2_EMPLOYEE($select=ID,MANAGER_ID,Name)", {
				Category : "Electronics",
				ID : 1,
				EQUIPMENT_2_EMPLOYEE : {
					ID : "2",
					MANAGER_ID : "5",
					Name : "Frederic Fall"
				},
				Name : "Office PC"
			})
			.expectChange("idEquipmentName", "Office PC")
			.expectChange("idEmployeeName", "Frederic Fall")
			.expectChange("idManagerId", "5");

		return this.createView(assert, sView, oModel).then(function () {
			oOuterForm = that.oView.byId("outerForm");

			oOuterForm.getObjectBinding().suspend();

			// code under test
			oOuterForm.getObjectBinding().resume();

			return that.waitForChanges(assert, "1. without any changes -> no request");
		}).then(function () {
			var oInnerForm = that.oView.byId("innerForm");

			oOuterForm.getObjectBinding().suspend();
			that.removeFromForm(oInnerForm, "idEmployeeName");

			// code under test
			oOuterForm.getObjectBinding().resume();

			return that.waitForChanges(assert, "2. remove property -> no request");
		});
	});

	//*********************************************************************************************
	// Scenario: Given an object page that contains a form and a table we test suspend/resume on
	// the root binding and the use cases:
	// 1. initially suspended root binding -> requests data for the object page in one request
	// 2. suspend/resume w/o changes -> no request
	// 3. suspend/resume with changes on the dependent ODLB:
	//    a. filter API -> ODLB has own cache
	//    b. sort API -> ODLB has own cache
	//    c. changeParameters API -> ODLB has own cache
	//    d. setAggregation API -> ODLB has own cache
	//    e. remove all filters/sorters/parameters and change the root ODCB
	//       -> ODLB uses parent cache
	// 4. suspend/resume with changes on the dependent ODCB:
	//    a. adding a property to the dependent ODCB -> late property request
	//    b. adding a custom parameter -> ODCB has own cache
	//    c. removing custom parameter -> ODCB uses parent cache, no request
	//    d. adding a custom parameter to ODCB & root ODCB -> ODCB has own cache, two requests
	//    e. removing the custom parameter and change the root ODCB -> ODCB uses parent cache
	// JIRA: CPOUI5ODATAV4-227
	QUnit.test("suspend/resume: dependent binding hierarchy w/o own cache only refreshes changed"
			+ " parts", function (assert) {
		var oFormBinding,
			sIdTeam,
			oInnerFormBinding,
			oListBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{path : \'/TEAMS(\\\'TEAM_01\\\')\', suspended : true}">\
	<Text id="memberCount" text="{MEMBER_COUNT}"/>\
	<FlexBox id="manager" binding="{TEAM_2_MANAGER}">\
		<Text id="managerID" text="{ID}"/>\
	</FlexBox>\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Text id="age" text="{AGE}"/>\
		<Text id="name" text="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("memberCount")
			.expectChange("managerID")
			.expectChange("age", [])
			.expectChange("name", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("TEAMS('TEAM_01')?$select=MEMBER_COUNT,Team_Id"
					+ "&$expand=TEAM_2_EMPLOYEES($select=AGE,ID,Name),TEAM_2_MANAGER($select=ID)", {
					MEMBER_COUNT : 2,
					Team_Id : "TEAM_01",
					TEAM_2_EMPLOYEES : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}],
					TEAM_2_MANAGER : {
						ID : "4711"
					}
				})
				.expectChange("memberCount", "2")
				.expectChange("managerID", "4711")
				.expectChange("age", ["52", "56"])
				.expectChange("name", ["Frederic Fall", "Jonathan Smith"]);

			oFormBinding = that.oView.byId("form").getObjectBinding();

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "1. initially suspended");
		}).then(function () {
			oFormBinding.suspend();

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "2. suspend/resume w/o changes");
		}).then(function () {
			oListBinding = that.oView.byId("table").getBinding("items");

			oFormBinding.suspend();
			oListBinding.filter(new Filter("AGE", FilterOperator.GT, 42));
			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=AGE,ID,Name"
					+ "&$filter=AGE gt 42&$skip=0&$top=100", {
					value : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}]
				});

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "3a. filter API");
		}).then(function () {
			oFormBinding.suspend();
			oListBinding.sort(new Sorter("Name"));
			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=AGE,ID,Name"
					+ "&$filter=AGE gt 42&$orderby=Name&$skip=0&$top=100", {
					value : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}]
				});

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "3b. sort API");
		}).then(function () {
			oFormBinding.suspend();
			oListBinding.changeParameters({custom : "foo"});
			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=AGE,ID,Name"
					+ "&$filter=AGE gt 42&$orderby=Name&custom=foo&$skip=0&$top=100", {
					value : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}]
				});

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "3c. changeParameters API");
		}).then(function () {
			oFormBinding.suspend();
			oListBinding.setAggregation({aggregate : {AGE : {}}});

			// code under test
			assert.deepEqual(oListBinding.getAggregation(/*bVerbose*/true), {
				aggregate : {
					AGE : {}
				},
				group : {},
				groupLevels : []
			}, "JIRA: CPOUI5ODATAV4-1825 & CPOUI5ODATAV4-1961");

			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?custom=foo&$apply=aggregate(AGE)"
					+ "&$orderby=Name&$filter=AGE gt 42&$skip=0&$top=100", {
					value : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}]
				});

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "3d. setAggregation API");
		}).then(function () {
			oFormBinding.suspend();
			oListBinding.setAggregation(undefined);
			oListBinding.changeParameters({custom : undefined});
			oListBinding.sort([]);
			oListBinding.filter([]);
			oFormBinding.changeParameters({custom : "foo"});

			// code under test
			assert.strictEqual(oListBinding.getAggregation(), undefined,
				"JIRA: CPOUI5ODATAV4-1825");

			that.expectRequest("TEAMS('TEAM_01')?custom=foo&$select=MEMBER_COUNT,Team_Id"
					+ "&$expand=TEAM_2_EMPLOYEES($select=AGE,ID,Name),TEAM_2_MANAGER($select=ID)", {
					MEMBER_COUNT : 2,
					Team_Id : "TEAM_01",
					TEAM_2_EMPLOYEES : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}],
					TEAM_2_MANAGER : {
						ID : "4711"
					}
				});

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "3e. Remove all changes from ODLB and change ODCB");
		}).then(function () {
			var oInnerForm = that.oView.byId("manager");

			oFormBinding.suspend();
			sIdTeam = that.addToForm(oInnerForm, "TEAM_ID", assert);

			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_MANAGER?custom=foo&$select=ID,TEAM_ID", {
					ID : "4711",
					TEAM_ID : "TEAM_01"
				})
				.expectChange(sIdTeam, "TEAM_01");

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "4a. Adding a property to the dependent ODCB");
		}).then(function () {
			oInnerFormBinding = that.oView.byId("manager").getObjectBinding();

			oFormBinding.suspend();
			oInnerFormBinding.changeParameters({custom0 : "bar"});

			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_MANAGER?custom0=bar&$select=ID,TEAM_ID", {
					ID : "4711",
					TEAM_ID : "TEAM_01 (custom0)"
				})
				.expectChange(sIdTeam, "TEAM_01 (custom0)");

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "4b. add custom parameter to ODCB");
		}).then(function () {
			oFormBinding.suspend();
			oInnerFormBinding.changeParameters({custom0 : undefined});

			// Note: ODCB can again use the parent cache.
			// -> As the data is already available no new request is sent
			that.expectChange(sIdTeam, "TEAM_01");

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "4c. remove custom parameter from ODCB");
		}).then(function () {
			oFormBinding.suspend();
			oFormBinding.changeParameters({custom : "bar"});
			oInnerFormBinding.changeParameters({custom0 : "foo"});

			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_MANAGER?custom0=foo&$select=ID,TEAM_ID", {
					ID : "4711",
					TEAM_ID : "TEAM_01"
				})
				.expectRequest("TEAMS('TEAM_01')?custom=bar&$select=MEMBER_COUNT,Team_Id"
					+ "&$expand=TEAM_2_EMPLOYEES($select=AGE,ID,Name)", {
					MEMBER_COUNT : 2,
					Team_Id : "TEAM_01",
					TEAM_2_EMPLOYEES : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}]
				});

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert, "4d. add custom parameter to ODCB and root ODCB");
		}).then(function () {
			oFormBinding.suspend();
			oFormBinding.changeParameters({custom : "foo"});
			oInnerFormBinding.changeParameters({custom0 : undefined});

			that.expectRequest("TEAMS('TEAM_01')?custom=foo&$select=MEMBER_COUNT,Team_Id"
					+ "&$expand=TEAM_2_EMPLOYEES($select=AGE,ID,Name)"
						+ ",TEAM_2_MANAGER($select=ID,TEAM_ID)", {
					MEMBER_COUNT : 2,
					Team_Id : "TEAM_01",
					TEAM_2_EMPLOYEES : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}],
					TEAM_2_MANAGER : {
						ID : "4711",
						TEAM_ID : "TEAM_01"
					}
				});

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert,
				"4e. remove custom parameter from ODCB and change root ODCB");
		});
	});

	//*********************************************************************************************
	// Scenario: suspend/resume on a root binding (w/o autoExpandSelect)
	// Change the $expand/select parameters on both both ODCB and ODLB. Afterwards both bindings
	// get their own cache and send own requests.
	// JIRA: CPOUI5ODATAV4-227
	//
	// The form contains an input field where an invalid value is set. Expect messages on the UI and
	// an invalid data state. After resuming the invalid value shall be removed and the model value
	// shall be visible (esp. also if this value is the previous binding value).
	QUnit.test("suspend/resume (w/o autoExpandSelect) change $expand/$select on ODCB and ODLB",
			function (assert) {
		var oFormBinding,
			oModel = this.createTeaBusiModel({}),
			sView = '\
<FlexBox id="form" binding="{path : \'/TEAMS(\\\'TEAM_01\\\')\', \
		parameters : {\
			$expand : {\'TEAM_2_EMPLOYEES\' : {$select : \'AGE,Name\'}},\
			$select : \'BudgetCurrency,MEMBER_COUNT\'}\
		}">\
	<Input id="budgetCurrency" value="{BudgetCurrency}"/>\
	<Text id="memberCount" text="{MEMBER_COUNT}"/>\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Text id="age" text="{AGE}"/>\
		<Text id="name" text="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('TEAM_01')?$expand=TEAM_2_EMPLOYEES($select=AGE,Name)"
				+ "&$select=BudgetCurrency,MEMBER_COUNT", {
				BudgetCurrency : "EUR",
				TEAM_2_EMPLOYEES : [{
					AGE : 52,
					Name : "Frederic Fall"
				}, {
					AGE : 56,
					Name : "Jonathan Smith"
				}],
				MEMBER_COUNT : 2
			})
			.expectChange("memberCount", "2")
			.expectChange("age", ["52", "56"])
			.expectChange("name", ["Frederic Fall", "Jonathan Smith"]);

		return this.createView(assert, sView, oModel).then(function () {
			oFormBinding = that.oView.byId("form").getObjectBinding();

			return that.setInvalidBudgetCurrency(assert);
		}).then(function () {
			oFormBinding.suspend();

			oFormBinding.changeParameters({
				$expand : undefined,
				$select : "BudgetCurrency,Name,MEMBER_COUNT"
			});
			that.oView.byId("table").getBinding("items")
				.changeParameters({$select : "AGE,ID,Name"});

			that.expectRequest("TEAMS('TEAM_01')?$select=BudgetCurrency,Name,MEMBER_COUNT", {
					BudgetCurrency : "EUR",
					Name : "invisible",
					MEMBER_COUNT : 3
				})
				.expectChange("memberCount", "3")
				.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=AGE,ID,Name"
					+ "&$skip=0&$top=100", {
					value : [{
						AGE : 52,
						ID : "1",
						Name : "Frederic Fall"
					}, {
						AGE : 56,
						ID : "3",
						Name : "Jonathan Smith"
					}, {
						AGE : 58,
						ID : "5",
						Name : "John Doe"
					}]
				})
				.expectChange("age", [,, "58"])
				.expectChange("name", [,, "John Doe"]);

			that.expectMessages([]); // validation error has gone

			// code under test
			oFormBinding.resume();

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(that.oView.byId("budgetCurrency").getValue(), "EUR");

			return that.checkValueState(assert, "budgetCurrency", "None", "");
		});
	});

	//*********************************************************************************************
	// Scenario: Outer form with context binding is suspended after initialization; outer form
	//   contains inner table. Both form and table are then changed by adding and removing a form
	//   field resp. a table column.
	//   After resume, a new request reflecting the changes is sent and the added field/column is
	//   updated.
	QUnit.test("suspend/resume: context binding with dependent list binding", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/TEAMS(\'TEAM_01\')}">\
	<Text id="memberCount" text="{MEMBER_COUNT}"/>\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Text id="age" text="{AGE}"/>\
		<Text id="name" text="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('TEAM_01')?$select=MEMBER_COUNT,Team_Id"
				+ "&$expand=TEAM_2_EMPLOYEES($select=AGE,ID,Name)", {
				Team_Id : "TEAM_01",
				MEMBER_COUNT : 2,
				TEAM_2_EMPLOYEES : [{
					ID : "1",
					Name : "Frederic Fall",
					AGE : 52
				}, {
					ID : "3",
					Name : "Jonathan Smith",
					AGE : 56
				}]
			})
			.expectChange("memberCount", "2")
			.expectChange("age", ["52", "56"])
			.expectChange("name", ["Frederic Fall", "Jonathan Smith"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oForm = that.oView.byId("form"),
				sIdManagerId,
				sIdStatus,
				oTable = that.oView.byId("table");

			oForm.getObjectBinding().suspend();
			sIdManagerId = that.addToForm(oForm, "MANAGER_ID", assert);
			that.removeFromForm(oForm, "memberCount");
			sIdStatus = that.addToTable(oTable, "STATUS", assert);
			that.removeFromTable(oTable, "age");
			// late property request for new property MANAGER_ID
			that.expectRequest("TEAMS('TEAM_01')?$select=MANAGER_ID", {
					MANAGER_ID : "3"
				})
				.expectChange(sIdManagerId, "3")
				// complete reload of the table
				.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name,STATUS"
					+ "&$skip=0&$top=100", {
					value : [{
						ID : "1",
						Name : "Frederic Fall",
						STATUS : "Available"
					}, {
						ID : "3",
						Name : "Jonathan Smith",
						STATUS : "Occupied"
					}]
				})
				.expectChange("name", ["Frederic Fall", "Jonathan Smith"])
				.expectChange(sIdStatus, ["Available", "Occupied"]);

			return Promise.all([
				oForm.getObjectBinding().resumeAsync(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Outer form with context binding is suspended after initialization; outer form
	// contains inner table. The inner table is sorted resulting in a different order.
	QUnit.test("suspend/resume: sort dependent list binding", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/TEAMS(\'TEAM_01\')}">\
	<Text id="memberCount" text="{MEMBER_COUNT}"/>\
	<Table id="table" items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$$ownRequest : true}}">\
		<Text id="age" text="{AGE}"/>\
		<Text id="name" text="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('TEAM_01')?$select=MEMBER_COUNT,Team_Id", {
				Team_Id : "TEAM_01",
				MEMBER_COUNT : 2
			})
			.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=AGE,ID,Name"
				+ "&$skip=0&$top=100", {
				value : [{
					ID : "1",
					Name : "Frederic Fall",
					AGE : 56
				}, {
					ID : "3",
					Name : "Jonathan Smith",
					AGE : 52
				}]
			})
			.expectChange("memberCount", "2")
			.expectChange("age", ["56", "52"])
			.expectChange("name", ["Frederic Fall", "Jonathan Smith"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oFormBinding = that.oView.byId("form").getObjectBinding();

			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=AGE,ID,Name&$orderby=AGE"
					+ "&$skip=0&$top=100", {
					value : [{
						ID : "3",
						Name : "Jonathan Smith",
						AGE : 52
					}, {
						ID : "1",
						Name : "Frederic Fall",
						AGE : 56
					}]
				})
				.expectChange("age", ["52", "56"])
				.expectChange("name", ["Jonathan Smith", "Frederic Fall"]);

			oFormBinding.suspend();
			that.oView.byId("table").getBinding("items").sort(new Sorter("AGE"));
			oFormBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Operation binding for a function, first it is deferred, later is has been invoked.
	//   Show interaction of invoke() and suspend()/resume(); setParameter() has been tested
	//   for refresh() already, see test "Function binding: setParameter, invoke and refresh".
	QUnit.test("Function binding: invoke and suspend/resume", function (assert) {
		var oEmployeeBinding,
			sFunctionName = "com.sap.gateway.default.iwbep.tea_busi.v0001"
				+ ".FuGetEmployeeSalaryForecast",
			sView = '\
<FlexBox id="employee" binding="{/EMPLOYEES(\'2\')}">\
	<Text id="salary" text="{SALARY/YEARLY_BONUS_AMOUNT}"/>\
	<FlexBox id="function" binding="{' + sFunctionName + '(...)}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="forecastSalary" text="{SALARY/YEARLY_BONUS_AMOUNT}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')", {
				SALARY : {YEARLY_BONUS_AMOUNT : "100"}
			})
			.expectChange("salary", "100")
			.expectChange("forecastSalary", null);

		return this.createView(assert, sView).then(function () {
			oEmployeeBinding = that.oView.byId("employee").getObjectBinding();
			oEmployeeBinding.suspend();

			// code under test
			oEmployeeBinding.resume();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("EMPLOYEES('2')/" + sFunctionName + "()", {
					SALARY : {YEARLY_BONUS_AMOUNT : "142"}
				})
				.expectChange("forecastSalary", "142");

			return Promise.all([
				that.oView.byId("function").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			oEmployeeBinding.suspend();

			// code under test
			oEmployeeBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: List table with list binding is suspended after initialization. Detail form for
	//   "selected" context from table is then changed by adding and removing a form field; table
	//   remains unchanged.
	//   After resume, *separate* new requests for the list table and the details form are sent;
	//   the request for the form reflects the changes. The field added to the form is updated.
	// JIRA bug 1169
	// Ensure separate requests for list-detail scenarios with auto-$expand/$select and
	// suspend/resume
	QUnit.test("suspend/resume: list binding with details context binding, only context"
			+ " binding is adapted", function (assert) {
		var oForm,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/Equipments}">\
	<Text id="idEquipmentName" text="{Name}"/>\
</Table>\
<FlexBox id="form" binding="{path : \'EQUIPMENT_2_EMPLOYEE\', parameters : {$$ownRequest : true}}">\
	<Text id="name" text="{Name}"/>\
	<Text id="age" text="{AGE}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Equipments?$select=Category,ID,Name&$skip=0&$top=100", {
				value : [{
					Category : "Electronics",
					ID : 1,
					Name : "Office PC"
				}, {
					Category : "Electronics",
					ID : 2,
					Name : "Tablet X"
				}]
			})
			.expectChange("idEquipmentName", ["Office PC", "Tablet X"])
			.expectChange("name")
			.expectChange("age");

		return this.createView(assert, sView, oModel).then(function () {
			oForm = that.oView.byId("form");

			oForm.setBindingContext(that.oView.byId("table").getBinding("items")
				.getCurrentContexts()[0]);

			that.expectRequest("Equipments(Category='Electronics',ID=1)/EQUIPMENT_2_EMPLOYEE"
					+ "?$select=AGE,ID,Name", {
					AGE : 52,
					ID : "2",
					Name : "Frederic Fall"
				})
				.expectChange("name", "Frederic Fall")
				.expectChange("age", "52");

			return that.waitForChanges(assert);
		}).then(function () {
			var sIdManagerId;

			// no change in table, only in contained form
			oForm.getObjectBinding().getRootBinding().suspend();
			sIdManagerId = that.addToForm(oForm, "MANAGER_ID", assert);
			that.removeFromForm(oForm, "age");

			that.expectRequest("Equipments(Category='Electronics',ID=1)/EQUIPMENT_2_EMPLOYEE"
					+ "?$select=ID,MANAGER_ID", {
					ID : "2",
					MANAGER_ID : "1"
				})
				.expectChange(sIdManagerId, "1");

			return Promise.all([
				oForm.getObjectBinding().getRootBinding().resumeAsync(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: call filter, sort, changeParameters on a suspended ODLB
	// JIRA: CPOUI5ODATAV4-102: call ODLB#create on a just resumed binding
	QUnit.test("suspend/resume: call read APIs on a suspended ODLB", function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "doNotSubmit"
			}),
			sView = '\
<Table id="table" items="{path : \'/BusinessPartnerList\', suspended : true}">\
	<Text id="id" text="{BusinessPartnerID}"/>\
</Table>',
			that = this;

		this.expectChange("id", []);

		return this.createView(assert, sView, oModel).then(function () {
			// avoid that the metadata request disturbs the timing
			return oModel.getMetaModel().requestObject("/");
		}).then(function () {
			var oContext;

			oBinding = that.oView.byId("table").getBinding("items");
			oBinding.filter(new Filter("BusinessPartnerRole", FilterOperator.EQ, "01"))
				.sort(new Sorter("CompanyName"))
				.changeParameters({$filter : "BusinessPartnerID gt '0100000001'"});

			that.expectEvents(assert, oBinding, [
					[, "change", {detailedReason : "AddVirtualContext", reason : "filter"}],
					[, "change", {reason : "add"}], //TODO does this really work as expected?
					[, "dataRequested"],
					[, "change", {detailedReason : "RemoveVirtualContext", reason : "change"}],
					[, "refresh", {reason : "refresh"}],
					[, "change", {reason : "change"}],
					[, "dataReceived", {data : {}}]
				])
				.expectRequest("BusinessPartnerList?$filter=BusinessPartnerRole eq '01' "
					+ "and (BusinessPartnerID gt '0100000001')&$orderby=CompanyName"
					+ "&$select=BusinessPartnerID&$skip=0&$top=99", {
					value : [{
						BusinessPartnerID : "0100000002"
					}, {
						BusinessPartnerID : "0100000003"
					}]
				})
				.expectChange("id", ["0100000099", "0100000002", "0100000003"]);

			// code under test
			oBinding.resume();

			// code under test (CPOUI5ODATAV4-102)
			oContext = oBinding.create({BusinessPartnerID : "0100000099"});

			assert.strictEqual(oContext.getProperty("BusinessPartnerID"), undefined, "not now :-(");

			return Promise.all([
				oContext.requestProperty("BusinessPartnerID").then(function (sBusinessPartnerID) {
					assert.strictEqual(sBusinessPartnerID, "0100000099", "but now :-)");
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assertIndices(assert, oBinding.getCurrentContexts(), [-1, 0, 1]); // BCP: 2170049510
		});
	});

	//*********************************************************************************************
	// Scenario: ODM#refresh ignores suspended bindings
	// A suspended binding should not be considered when refreshing via ODM#refresh
	QUnit.test("ODM#refresh ignores suspended bindings", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/BusinessPartnerList\', suspended : true}">\
	<Text id="id" text="{BusinessPartnerID}"/>\
</Table>',
			that = this;

		this.expectChange("id", []);

		return this.createView(assert, sView, oModel).then(function () {
			// code under test
			that.oModel.refresh("foo");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: call setAggregation on a suspended ODLB
	//
	// Ensure that auto-$expand/$select does not add $select (JIRA: CPOUI5ODATAV4-270).
	// Ensure that #changeParameters w/ unchanged $$aggregation is ignored (BCP: 2370045709).
	QUnit.test("suspend/resume: call setAggregation on a suspended ODLB", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/BusinessPartnerList\', suspended : true}">\
	<Text id="role" text="{BusinessPartnerRole}"/>\
</Table>',
			that = this;

		this.expectChange("role", []);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("table").getBinding("items");

			oBinding.setAggregation({groupLevels : ["BusinessPartnerRole"]});
			// code under test (BCP: 2370045709)
			oBinding.changeParameters({$$aggregation : {groupLevels : ["BusinessPartnerRole"]}});

			// code under test
			assert.deepEqual(oBinding.getAggregation(), {
				aggregate : {},
				group : {
					BusinessPartnerRole : {}
				},
				groupLevels : ["BusinessPartnerRole"]
			}, "JIRA: CPOUI5ODATAV4-1825");

			that.expectEvents(assert, oBinding, [
					[, "change", {detailedReason : "AddVirtualContext", reason : "filter"}],
					[, "dataRequested"],
					[, "change", {detailedReason : "RemoveVirtualContext", reason : "change"}],
					[, "refresh", {reason : "refresh"}],
					[, "change", {reason : "change"}],
					[, "dataReceived", {data : {}}]
				])
				.expectRequest("BusinessPartnerList?$apply=groupby((BusinessPartnerRole))"
					+ "&$count=true&$skip=0&$top=100", {
					"@odata.count" : "2",
					value : [{
						BusinessPartnerRole : "01"
					}, {
						BusinessPartnerRole : "02"
					}]
				})
				.expectChange("role", ["01", "02"]);

			// code under test
			oBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: call changeParameters on a suspended ODCB
	QUnit.test("suspend/resume: call changeParameters on a suspended ODCB", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'42\')}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text id="pos" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)", {
				SalesOrderID : "42",
				SO_2_SOITEM : [{
					ItemPosition : "10",
					SalesOrderID : "42"
				}]
			})
			.expectChange("id", "42")
			.expectChange("pos", ["10"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("form").getElementBinding();

			oBinding.suspend();
			oBinding.changeParameters({custom : "n/a"}); // just to call it twice
			oBinding.changeParameters({custom : "option"});

			that.expectRequest("SalesOrderList('42')?custom=option&$select=SalesOrderID"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)", {
					SalesOrderID : "42",
					SO_2_SOITEM : [{
						ItemPosition : "10",
						SalesOrderID : "42"
					}]
				});

			// code under test
			oBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: create a suspended ODCB in the controller code, bind it and resume.
	//
	// JIRA: CPOUI5ODATAV4-474
	QUnit.test("suspend/resume: suspended ODCB created by app", function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form">\
	<Text id="note" text="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectChange("note");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectCanceledError("Failed to read path /SalesOrderList('1')/Note",
					"Suspended binding provides no value");

			oBinding = oModel.bindContext("/SalesOrderList('1')");
			oBinding.suspend();
			that.oView.byId("form").setBindingContext(oBinding.getBoundContext());

			return resolveLater(); // expectCanceledError doesn't wait, but we have to wait
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=Note,SalesOrderID", {
					Note : "Note 1",
					SalesOrderID : "1"
				})
				.expectChange("note", "Note 1");

			oBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A quasi-absolute ODCB is suspended, then #setContext is called.
	// JIRA: CPOUI5ODATAV4-979
	QUnit.test("setContext on a suspended quasi-absolute ODCB", function (assert) {
		var oBinding,
			sView = '\
<FlexBox id="form" binding="{SO_2_BP}">\
	<Text id="role" text="{BusinessPartnerRole}"/>\
</FlexBox>',
			that = this;

		this.expectChange("role");

		return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
			oBinding = that.oView.byId("form").getObjectBinding();

			that.expectRequest("SalesOrderList('42')/SO_2_BP", {
					BusinessPartnerID : "0100000000",
					BusinessPartnerRole : "01"
				})
				.expectChange("role", "01");

			oBinding.setContext(that.oModel.createBindingContext("/SalesOrderList('42')"));
			oBinding.suspend();

			return that.waitForChanges(assert);
		}).then(function () {
			assert.throws(function () {
				oBinding.setContext(that.oModel.createBindingContext("/SalesOrderList('23')"));
			}, "Must not call method when the binding's root binding is suspended"
				+ ": sap.ui.model.odata.v4.ODataContextBinding: /SalesOrderList('42')|SO_2_BP");
		});
	});

	//*********************************************************************************************
	// Scenario: create a suspended ODCB with a dependent list in the controller code, and bind it.
	// The list binding's state transitions from unresolved to suspended. It must remain silent
	// until it is resumed.
	//
	// JIRA: CPOUI5ODATAV4-474
	QUnit.test("ODLB implicitly switching from unresolved to suspended", function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form">\
	<Text id="note" text="{Note}"/>\
	<Table items="{SO_2_SOITEM}">\
		<Text id="position" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("note")
			.expectChange("position", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectCanceledError("Failed to read path /SalesOrderList('1')/Note",
					"Suspended binding provides no value");

			oBinding = oModel.bindContext("/SalesOrderList('1')");
			oBinding.suspend();
			// code under test
			that.oView.byId("form").setBindingContext(oBinding.getBoundContext());

			return resolveLater(null, 0); // expectCanceledError doesn't wait, but we have to wait
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=Note,SalesOrderID"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)", {
					Note : "Note 1",
					SalesOrderID : "1",
					SO_2_SOITEM : [{
						ItemPosition : "0010",
						SalesOrderID : "1"
					}]
				})
				.expectChange("note", "Note 1")
				.expectChange("position", ["0010"]);

			oBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Deferred operation binding returns a collection. A dependent list binding for
	// "value" with auto-$expand/$select displays the result.
	QUnit.test("Deferred operation returns collection, auto-$expand/$select", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/GetSOContactList(...)}" id="function">\
	<Table items="{value}">\
		<Text id="nickname" text="{Nickname}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("nickname", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("GetSOContactList(SalesOrderID='0500000001')", {
					value : [
						{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c591d177", Nickname : "a"},
						{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c591f177", Nickname : "b"},
						{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c5921177", Nickname : "c"}
					]
				})
				.expectChange("nickname", ["a", "b", "c"]);

			return Promise.all([
				// code under test
				that.oView.byId("function").getObjectBinding()
					.setParameter("SalesOrderID", "0500000001")
					.invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: List binding for non-deferred function call which returns a collection, with
	// auto-$expand/$select.
	QUnit.test("List: function returns collection, auto-$expand/$select", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table items="{/GetSOContactList(SalesOrderID=\'0500000001\')}">\
	<Text id="nickname" text="{Nickname}"/>\
</Table>';

		this.expectRequest("GetSOContactList(SalesOrderID='0500000001')"
				+ "?$select=ContactGUID,Nickname&$skip=0&$top=100", {
				value : [
					{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c591d177", Nickname : "a"},
					{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c591f177", Nickname : "b"},
					{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c5921177", Nickname : "c"}
				]
			})
			.expectChange("nickname", ["a", "b", "c"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: ODataContextBinding for non-deferred function call which returns a collection. A
	// dependent list binding for "value" with auto-$expand/$select displays the result.
	// github.com/SAP/openui5/issues/1727
	QUnit.test("Context: function returns collection, auto-$expand/$select", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/GetSOContactList(SalesOrderID=\'0500000001\')}" id="function">\
	<Table items="{value}">\
		<Text id="nickname" text="{Nickname}"/>\
	</Table>\
</FlexBox>';

		this.expectRequest("GetSOContactList(SalesOrderID='0500000001')"
				+ "?$select=ContactGUID,Nickname", {
				value : [
					{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c591d177", Nickname : "a"},
					{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c591f177", Nickname : "b"},
					{ContactGUID : "fa163e7a-d4f1-1ee8-84ac-11f9c5921177", Nickname : "c"}
				]
			})
			.expectChange("nickname", ["a", "b", "c"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: ODataContextBinding for non-deferred bound function call which returns a
	// collection. A dependent list binding for "value" with auto-$expand/$select displays the
	// result.
	// JIRA: CPOUI5UISERVICESV3-965
	// BCP: 2070134549
	QUnit.test("Rel. bound function, auto-$expand/$select (BCP 2070134549)", function (assert) {
		var sFunctionName = "com.sap.gateway.default.iwbep.tea_busi.v0001"
				+ ".__FAKE__FuGetEmployeesByManager",
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/MANAGERS(\'1\')}" id="manager">\
	<Text id="TEAM_ID" text="{TEAM_ID}"/>\
	<FlexBox binding="{' + sFunctionName + '()}" id="function">\
		<Table items="{value}">\
			<Text id="id" text="{ID}"/>\
			<Text id="name" text="{Name}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>';

		this.expectRequest("MANAGERS('1')?$select=ID,TEAM_ID", {
				ID : "1",
				TEAM_ID : "TEAM_03"
			})
			.expectRequest("MANAGERS('1')/" + sFunctionName + "()?$select=ID,Name", {
				value : [{
					ID : "3",
					Name : "Jonathan Smith"
				}, {
					ID : "6",
					Name : "Susan Bay"
				}]
			})
			.expectChange("TEAM_ID", "TEAM_03")
			.expectChange("id", ["3", "6"])
			.expectChange("name", ["Jonathan Smith", "Susan Bay"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Delete an entity via a context binding and check that bindings to properties of
	// this entity are notified even if they have a child path of the context binding without being
	// dependent to it.
	QUnit.test("notify non-dependent bindings after deletion", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/SalesOrderList(\'0500000000\')}" id="form">\
	<FlexBox binding="{SO_2_BP}" id="businessPartner">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="phoneNumber" text="{PhoneNumber}"/>\
	</FlexBox>\
	<Text id="companyName" text="{SO_2_BP/CompanyName}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('0500000000')?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName,PhoneNumber)", {
				SalesOrderID : "0500000000",
				SO_2_BP : {
					"@odata.etag" : "ETag",
					BusinessPartnerID : "0100000000",
					CompanyName : "SAP",
					PhoneNumber : "06227747474"
				}
			})
			.expectChange("companyName", "SAP")
			.expectChange("phoneNumber", "06227747474");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("businessPartner").getBindingContext();

			that.expectRequest({
					headers : {"If-Match" : "ETag"},
					method : "DELETE",
					url : "BusinessPartnerList('0100000000')"
				})
				.expectChange("companyName", "") // defaulting to null in the cache
				.expectChange("phoneNumber", null);

			return Promise.all([
				// code under test
				oContext.delete(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity via a context binding with an empty path and $$ownRequest. The
	// binding hierarchy is ODCB - ODCB. The top binding may or may not have read data on its own.
	// BCP: 1980308439
	// JIRA: CPOUI5UISERVICESV3-1917
	// Use deferred delete and cancel; check isDeleted on both contexts (JIRA: CPOUI5ODATAV4-1926)
[false, true].forEach(function (bParentHasData) {
	[false, true].forEach(function (bReset) {
		var sTitle = "delete context of binding with empty path and $$ownRequest (" + bParentHasData
				+ "), bReset=" + bReset;

	QUnit.test(sTitle, function (assert) {
		var oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oParentContext,
			oPromise,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'0500000000\')}" id="form">'
	+ (bParentHasData ? '<Text id="netAmount" text="{NetAmount}"/>' : "") + '\
	<FlexBox binding="{path : \'\', parameters : {$$ownRequest : true}}" id="blackBinding">\
		<Text id="note" text="{Note}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		if (bParentHasData) {
			this.expectRequest("SalesOrderList('0500000000')?$select=NetAmount,SalesOrderID", {
					"@odata.etag" : "n/a",
					NetAmount : "10",
					SalesOrderID : "0500000000"
				})
				.expectChange("netAmount", "10.00");
		}
		this.expectRequest("SalesOrderList('0500000000')?$select=Note,SalesOrderID", {
				"@odata.etag" : "ETag",
				Note : "Test",
				SalesOrderID : "0500000000"
			})
			.expectChange("note", "Test");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("blackBinding").getBindingContext();
			oParentContext = that.oView.byId("form").getBindingContext();

			// Note: The value of the property binding is undefined because there is no
			// explicit cache value for it, but the type's formatValue converts this to null.
			that.expectChange("note", null);
			if (bParentHasData) {
				that.expectChange("netAmount", null);
			}

			// code under test
			oPromise = oContext.delete("update");

			assert.ok(oContext.isDeleted());
			assert.ok(oParentContext.isDeleted());

			return that.waitForChanges(assert, "delete");
		}).then(function () {
			if (bReset) {
				that.expectCanceledError("Failed to delete /SalesOrderList('0500000000')",
					"Request canceled: DELETE SalesOrderList('0500000000'); group: update");

				oModel.resetChanges("update");
			} else {
				that.expectRequest({
					headers : {"If-Match" : "ETag"},
					method : "DELETE",
					url : "SalesOrderList('0500000000')"
				});
			}

			return Promise.all([
				oPromise.then(function () {
					assert.notOk(bReset);
				}, function (oError) {
					assert.ok(bReset);
					assert.ok(oError.canceled);
				}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, bReset ? "reset" : "submit")
			]);
		}).then(function () {
			assert.notStrictEqual(oContext.isDeleted(), bReset);
			assert.notStrictEqual(oParentContext.isDeleted(), bReset);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: Delete an entity via a context binding with an empty path and $$ownRequest. The
	// hierarchy is ODLB - ODCB - ODCB, both ODCB with empty path. The deletion has to use the ETag
	// of the context for which Context#delete is called.
	// JIRA: CPOUI5UISERVICESV3-1917
	// Use "If-Match: *" if a PATCH is in the same changeset (JIRA: CPOUI5ODATAV4-1670)
	// Use deferred delete and cancel; check isDeleted on both contexts (JIRA: CPOUI5ODATAV4-1926)
[false, true].forEach(function (bChange) {
	[false, true].forEach(function (bReset) {
	var sTitle = "delete context of binding with empty path, delegate to ODLB, change=" + bChange
			+ ", reset=" + bReset;

	QUnit.test(sTitle, function (assert) {
		var oDeletedContext,
			oDeletePromise,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oRowContext,
			sView = '\
<t:Table id="table" rows="{/SalesOrderList}">\
	<Text id="lang" text="{NoteLanguage}"/>\
</t:Table>\
<FlexBox binding="{path : \'\', parameters : {$$ownRequest : true}}" id="form">\
	<Text id="netAmount" text="{NetAmount}"/>\
	<FlexBox binding="{path : \'\', parameters : {$$ownRequest : true}}" id="form2">\
		<Input id="note" value="{Note}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=NoteLanguage,SalesOrderID&$skip=0&$top=110", {
				value : [{
					"@odata.etag" : "ETag1",
					SalesOrderID : "0500000000",
					NoteLanguage : "de"
				}, {
					"@odata.etag" : "ETag2",
					SalesOrderID : "0500000001",
					NoteLanguage : "en"
				}]
			})
			.expectChange("lang", ["de", "en"])
			.expectChange("netAmount")
			.expectChange("note");

		return this.createView(assert, sView, oModel).then(function () {
			var oContextBinding = that.oView.byId("form").getElementBinding(),
				oListBinding = that.oView.byId("table").getBinding("rows");

			that.expectRequest("SalesOrderList('0500000000')?$select=NetAmount,SalesOrderID", {
					"@odata.etag" : "ETag3",
					SalesOrderID : "0500000000",
					NetAmount : "10"
				})
				.expectRequest("SalesOrderList('0500000000')?$select=Note,SalesOrderID", {
					"@odata.etag" : "ETag4",
					Note : "Note",
					SalesOrderID : "0500000000"
				})
				.expectChange("netAmount", "10.00")
				.expectChange("note", "Note");

			oRowContext = oListBinding.getCurrentContexts()[0];
			oContextBinding.setContext(oRowContext);

			return that.waitForChanges(assert);
		}).then(function () {
			if (bChange) {
				that.expectChange("note", "Note (changed)");

				that.oView.byId("note").getBinding("value").setValue("Note (changed)");
			}

			that.expectChange("lang", ["en"])
				.expectChange("netAmount", null)
				.expectChange("note", null);

			// code under test
			oDeletedContext = that.oView.byId("form2").getBindingContext();
			oDeletePromise = oDeletedContext.delete();

			assert.ok(oRowContext.isDeleted());
			assert.ok(oRowContext.hasPendingChanges());
			// Note: The ODCB of "form2" is now unresolved, and oDeletedContext is destroyed,
			// because oRowContext removed itself as parent during the deletion
			assert.notOk(that.oView.byId("form2").getObjectBinding().isResolved());
			assert.notOk(oDeletedContext.getModel());
			assert.ok(oDeletedContext.isDeleted());
			// assert.ok(oDeletedContext.hasPendingChanges());

			return that.waitForChanges(assert);
		}).then(function () {
			if (bReset) {
				that.expectChange("lang", ["de", "en"]);

				that.expectCanceledError("Failed to delete /SalesOrderList('0500000000')",
					"Request canceled: DELETE SalesOrderList('0500000000'); group: update");
				if (bChange) {
					that.expectCanceledError(
						"Failed to update path /SalesOrderList('0500000000')/Note",
						"Request canceled: PATCH SalesOrderList('0500000000'); group: update");
				}

				// code under test (CPOUI5ODATAV4-1884)
				oModel.resetChanges();

				assert.notOk(oDeletedContext.isDeleted()); // nevertheless it is destroyed!
				assert.notOk(oRowContext.isDeleted());
				assert.notOk(oRowContext.hasPendingChanges());
			} else {
				if (bChange) {
					that.expectRequest({
						headers : {"If-Match" : "ETag4"},
						method : "PATCH",
						url : "SalesOrderList('0500000000')",
						payload : {Note : "Note (changed)"}
					});
				}
				that.expectRequest({
						headers : {"If-Match" : bChange ? "*" : "ETag4"},
						method : "DELETE",
						url : "SalesOrderList('0500000000')"
					});
			}

			return Promise.all([
				oModel.submitBatch("update"),
				oDeletePromise.then(function () {
					assert.notOk(bReset);
				}, function (oError) {
					assert.ok(bReset);
					assert.ok(oError.canceled);
				}),
				that.waitForChanges(assert)
			]);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: Deferred deletion of a bound context with a dependent list. A corresponding state
	// message (from the GET) and transition message (from a failed PATCH) are also deleted. Another
	// property is updated, so that there is a PATCH in the same change set as the DELETE and the
	// DELETE must use "If-Match: *".
	// If the deletion is canceled via a reset, both messages are restored. If it fails, only the
	// state message is restored while a new transition message comes with the error.
	// JIRA: CPOUI5ODATAV4-1629
	// JIRA: CPOUI5ODATAV4-1670: Use "If-Match: *" if a PATCH is in the same changeset
	// JIRA: CPOUI5ODATAV4-1637: state messages
	// JIRA: CPOUI5ODATAV4-1745: transition messages
[
	{desc : "submit"},
	{desc : "reset via model", resetViaModel : true},
	{desc : "reset via binding", resetViaBinding : true},
	{desc : "error", error : true}
].forEach(function (oFixture) {
	QUnit.test("CPOUI5ODATAV4-1629: ODCB: deferred delete, " + oFixture.desc, function (assert) {
		var oBinding,
			oContext,
			sItemPath = "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')",
			oListBinding,
			oModel = this.createSalesOrdersModel({updateGroupId : "update"}),
			oPromise,
			sQuantityTarget = "/" + sItemPath + "/Quantity",
			bReset = oFixture.resetViaModel || oFixture.resetViaBinding,
			oRowContext,
			oStateMessage = {
				code : "code 1",
				message : "Enter a minimum quantity of 2",
				target : sQuantityTarget,
				type : "Warning"
			},
			oTransitionMessage = {
				code : "code 2",
				message : "Only multiples of 2 are allowed",
				persistent : true,
				target : sQuantityTarget,
				technical : true,
				type : "Error"
			},
			oUpdatePromise,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Input id="note" value="{Note}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\',\
			parameters : {$select : \'Messages\', $$ownRequest : true}}">\
		<Text id="pos" text="{ItemPosition}"/>\
		<Input id="quantity" value="{Quantity}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')", {
				"@odata.etag" : "etag",
				Note : "Note",
				SalesOrderID : "1"
			})
			.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$select=Messages&$skip=0&$top=100",
				{value : [{
					ItemPosition : "0010",
					SalesOrderID : "1",
					Quantity : "1",
					QuantityUnit : "DZ",
					Messages : [{
						code : "code 1",
						message : "Enter a minimum quantity of 2",
						numericSeverity : 3,
						target : "Quantity"
					}]
				}]})
			.expectChange("id", "1")
			.expectChange("note", "Note")
			.expectChange("pos", ["0010"])
			.expectChange("quantity", ["1.000"])
			.expectMessages([oStateMessage]);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("items");
			oRowContext = oListBinding.getCurrentContexts()[0];

			that.expectChange("quantity", ["3.000"]);

			oUpdatePromise = oRowContext.setProperty("Quantity", "3", "update");

			return that.waitForChanges(assert, "object page");
		}).then(function () {
			var oError = createErrorInsideBatch({
					code : "code 2",
					message : "Only multiples of 2 are allowed",
					target : sQuantityTarget
				});

			that.oLogMock.expects("error")
				.withArgs("Failed to update path " + sQuantityTarget);
			that.expectRequest({
					method : "PATCH",
					payload : {Quantity : "3", QuantityUnit : "DZ"},
					url : sItemPath
				}, oError)
				.expectChange("quantity", ["1.000"])
				.expectMessages([oStateMessage, oTransitionMessage]);

			return Promise.all([
				oUpdatePromise.then(mustFail(assert), function () {}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, "failed update for a transition message")
			]);
		}).then(function () {
			that.expectChange("note", "Note (changed)");

			oBinding = that.oView.byId("form").getObjectBinding();
			oContext = oBinding.getBoundContext();
			that.oView.byId("note").getBinding("value").setValue("Note (changed)");

			that.expectChange("id", null)
				.expectChange("note", null)
				.expectChange("pos", [])
				.expectMessages([]);

			oPromise = oContext.delete();

			assert.ok(oContext.isDeleted());
			assert.ok(oContext.hasPendingChanges());
			assert.ok(oBinding.hasPendingChanges());
			assert.strictEqual(oBinding.getBoundContext(), null);
			assert.ok(oModel.hasPendingChanges());

			return that.waitForChanges(assert, "deferred update & delete in one change set");
		}).then(function () {
			if (bReset) {
				that.expectCanceledError("Failed to delete /SalesOrderList('1')",
					"Request canceled: DELETE SalesOrderList('1'); group: update");
				that.expectCanceledError("Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: update");
				that.expectChange("note", "Note")
					.expectMessages([oStateMessage, oTransitionMessage]);
			} else {
				that.expectRequest({
						headers : {"If-Match" : "etag"},
						method : "PATCH",
						url : "SalesOrderList('1')",
						payload : {Note : "Note (changed)"}
					})
					.expectRequest({
						headers : {"If-Match" : "*"},
						method : "DELETE",
						url : "SalesOrderList('1')"
					}, oFixture.error
						? createErrorInsideBatch({
							details : [{
								"@SAP__core.ContentID" : "1.0",
								"@SAP__core.numericSeverity" : 4,
								message : "Not deletable",
								target : ""
							}]
						})
						: undefined
					);
				if (oFixture.error) {
					that.oLogMock.expects("error")
						.withArgs("Failed to update path /SalesOrderList('1')/Note");
					that.oLogMock.expects("error")
						.withArgs("Failed to delete /SalesOrderList('1')");
					that.expectChange("note", "Note (changed)")
						.expectMessages([oStateMessage, {
							code : "CODE",
							message : "Request intentionally failed",
							persistent : true,
							technical : true,
							type : "Error"
						}, {
							message : "Not deletable",
							persistent : true,
							target : "/SalesOrderList('1')",
							type : "Error"
						}]);
				}
			}
			if (bReset || oFixture.error) {
				that.expectChange("id", "1")
					.expectChange("pos", ["0010"])
					.expectChange("quantity", ["1.000"]);
			}

			if (oFixture.resetViaModel) {
				oModel.resetChanges();
			} else if (oFixture.resetViaBinding) {
				oBinding.resetChanges();
			}
			// reset works synchronously, but a pending request is a pending change
			assert.strictEqual(oModel.hasPendingChanges(), !bReset);
			assert.strictEqual(oBinding.hasPendingChanges(), !bReset);
			assert.strictEqual(oContext.hasPendingChanges(), !bReset);

			return Promise.all([
				oPromise.then(function () {
					assert.notOk(bReset || oFixture.error);
				}, function (oError) {
					assert.ok(bReset || oFixture.error);
					assert.strictEqual(oError.message, bReset
						? "Request canceled: DELETE SalesOrderList('1'); group: update"
						: "Request intentionally failed");
					assert.notOk(oContext.isDeleted());
					assert.strictEqual(oContext.getProperty("SalesOrderID"), "1");
					// in case of failure the PATCH is reinserted and remains a pending change
					assert.strictEqual(oModel.hasPendingChanges(), !bReset);
					assert.strictEqual(oBinding.hasPendingChanges(), !bReset);
					assert.strictEqual(oContext.hasPendingChanges(), !bReset);
				}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, oFixture.desc)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Deferred deletion of a bound context. The binding becomes unresolved. Then the
	// deletion is canceled. The element context must not be restored.
	// JIRA CPOUI5ODATAV4-1629
	QUnit.test("CPOUI5ODATAV4-1629: ODCB: deferred delete, context loss, reset", function (assert) {
		var oBinding,
			oContext,
			oModel = this.createSalesOrdersModel({updateGroupId : "update"}),
			oPromise,
			sView = '\
<FlexBox id="form" binding="{SalesOrderList(\'1\')}">\
	<Text id="id" text="{SalesOrderID}"/>\
</FlexBox>',
			that = this;

		this.expectChange("id");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')", {SalesOrderID : "1"})
				.expectChange("id", "1");

			oBinding = that.oView.byId("form").getObjectBinding();
			oBinding.setContext(oModel.createBindingContext("/"));
			oContext = oBinding.getBoundContext();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("id", null);

			oPromise = oContext.delete();
			oBinding.setContext(null);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectCanceledError("Failed to delete /SalesOrderList('1')",
				"Request canceled: DELETE SalesOrderList('1'); group: update");

			oModel.resetChanges();

			return Promise.all([
				oPromise.then(function () {
					assert.notOk(true);
				}, function () {
					assert.strictEqual(oBinding.getBoundContext(), null);
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Deferred deletion of row contexts with an object page. The binding context of the
	// object page is also deleted, but not unbound. See that all bindings in the object page become
	// unresolved immediately, regardless whether they are direct or indirect dependents of the
	// deleted context ("note" has an ODCB in between).
	// In the catch handler of the delete promise the object page is restored by setting its binding
	// context again.
	// JIRA: CPOUI5ODATAV4-1629
	// JIRA: CPOUI5ODATAV4-1831: unresolve dependents
	//
	// Selection on contexts which are deleted and restored (JIRA: CPOUI5ODATAV4-1943).
	// Selection is cleared on successful deletion (JIRA: CPOUI5ODATAV4-2053).
	// Data binding for selection (JIRA: CPOUI5ODATAV4-1944).
[
	{desc : "submit", success : true},
	{desc : "reset via model", resetViaModel : true},
	{desc : "reset via binding", resetViaBinding : true}
].forEach(function (oFixture) {
	QUnit.test("CPOUI5ODATAV4-1629: ODLB: deferred delete, " + oFixture.desc, function (assert) {
		var oBinding,
			oContext2,
			oContext3,
			oContext4,
			oItemsBinding,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oObjectPage,
			oPromise2,
			oPromise4,
			bReset = oFixture.resetViaModel || oFixture.resetViaBinding,
			sView = '\
<Text id="count" text="{$count}"/>\
<Table id="list" growing="true" growingThreshold="5" \
		items="{path : \'/SalesOrderList\', parameters : {$count : true}}">\
	<Text id="listId" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Input id="note" binding="{}" value="{Note}"/>\
	<Text id="itemCount" text="{itemHeader>$count}"/>\
	<Table id="items" items="{path: \'SO_2_SOITEM\', parameters : {$count : true}}">\
		<Text id="pos" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID&$skip=0&$top=5", {
				"@odata.count" : "20",
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"},
					{SalesOrderID : "3"},
					{SalesOrderID : "4"},
					{SalesOrderID : "5"}
				]
			})
			.expectChange("count")
			.expectChange("listId", ["1", "2", "3", "4", "5"])
			.expectChange("id")
			.expectChange("note")
			.expectChange("pos", [])
			.expectChange("itemCount");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("count", "20");

			oBinding = that.oView.byId("list").getBinding("items");
			that.oView.byId("count").setBindingContext(oBinding.getHeaderContext());

			return that.waitForChanges(assert, "count");
		}).then(function () {
			var aContexts;

			that.expectChange("id", "2")
				.expectRequest("SalesOrderList('2')?$select=Note", {Note : "Note 2"})
				.expectChange("note", "Note 2")
				.expectChange("itemCount", null) // due to setBindingContext
				.expectRequest("SalesOrderList('2')/SO_2_SOITEM?$count=true"
					+ "&$select=ItemPosition,SalesOrderID&$skip=0&$top=100", {
					"@odata.count" : "2",
					value : [
						{ItemPosition : "10", SalesOrderID : "2"},
						{ItemPosition : "20", SalesOrderID : "2"}
					]
				})
				.expectChange("pos", ["10", "20"])
				.expectChange("itemCount", "2");

			aContexts = oBinding.getCurrentContexts();
			oContext2 = aContexts[1];
			oContext3 = aContexts[2];
			oContext4 = aContexts[3];
			that.oView.setModel(oModel, "itemHeader");
			oObjectPage = that.oView.byId("objectPage");
			oObjectPage.setBindingContext(oContext2);
			oItemsBinding = that.oView.byId("items").getBinding("items");
			oObjectPage.setBindingContext(oItemsBinding.getHeaderContext(), "itemHeader");

			return that.waitForChanges(assert, "object page");
		}).then(function () {
			that.expectChange("note", "Note 2 (changed)");

			that.oView.byId("note").getBinding("value").setValue("Note 2 (changed)");

			return that.waitForChanges(assert, "modify note");
		}).then(function () {
			that.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID"
					+ "&$filter=not (SalesOrderID eq '2' or SalesOrderID eq '4')&$skip=3&$top=2", {
					"@odata.count" : "18",
					value : [
						{SalesOrderID : "6"},
						{SalesOrderID : "7"}
					]
				})
				.expectChange("listId", [,,, "6", "7"]) // no change events for the moved rows
				.expectChange("count", "19")
				.expectChange("count", "18")
				.expectChange("id", null)
				.expectChange("note", null);

			// code under test (JIRA: CPOUI5ODATAV4-1943)
			oContext2.setSelected(true);
			oContext4.setSelected(true);

			assert.strictEqual(oContext2.toString(), "/SalesOrderList('2')[1;selected]");
			checkSelected(assert, oContext2, true);

			oPromise2 = oContext2.delete();
			oPromise4 = oContext4.delete();

			checkSelected(assert, oContext2, true); // selection hidden while deleted

			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-1943)
				oContext2.setSelected(true);
			}, new Error("Must not select a deleted entity: /SalesOrderList('2');deleted"));
			// code under test (JIRA: CPOUI5ODATAV4-1943)
			oContext2.setSelected(false);
			checkSelected(assert, oContext2, false);

			assert.ok(oBinding.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges());

			assert.throws(function () {
				oContext2.setProperty("Note", "n/a");
			}, new Error("Must not modify a deleted entity: " + oContext2));
			assert.strictEqual(that.oView.byId("id").getBinding("text").isResolved(), false);
			assert.strictEqual(that.oView.byId("note").getObjectBinding().isResolved(), false);
			assert.strictEqual(that.oView.byId("note").getBinding("value").isResolved(), false);
			assert.strictEqual(that.oView.byId("items").getBinding("items").isResolved(), false);

			return that.waitForChanges(assert, "deferred delete");
		}).then(function () {
			that.expectChange("count", "17")
				.expectRequest("DELETE SalesOrderList('3')", createErrorInsideBatch())
				.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID"
					+ "&$filter=not (SalesOrderID eq '2' or SalesOrderID eq '3'"
						+ " or SalesOrderID eq '4')"
					+ "&$skip=4&$top=1")
					// no response required
				.expectChange("count", "18")
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			that.oLogMock.expects("error").withArgs("Failed to delete /SalesOrderList('3')");
			that.oLogMock.expects("error")
				.withArgs(sinon.match.string, sinon.match(sPreviousFailed));

			return Promise.all([
				oContext3.delete("$auto").then(mustFail(assert), function () {}),
				that.waitForChanges(assert, "direct delete failed")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getLength(), 18);

			that.expectChange("count", "17")
				.expectRequest("DELETE SalesOrderList('3')")
				.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID"
					+ "&$filter=not (SalesOrderID eq '2' or SalesOrderID eq '3'"
						+ " or SalesOrderID eq '4')"
					+ "&$skip=4&$top=1", {
					"@odata.count" : "17",
					value : [{SalesOrderID : "8"}]
				})
				.expectChange("listId", [,,,, "8"]);

			return Promise.all([
				oContext3.delete("$auto"),
				that.waitForChanges(assert, "direct delete succeeded")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getLength(), 17);

			if (oFixture.success) {
				that.expectRequest({
						method : "PATCH",
						url : "SalesOrderList('2')",
						payload : {Note : "Note 2 (changed)"}
					})
					.expectRequest("DELETE SalesOrderList('2')")
					.expectRequest("DELETE SalesOrderList('4')");
			} else {
				that.expectCanceledError("Failed to delete /SalesOrderList('4')",
					"Request canceled: DELETE SalesOrderList('4'); group: update");
				that.expectCanceledError("Failed to delete /SalesOrderList('2')",
					"Request canceled: DELETE SalesOrderList('2'); group: update");
				that.expectCanceledError("Failed to update path /SalesOrderList('2')/Note",
					"Request canceled: PATCH SalesOrderList('2'); group: update");
				that.expectChange("listId", [, "2", "4"])
					.expectChange("count", "18") // change handler of $count fired synchronously
					.expectChange("count", "19")
					// from the setBindingContext
					.expectChange("id", "2")
					.expectChange("note", "Note 2")
					.expectChange("pos", ["10", "20"]);
			}

			if (oFixture.resetViaModel) {
				oModel.resetChanges();
			} else if (oFixture.resetViaBinding) {
				oBinding.resetChanges();
			}
			// reset works synchronously, but a pending request is a pending change
			assert.strictEqual(oModel.hasPendingChanges(), !bReset);
			assert.strictEqual(oBinding.hasPendingChanges(), !bReset);
			assert.strictEqual(oContext2.hasPendingChanges(), !bReset);
			assert.strictEqual(oContext4.hasPendingChanges(), !bReset);

			return Promise.all([
				oPromise2.then(function () {
					assert.ok(oFixture.success);
					assert.ok(oContext2.isDeleted());
				}, function (oError) {
					assert.notOk(oFixture.success);
					assert.ok(oError.canceled);
					assert.notOk(oContext2.hasPendingChanges());
					assert.notOk(oContext2.isDeleted());
					assert.strictEqual(oContext2.getProperty("SalesOrderID"), "2");

					// Restore the object page.
					// The binding context must have been changed, so that setting it to the
					// undeleted context has an effect. The application typically would do this when
					// calling delete.
					oObjectPage.setBindingContext(null);
					oObjectPage.setBindingContext(oContext2);
					oObjectPage.setBindingContext(oItemsBinding.getHeaderContext(), "itemHeader");
				}),
				oPromise4.then(function () {
					assert.ok(oFixture.success);
					assert.ok(oContext4.isDeleted());
					checkSelected(assert, oContext4, undefined, "JIRA: CPOUI5ODATAV4-2053");
				}, function (oError) {
					assert.notOk(oFixture.success);
					assert.ok(oError.canceled);
					assert.notOk(oContext4.hasPendingChanges());
					assert.notOk(oContext4.isDeleted());
					checkSelected(assert, oContext4, true);
					assert.strictEqual(oContext4.getProperty("SalesOrderID"), "4");
				}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, oFixture.success ? "submit" : "reset")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getLength(), oFixture.success ? 17 : 19);
			assert.notOk(oModel.hasPendingChanges());
			assert.notOk(oBinding.hasPendingChanges());
			if (!oFixture.success) { // otherwise they are destroyed
				assert.notOk(oContext2.hasPendingChanges());
				assert.notOk(oContext4.hasPendingChanges());
			}
		});
	});
});

	//*********************************************************************************************
	// Scenario: Deferred deletion of a row context in a binding w/o cache
	// JIRA: CPOUI5ODATAV4-1629
[
	{desc : "submit", success : true},
	{desc : "reset via model", resetViaModel : true},
	{desc : "reset via binding", resetViaBinding : true},
	{desc : "reset via model, reverse", resetViaModel : true, reverse : true},
	{desc : "reset via binding, reverse", resetViaBinding : true, reverse : true},
	{desc : "failure", failure : true}
].forEach(function (oFixture) {
	var sTitle = "CPOUI5ODATAV4-1629: ODLB: no cache, deferred delete, " + oFixture.desc;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oContext1,
			oContext2,
			sEntityPath1 = "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')",
			sEntityPath2 = "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='30')",
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oPromise1,
			oPromise2,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Table id="list" items="{SO_2_SOITEM}">\
		<Text id="pos" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)", {
				SalesOrderID : "1",
				SO_2_SOITEM : [
					{ItemPosition : "10", SalesOrderID : "1"},
					{ItemPosition : "20", SalesOrderID : "1"},
					{ItemPosition : "30", SalesOrderID : "1"},
					{ItemPosition : "40", SalesOrderID : "1"}
				]
			})
			.expectChange("id", "1")
			.expectChange("pos", ["10", "20", "30", "40"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oCurrentContexts;

			oBinding = that.oView.byId("list").getBinding("items");
			assert.strictEqual(oBinding.getCount(), 4);
			assert.strictEqual(oBinding.getLength(), 4);

			that.expectChange("pos", [, "40"]);

			oCurrentContexts = oBinding.getCurrentContexts();
			oContext1 = oCurrentContexts[1];
			oContext2 = oCurrentContexts[2];
			if (oFixture.reverse) {
				oPromise2 = oContext2.delete();
				oPromise1 = oContext1.delete();
			} else {
				oPromise1 = oContext1.delete();
				oPromise2 = oContext2.delete();
			}

			assert.ok(oBinding.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges());

			return that.waitForChanges(assert, "deferred delete");
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 2);
			assert.strictEqual(oBinding.getLength(), 2);

			if (oFixture.reverse) {
				that.expectCanceledError("Failed to delete /" + sEntityPath1,
					"Request canceled: DELETE " + sEntityPath1 + "; group: update");
				that.expectCanceledError("Failed to delete /" + sEntityPath2,
					"Request canceled: DELETE " + sEntityPath2 + "; group: update");
			} else if (oFixture.resetViaBinding || oFixture.resetViaModel) {
				that.expectCanceledError("Failed to delete /" + sEntityPath2,
					"Request canceled: DELETE " + sEntityPath2 + "; group: update");
				that.expectCanceledError("Failed to delete /" + sEntityPath1,
					"Request canceled: DELETE " + sEntityPath1 + "; group: update");
			} else {
				if (oFixture.failure) {
					that.oLogMock.expects("error")
						.withExactArgs("Failed to delete /" + sEntityPath1,
							sinon.match("Request intentionally failed"), sContext);
					that.oLogMock.expects("error")
						.withExactArgs("Failed to delete /" + sEntityPath2,
							sinon.match("Request intentionally failed"), sContext);
					that.expectMessages([{
							code : "CODE",
							message : "Request intentionally failed",
							persistent : true,
							technical : true,
							type : "Error"
						}]);
				}
				that.expectRequest("DELETE " + sEntityPath1,
						oFixture.failure ? createErrorInsideBatch() : undefined)
					.expectRequest("DELETE " + sEntityPath2);
			}
			if (!oFixture.success) {
				that.expectChange("pos", [, "20", "30", "40"]);
			}

			if (oFixture.resetViaModel) {
				oModel.resetChanges();
			} else if (oFixture.resetViaBinding) {
				oBinding.resetChanges();
			}

			return Promise.all([
				oPromise1.then(function () {
					assert.ok(oFixture.success);
				}, function (oError) {
					assert.notOk(oFixture.success);
					assert.strictEqual(oError.canceled, oFixture.failure ? undefined : true);
					assert.notOk(oContext1.isDeleted());
					assert.strictEqual(oContext1.getProperty("ItemPosition"), "20");
				}),
				oPromise2.then(function () {
					assert.ok(oFixture.success);
				}, function (oError) {
					assert.notOk(oFixture.success);
					assert.strictEqual(oError.canceled, oFixture.failure ? undefined : true);
					assert.notOk(oContext2.isDeleted());
					assert.strictEqual(oContext2.getProperty("ItemPosition"), "30");
				}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, oFixture.success ? "submit" : "reset")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), oFixture.success ? 2 : 4);
			assert.strictEqual(oBinding.getLength(), oFixture.success ? 2 : 4);
			assert.notOk(oBinding.hasPendingChanges());
			assert.notOk(oModel.hasPendingChanges());
		});
	});
});

	//*********************************************************************************************
	// Scenario: Deferred deletion of a created-persisted context. See that paging requests are
	// correct when the context is deleted on the client and when the deletion has been canceled.
	// JIRA: CPOUI5ODATAV4-1629
	QUnit.test("CPOUI5ODATAV4-1629: ODLB: deferred delete, created-persisted", function (assert) {
		var oBinding,
			oContext,
			oModel = this.createSalesOrdersModel({updateGroupId : "update"}),
			oPromise,
			sView = '\
<Table id="list" growing="true" growingThreshold="3" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		function assertIDs(aExpectedIDs) {
			assert.deepEqual(oBinding.getCurrentContexts().map(function (oContext) {
				return oContext.getValue("SalesOrderID");
			}), aExpectedIDs);
		}

		this.expectRequest("SalesOrderList?$skip=0&$top=3", {value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"},
					{SalesOrderID : "3"}
				]}
			)
			.expectChange("id", ["1", "2", "3"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("id", [""])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {}
				}, {SalesOrderID : "new"})
				.expectChange("id", ["new"]);

			oBinding = that.oView.byId("list").getBinding("items");
			oContext = oBinding.create({}, true);

			return Promise.all([
				oModel.submitBatch("update"),
				oContext.created(),
				that.waitForChanges(assert, "create")
			]);
		}).then(function () {
			assertIDs(["new", "1", "2"]);

			that.expectChange("id", [,, "3"]);

			oPromise = oContext.delete();

			return that.waitForChanges(assert, "deferred delete");
		}).then(function () {
			assertIDs(["1", "2", "3"]);

			that.expectRequest("SalesOrderList?$filter=not (SalesOrderID eq 'new')"
					+ "&$skip=3&$top=3", {value : [
						{SalesOrderID : "4"},
						{SalesOrderID : "5"},
						{SalesOrderID : "6"}
					]}
				)
				.expectChange("id", [,,, "4", "5", "6"]);

			that.oView.byId("list").requestItems();

			return that.waitForChanges(assert, "show more items 1");
		}).then(function () {
			assertIDs(["1", "2", "3", "4", "5", "6"]);

			that.expectChange("id", ["new"])
				.expectCanceledError("Failed to delete /SalesOrderList('new')",
				"Request canceled: DELETE SalesOrderList('new'); group: update");

			oModel.resetChanges();

			return Promise.all([
				checkCanceled(assert, oPromise),
				that.waitForChanges(assert, "resetChanges")
			]);
		}).then(function () {
			assertIDs(["new", "1", "2", "3", "4", "5"]);

			that.expectRequest("SalesOrderList?$filter=not (SalesOrderID eq 'new')"
					+ "&$skip=6&$top=2", {value : [
						{SalesOrderID : "7"},
						{SalesOrderID : "8"}
					]}
				)
				.expectChange("id", [,,,,,, "6", "7", "8"]);

			that.oView.byId("list").requestItems();

			return that.waitForChanges(assert, "show more items 2");
		}).then(function () {
			assertIDs(["new", "1", "2", "3", "4", "5", "6", "7", "8"]);
		});
	});

	//*********************************************************************************************
	// Scenario: Deferred delete in a nested list w/o cache. Filter in the parent list, so that the
	// parent entity drops out. Then submit or reset (canceling the delete).
	// BCP: 2380081607
[false, true].forEach(function (bReset) {
	QUnit.test("ODLB: no cache, deferred delete, parent lost, reset=" + bReset, function (assert) {
		var oDeletePromise,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<Table id="teams" items="{/TEAMS}">\
	<Text id="team" text="{Team_Id}"/>\
	<Table items="{path : \'TEAM_2_EMPLOYEES\', templateShareable : true}">\
		<Text id="employee" text="{ID}"/>\
	</Table>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Team_Id&$expand=TEAM_2_EMPLOYEES($select=ID)"
				+ "&$skip=0&$top=100", {
				value : [{
					Team_Id : "TEAM_1",
					TEAM_2_EMPLOYEES : [{ID : "1"}, {ID : "2"}]
				}]
			})
			.expectChange("team", ["TEAM_1"])
			.expectChange("employee", ["1", "2"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("employee", ["2"]);

			oDeletePromise = that.oView.byId("teams").getItems()[0].getCells()[1]
				.getBinding("items").getCurrentContexts()[0].delete();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("TEAMS?$select=Team_Id&$expand=TEAM_2_EMPLOYEES($select=ID)"
					+ "&$filter=Team_Id ne '1'&$skip=0&$top=100", {value : []});

			that.oView.byId("teams").getBinding("items")
				.filter(new Filter("Team_Id", FilterOperator.NE, "1"));

			return that.waitForChanges(assert);
		}).then(function () {
			if (bReset) {
				that.expectCanceledError("Failed to delete /TEAMS('TEAM_1')/TEAM_2_EMPLOYEES('1')",
					"Request canceled: DELETE EMPLOYEES('1'); group: update");

				oModel.resetChanges();
			} else {
				that.expectRequest("DELETE EMPLOYEES('1')");
			}

			return Promise.all([
				oModel.submitBatch("update"),
				oDeletePromise.then(function () {
					assert.notOk(bReset);
				}, function (oError) {
					assert.ok(bReset);
					assert.ok(oError.canceled);
				}),
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Create and persist two contexts using "end of start". Delete one via API group and
	// the other one via $auto (to see that we must react on the last deletion). Create a third
	// context before submitting the deferred deletion. See that this context is inserted at the end
	// of start, although no created context is shown in the table currently.
	// JIRA: CPOUI5ODATAV4-1629
	QUnit.test("CPOUI5ODATAV4-1629: ODLB: deferred delete & createAtEnd", function (assert) {
		var oBinding,
			oContext1,
			oContext2,
			oContext3,
			oModel = this.createSalesOrdersModel({updateGroupId : "update"}),
			oPromise,
			sView = '\
<Table id="list" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$skip=0&$top=100", {value : [{SalesOrderID : "1"}]})
			.expectChange("id", ["1"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("id", ["new1", "new2", "1"])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {SalesOrderID : "new1"}
				}, {SalesOrderID : "new1"})
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {SalesOrderID : "new2"}
				}, {SalesOrderID : "new2"});

			oBinding = that.oView.byId("list").getBinding("items");
			oContext1 = oBinding.create({SalesOrderID : "new1"}, true, /*bAtEnd*/false);
			oContext2 = oBinding.create({SalesOrderID : "new2"}, true, /*bAtEnd*/true);

			return Promise.all([
				oModel.submitBatch("update"),
				oContext1.created(),
				oContext2.created(),
				that.waitForChanges(assert, "create")
			]);
		}).then(function () {
			that.expectChange("id", ["1"])
				.expectRequest("DELETE SalesOrderList('new2')");

			oPromise = oContext1.delete();

			return Promise.all([
				oContext2.delete("$auto"),
				that.waitForChanges(assert, "delete")
			]);
		}).then(function () {
			that.expectChange("id", ["new3", "1"]);

			oContext3 = oBinding.create({SalesOrderID : "new3"}, true, /*bAtEnd*/true);

			return that.waitForChanges(assert, "create w/ a pending delete");
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('new1')")
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {SalesOrderID : "new3"}
				}, {SalesOrderID : "new3"});

			return Promise.all([
				oModel.submitBatch("update"),
				oPromise,
				oContext3.created(),
				that.waitForChanges(assert, "submit")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create a draft at the end, save it and replace it with the active entity. Start
	// deleting it, but cancel the deletion. See that it is still at the end.
	// JIRA: CPOUI5ODATAV4-1629
	QUnit.test("CPOUI5ODATAV4-1629: ODLB: create, delete & doReplaceWith", function (assert) {
		var sAction = "special.cases.ActivationAction",
			oBinding,
			oContext,
			oModel = this.createSpecialCasesModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oPromise,
			sView = '\
<Table id="list" items="{/Artists}">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="active" text="{IsActiveEntity}"/>\
</Table>',
			that = this;

		this.expectRequest("Artists?$select=ArtistID,IsActiveEntity&$skip=0&$top=100", {
				value : [
					{ArtistID : "1", IsActiveEntity : true}
				]
			})
			.expectChange("id", ["1"])
			.expectChange("active", ["Yes"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("id", [, ""])
				.expectChange("active", [, null])
				.expectRequest({
					method : "POST",
					url : "Artists",
					payload : {}
				}, {ArtistID : "new", IsActiveEntity : false})
				.expectChange("id", [, "new"])
				.expectChange("active", [, "No"]);

			oBinding = that.oView.byId("list").getBinding("items");
			oContext = oBinding.create({}, true, /*bAtEnd*/true);

			return Promise.all([
				oModel.submitBatch("update"),
				oContext.created(),
				that.waitForChanges(assert, "create draft at end")
			]);
		}).then(function () {
			var oAction = oModel.bindContext(sAction + "(...)", oContext);

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='new',IsActiveEntity=false)/" + sAction,
					payload : {}
				}, {ArtistID : "new", IsActiveEntity : true})
				.expectChange("active", [, "Yes"]);

			return Promise.all([
				oAction.invoke(undefined, false, null, /*bReplaceWithRVC*/true),
				that.waitForChanges(assert, "replace with active")
			]);
		}).then(function (aResult) {
			oPromise = aResult[0].delete(); // delete the RVC

			// It's not possible to synchronously reset after delete, so wait a short moment.
			return that.waitForChanges(assert, "deferred delete");
		}).then(function () {
			that.expectCanceledError(
				"Failed to delete /Artists(ArtistID='new',IsActiveEntity=true)",
				"Request canceled: DELETE Artists(ArtistID='new',IsActiveEntity=true);"
				+ " group: update"
			);
			that.expectChange("id", [, "new"])
				.expectChange("active", [, "Yes"]);

			// code under test
			oModel.resetChanges();

			return Promise.all([
				checkCanceled(assert, oPromise),
				that.waitForChanges(assert, "resetChanges")
			]);
		}).then(function () {
			assert.deepEqual(oBinding.getCurrentContexts().map(getPath), [
				"/Artists(ArtistID='1',IsActiveEntity=true)",
				"/Artists(ArtistID='new',IsActiveEntity=true)"
			], "correct order");
			assert.strictEqual(oBinding.getLength(), 2, "correct length");
		});
	});

	//*********************************************************************************************
	// Scenario: Deferred deletion of a row context (oRowContext) and a hidden kept-alive context
	// (oKeptContext1) in different groups. The count must be decreased immediately; for
	// oKeptContext1 a count request is needed. Then the binding reads more contexts. The context
	// with highest index is also kept alive (oKeptContext2). Then the deletion of oKeptContext1
	// fails, and it must be reinserted. The binding must refresh the data to find the context's
	// correct position and must not disturb the pending delete of oRowContext. oKeptContext2
	// becomes invisible by this, but must not be lost. In the end the binding is reset and
	// oRowContext must be re-inserted causing another refresh.
	// JIRA: CPOUI5ODATAV4-1638
	//
	// Selection is hidden, but kept while deleted (JIRA: CPOUI5ODATAV4-2053).
	// Data binding for selection (JIRA: CPOUI5ODATAV4-1944).
	QUnit.test("CPOUI5ODATAV4-1638: ODLB: deferred delete w/ isKeepAlive fails", function (assert) {
		var oBinding,
			oKeptContext1,
			oKeptContext2,
			oKeptPromise,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oRowContext,
			oRowPromise,
			oTable,
			sView = '\
<Table id="listReport" growing="true" growingThreshold="2" items="{path : \'/SalesOrderList\',\
		parameters : {$count : true, $filter : \'LifecycleStatus eq \\\'N\\\'\'}}">\
	<Text text="{SalesOrderID}"/>\
	<Text text="{GrossAmount}"/>\
</Table>',
			that = this;

		function assertIDs(aExpectedIDs) {
			assert.deepEqual(oBinding.getCurrentContexts().map(function (oContext) {
				return oContext.getValue("SalesOrderID");
			}), aExpectedIDs, "IDs " + aExpectedIDs);
		}

		this.expectRequest("SalesOrderList?$count=true&$filter=LifecycleStatus eq 'N'"
				+ "&$select=GrossAmount,SalesOrderID&$skip=0&$top=2", {
				"@odata.count" : "8",
				value : [
					{GrossAmount : "3", SalesOrderID : "1", "@odata.etag" : "etag1"},
					{GrossAmount : "1", SalesOrderID : "2"}
				]
			});

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("listReport");
			oBinding = oTable.getBinding("items");
			assertIDs(["1", "2"]);

			that.expectRequest("SalesOrderList?$count=true&$filter=LifecycleStatus eq 'N'"
					+ "&$select=GrossAmount,SalesOrderID&$orderby=GrossAmount&$skip=0&$top=2", {
					"@odata.count" : "8",
					value : [
						{GrossAmount : "1", SalesOrderID : "2"},
						{GrossAmount : "2", SalesOrderID : "3"}
					]
				});

			oKeptContext1 = oBinding.getCurrentContexts()[0];
			oKeptContext1.setKeepAlive(true);
			oBinding.sort(new Sorter("GrossAmount"));

			return that.waitForChanges(assert, "setKeepAlive and sort");
		}).then(function () {
			assertIDs(["2", "3"]);
			that.checkMoreButton(assert, "[2/8]");

			that.expectRequest("SalesOrderList?$count=true"
					+ "&$filter=(LifecycleStatus eq 'N') and not (SalesOrderID eq '2')"
					+ "&$select=GrossAmount,SalesOrderID&$orderby=GrossAmount&$skip=1&$top=1", {
					"@odata.count" : "7",
					value : [
						{GrossAmount : "4", SalesOrderID : "4"}
					]
				});

			oRowContext = oBinding.getCurrentContexts()[0];
			oRowContext.setSelected(true);
			oRowPromise = oRowContext.delete("doNotSubmit");
			checkSelected(assert, oRowContext, true); // selection hidden while deleted

			// code under test (JIRA: CPOUI5ODATAV4-2053)
			assert.notOk(oBinding.getAllCurrentContexts().includes(oRowContext),
				"hidden, although selected");

			return that.waitForChanges(assert, "delete and fill gap");
		}).then(function () {
			assertIDs(["3", "4"]);
			that.checkMoreButton(assert, "[2/7]");

			that.expectRequest("SalesOrderList?$count=true&$filter=(LifecycleStatus eq 'N')"
					+ " and not (SalesOrderID eq '1' or SalesOrderID eq '2')&$top=0",
					{"@odata.count" : "6", value : []}
				);

			oKeptPromise = oKeptContext1.delete("update");

			return that.waitForChanges(assert, "delete kept-alive and request count");
		}).then(function () {
			assertIDs(["3", "4"]);
			that.checkMoreButton(assert, "[2/6]");

			that.expectRequest("SalesOrderList?$count=true"
					+ "&$filter=(LifecycleStatus eq 'N') and"
					+ " not (SalesOrderID eq '1' or SalesOrderID eq '2')"
					+ "&$select=GrossAmount,SalesOrderID&$orderby=GrossAmount&$skip=2&$top=2", {
					"@odata.count" : "6",
					value : [
						{GrossAmount : "5", SalesOrderID : "5"},
						{GrossAmount : "6", SalesOrderID : "6"}
					]
				});

			that.oView.byId("listReport").requestItems();

			return that.waitForChanges(assert, "more");
		}).then(function () {
			assertIDs(["3", "4", "5", "6"]);
			that.checkMoreButton(assert, "[4/6]");

			that.oLogMock.expects("error").withArgs("Failed to delete /SalesOrderList('1')");
			that.expectRequest({
					batchNo : 6,
					method : "DELETE",
					headers : {"If-Match" : "etag1"},
					url : "SalesOrderList('1')"
				}, createErrorInsideBatch())
				.expectRequest({
					batchNo : 7, // from the binding's reset due to the failed DELETE
					url : "SalesOrderList?$count=true"
						+ "&$filter=(LifecycleStatus eq 'N') and not (SalesOrderID eq '2')"
						+ "&$select=GrossAmount,SalesOrderID&$orderby=GrossAmount&$skip=0&$top=4"
				}, {
					"@odata.count" : "7",
					value : [
						{GrossAmount : "2", SalesOrderID : "3"},
						{GrossAmount : "3", SalesOrderID : "1"},
						{GrossAmount : "4", SalesOrderID : "4"},
						{GrossAmount : "5", SalesOrderID : "5"}
					]
				})
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			oKeptContext2 = oBinding.getCurrentContexts()[3];
			oKeptContext2.setKeepAlive(true);

			return Promise.all([
				that.oModel.submitBatch("update"),
				oKeptPromise.then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, "Request intentionally failed");
				}),
				that.waitForChanges(assert, "submit")
			]);
		}).then(function () {
			assertIDs(["3", "1", "4", "5"]);
			that.checkMoreButton(assert, "[4/7]");
			assert.deepEqual(oKeptContext1.getObject(), {GrossAmount : "3", SalesOrderID : "1"});
			assert.deepEqual(oKeptContext2.getObject(), {GrossAmount : "6", SalesOrderID : "6"});

			that.expectRequest("SalesOrderList?$count=true&$filter=LifecycleStatus eq 'N'"
					+ "&$select=GrossAmount,SalesOrderID&$orderby=GrossAmount&$skip=0&$top=4", {
					"@odata.count" : "8",
					value : [
						{GrossAmount : "1", SalesOrderID : "2"},
						{GrossAmount : "2", SalesOrderID : "3"},
						{GrossAmount : "3", SalesOrderID : "1"},
						{GrossAmount : "4", SalesOrderID : "4"}
					]
				});
			that.expectCanceledError("Failed to delete /SalesOrderList('2')",
				"Request canceled: DELETE SalesOrderList('2'); group: doNotSubmit");

			oBinding.resetChanges();
			assert.notOk(oRowContext.hasPendingChanges());
			assert.notOk(oRowContext.isDeleted());
			checkSelected(assert, oRowContext, true, "selection hidden, but kept while deleted");

			return Promise.all([
				checkCanceled(assert, oRowPromise),
				that.waitForChanges(assert, "resetChanges")
			]);
		}).then(function () {
			assertIDs(["2", "3", "1", "4"]);
			that.checkMoreButton(assert, "[4/8]");
			assert.deepEqual(oRowContext.getObject(),
				{"@$ui5.context.isSelected" : true, GrossAmount : "1", SalesOrderID : "2"});
			assert.deepEqual(oKeptContext1.getObject(), {GrossAmount : "3", SalesOrderID : "1"});
			assert.deepEqual(oKeptContext2.getObject(), {GrossAmount : "6", SalesOrderID : "6"});
		});
	});

	//*********************************************************************************************
	// Scenario: Deferred deletion of a context, then sort/filter/refresh the list, then reset the
	// changes. The list must be refreshed to restore the deleted context in its right place.
	// JIRA: CPOUI5ODATAV4-1639
	// Also filter the deleted element out and observe $count (JIRA: CPOUI5ODATAV4-1873)
[{
	name : "sort",
	reload : function (oBinding) {
		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$orderby=SalesOrderID desc&$filter=not (SalesOrderID eq '2')"
				+ "&$skip=0&$top=100", {
				"@odata.count" : "2",
				value : [
					{"@odata.etag" : "etag3", Note : "Note 3", SalesOrderID : "3"},
					{"@odata.etag" : "etag1", Note : "Note 1", SalesOrderID : "1"}
				]
			})
			.expectChange("id", ["3", "1"])
			.expectChange("note", ["Note 3", "Note 1"]);

		oBinding.sort(new Sorter("SalesOrderID", true));
	},
	expectOnReset : function () {
		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$orderby=SalesOrderID desc&$skip=0&$top=100", {
				"@odata.count" : "3",
				value : [
					{"@odata.etag" : "etag3", Note : "Note 3", SalesOrderID : "3"},
					{"@odata.etag" : "etag2", Note : "Note 2", SalesOrderID : "2"},
					{"@odata.etag" : "etag1", Note : "Note 1", SalesOrderID : "1"}
				]
			})
			.expectChange("id", [, "2", "1"])
			.expectChange("note", [, "Note 2", "Note 1"])
			.expectChange("count", "3");
	}
}, {
	name : "filter deleted",
	reload : function (oBinding) {
		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$filter=(SalesOrderID ne '2') and not (SalesOrderID eq '2')"
				+ "&$skip=0&$top=100", {
				"@odata.count" : "2",
				value : [
					{"@odata.etag" : "etag1", Note : "Note 1", SalesOrderID : "1"},
					{"@odata.etag" : "etag3", Note : "Note 3", SalesOrderID : "3"}
				]
			});

		oBinding.filter(new Filter("SalesOrderID", FilterOperator.NE, "2"));
	},
	expectOnReset : function () {
		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$filter=SalesOrderID ne '2'&$skip=0&$top=100", {
				"@odata.count" : "2",
				value : [
					{"@odata.etag" : "etag1", Note : "Note 1", SalesOrderID : "1"},
					{"@odata.etag" : "etag3", Note : "Note 3", SalesOrderID : "3"}
				]
			});
	}
}, {
	name : "filter other",
	reload : function (oBinding) {
		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$filter=(SalesOrderID gt '1') and not (SalesOrderID eq '2')"
				+ "&$skip=0&$top=100", {
				"@odata.count" : "1",
				value : [
					{"@odata.etag" : "etag3", Note : "Note 3", SalesOrderID : "3"}
				]
			})
			.expectChange("id", ["3"])
			.expectChange("note", ["Note 3"])
			.expectChange("count", "1");

		oBinding.filter(new Filter("SalesOrderID", FilterOperator.GT, "1"));
	},
	expectOnReset : function () {
		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$filter=SalesOrderID gt '1'&$skip=0&$top=100", {
				"@odata.count" : "2",
				value : [
					{"@odata.etag" : "etag2", Note : "Note 2", SalesOrderID : "2"},
					{"@odata.etag" : "etag3", Note : "Note 3", SalesOrderID : "3"}
				]
			})
			.expectChange("id", ["2", "3"])
			.expectChange("note", ["Note 2", "Note 3"])
			.expectChange("count", "2");
	}
}, {
	name : "refresh",
	reload : function (oBinding) {
		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$filter=not (SalesOrderID eq '2')&$skip=0&$top=100", {
				"@odata.count" : "2",
				value : [
					{"@odata.etag" : "etag1*", Note : "Note 1*", SalesOrderID : "1"},
					{"@odata.etag" : "etag3*", Note : "Note 3*", SalesOrderID : "3"}
				]
			})
			.expectChange("note", ["Note 1*", "Note 3*"]);

		oBinding.refresh();
	},
	expectOnReset : function () {
		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$skip=0&$top=100", {
				"@odata.count" : "3",
				value : [
					{"@odata.etag" : "etag1*", Note : "Note 1*", SalesOrderID : "1"},
					{"@odata.etag" : "etag2*", Note : "Note 2*", SalesOrderID : "2"},
					{"@odata.etag" : "etag3*", Note : "Note 3*", SalesOrderID : "3"}
				]
			})
			.expectChange("id", [, "2", "3"])
			.expectChange("note", [, "Note 2*", "Note 3*"])
			.expectChange("count", "3");
	}
}].forEach(function (oFixture) {
	QUnit.test("CPOUI5ODATAV4-1639: ODLB: deferred delete & " + oFixture.name, function (assert) {
		var oBinding,
			oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oPromise,
			sView = '\
<Text id="count" text="{header>$count}"/>\
<Table id="list" items="{path : \'/SalesOrderList\', parameters : {$count : true}}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$count=true&$select=Note,SalesOrderID"
				+ "&$skip=0&$top=100", {
				"@odata.count" : "3",
				value : [
					{"@odata.etag" : "etag1", Note : "Note 1", SalesOrderID : "1"},
					{"@odata.etag" : "etag2", Note : "Note 2", SalesOrderID : "2"},
					{"@odata.etag" : "etag3", Note : "Note 3", SalesOrderID : "3"}
				]
			})
			.expectChange("id", ["1", "2", "3"])
			.expectChange("note", ["Note 1", "Note 2", "Note 3"])
			.expectChange("count");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("count", "3");

			oBinding = that.oView.byId("list").getBinding("items");
			that.oView.setModel(oModel, "header");
			that.oView.byId("count").setBindingContext(oBinding.getHeaderContext(), "header");

			return that.waitForChanges(assert, "count");
		}).then(function () {
			that.expectChange("id", [, "3"])
				.expectChange("note", [, "Note 3"])
				.expectChange("count", "2");

			oContext = oBinding.getCurrentContexts()[1];
			oPromise = oContext.delete("doNotSubmit");

			return that.waitForChanges(assert, "deferred delete");
		}).then(function () {
			oFixture.reload.call(that, oBinding);

			return that.waitForChanges(assert, oFixture.name);
		}).then(function () {
			that.expectCanceledError("Failed to delete /SalesOrderList('2')",
				"Request canceled: DELETE SalesOrderList('2'); group: doNotSubmit");
			oFixture.expectOnReset.call(that);

			return Promise.all([
				// code under test
				oBinding.resetChanges(),
				oPromise.then(mustFail, function (oError) {
					assert.ok(oError.canceled);
					assert.notOk(oContext.isDeleted());
					if (oFixture.name !== "filter deleted") {
						// the cache is still waiting for the response
						return oContext.requestProperty("SalesOrderID").then(function (sValue) {
							assert.strictEqual(sValue, "2");
						});
					}
				}),
				that.waitForChanges(assert, "reset")
			]);
		}).then(function () {
			if (oFixture.name !== "filter deleted") {
				assert.strictEqual(oContext.getBinding(), oBinding);
				assert.strictEqual(oContext.getProperty("SalesOrderID"), "2");
			}
		});
	});
});

	//*********************************************************************************************
	// Scenario: Deferred deletion of a context in a relative ODLB. Switch to another parent
	// context, so that the cache is inactive. Then cancel the delete. The binding must not change
	// (neither its contexts, nor its count).
	// In a second test, sort before changing the parent context, so that the cache must be reset
	// for the reinsertion.
	// BCP: 2270160572
	//
	// Context#hasPendingChanges works properly for changes in active caches, even if there are
	// intermediate bindings (w/ and w/o own cache) in place.
	// JIRA: CPOUI5ODATAV4-1813
[true, false].forEach(function (bSort) {
	var sTitle = "BCP: 2270160572: deferred delete, reset in parked cache, sort=" + bSort;

	QUnit.test(sTitle, function (assert) {
		var oDeletePromise,
			sIntermediate = bSort
				? "binding=\"{path : \'\', parameters : {$$ownRequest : true}}\""
				: "",
			oItemsBinding,
			oModel = this.createSalesOrdersModel({updateGroupId : "update"}),
			oObjectPage,
			sOrderBy = bSort ? "&$orderby=SalesOrderID desc" : "",
			oOrdersBinding,
			oSalesOrder1,
			oSalesOrder2,
			sView = '\
<Table id="orders" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="objectPage" ' + sIntermediate + '>\
	<Text id="note" text="{Note}"/>\
	<FlexBox binding="{}">\
		<Text id="count" text="{header>$count}"/>\
		<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$count : true}}">\
			<Text id="pos" text="{ItemPosition}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1", Note : "Note 1"},
					{SalesOrderID : "2", Note : "Note 2"}
				]
			})
			.expectChange("id", ["1", "2"])
			.expectChange("note")
			.expectChange("count")
			.expectChange("pos", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.oView.setModel(oModel, "header");
			oOrdersBinding = that.oView.byId("orders").getBinding("items");
			oItemsBinding = that.oView.byId("items").getBinding("items");
			oObjectPage = that.oView.byId("objectPage");
			oSalesOrder1 = oOrdersBinding.getCurrentContexts()[0];
			oSalesOrder2 = oOrdersBinding.getCurrentContexts()[1];

			if (sIntermediate) {
				that.expectRequest("SalesOrderList('1')", {Note : "Note 1", SalesOrderID : "1"});
			}
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$count=true&$skip=0&$top=100", {
					"@odata.count" : "3",
					value : [
						{ItemPosition : "11", SalesOrderID : "1"},
						{ItemPosition : "12", SalesOrderID : "1"},
						{ItemPosition : "13", SalesOrderID : "1"}
					]
				})
				.expectChange("note", "Note 1")
				.expectChange("count", "3")
				.expectChange("pos", ["11", "12", "13"]);

			oObjectPage.setBindingContext(oSalesOrder1);
			oObjectPage.setBindingContext(oItemsBinding.getHeaderContext(), "header");

			return that.waitForChanges(assert, "SalesOrderList('1')");
		}).then(function () {
			that.expectChange("count", "2");
			if (bSort) {
				that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$count=true" + sOrderBy
						+ "&$filter=not (SalesOrderID eq '1' and ItemPosition eq '11')"
						+ "&$skip=0&$top=100", {
						"@odata.count" : "2",
						value : [
							{ItemPosition : "13", SalesOrderID : "1"},
							{ItemPosition : "12", SalesOrderID : "1"}
						]
					})
					.expectChange("pos", ["13", "12"]);
			} else {
				that.expectChange("pos", ["12", "13"]);
			}

			oDeletePromise = oItemsBinding.getCurrentContexts()[0].delete();
			if (bSort) {
				oItemsBinding.sort(new Sorter("SalesOrderID", true));
			}

			return that.waitForChanges(assert, "deferred delete" + (bSort ? " and sort" : ""));
		}).then(function () {
			if (sIntermediate) {
				that.expectRequest("SalesOrderList('2')", {Note : "Note 2", SalesOrderID : "2"});
			}
			that.expectRequest("SalesOrderList('2')/SO_2_SOITEM?$count=true" + sOrderBy
					+ "&$skip=0&$top=100", {
					"@odata.count" : "1",
					value : [
						{ItemPosition : "21", SalesOrderID : "2"}
					]
				})
				.expectChange("note", "Note 2")
				.expectChange("count", "1")
				.expectChange("pos", ["21"]);

			assert.ok(oSalesOrder1.hasPendingChanges());

			oObjectPage.setBindingContext(oSalesOrder2);
			oObjectPage.setBindingContext(oItemsBinding.getHeaderContext(), "header");

			assert.ok(oOrdersBinding.hasPendingChanges());
			assert.notOk(oItemsBinding.hasPendingChanges());
			// assert.ok(oSalesOrder1.hasPendingChanges()); we do not care, false is ok so far
			assert.notOk(oSalesOrder2.hasPendingChanges());

			return that.waitForChanges(assert, "SalesOrderList('2')");
		}).then(function () {
			that.expectCanceledError("Failed to delete /SalesOrderList('1')"
					+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='11')",
				"Request canceled: DELETE SalesOrderList('1')"
					+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='11'); group: update");

			// code under test
			oOrdersBinding.resetChanges();

			return Promise.all([
				checkCanceled(assert, oDeletePromise),
				that.waitForChanges(assert, "cancel the delete")
			]);
		}).then(function () {
			assert.notOk(oOrdersBinding.hasPendingChanges());
			assert.notOk(oSalesOrder1.hasPendingChanges());
			assert.strictEqual(oItemsBinding.getCount(), 1);
			assert.deepEqual(oItemsBinding.getAllCurrentContexts().map(getPath), [
				"/SalesOrderList('2')/SO_2_SOITEM(SalesOrderID='2',ItemPosition='21')"
			]);

			that.expectChange("note", "Note 1")
				.expectChange("count", "3");
			if (bSort) {
				that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$count=true" + sOrderBy
						+ "&$skip=0&$top=100", {
						"@odata.count" : "3",
						value : [
							{ItemPosition : "13", SalesOrderID : "1"},
							{ItemPosition : "12", SalesOrderID : "1"},
							{ItemPosition : "11", SalesOrderID : "1"}
						]
					})
					.expectChange("pos", ["13", "12", "11"]);
			} else {
				that.expectChange("pos", ["11", "12", "13"]);
			}

			oObjectPage.setBindingContext(oOrdersBinding.getCurrentContexts()[0]);
			oObjectPage.setBindingContext(oItemsBinding.getHeaderContext(), "header");

			return that.waitForChanges(assert, "back to SalesOrderList('1')");
		}).then(function () {
			var aExpectedPaths = [
					"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='11')",
					"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='12')",
					"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='13')"
				];

			if (bSort) {
				aExpectedPaths.reverse();
			}
			assert.strictEqual(oItemsBinding.getCount(), 3);
			assert.deepEqual(oItemsBinding.getAllCurrentContexts().map(getPath), aExpectedPaths);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Entity list and detail page with empty-path ODCB. Deferred deletion on the ODCB
	// which delegates to the ODLB.
	// JIRA: CPOUI5ODATAV4-1926
[false, true].forEach(function (bReset) {
	var sTitle = "CPOUI5ODATAV4-1926: deferred delete, delegate to ODLB, reset=" + bReset;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oDetailPage,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oPageContext,
			oPromise,
			oRowContext,
			sView = '\
<Table id="list" items="{/SalesOrderList}">\
	<Text id="listId" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="detailPage" binding="{}">\
	<Text id="id" text="{SalesOrderID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"}
				]
			})
			.expectChange("listId", ["1", "2"])
			.expectChange("id");

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("list").getBinding("items");
			oRowContext = oBinding.getCurrentContexts()[0];
			oDetailPage = that.oView.byId("detailPage");

			that.expectChange("id", "1");

			oDetailPage.setBindingContext(oRowContext);

			return that.waitForChanges(assert, "object page");
		}).then(function () {
			oPageContext = oDetailPage.getBindingContext();

			that.expectChange("listId", ["2"])
				.expectChange("id", null);

			// code under test
			oPromise = oPageContext.delete();
			// Note: This must be done afterwards; it would destroy oPageContext otherwise.
			// (oPageContext.delete() destroys it too; in both cases simply because the ODCB of the
			// detail page becomes unresolved.)
			oDetailPage.setBindingContext(null);

			assert.notStrictEqual(oPageContext, oRowContext);
			assert.ok(oPageContext.isDeleted(), "the deletion is started here");
			assert.ok(oRowContext.isDeleted(), "the deletion is performed here");
			assert.notOk(oPageContext.getModel(), "destroyed, the page binding became unresolved");

			return that.waitForChanges(assert, "deferred delete");
		}).then(function () {
			if (bReset) {
				that.expectCanceledError("Failed to delete /SalesOrderList('1')",
					"Request canceled: DELETE SalesOrderList('1'); group: update");
				that.expectChange("listId", ["1", "2"]);

				// code under test
				oModel.resetChanges("update");

				assert.notOk(oPageContext.isDeleted());
				assert.notOk(oRowContext.isDeleted());
			} else {
				that.expectRequest("DELETE SalesOrderList('1')");
			}

			return Promise.all([
				oPromise.then(function () {
					assert.notOk(bReset);
					assert.ok(oPageContext.isDeleted());
					assert.ok(oRowContext.isDeleted());
				}, function (oError) {
					assert.ok(bReset);
					assert.ok(oError.canceled);
					assert.deepEqual(oBinding.getCurrentContexts().map(getPath),
						["/SalesOrderList('1')", "/SalesOrderList('2')"]);
					assert.strictEqual(oRowContext.getProperty("SalesOrderID"), "1");
					assert.notOk(oPageContext.isDeleted());
					assert.notOk(oRowContext.isDeleted());

					that.expectChange("id", "1");

					oDetailPage.setBindingContext(oRowContext);
				}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, bReset ? "reset" : "submit")
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Create a context in a relative ODLB below an ODCB. Switch to another parent
	// context of the ODCB, so that the cache is inactive. Then cancel the creation. The binding
	// must not change (neither its contexts, nor its count).
	QUnit.test("BCP: 2270164161: create, reset in parked cache", function (assert) {
		var oContext,
			oItemsBinding,
			oModel = this.createSalesOrdersModel({updateGroupId : "update"}),
			oObjectPage,
			oOrdersBinding,
			sView = '\
<Table id="orders" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>\
<FlexBox binding="{}" id="objectPage">\
	<Text id="count" text="{header>$count}"/>\
	<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$count : true}}">\
		<Text id="pos" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"}
				]
			})
			.expectChange("id", ["1", "2"])
			.expectChange("count")
			.expectChange("pos", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.oView.setModel(oModel, "header");
			oOrdersBinding = that.oView.byId("orders").getBinding("items");
			oItemsBinding = that.oView.byId("items").getBinding("items");
			oObjectPage = that.oView.byId("objectPage");

			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$count=true&$skip=0&$top=100", {
					"@odata.count" : "3",
					value : [
						{ItemPosition : "11", SalesOrderID : "1"},
						{ItemPosition : "12", SalesOrderID : "1"},
						{ItemPosition : "13", SalesOrderID : "1"}
					]
				})
				.expectChange("count", "3")
				.expectChange("pos", ["11", "12", "13"]);

			oObjectPage.setBindingContext(oOrdersBinding.getCurrentContexts()[0]);
			oObjectPage.setBindingContext(oItemsBinding.getHeaderContext(), "header");

			return that.waitForChanges(assert, "SalesOrderList('1')");
		}).then(function () {
			that.expectChange("count", "4")
				.expectChange("pos", ["new", "11", "12", "13"]);

			oContext = oItemsBinding.create({ItemPosition : "new"});

			return that.waitForChanges(assert, "create");
		}).then(function () {
			that.expectRequest("SalesOrderList('2')/SO_2_SOITEM?$count=true&$skip=0&$top=100", {
					"@odata.count" : "1",
					value : [
						{ItemPosition : "21", SalesOrderID : "2"}
					]
				})
				.expectChange("count", "1")
				.expectChange("pos", ["21"]);

			oObjectPage.setBindingContext(oOrdersBinding.getCurrentContexts()[1]);
			oObjectPage.setBindingContext(oItemsBinding.getHeaderContext(), "header");

			return that.waitForChanges(assert, "SalesOrderList('2')");
		}).then(function () {
			// There is no reportError

			// code under test
			oOrdersBinding.resetChanges();

			return Promise.all([
				checkCanceled(assert, oContext.created()),
				that.waitForChanges(assert, "cancel the create")
			]);
		}).then(function () {
			assert.strictEqual(oItemsBinding.getCount(), 1);
			assert.deepEqual(oItemsBinding.getAllCurrentContexts().map(getPath), [
				"/SalesOrderList('2')/SO_2_SOITEM(SalesOrderID='2',ItemPosition='21')"
			]);

			that.expectChange("count", "3");
			that.expectChange("pos", ["11", "12", "13"]);

			oObjectPage.setBindingContext(oOrdersBinding.getCurrentContexts()[0]);
			oObjectPage.setBindingContext(oItemsBinding.getHeaderContext(), "header");

			return that.waitForChanges(assert, "back to SalesOrderList('1')");
		}).then(function () {
			assert.strictEqual(oItemsBinding.getCount(), 3);
			assert.deepEqual(oItemsBinding.getAllCurrentContexts().map(getPath), [
				"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='11')",
				"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='12')",
				"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='13')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A deletion causes a gap, is performed immediately (but not in $auto) and fails. The
	// gap-filling GET via $auto runs concurrently. Since it uses $filter to exclude the client-
	// deleted entities, it is indepent on the order in which the requests are processed on the
	// server. See that the re-inserted and the requested entities are ordered correctly, regardless
	// which response is processed first.
	// JIRA: CPOUI5ODATAV4-1660
[false, true].forEach(function (bDirect) {
	[false, true].forEach(function (bDeleteFirst) {
	var sTitle = "CPOUI5ODATAV4-1660: " + (bDirect ? "$direct" : "$auto.foo")
			+ " DELETE fails " + (bDeleteFirst ? "before" : "after") + " the gap-filling GET";

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oDeletePromise,
			oGetResult = {value : [{SalesOrderID : "3"}]},
			oModel = this.createSalesOrdersModel({
				groupId : bDirect ? "$direct" : "$auto",
				autoExpandSelect : true
			}),
			fnRejectDelete,
			fnResolveGet,
			sView = '\
<Table id="table" growing="true" growingThreshold="2" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=2", {
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"}
				]
			})
			.expectChange("id", ["1", "2"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("table").getItems()[1].getBindingContext();

			that.expectRequest("DELETE SalesOrderList('2')",
					new Promise(function (_resolve, reject) { fnRejectDelete = reject; }))
				.expectRequest("SalesOrderList?$select=SalesOrderID"
					+ "&$filter=not (SalesOrderID eq '2')&$skip=1&$top=1",
					new Promise(function (resolve) { fnResolveGet = resolve; }));

			oBinding = oContext.getBinding();
			/* code under test */
			oDeletePromise = oContext.delete(bDirect ? "$direct" : "$auto.foo");

			if (!bDeleteFirst) {
				that.expectChange("id", [, "3"]);

				fnResolveGet(oGetResult);
			}

			return that.waitForChanges(assert, bDeleteFirst ? "delete" : "delete and GET");
		}).then(function () {
			var sMessage = bDirect ? "Communication error: 500 " : "Request intentionally failed";

			that.oLogMock.expects("error").withArgs("Failed to delete /SalesOrderList('2')");
			that.expectMessages([{
					code : bDirect ? undefined : "CODE",
					message : sMessage,
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			if (!bDeleteFirst) {
				that.expectChange("id", [, "2"]);
			}

			fnRejectDelete(bDirect ? createError() : createErrorInsideBatch());

			return Promise.all([
				oDeletePromise.then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, sMessage);
				}),
				that.waitForChanges(assert, "DELETE fails")
			]);
		}).then(function () {
			if (bDeleteFirst) {
				fnResolveGet(oGetResult);

				// no visible changes to wait for because the GET response is added behind the
				// visible range
				return resolveLater();
			}
		}).then(function () {
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getPath),
				["/SalesOrderList('1')", "/SalesOrderList('2')", "/SalesOrderList('3')"]);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: BCP 1870017061
	// List/Detail, object page with a sap.ui.table.Table: When changing the entity for the object
	// page the property bindings below the table's list binding complained about an invalid path in
	// deregisterChangeListener. This scenario only simulates the object page, the contexts from the
	// list are hardcoded to keep the test small.
	QUnit.test("deregisterChangeListener", function (assert) {
		var oModel = this.createSalesOrdersModel(),
			sView = '\
<FlexBox id="form">\
	<t:Table rows="{path : \'SO_2_SOITEM\', parameters : {$$updateGroupId : \'update\'}}">\
		<Text id="position" text="{ItemPosition}"/>\
	</t:Table>\
</FlexBox>',
			that = this;

		this.expectChange("position", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('0500000000')/SO_2_SOITEM?$skip=0&$top=110", {
					value : [{
						ItemPosition : "10",
						SalesOrderID : "0500000000"
					}]
				})
				.expectChange("position", ["10"]);

			that.oView.byId("form").bindElement("/SalesOrderList('0500000000')");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('0500000001')/SO_2_SOITEM?$skip=0&$top=110", {
					value : [{
						ItemPosition : "20",
						SalesOrderID : "0500000001"
					}]
				})
				.expectChange("position", ["20"]);

			that.oView.byId("form").bindElement("/SalesOrderList('0500000001')");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	QUnit.test("delayed create", function (assert) {
		var oModel = this.createSalesOrdersModel(),
			sView = '<FlexBox id="form" binding="{/SalesOrderList(\'0500000000\')}"/>',
			that = this;

		return this.createView(assert, sView, oModel).then(function () {
			var oParentBinding = that.oView.byId("form").getElementBinding(),
				oListBinding = that.oModel.bindList("SO_2_SOITEM", oParentBinding.getBoundContext(),
					undefined, undefined, {$$updateGroupId : "update"});

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('0500000000')/SO_2_SOITEM",
					payload : {}
				}, {
					SalesOrderID : "0500000000",
					ItemPosition : "0010"
				})
				.expectRequest("SalesOrderList('0500000000')"
					+ "/SO_2_SOITEM(SalesOrderID='0500000000',ItemPosition='0010')", {
					SalesOrderID : "0500000000",
					ItemPosition : "0010"
				});

			oListBinding.create();

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	QUnit.test("delayed invoke", function (assert) {
		var sAction = "SalesOrderList('0500000000')/"
				+ "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Cancel",
			oModel = this.createSalesOrdersModel(),
			sView = '<FlexBox id="form" binding="{/' + sAction + '(...)}"/>',
			that = this;

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "POST",
					url : sAction,
					payload : {}
				}, {SalesOrderID : "0500000000"});

			return Promise.all([
				that.oView.byId("form").getElementBinding().invoke("update"),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh using a group with submit mode 'API'. The view contains one context binding
	// without children. Hence the binding doesn't invoke a request, but its lock must be released.
	QUnit.test("ODCB: delayed refresh", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = `
<FlexBox binding="{/BusinessPartnerList('0100000000')}">
	<Text id="company" text="{CompanyName}"/>
</FlexBox>
<FlexBox binding="{/SalesOrderList('1')}"/>`,
			that = this;

		this.expectRequest("BusinessPartnerList('0100000000')"
				+ "?$select=BusinessPartnerID,CompanyName", {
				BusinessPartnerID : "0100000000",
				CompanyName : "SAP AG"
			})
			.expectChange("company", "SAP AG");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("BusinessPartnerList('0100000000')"
					+ "?$select=BusinessPartnerID,CompanyName", {
					BusinessPartnerID : "0100000000",
					CompanyName : "SAP SE"
				})
				.expectChange("company", "SAP SE");

			that.oModel.refresh("update");

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh using a group with submit mode 'API'. The model contains one list binding
	// without a control. Hence getContexts() is not called and no request is invoked. But the
	// lock must be released.
	QUnit.test("ODLB: delayed refresh", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
				value : [{
					Note : "Note",
					SalesOrderID : "0500000000"
				}]
			})
			.expectChange("note", ["Note"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.oModel.bindList("/BusinessPartnerList"); // a list binding w/ no control behind

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						Note : "Note updated",
						SalesOrderID : "0500000000"
					}]
				})
				.expectChange("note", ["Note updated"]);

			that.oModel.refresh("update");

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: change the filter on a list binding with submit group 'API' and immediately call
	// submitBatch. The resulting GET request becomes asynchronous because it requires additional
	// metadata. Check that the request is sent with this batch nevertheless.
	// In a second step call filter on a list binding w/o control. Verify that the queue does not
	// remain blocked, although there is no getContexts and no GET request.
	QUnit.test("ODLB: delayed filter", function (assert) {
		var oTableBinding,
			sView = '\
<Table id="table" items="{path : \'/Equipments\', parameters : {$$groupId : \'api\'}}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectChange("name", []);

		return this.createView(assert, sView).then(function () {
			that.expectRequest("Equipments?$skip=0&$top=100", {
					value : [{
						Category : "1",
						ID : "2",
						Name : "Foo"
					}]
				})
				.expectChange("name", ["Foo"]);

			return Promise.all([
				that.oModel.submitBatch("api"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			oTableBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("Equipments"
					+ "?$filter=EQUIPMENT_2_PRODUCT/ID eq 42&$skip=0&$top=100", {
					value : [{Name : "Bar"}]
				})
				.expectChange("name", ["Bar"]);

			oTableBinding.filter(new Filter("EQUIPMENT_2_PRODUCT/ID", "EQ", 42));

			return Promise.all([
				that.oModel.submitBatch("api"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oListBinding = that.oModel.bindList("/Equipments", undefined, undefined, undefined,
					{$$groupId : "api"});

			that.expectRequest("Equipments?$skip=0&$top=100", {
					value : [{Name : "Foo"}]
				})
				// The field is reset first, because the filter request is delayed until the next
				// prerendering task
				.ignoreNullChanges("name")
				.expectChange("name", ["Foo"]);

			// This binding has no control -> no request, but timeout of group lock expected
			oListBinding.filter(new Filter("Name", "GT", "M"));
			oTableBinding.filter(null);

			return Promise.all([
				that.oModel.submitBatch("api"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with rowMode="Auto" and submit group 'API'
	// In the first step resume and immediately call submitBatch.
	// In the second step synchronously refresh with another group ID, change the filter and call
	// submitBatch. Check that the filter request is sent with this batch nevertheless.
	// Two issues have to be solved: the lock for the filter must win over the one for refresh and
	// the lock must not be removed again before the table becomes active.
	//
	//TODO enable this test again once the following issue is fixed: table calls ODLB#getContexts
	// while binding is still suspended, which is currently forbidden
	//ODataListBinding.getContexts (ODataListBinding.js?eval:1004)
	//Table._getContexts (Table.js?eval:2154)
	//Table._getRowContexts (Table.js?eval:2233)
	//Table._updateRows (Table.js?eval:3511)
	//Table._updateTableSizes (Table.js?eval:1503)
	//Promise.then (async)
	//Table.onAfterRendering (Table.js?eval:1402)
	QUnit.skip("ODLB: resume/refresh/filter w/ submitBatch on a t:Table", function (assert) {
		var oListBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<t:Table id="table" rowMode="Auto"\
		rows="{path : \'/Equipments\', parameters : {$$groupId : \'api\'}, suspended : true}">\
	<t:Column>\
		<t:label>\
			<Label text="Name"/>\
		</t:label>\
		<t:template>\
			<Text id="name" text="{Name}"/>\
		</t:template>\
	</t:Column>\
</t:Table>',
			that = this;

		this.expectChange("name", []);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("rows");

			that.expectRequest("Equipments?$select=Category,ID,Name&$skip=0&$top=105", {
					value : [{
						Category : "1",
						ID : "2",
						Name : "Foo"
					}]
				})
				.expectChange("name", ["Foo"]);

			oListBinding.resume();

			return Promise.all([
				that.oModel.submitBatch("api"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("Equipments?$select=Category,ID,Name"
					+ "&$filter=EQUIPMENT_2_PRODUCT/ID eq 42&$skip=0&$top=105", {
					value : [{
						Category : "1",
						ID : "2",
						Name : "Bar"
					}]
				})
				.expectChange("name", ["Bar"]);

			oListBinding.refresh("foo");
			oListBinding.filter(new Filter("EQUIPMENT_2_PRODUCT/ID", "EQ", 42));

			return Promise.all([
				that.oModel.submitBatch("api"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Binding-specific parameter $$aggregation is used (JIRA: CPOUI5UISERVICESV3-1195).
	// Check download URL (JIRA: CPOUI5ODATAV4-609).
	// Request leaf count(JIRA: CPOUI5ODATAV4-164).
	// Test ODLB#getCount (JIRA: CPOUI5ODATAV4-958).
	// Ensure that unchanged $$aggregation is ignored (BCP: 2370045709).
	//TODO support $filter : \'GrossAmount gt 0\',\
	QUnit.test("Data Aggregation: $$aggregation w/ groupLevels, paging", function (assert) {
		var oListBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<t:Table id="table" rows="{path : \'/SalesOrderList\',\
		parameters : {\
			$$aggregation : {\
				aggregate : {\
					GrossAmount : {subtotals : true},\
					NetAmount : {}\
				},\
				group : {\
					CurrencyCode : {},\
					LifecycleStatus : {}\
				},\
				groupLevels : [\'LifecycleStatus\']\
			},\
			$count : true,\
			$orderby : \'LifecycleStatus desc,ItemPosition asc\'\
		}}" threshold="0" visibleRowCount="3">\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="lifecycleStatus" text="{LifecycleStatus}"/>\
	<Text id="grossAmount" text="{= %{GrossAmount}}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList?$apply=concat("
				+ "groupby((CurrencyCode,LifecycleStatus))/aggregate($count as UI5__leaves)"
				+ ",groupby((LifecycleStatus),aggregate(GrossAmount))/orderby(LifecycleStatus desc)"
				+ "/concat(aggregate($count as UI5__count),top(3)))", {
				value : [
					{UI5__leaves : "42", "UI5__leaves@odata.type" : "#Decimal"},
					{UI5__count : "26", "UI5__count@odata.type" : "#Decimal"},
					{GrossAmount : "1", LifecycleStatus : "Z"},
					{GrossAmount : "2", LifecycleStatus : "Y"},
					{GrossAmount : "3", LifecycleStatus : "X"}
				]
			})
			.expectChange("count")
			.expectChange("isExpanded", [false, false, false])
			.expectChange("isTotal", [true, true, true])
			.expectChange("level", [1, 1, 1])
			.expectChange("grossAmount", ["1", "2", "3"])
			.expectChange("lifecycleStatus", ["Z", "Y", "X"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("rows");

			assert.strictEqual(oListBinding.getDownloadUrl(), sSalesOrderService + "SalesOrderList"
				+ "?$apply=groupby((LifecycleStatus,CurrencyCode),aggregate(GrossAmount,NetAmount))"
				// Note: ordering by 'ItemPosition asc' does not apply, even on leaf level
				+ "/orderby(LifecycleStatus%20desc)",
				"CPOUI5ODATAV4-609");

			oListBinding.getCurrentContexts().forEach(function (oContext, i) {
				assert.strictEqual(oContext.getPath(),
					"/SalesOrderList(LifecycleStatus='" + "ZYX"[i] + "')");
			});

			assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
			assert.strictEqual(oListBinding.getLength(), 26, "flat list as currently expanded");
			assert.strictEqual(oListBinding.getCount(), 42, "count of leaves");
			// Note: header context gives count of leaves
			that.expectChange("count", "42");

			that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList"
					+ "?$apply=groupby((LifecycleStatus),aggregate(GrossAmount))"
					+ "/orderby(LifecycleStatus desc)/skip(7)/top(3)", {
					value : [
						{GrossAmount : "7", LifecycleStatus : "T"},
						{GrossAmount : "8", LifecycleStatus : "S"},
						{GrossAmount : "9", LifecycleStatus : "R"}
					]
				})
				.expectChange("isExpanded", [,,,,,,, false, false, false])
				.expectChange("isTotal", [,,,,,,, true, true, true])
				.expectChange("level", [,,,,,,, 1, 1, 1])
				.expectChange("grossAmount", [,,,,,,, "7", "8", "9"])
				.expectChange("lifecycleStatus", [,,,,,,, "T", "S", "R"]);

			oTable.setFirstVisibleRow(7);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$apply=concat("
					+ "groupby((CurrencyCode,LifecycleStatus))/aggregate($count as UI5__leaves)"
					+ ",groupby((LifecycleStatus))/orderby(LifecycleStatus desc)"
					+ "/concat(aggregate($count as UI5__count),top(3)))", {
					value : [
						{UI5__leaves : "32", "UI5__leaves@odata.type" : "#Decimal"},
						{UI5__count : "26", "UI5__count@odata.type" : "#Decimal"},
						{LifecycleStatus : "Z"},
						{LifecycleStatus : "Y"},
						{LifecycleStatus : "X"}
					]
				})
				.expectChange("count", "32")
				.expectChange("isExpanded", [false, false, false])
				.expectChange("isTotal", [false, false, false])
				.expectChange("level", [1, 1, 1])
				.expectChange("lifecycleStatus", ["Z", "Y", "X"]);

			oTable.removeColumn(4).destroy(); // GrossAmount
			oListBinding.setAggregation({
				group : {
					// Note: a single group level w/o further groups makes little sense
					CurrencyCode : {}
				},
				groupLevels : ["LifecycleStatus"]
			});

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(oListBinding.getCount(), 32, "count of leaves");

			assert.throws(function () {
				oListBinding.changeParameters({$apply : "groupby((LifecycleStatus))"});
			}, new Error("Cannot combine $$aggregation and $apply"));

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {},
				group : {
					CurrencyCode : {},
					LifecycleStatus : {}
				},
				groupLevels : ["LifecycleStatus"]
			}, "JIRA: CPOUI5ODATAV4-1825");

			// no additional request for same aggregation data
			// code under test (BCP: 2370045709)
			oListBinding.setAggregation({
				group : {
					CurrencyCode : {}
					// LifecycleStatus : {}
				},
				groupLevels : ["LifecycleStatus"]
			});
			// code under test (BCP: 2370045709)
			oListBinding.changeParameters({
				$$aggregation : {
					group : {
						CurrencyCode : {}
						// LifecycleStatus : {}
					},
					groupLevels : ["LifecycleStatus"]
				}
			});

			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-2337)
				oListBinding.getHeaderContext().isAncestorOf(/*don't care*/);
			}, new Error("Missing recursive hierarchy"));
		});
	});

	//*********************************************************************************************
	// Scenario: Data aggregation with grand total, but no visual grouping. Observe the node status.
	// BCP: 2080089628
	//
	// Use a unit for the grand total.
	// JIRA: CPOUI5ODATAV4-583
	//
	// Show additional text property even w/o group levels.
	// JIRA: CPOUI5ODATAV4-680
	//
	// Check the download URL.
	// JIRA: CPOUI5ODATAV4-609
	//
	// Test ODLB#getCount
	// JIRA: CPOUI5ODATAV4-958
	QUnit.test("Data Aggregation: $$aggregation w/ grand total w/ unit", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/SalesOrderList\',\
		parameters : {\
			$$aggregation : {\
				aggregate : {\
					GrossAmount : {grandTotal : true, unit : \'CurrencyCode\'}\
				},\
				group : {\
					LifecycleStatus : {additionally : [\'LifecycleStatusDesc\']}\
				}\
			},\
			$orderby : \'LifecycleStatusDesc asc\'\
		}}">\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="lifecycleStatus" text="{LifecycleStatus}"/>\
	<Text id="lifecycleStatusDesc" text="{LifecycleStatusDesc}"/>\
	<Text id="grossAmount" text="{= %{GrossAmount}}"/>\
	<Text id="currencyCode" text="{CurrencyCode}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$apply=concat(aggregate(GrossAmount,CurrencyCode)"
				+ ",groupby((LifecycleStatus,LifecycleStatusDesc)"
					+ ",aggregate(GrossAmount,CurrencyCode))"
				+ "/orderby(LifecycleStatusDesc asc)"
				+ "/concat(aggregate($count as UI5__count),top(99)))", {
				value : [
					{CurrencyCode : null, GrossAmount : "12345"},
					{UI5__count : "2", "UI5__count@odata.type" : "#Decimal"},
					{CurrencyCode : "EUR", GrossAmount : "1", LifecycleStatus : "Z",
						LifecycleStatusDesc : "<Z>"},
					{CurrencyCode : "GBP", GrossAmount : "2", LifecycleStatus : "Y",
						LifecycleStatusDesc : "<Y>"}
				]
			})
			.expectChange("isExpanded", [true, undefined, undefined])
			.expectChange("isTotal", [true, false, false])
			.expectChange("level", [0, 1, 1])
			.expectChange("lifecycleStatus", ["", "Z", "Y"])
			.expectChange("lifecycleStatusDesc", ["", "<Z>", "<Y>"])
			.expectChange("grossAmount", ["12345", "1", "2"])
			.expectChange("currencyCode", ["", "EUR", "GBP"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oListBinding = that.oView.byId("table").getBinding("items");

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {
					GrossAmount : {grandTotal : true, unit : "CurrencyCode"}
				},
				group : {
					LifecycleStatus : {additionally : ["LifecycleStatusDesc"]}
				},
				groupLevels : []
			}, "JIRA: CPOUI5ODATAV4-1825");

			// code under test
			assert.strictEqual(oListBinding.getDownloadUrl(),
				sSalesOrderService + "SalesOrderList"
				+ "?$apply=groupby((LifecycleStatus,LifecycleStatusDesc)"
					+ ",aggregate(GrossAmount,CurrencyCode))/orderby(LifecycleStatusDesc%20asc)",
				"CPOUI5ODATAV4-609");
			assert.strictEqual(oListBinding.getLength(), 3, "table length");
			assert.strictEqual(oListBinding.getCount(), 2, "count of leaves");
		});
	});

	//*********************************************************************************************
	// Scenario: Data aggregation with grand total, but no visual grouping. Observe the leaves' key
	// predicates in case all key properties are available. Expect no unnecessary group levels in
	// there!
	// JIRA: CPOUI5ODATAV4-700
	// Check that create, delete, refresh, and late property requests are not supported.
	// JIRA: CPOUI5ODATAV4-1851
	QUnit.test("Data Aggregation: leaves' key predicates", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/SalesOrderList\',\
		parameters : {\
			$$aggregation : {\
				aggregate : {\
					GrossAmount : {grandTotal : true}\
				},\
				group : {\
					LifecycleStatus : {},\
					SalesOrderID : {}\
				}\
			}\
		}}">\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="lifecycleStatus" text="{LifecycleStatus}"/>\
	<Text id="grossAmount" text="{= %{GrossAmount}}"/>\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$apply=concat(aggregate(GrossAmount)"
				+ ",groupby((LifecycleStatus,SalesOrderID),aggregate(GrossAmount))"
				+ "/concat(aggregate($count as UI5__count),top(99)))", {
				value : [
					{GrossAmount : "12345"},
					{UI5__count : "2", "UI5__count@odata.type" : "#Decimal"},
					{GrossAmount : "1", LifecycleStatus : "Z", SalesOrderID : "26"},
					{GrossAmount : "2", LifecycleStatus : "Y", SalesOrderID : "25"}
				]
			})
			.expectChange("isExpanded", [true, undefined, undefined])
			.expectChange("isTotal", [true, false, false])
			.expectChange("level", [0, 1, 1])
			.expectChange("lifecycleStatus", ["", "Z", "Y"])
			.expectChange("grossAmount", ["12345", "1", "2"])
			.expectChange("salesOrderID", ["", "26", "25"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oPromise,
				oTable = that.oView.byId("table"),
				oBinding = oTable.getBinding("items"),
				aCurrentContexts = oBinding.getCurrentContexts();

			assert.deepEqual(aCurrentContexts.map(getPath), [
				"/SalesOrderList()",
				"/SalesOrderList('26')", // SalesOrderID is the single key property!
				"/SalesOrderList('25')"
			]);

			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-1851)
				oBinding.create();
			}, new Error("Cannot create in " + oBinding + " when using data aggregation"));

			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-1851)
				aCurrentContexts[1].delete();
			}, new Error("Cannot delete " + aCurrentContexts[1] + " when using data aggregation"));

			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-1851)
				aCurrentContexts[1].requestRefresh();
			}, new Error("Cannot refresh " + aCurrentContexts[1] + " when using data aggregation"));

			that.expectChange("lifecycleStatus", [, "Z*"])
				.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('26')",
					payload : {LifecycleStatus : "Z*"}
				}, {GrossAmount : "1", LifecycleStatus : "*Z*", SalesOrderID : "26"})
				.expectChange("lifecycleStatus", [, "*Z*"]);

			// code under test (JIRA: CPOUI5ODATAV4-1851)
			oPromise = aCurrentContexts[1].setProperty("LifecycleStatus", "Z*");

			// Note: _Helper.isDataAggregation prevents mLateQueryOptions as intended
			that.oLogMock.expects("error")
				.withArgs("Failed to drill-down into (\'26\')/Note, invalid segment: Note");

			return Promise.all([
				oPromise,
				// code under test (JIRA: CPOUI5ODATAV4-1851)
				aCurrentContexts[1].requestProperty("Note").then(function (sNote) {
					assert.strictEqual(sNote, undefined, "no late property request");
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Data aggregation which aggregates a key property (count number of sales orders per
	// lifecycle status) via $$aggregation or directly via $apply. Expect no issues with duplicate
	// key predicates.
	// BCP: 2280187516
[false, true].forEach(function (bApply) {
	var sTitle = "Data Aggregation: aggregate a key property, use $apply: " + bApply;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSalesOrdersModel(),
			mParameters = bApply
			? {$apply : "groupby((LifecycleStatus),aggregate(SalesOrderID))"}
			: {
				$$aggregation : {
					aggregate : {
						SalesOrderID : {}
					},
					group : {
						LifecycleStatus : {}
					}
				}
			},
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oBinding = oModel.bindList("/SalesOrderList", null, [], [], mParameters);

			that.expectRequest("SalesOrderList"
					+ "?$apply=groupby((LifecycleStatus),aggregate(SalesOrderID))"
					+ "&$skip=0&$top=10", {
					value : [{
						LifecycleStatus : "Z",
						SalesOrderID : 1, "SalesOrderID@odata.type" : "#Int32"
					}, {
						LifecycleStatus : "Y",
						SalesOrderID : 3, "SalesOrderID@odata.type" : "#Int32"
					}, {
						LifecycleStatus : "X",
						SalesOrderID : 1, "SalesOrderID@odata.type" : "#Int32"
					}]
				});

			return oBinding.requestContexts(0, 10);
		}).then(function (aContexts) {
			assert.notStrictEqual(aContexts[0], aContexts[2], "no duplicates");
			assert.deepEqual(aContexts.map(getPath),
				["/SalesOrderList/0", "/SalesOrderList/1", "/SalesOrderList/2"]);
			assert.deepEqual(aContexts.map(getObject), [
				{LifecycleStatus : "Z", SalesOrderID : 1, "SalesOrderID@odata.type" : "#Int32"},
				{LifecycleStatus : "Y", SalesOrderID : 3, "SalesOrderID@odata.type" : "#Int32"},
				{LifecycleStatus : "X", SalesOrderID : 1, "SalesOrderID@odata.type" : "#Int32"}
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Data aggregation which aggregates a key property (count number of sales orders per
	// lifecycle status) via $$aggregation including a grand total. Expect no issues with duplicate
	// key predicates.
	// BCP: 2280187516
	QUnit.test("Data Aggregation: aggregate a key property, w/ grand total", function (assert) {
		var oModel = this.createSalesOrdersModel(),
			mParameters = {
				$$aggregation : {
					aggregate : {
						SalesOrderID : {grandTotal : true}
					},
					group : {
						LifecycleStatus : {}
					}
				}
			},
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oBinding = oModel.bindList("/SalesOrderList", null, [], [], mParameters);

			that.expectRequest("SalesOrderList?$apply=concat(aggregate(SalesOrderID)"
					+ ",groupby((LifecycleStatus),aggregate(SalesOrderID))"
					+ "/concat(aggregate($count as UI5__count),top(9)))", {
					value : [{
						LifecycleStatus : null,
						SalesOrderID : 5, "SalesOrderID@odata.type" : "#Int32"
					}, {
						UI5__count : "3", "UI5__count@odata.type" : "#Decimal"
					}, {
						LifecycleStatus : "Z",
						SalesOrderID : 1, "SalesOrderID@odata.type" : "#Int32"
					}, {
						LifecycleStatus : "Y",
						SalesOrderID : 3, "SalesOrderID@odata.type" : "#Int32"
					}, {
						LifecycleStatus : "X",
						SalesOrderID : 1, "SalesOrderID@odata.type" : "#Int32"
					}]
				});

			return oBinding.requestContexts(0, 10);
		}).then(function (aContexts) {
			assert.notStrictEqual(aContexts[0], aContexts[2], "no duplicates");
			assert.deepEqual(aContexts.map(getPath), [
				"/SalesOrderList()",
				"/SalesOrderList(LifecycleStatus='Z')",
				"/SalesOrderList(LifecycleStatus='Y')",
				"/SalesOrderList(LifecycleStatus='X')"
			]);
			assert.deepEqual(aContexts.map(getObject), [{
				"@$ui5.node.isExpanded" : true,
				"@$ui5.node.isTotal" : true,
				"@$ui5.node.level" : 0,
				LifecycleStatus : null,
				SalesOrderID : 5,
				"SalesOrderID@odata.type" : "#Int32"
			}, {
				"@$ui5.node.isTotal" : false,
				"@$ui5.node.level" : 1,
				LifecycleStatus : "Z",
				SalesOrderID : 1,
				"SalesOrderID@odata.type" : "#Int32"
			}, {
				"@$ui5.node.isTotal" : false,
				"@$ui5.node.level" : 1,
				LifecycleStatus : "Y",
				SalesOrderID : 3,
				"SalesOrderID@odata.type" : "#Int32"
			}, {
				"@$ui5.node.isTotal" : false,
				"@$ui5.node.level" : 1,
				LifecycleStatus : "X",
				SalesOrderID : 1,
				"SalesOrderID@odata.type" : "#Int32"
			}]);
		});
	});

	//*********************************************************************************************
	// Scenario: sap.m.Table with aggregation and visual grouping.
	// JIRA: CPOUI5ODATAV4-162
	//
	// Expand the first node. Now press on "more" and you will see the next sub-nodes.
	// JIRA: CPOUI5ODATAV4-177
	//
	// Collapse the first node.
	// JIRA: CPOUI5ODATAV4-179
	//
	// Expand the first node again.
	// JIRA: CPOUI5ODATAV4-378
	//
	// Test ODLB#getCount
	// JIRA: CPOUI5ODATAV4-958
	//
	// Observe dataRequested and dataReceived events (BCP: 2370044114)
	QUnit.test("Data Aggregation: expand, paging and collapse on sap.m.Table", function (assert) {
		var oListBinding,
			iDataReceivedCount = 0,
			iDataRequestedCount = 0,
			oModel = this.createAggregationModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" growing="true" growingThreshold="3" items="{path : \'/BusinessPartners\',\
		parameters : {\
			$$aggregation : {\
				aggregate : {\
					SalesAmount : {subtotals : true},\
					SalesNumber : {}\
				},\
				group : {\
					AccountResponsible : {}\
				},\
				groupLevels : [\'Region\']\
			},\
			$count : false,\
			$orderby : \'Region desc,AccountResponsible\'\
		}}">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="accountResponsible" text="{AccountResponsible}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</Table>\
<FlexBox id="detail">\
	<Text id="regionDetail" text="{Region}"/>\
</FlexBox>',
			oTable,
			that = this;

		this.expectRequest("BusinessPartners?$apply=groupby((Region),aggregate(SalesAmount))"
				+ "/orderby(Region desc)&$count=true&$skip=0&$top=3", {
				"@odata.count" : "26",
				value : [
					{Region : "Z", SalesAmount : "100"},
					{Region : "Y", SalesAmount : "200"},
					{Region : "X", SalesAmount : "300"}
				]
			})
			.expectChange("groupLevelCount", [undefined, undefined, undefined])
			.expectChange("isExpanded", [false, false, false])
			.expectChange("isTotal", [true, true, true])
			.expectChange("level", [1, 1, 1])
			.expectChange("region", ["Z", "Y", "X"])
			.expectChange("accountResponsible", ["", "", ""])
			.expectChange("salesAmount", ["100", "200", "300"])
			.expectChange("salesNumber", [null, null, null])
			.expectChange("regionDetail");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("BusinessPartners?$apply=filter(Region eq 'Z')"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
					+ "/orderby(AccountResponsible)&$count=true&$skip=0&$top=3", {
					"@odata.count" : "4",
					value : [
						{AccountResponsible : "a", SalesAmount : "10", SalesNumber : 1},
						{AccountResponsible : "b", SalesAmount : "20", SalesNumber : 2},
						{AccountResponsible : "c", SalesAmount : "30", SalesNumber : 3}
					]
				})
				.expectChange("groupLevelCount", [4])
				.expectChange("isExpanded", [true, undefined, undefined])
				.expectChange("isTotal", [/*true*/, false, false])
				.expectChange("level", [/*1*/, 2, 2])
				.expectChange("region", [/*"Z"*/, "Z", "Z"])
				.expectChange("accountResponsible", [/*""*/, "a", "b"])
				.expectChange("salesAmount", [/*"100"*/, "10", "20"])
				.expectChange("salesNumber", [/*null*/, "1", "2"]);

			that.oLogMock.expects("error").withExactArgs("Failed to drill-down into $count, "
				+ "invalid segment: $count",
				"/aggregation/BusinessPartners?$apply=groupby((Region,AccountResponsible),"
				+ "aggregate(SalesAmount,SalesNumber))/orderby(Region%20desc,AccountResponsible)",
				"sap.ui.model.odata.v4.lib._Cache");

			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("items");
			oListBinding.attachDataRequested(function () {
				iDataRequestedCount += 1;
			});
			oListBinding.attachDataReceived(function () {
				iDataReceivedCount += 1;
			});

			// code under test -- will log an error because $count was not requested and is
			// therefore not available
			assert.strictEqual(oListBinding.getCount(), undefined);

			// code under test
			oTable.getItems()[0].getBindingContext().expand();

			return that.waitForChanges(assert, "expand 'Z'");
		}).then(function () {
			assert.strictEqual(iDataRequestedCount, 1);
			assert.strictEqual(iDataReceivedCount, 1);

			that.expectRequest("BusinessPartners?$apply=filter(Region eq 'Z')"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
					+ "/orderby(AccountResponsible)&$skip=3&$top=1", {
					value : [
						{AccountResponsible : "d", SalesAmount : "40", SalesNumber : 4}
					]
				})
				.expectChange("groupLevelCount",
					[/*4*/, /*undefined*/, /*undefined*/, undefined, undefined, undefined])
				.expectChange("isExpanded", [,,, undefined, undefined, false])
				.expectChange("isTotal", [,,, false, false, true])
				.expectChange("level", [,,, 2, 2, 1])
				.expectChange("region", [,,, "Z", "Z", "Y"])
				.expectChange("accountResponsible", [,,, "c", "d", ""])
				.expectChange("salesAmount", [,,, "30", "40", "200"])
				.expectChange("salesNumber", [,,, "3", "4", null]);

			// code under test (CPOUI5ODATAV4-177)
			oTable.requestItems();

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(iDataRequestedCount, 2);
			assert.strictEqual(iDataReceivedCount, 2);
			assert.deepEqual(oListBinding.getCurrentContexts().map(getPath), [
				"/BusinessPartners(Region='Z')",
				"/BusinessPartners(Region='Z',AccountResponsible='a')",
				"/BusinessPartners(Region='Z',AccountResponsible='b')",
				"/BusinessPartners(Region='Z',AccountResponsible='c')",
				"/BusinessPartners(Region='Z',AccountResponsible='d')",
				"/BusinessPartners(Region='Y')"
			]);

			that.expectChange("regionDetail", "Z");
			that.oView.byId("detail").setBindingContext(
				oTable.getItems()[1].getBindingContext()); // Z-a

			that.expectRequest("BusinessPartners?$apply=groupby((Region),aggregate(SalesAmount))"
					+ "/orderby(Region desc)&$skip=3&$top=3", {
					value : [
						{Region : "W", SalesAmount : "400"},
						{Region : "V", SalesAmount : "500"},
						{Region : "U", SalesAmount : "600"}
					]
				})
				// first row is unchanged except isExpanded
				// second row with "Y" was moved (E.C.D.)
				// third row is *new*
				.expectChange("groupLevelCount",
					[/*4*/, /*undefined*/, undefined, undefined, undefined, undefined])
				.expectChange("isExpanded", [false, /*false*/, false, false, false, false])
				.expectChange("isTotal", [, /*true*/, true, true, true, true])
				.expectChange("level", [, /*1*/, 1, 1, 1, 1])
				.expectChange("region", [, /*"Y"*/, "X", "W", "V", "U"])
				.expectChange("accountResponsible", [, /*""*/, "", "", "", ""])
				.expectChange("salesAmount", [, /*"200"*/, "300", "400", "500", "600"])
				.expectChange("salesNumber", [, /*null*/, null, null, null, null])
				.expectChange("regionDetail", null); // detail's context was destroyed

			// code under test
			oTable.getItems()[0].getBindingContext().collapse();

			return that.waitForChanges(assert, "collapse 'Z'");
		}).then(function () {
			assert.strictEqual(iDataRequestedCount, 3);
			assert.strictEqual(iDataReceivedCount, 3);
			assert.deepEqual(oListBinding.getCurrentContexts().map(getPath), [
				"/BusinessPartners(Region='Z')",
				"/BusinessPartners(Region='Y')",
				"/BusinessPartners(Region='X')",
				"/BusinessPartners(Region='W')",
				"/BusinessPartners(Region='V')",
				"/BusinessPartners(Region='U')"
			]);

			that.expectChange("groupLevelCount",
					[/*4*/, undefined, undefined, undefined, undefined])
				.expectChange("isExpanded", [true, undefined, undefined, undefined, undefined])
				.expectChange("isTotal", [/*true*/, false, false, false, false])
				.expectChange("level", [/*1*/, 2, 2, 2, 2])
				.expectChange("region", [/*"Z"*/, "Z", "Z", "Z", "Z"])
				.expectChange("accountResponsible", [/*""*/, "a", "b", "c", "d"])
				.expectChange("salesAmount", [/*"100"*/, "10", "20", "30", "40"])
				.expectChange("salesNumber", [/*null*/, "1", "2", "3", "4"]);

			// code under test
			oTable.getItems()[0].getBindingContext().expand();

			return that.waitForChanges(assert, "expand 'Z'");
		}).then(function () {
			assert.strictEqual(iDataRequestedCount, 3);
			assert.strictEqual(iDataReceivedCount, 3);
			assert.deepEqual(oListBinding.getCurrentContexts().map(getPath), [
				"/BusinessPartners(Region='Z')",
				"/BusinessPartners(Region='Z',AccountResponsible='a')",
				"/BusinessPartners(Region='Z',AccountResponsible='b')",
				"/BusinessPartners(Region='Z',AccountResponsible='c')",
				"/BusinessPartners(Region='Z',AccountResponsible='d')",
				"/BusinessPartners(Region='Y')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation and visual grouping.
	// Expand the first group. After that show more elements of the first group.
	// After that expand the second group and also show more elements.
	// JIRA: CPOUI5ODATAV4-177
	//
	// Filter before aggregation; make sure it is also applied to children when expanding.
	// JIRA: CPOUI5ODATAV4-180
	//
	// Check download URL.
	// JIRA: CPOUI5ODATAV4-609
	QUnit.test("Data Aggregation: expand and paging on sap.ui.table.Table", function (assert) {
		var oModel = this.createAggregationModel(),
			oTable,
			sView = '\
<t:Table id="table" threshold="0" visibleRowCount="3"\
	rows="{path : \'/BusinessPartners\',\
		parameters : {\
			$$aggregation : {\
				aggregate : {\
					SalesAmount : {subtotals : true},\
					SalesNumber : {}\
				},\
				group : {\
					AccountResponsible : {}\
				},\
				groupLevels : [\'Region\']\
			}\
		},\
		filters : {path : \'AccountResponsible\', operator : \'GE\', value1 : \'a\'}}">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="accountResponsible" text="{AccountResponsible}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=filter(AccountResponsible ge 'a')"
				+ "/groupby((Region),aggregate(SalesAmount))&$count=true&$skip=0&$top=3", {
				"@odata.count" : "26",
				value : [
					{Region : "Z", SalesAmount : "100"},
					{Region : "Y", SalesAmount : "280"},
					{Region : "X", SalesAmount : "300"}
				]
			})
			.expectChange("groupLevelCount", [undefined, undefined, undefined])
			.expectChange("isExpanded", [false, false, false])
			.expectChange("isTotal", [true, true, true])
			.expectChange("level", [1, 1, 1])
			.expectChange("region", ["Z", "Y", "X"])
			.expectChange("accountResponsible", ["", "", ""])
			.expectChange("salesAmount", ["100", "280", "300"])
			.expectChange("salesNumber", [null, null, null]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			assert.strictEqual(oTable.getBinding("rows").getDownloadUrl(),
				"/aggregation/BusinessPartners?$apply=filter(AccountResponsible%20ge%20'a')"
				+ "/groupby((Region,AccountResponsible),aggregate(SalesAmount,SalesNumber))",
				"CPOUI5ODATAV4-609");

			that.expectRequest("BusinessPartners?$apply="
					+ "filter(Region eq 'Z' and (AccountResponsible ge 'a'))"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
					+ "&$count=true&$skip=0&$top=3", {
					"@odata.count" : "4",
					value : [
						{AccountResponsible : "a", SalesAmount : "10", SalesNumber : 1},
						{AccountResponsible : "b", SalesAmount : "20", SalesNumber : 2},
						{AccountResponsible : "c", SalesAmount : "30", SalesNumber : 3}
					]
				})
				.expectChange("groupLevelCount", [4])
				.expectChange("isExpanded", [true, undefined, undefined])
				.expectChange("isTotal", [/*true*/, false, false])
				.expectChange("level", [/*1*/, 2, 2])
				.expectChange("region", [/*"Z"*/, "Z", "Z"])
				.expectChange("accountResponsible", [/*""*/, "a", "b"])
				.expectChange("salesAmount", [/*"100"*/, "10", "20"])
				.expectChange("salesNumber", [/*null*/, "1", "2"]);

			// code under test
			oTable.getRows()[0].getBindingContext().expand();

			return that.waitForChanges(assert, "expand node 'Z'");
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply="
					+ "filter(Region eq 'Z' and (AccountResponsible ge 'a'))"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
					+ "&$skip=3&$top=1", {
					value : [
						{AccountResponsible : "d", SalesAmount : "40", SalesNumber : 4}
					]
				})
				.expectChange("isExpanded", [,,,,, false])
				.expectChange("isTotal", [,,, false, false, true])
				.expectChange("level", [,,, 2, 2, 1])
				.expectChange("region", [,,, "Z", "Z", "Y"])
				.expectChange("accountResponsible", [,,, "c", "d", ""])
				.expectChange("salesAmount", [,,, "30", "40", "280"])
				.expectChange("salesNumber", [,,, "3", "4", null]);

			// code under test
			oTable.setFirstVisibleRow(3);

			return that.waitForChanges(assert, "scroll so that 'Z-c' is in first row");
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply="
					+ "filter(Region eq 'Y' and (AccountResponsible ge 'a'))"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
					+ "&$count=true&$skip=0&$top=3", {
					"@odata.count" : "8",
					value : [
						{AccountResponsible : "a", SalesAmount : "10", SalesNumber : 1},
						{AccountResponsible : "b", SalesAmount : "20", SalesNumber : 2},
						{AccountResponsible : "c", SalesAmount : "30", SalesNumber : 3}
					]
				})
				// no other changes because "Y" is the last visible row
				.expectChange("groupLevelCount", [,,,,, 8])
				.expectChange("isExpanded", [,,,,, true]);

			// code under test
			oTable.getRows()[2].getBindingContext().expand();

			return that.waitForChanges(assert, "expand node 'Y'");
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply="
					+ "filter(Region eq 'Y' and (AccountResponsible ge 'a'))"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
					+ "&$skip=7&$top=1", {
					value : [
						{AccountResponsible : "h", SalesAmount : "80", SalesNumber : 8}
					]
				})
				.expectRequest("BusinessPartners?$apply=filter(AccountResponsible ge 'a')"
					+ "/groupby((Region),aggregate(SalesAmount))"
					+ "&$skip=3&$top=1", {
					value : [
						{Region : "W", SalesAmount : "400"}
					]
				})
				.expectChange("isExpanded", [,,,,,,,,,,,,, /*undefined*/, false, false])
				.expectChange("isTotal", [,,,,,,,,,,,,, false, true, true])
				.expectChange("level", [,,,,,,,,,,,,, 2, 1, 1])
				.expectChange("region", [,,,,,,,,,,,,, "Y", "X", "W"])
				.expectChange("accountResponsible", [,,,,,,,,,,,,, "h", "", ""])
				.expectChange("salesAmount", [,,,,,,,,,,,,, "80", "300", "400"])
				.expectChange("salesNumber", [,,,,,,,,,,,,, "8", null, null]);

			// code under test
			// creates a gap to show that we are not requesting unnecessary data
			oTable.setFirstVisibleRow(13);

			return that.waitForChanges(assert, "scroll to 'Y-h': 'Y-h', 'X' and 'W' visible");
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply="
					+ "filter(Region eq 'Y' and (AccountResponsible ge 'a'))"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
					+ "&$skip=3&$top=3", {
					value : [
						{AccountResponsible : "d", SalesAmount : "40", SalesNumber : 4},
						{AccountResponsible : "e", SalesAmount : "50", SalesNumber : 5},
						{AccountResponsible : "f", SalesAmount : "60", SalesNumber : 6}
					]
				})
				// .expectChange("isExpanded", [])
				.expectChange("isTotal", [,,,,,,,,, false, false, false])
				.expectChange("level", [,,,,,,,,, 2, 2, 2])
				.expectChange("region", [,,,,,,,,, "Y", "Y", "Y"])
				.expectChange("accountResponsible", [,,,,,,,,, "d", "e", "f"])
				.expectChange("salesAmount", [,,,,,,,,, "40", "50", "60"])
				.expectChange("salesNumber", [,,,,,,,,, "4", "5", "6"]);

			// code under test
			oTable.setFirstVisibleRow(9);

			return that.waitForChanges(assert, "scroll to the middle of 'Y': "
				+ "'Y-d', 'Y-e', 'Y-f' visible");
		}).then(function () {
			that.expectChange("groupLevelCount", [4])
				.expectChange("isExpanded", [true])
				.expectChange("isTotal", [true])
				.expectChange("level", [1])
				.expectChange("region", ["Z", "Z", "Z"])
				.expectChange("accountResponsible", ["", "a", "b"])
				.expectChange("salesAmount", ["100", "10", "20"])
				.expectChange("salesNumber", [null, "1", "2"]);

			// code under test
			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert, "scroll back to the first row: "
				+ "'Z', 'Z-a' and 'Z-b' visible");
		}).then(function () {
			assert.deepEqual(oTable.getBinding("rows").getCurrentContexts().map(getPath), [
				"/BusinessPartners(Region='Z')",
				"/BusinessPartners(Region='Z',AccountResponsible='a')",
				"/BusinessPartners(Region='Z',AccountResponsible='b')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation and visual grouping.
	// Optionally expand and scroll down in two steps with intersecting ranges.
	// JIRA: CPOUI5ODATAV4-255
[false, true].forEach(function (bWithExpand) {
	var sTitle = "Data Aggregation: intersecting requests, with expand = " + bWithExpand;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createAggregationModel(),
			fnRespondExpand,
			fnRespondScroll1,
			fnRespondScroll2,
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\',\
	parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesAmount : {subtotals : true},\
				SalesNumber : {}\
			},\
			group : {\
				AccountResponsible : {}\
			},\
			groupLevels : [\'Region\']\
		}\
	}}" threshold="0" visibleRowCount="3">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="accountResponsible" text="{AccountResponsible}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=groupby((Region),aggregate(SalesAmount))"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "26",
				value : [
					{Region : "Z", SalesAmount : "100"},
					{Region : "Y", SalesAmount : "200"},
					{Region : "X", SalesAmount : "300"}
				]
			})
			.expectChange("groupLevelCount", [undefined, undefined, undefined])
			.expectChange("isExpanded", [false, false, false])
			.expectChange("isTotal", [true, true, true])
			.expectChange("level", [1, 1, 1])
			.expectChange("region", ["Z", "Y", "X"])
			.expectChange("accountResponsible", ["", "", ""])
			.expectChange("salesAmount", ["100", "200", "300"])
			.expectChange("salesNumber", [null, null, null]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			if (bWithExpand) {
				that.expectChange("isExpanded", [, true]) // "client side expand"
					.expectRequest("BusinessPartners?$apply=filter(Region eq 'Y')"
						+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
						+ "&$count=true&$skip=0&$top=3", new Promise(function (resolve) {
							fnRespondExpand = resolve.bind(null, {
								"@odata.count" : "1",
								value : [
									{AccountResponsible : "a", SalesAmount : "10", SalesNumber : 1}
								]
							});
						})
					);

				// code under test
				oTable.getRows()[1].getBindingContext().expand();
			}

			return that.waitForChanges(assert, "expand 'Y' before scroll");
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply=groupby((Region),aggregate(SalesAmount))"
					+ "&$skip=3&$top=3", new Promise(function (resolve) {
					fnRespondScroll1 = resolve.bind(null, {
						value : [
							{Region : "W", SalesAmount : "400"},
							{Region : "V", SalesAmount : "500"},
							{Region : "U", SalesAmount : "600"}
						]
					});
				}));

			oTable.setFirstVisibleRow(3);

			return that.waitForChanges(assert, "first scroll to node 'W'");
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply=groupby((Region),aggregate(SalesAmount))"
					+ "&$skip=6&$top=1", new Promise(function (resolve) {
					fnRespondScroll2 = resolve.bind(null, {
						value : [
							{Region : "T", SalesAmount : "700"}
						]
					});
				}));

			oTable.setFirstVisibleRow(4);

			return that.waitForChanges(assert, "second scroll to node 'V'");
		}).then(function () {
			if (bWithExpand) {
				that.expectChange("isExpanded", [,,,, false, false, false])
					.expectChange("isTotal", [,,,, true, true, true])
					.expectChange("level", [,,,, 1, 1, 1])
					.expectChange("region", [/*Z*/, /*Y*/, /*Y*/, /*X*/, "W", "V", "U"])
					.expectChange("accountResponsible", [,,,, "", "", ""])
					.expectChange("salesAmount", [,,,, "400", "500", "600"])
					.expectChange("salesNumber", [,,,, null, null, null])
					.expectCanceledError("Failed to get contexts for /aggregation/BusinessPartners"
							+ " with start index 3 and length 3",
						"Collapse or expand before read has finished")
					.expectCanceledError("Failed to get contexts for /aggregation/BusinessPartners"
							+ " with start index 4 and length 3",
						"Collapse or expand before read has finished");

				// code under test
				fnRespondExpand();
			} else {
				that.expectChange("isExpanded", [,,,, false, false, false])
					.expectChange("isTotal", [,,,, true, true, true])
					.expectChange("level", [,,,, 1, 1, 1])
					.expectChange("region", [/*Z*/, /*Y*/, /*X*/, /*W*/, "V", "U", "T"])
					.expectChange("accountResponsible", [,,,, "", "", ""])
					.expectChange("salesAmount", [,,,, "500", "600", "700"])
					.expectChange("salesNumber", [,,,, null, null, null]);
			}
			// code under test
			fnRespondScroll1();
			fnRespondScroll2();

			return that.waitForChanges(assert, "result");
		}).then(function () {
			// Check oCache.aElements because only there the error case is observable.
			assert.deepEqual(
				oTable.getBinding("rows").oCache.aElements.slice(0, 7)
					.map(function (oElement) {
						return oElement["@$ui5._"]["predicate"];
					}),
				bWithExpand ? [
					"(Region='Z')",
					"(Region='Y')",
					"(Region='Y',AccountResponsible='a')",
					"(Region='X')",
					"(Region='W')",
					"(Region='V')",
					"(Region='U')"
				] : [
					"(Region='Z')",
					"(Region='Y')",
					"(Region='X')",
					"(Region='W')",
					"(Region='V')",
					"(Region='U')",
					"(Region='T')"
				]
			);
		});
	});
});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation, visual grouping, and grand total.
	// Expand the last visible node and scroll to the last loaded leaf.
	// JIRA: CPOUI5ODATAV4-255
	// JIRA: CPOUI5ODATAV4-163
	//
	// Use grand total without subtotals.
	// JIRA: CPOUI5ODATAV4-608
	//
	// Use a unit for the grand total and the subtotals. Use an "own" unit (that is, the unit must
	// not appear for subtotals at all) for a grand total without subtotals to check for drill-down
	// errors.
	// JIRA: CPOUI5ODATAV4-583
	//
	// Order by units as well (at least expect the right requests).
	// JIRA: CPOUI5ODATAV4-763
	//
	// Check download URL.
	// JIRA: CPOUI5ODATAV4-609
	//
	// Request leaf count.
	// JIRA: CPOUI5ODATAV4-164
	QUnit.test("Data Aggregation: expand and paging to the last loaded leaf", function (assert) {
		var oModel = this.createAggregationModel(),
			oTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<t:Table id="table" rows="{path : \'/BusinessPartners\',\
	parameters : {\
		$$aggregation : {\
			aggregate : {\
				AmountPerSale : {grandTotal : true, unit : \'Currency\'},\
				SalesAmount : {grandTotal : true, unit : \'Currency\'},\
				SalesAmountLocalCurrency\
					: {grandTotal : true, subtotals : true, unit : \'LocalCurrency\'},\
				SalesNumber : {grandTotal : true}\
			},\
			group : {\
				Region : {}\
			},\
			groupLevels : [\'Country\']\
		},\
		$count : true,\
		$orderby : \'Country desc,Region,Currency asc,LocalCurrency desc\'\
	}}" threshold="0" visibleRowCount="4">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="amountPerSale" text="{= %{AmountPerSale} }"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
	<Text id="currency" text="{Currency}"/>\
	<Text id="salesAmountLocalCurrency" text="{= %{SalesAmountLocalCurrency} }"/>\
	<Text id="localCurrency" text="{LocalCurrency}"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=concat("
				+ "groupby((Country,Region))/aggregate($count as UI5__leaves)"
				+ ",aggregate(AmountPerSale,Currency,SalesAmount,SalesAmountLocalCurrency"
					+ ",LocalCurrency,SalesNumber)"
				+ ",groupby((Country),aggregate(SalesAmountLocalCurrency,LocalCurrency))"
				+ "/orderby(Country desc,LocalCurrency desc)"
				+ "/concat(aggregate($count as UI5__count),top(3)))", {
				value : [{
					UI5__leaves : "42",
					"UI5__leaves@odata.type" : "#Decimal"
				}, {
					AmountPerSale : "10",
					Currency : "DEM",
					SalesAmount : "38610", // + 10% ;-)
					SalesAmountLocalCurrency : "35100", // 1/2 * 26 * 27 * 100
					LocalCurrency : null,
					// grand total for SalesNumber might be custom aggregate with min,
					// falsy value is important edge case!
					SalesNumber : 0
				}, {
					UI5__count : "26",
					"UI5__count@odata.type" : "#Decimal"
				}, {
					Country : "Z",
					LocalCurrency : "GBP",
					SalesAmountLocalCurrency : "100"
				}, {
					Country : "Y",
					LocalCurrency : "USD",
					SalesAmountLocalCurrency : "200"
				}, {
					Country : "X",
					LocalCurrency : "EUR",
					SalesAmountLocalCurrency : "300"
				}]
			})
			.expectChange("count")
			.expectChange("isExpanded", [true, false, false, false])
			.expectChange("isTotal", [true, true, true, true])
			.expectChange("level", [0, 1, 1, 1])
			.expectChange("country", ["", "Z", "Y", "X"])
			.expectChange("region", ["", "", "", ""])
			.expectChange("amountPerSale", ["10", null, null, null])
			.expectChange("salesAmount", ["38610", null, null, null])
			.expectChange("currency", ["DEM", "", "", ""])
			.expectChange("salesAmountLocalCurrency", ["35100", "100", "200", "300"])
			.expectChange("localCurrency", ["", "GBP", "USD", "EUR"])
			.expectChange("salesNumber", ["0", null, null, null]);

		return this.createView(assert, sView, oModel).then(function () {
			var oListBinding;

			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("rows");

			assert.strictEqual(oTable.getBinding("rows").getDownloadUrl(),
				"/aggregation/BusinessPartners?$apply=groupby((Country,Region)"
				+ ",aggregate(AmountPerSale,Currency,SalesAmount,SalesAmountLocalCurrency"
					+ ",LocalCurrency,SalesNumber))"
				+ "/orderby(Country%20desc,Region,Currency%20asc,LocalCurrency%20desc)",
				"CPOUI5ODATAV4-609");

			assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
			assert.strictEqual(oListBinding.getLength(), 27, "length includes grand total row");
			// Note: header context gives count of leaves
			that.expectChange("count", "42");

			that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			///TODO could we omit Currency here because it was non-null at parent?
			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'X')/groupby((Region)"
					+ ",aggregate(AmountPerSale,Currency,SalesAmount,SalesAmountLocalCurrency"
					+ ",LocalCurrency,SalesNumber))/orderby(Region,Currency asc,LocalCurrency desc)"
					+ "&$count=true&$skip=0&$top=4", {
					"@odata.count" : "5",
					value : [{
						AmountPerSale : "10",
						Currency : "DEM",
						LocalCurrency : "USD",
						Region : "a",
						SalesAmount : "10.10",
						SalesAmountLocalCurrency : "10",
						SalesNumber : 1
					}, {
						AmountPerSale : "10",
						Currency : "DEM",
						LocalCurrency : "USD",
						Region : "b",
						SalesAmount : "20.20",
						SalesAmountLocalCurrency : "20",
						SalesNumber : 2
					}, {
						AmountPerSale : "10",
						Currency : "DEM",
						LocalCurrency : "USD",
						Region : "c",
						SalesAmount : "30.30",
						SalesAmountLocalCurrency : "30",
						SalesNumber : 3
					}, {
						AmountPerSale : "10",
						Currency : "DEM",
						LocalCurrency : "USD",
						Region : "d",
						SalesAmount : "40.40",
						SalesAmountLocalCurrency : "40",
						SalesNumber : 4
					}]
				})
				.expectChange("isExpanded", [,,, true]);

			// code under test
			oTable.getRows()[3].getBindingContext().expand();

			return that.waitForChanges(assert, "expand node 'X'");
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'X')/groupby((Region)"
					+ ",aggregate(AmountPerSale,Currency,SalesAmount,SalesAmountLocalCurrency"
					+ ",LocalCurrency,SalesNumber))/orderby(Region,Currency asc,LocalCurrency desc)"
					+ "&$skip=4&$top=1", {
					value : [{
						AmountPerSale : "10",
						Currency : "DEM",
						LocalCurrency : "USD",
						Region : "e",
						SalesAmount : "50.50",
						SalesAmountLocalCurrency : "50",
						SalesNumber : 5
					}]
				})
				.expectRequest("BusinessPartners?$apply=groupby((Country)"
					+ ",aggregate(SalesAmountLocalCurrency,LocalCurrency))"
					+ "/orderby(Country desc,LocalCurrency desc)/skip(3)/top(1)", {
					value : [{
						Country : "W",
						LocalCurrency : "JPY",
						SalesAmountLocalCurrency : "400"
					}]
				})
				.expectChange("isExpanded", [,,,,,,,,, false])
				.expectChange("isTotal", [,,,,,, false, false, false, true])
				.expectChange("level", [,,,,,, 2, 2, 2, 1])
				.expectChange("country", [,,,,,, "X", "X", "X", "W"])
				.expectChange("region", [,,,,,, "c", "d", "e", ""])
				.expectChange("amountPerSale", [,,,,,, "10", "10", "10", null])
				.expectChange("salesAmount", [,,,,,, "30.30", "40.40", "50.50", null])
				.expectChange("currency", [,,,,,, "DEM", "DEM", "DEM", ""])
				.expectChange("salesAmountLocalCurrency", [,,,,,, "30", "40", "50", "400"])
				.expectChange("localCurrency", [,,,,,, "USD", "USD", "USD", "JPY"])
				.expectChange("salesNumber", [,,,,,, "3", "4", "5", null]);

			// code under test
			oTable.setFirstVisibleRow(6);

			assert.throws(function () {
				oTable.getRows()[0].getBindingContext().collapse();
			}, new Error("Not expandable: /BusinessPartners()[0]"));

			return that.waitForChanges(assert, "scroll to 'X-c'");
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation, no visual grouping, and grand total at both
	// top and bottom - or at bottom only.
	// JIRA: CPOUI5ODATAV4-558
	//
	// Collapsing a grand total should throw an error
	// JIRA: CPOUI5ODATAV4-606
[false, true].forEach(function (bGrandTotalAtBottomOnly) {
	var sTitle = "Data Aggregation: grandTotalAtBottomOnly=" + bGrandTotalAtBottomOnly;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createAggregationModel(),
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\', parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesNumber : {grandTotal : true}\
			},\
			grandTotalAtBottomOnly : ' + bGrandTotalAtBottomOnly + ',\
			group : {Country : {}}\
		}\
	}}" threshold="0">\
	<t:rowMode>\
		<trm:Fixed rowCount="' + (bGrandTotalAtBottomOnly ? 4 : 5) + '"\
			fixedTopRowCount="' + (bGrandTotalAtBottomOnly ? 0 : 1) + '"\
			fixedBottomRowCount="1"/>\
	</t:rowMode>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=concat(aggregate(SalesNumber)"
				+ ",groupby((Country),aggregate(SalesNumber))"
				+ "/concat(aggregate($count as UI5__count),top(3)))", {
				value : [{
					SalesNumber : 0 // think "min" here ;-)
				}, {
					UI5__count : "7" // avoid ",,,,,,,,,,,,,,,,,,,,,,," hell
				}, {
					Country : "Z",
					SalesNumber : 26
				}, {
					Country : "Y",
					SalesNumber : 25
				}, {
					Country : "X",
					SalesNumber : 24
				}]
			});
		if (bGrandTotalAtBottomOnly) {
			this.expectChange("isExpanded", [undefined, undefined, undefined,,,,, true])
				.expectChange("isTotal", [false, false, false,,,,, true])
				.expectChange("level", [1, 1, 1,,,,, 0])
				.expectChange("country", ["Z", "Y", "X",,,,, ""])
				.expectChange("salesNumber", ["26", "25", "24",,,,, "0"]);
		} else {
			this.expectChange("isExpanded", [true, undefined, undefined, undefined,,,,, undefined])
				.expectChange("isTotal", [true, false, false, false,,,,, true])
				.expectChange("level", [0, 1, 1, 1,,,,, 0])
				.expectChange("country", ["", "Z", "Y", "X",,,,, ""])
				.expectChange("salesNumber", ["0", "26", "25", "24",,,,, "0"]);
		}

		return this.createView(assert, sView, oModel).then(function () {
			var aExpectedPaths = [
					"/BusinessPartners(Country='Z')",
					"/BusinessPartners(Country='Y')",
					"/BusinessPartners(Country='X')"
				],
				oTable = that.oView.byId("table");

			if (bGrandTotalAtBottomOnly) {
				aExpectedPaths.push("/BusinessPartners()");
			} else {
				aExpectedPaths.unshift("/BusinessPartners()");
				aExpectedPaths.push("/BusinessPartners($isTotal=true)");
			}
			assert.deepEqual(oTable.getRows().map(getBindingContextPath), aExpectedPaths);

			assert.throws(function () {
				oTable.getRows()[bGrandTotalAtBottomOnly ? 3 : 0].getBindingContext().collapse();
			}, new Error("Not expandable: /BusinessPartners()["
				+ (bGrandTotalAtBottomOnly ? "7" : "0") + "]"));
		});
	});
});

	//*********************************************************************************************
	// Scenario: sap.m.Table with aggregation, visual grouping, grand total at top and bottom, and
	// subtotals at both top and bottom - or at bottom only. Expand and collapse the last node.
	// JIRA: CPOUI5ODATAV4-681
[false, true].forEach(function (bSubtotalsAtBottomOnly) {
	var sTitle = "Data Aggregation: subtotalsAtBottomOnly=" + bSubtotalsAtBottomOnly;

	QUnit.test(sTitle, function (assert) {
		var oListBinding,
			oModel = this.createAggregationModel(),
			oTable,
			sView = '\
<Table id="table" items="{path : \'/BusinessPartners\', parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesAmountLocalCurrency :\
					{grandTotal : true, subtotals : true, unit : \'LocalCurrency\'}\
			},\
			grandTotalAtBottomOnly : false,\
			groupLevels : [\'Country\',\'LocalCurrency\',\'Region\'],\
			subtotalsAtBottomOnly : ' + bSubtotalsAtBottomOnly + '\
		}\
	}}">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="salesAmountLocalCurrency" text="{= %{SalesAmountLocalCurrency} }"/>\
	<Text id="localCurrency" text="{LocalCurrency}"/>\
</Table>',
			that = this;

		function subtotalAtTop(sText) {
			return bSubtotalsAtBottomOnly ? "" : sText;
		}

		this.expectRequest("BusinessPartners"
				+ "?$apply=concat(aggregate(SalesAmountLocalCurrency,LocalCurrency)"
				+ ",groupby((Country),aggregate(SalesAmountLocalCurrency,LocalCurrency))"
				+ "/concat(aggregate($count as UI5__count),top(99)))", {
				value : [{
					LocalCurrency : null,
					SalesAmountLocalCurrency : "3510" // 1/2 * 26 * 27 * 10
				}, {
					UI5__count : "1",
					"UI5__count@odata.type" : "#Decimal"
				}, {
					Country : "A",
					LocalCurrency : "EUR",
					SalesAmountLocalCurrency : "10"
				}]
			})
			.expectChange("level", [0, 1, 0]); //TODO needed to make test stable, but why?

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("items");

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {
					SalesAmountLocalCurrency : {
						grandTotal : true,
						subtotals : true,
						unit : "LocalCurrency"
					}
				},
				grandTotalAtBottomOnly : false,
				group : {
					Country : {},
					LocalCurrency : {},
					Region : {}
				},
				groupLevels : ["Country", "LocalCurrency", "Region"],
				subtotalsAtBottomOnly : bSubtotalsAtBottomOnly
			}, "JIRA: CPOUI5ODATAV4-1825");

			checkTable("initial state", assert, oTable, [
				"/BusinessPartners()",
				"/BusinessPartners(Country='A')",
				"/BusinessPartners($isTotal=true)"
			], [
				[undefined, true, true, 0, "", "", "3510", ""],
				[undefined, false, true, 1, "A", "", "10", "EUR"],
				[undefined, undefined, true, 0, "", "", "3510", ""]
			]);

			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'A')"
					+ "/groupby((LocalCurrency),aggregate(SalesAmountLocalCurrency))"
					+ "&$count=true&$skip=0&$top=100", {
					"@odata.count" : "1",
					value : [{
						LocalCurrency : "EUR",
						SalesAmountLocalCurrency : "10"
					}]
				})
				.expectChange("level", [,, 2, 1, 0]);

			// code under test
			oListBinding.getCurrentContexts()[1].expand();

			return that.waitForChanges(assert, "expand node 'A'");
		}).then(function () {
			checkTable("node 'A' expanded", assert, oTable, [
				"/BusinessPartners()",
				"/BusinessPartners(Country='A')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR')",
				"/BusinessPartners(Country='A',$isTotal=true)",
				"/BusinessPartners($isTotal=true)"
			], [
				[undefined, true, true, 0, "", "", "3510", ""],
				[1, true, true, 1, "A", "", subtotalAtTop("10"), subtotalAtTop("EUR")],
				[undefined, false, true, 2, "A", "", "10", "EUR"],
				[undefined, undefined, true, 1, "", "", "10", "EUR"],
				[undefined, undefined, true, 0, "", "", "3510", ""]
			]);

			that.expectRequest("BusinessPartners"
					+ "?$apply=filter(Country eq 'A' and LocalCurrency eq 'EUR')"
					+ "/groupby((Region),aggregate(SalesAmountLocalCurrency,LocalCurrency))"
					+ "&$count=true&$skip=0&$top=100", {
					"@odata.count" : "3",
					value : [{
						LocalCurrency : "EUR",
						Region : "a",
						SalesAmountLocalCurrency : "1"
					}, {
						LocalCurrency : "EUR",
						Region : "b",
						SalesAmountLocalCurrency : "2"
					}, {
						LocalCurrency : "EUR",
						Region : "c",
						SalesAmountLocalCurrency : "3"
					}]
				})
				.expectChange("level", [,,, 3, 3, 3, 2, 1, 0]);

			// code under test
			oListBinding.getCurrentContexts()[2].expand();

			return that.waitForChanges(assert, "expand node 'A/EUR'");
		}).then(function () {
			checkTable("node 'A/EUR' expanded", assert, oTable, [
				"/BusinessPartners()",
				"/BusinessPartners(Country='A')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR',Region='a')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR',Region='b')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR',Region='c')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR',$isTotal=true)",
				"/BusinessPartners(Country='A',$isTotal=true)",
				"/BusinessPartners($isTotal=true)"
			], [
				[undefined, true, true, 0, "", "", "3510", ""],
				[1, true, true, 1, "A", "", subtotalAtTop("10"), subtotalAtTop("EUR")],
				// Note: "localCurrency" must not disappear here!
				[3, true, true, 2, "A", "", subtotalAtTop("10"), "EUR"],
				[undefined, false, true, 3, "A", "a", "1", "EUR"],
				[undefined, false, true, 3, "A", "b", "2", "EUR"],
				[undefined, false, true, 3, "A", "c", "3", "EUR"],
				[undefined, undefined, true, 2, "", "", "10", "EUR"],
				[undefined, undefined, true, 1, "", "", "10", "EUR"],
				[undefined, undefined, true, 0, "", "", "3510", ""]
			]);

			that.expectChange("level", [,, 0]);

			// code under test
			oListBinding.getCurrentContexts()[1].collapse();

			// Note: table's content is NOT updated synchronously
			return that.waitForChanges(assert, "collapse node 'A'");
		}).then(function () {
			checkTable("node 'A' collapsed", assert, oTable, [
				"/BusinessPartners()",
				"/BusinessPartners(Country='A')",
				"/BusinessPartners($isTotal=true)"
			], [
				[undefined, true, true, 0, "", "", "3510", ""],
				[1, false, true, 1, "A", "", "10", "EUR"],
				[undefined, undefined, true, 0, "", "", "3510", ""]
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: sap.m.Table with aggregation, visual grouping, and grand total at top and bottom.
	// Expand and collapse the last node. Use subtotalsAtBottomOnly w/o subtotals actually being
	// requested. This must not change anything!
	// JIRA: CPOUI5ODATAV4-825
[false, true].forEach(function (bSubtotalsAtBottomOnly) {
	var sTitle = "Data Aggregation: subtotalsAtBottomOnly = " + bSubtotalsAtBottomOnly
			+ " w/o subtotals";

	QUnit.test(sTitle, function (assert) {
		var oListBinding,
			oModel = this.createAggregationModel(),
			oTable,
			sView = '\
<Table id="table" items="{path : \'/BusinessPartners\', parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesAmountLocalCurrency : {\
					grandTotal : true,\
					unit : \'LocalCurrency\'\
				}\
			},\
			grandTotalAtBottomOnly : false,\
			groupLevels : [\'Country\',\'LocalCurrency\',\'Region\'],\
			subtotalsAtBottomOnly : ' + bSubtotalsAtBottomOnly + '\
		}\
	}}">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="salesAmountLocalCurrency" text="{= %{SalesAmountLocalCurrency} }"/>\
	<Text id="localCurrency" text="{LocalCurrency}"/>\
</Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply="
				+ "concat(aggregate(SalesAmountLocalCurrency,LocalCurrency),groupby((Country))"
				+ "/concat(aggregate($count as UI5__count),top(99)))", {
				value : [{
					LocalCurrency : null,
					SalesAmountLocalCurrency : "3510" // 1/2 * 26 * 27 * 10
				}, {
					UI5__count : "1",
					"UI5__count@odata.type" : "#Decimal"
				}, {
					Country : "A"
				}]
			})
			.expectChange("level", [0, 1, 0]); // wait for at least some data to appear on UI

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("items");

			checkTable("initial state", assert, oTable, [
				"/BusinessPartners()",
				"/BusinessPartners(Country='A')",
				"/BusinessPartners($isTotal=true)"
			], [
				[undefined, true, true, 0, "", "", "3510", ""],
				[undefined, false, false, 1, "A", "", "", ""],
				[undefined, undefined, true, 0, "", "", "3510", ""]
			]);

			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'A')"
					+ "/groupby((LocalCurrency))&$count=true&$skip=0&$top=100", {
					"@odata.count" : "1",
					value : [{
						LocalCurrency : "EUR"
					}]
				})
				.expectChange("level", [,, 2, 0]);

			// code under test
			oListBinding.getCurrentContexts()[1].expand();

			return that.waitForChanges(assert, "expand node 'A'");
		}).then(function () {
			checkTable("node 'A' expanded", assert, oTable, [
				"/BusinessPartners()",
				"/BusinessPartners(Country='A')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR')",
				"/BusinessPartners($isTotal=true)"
			], [
				[undefined, true, true, 0, "", "", "3510", ""],
				[1, true, false, 1, "A", "", "", ""],
				[undefined, false, false, 2, "A", "", "", "EUR"],
				[undefined, undefined, true, 0, "", "", "3510", ""]
			]);

			that.expectRequest("BusinessPartners"
					+ "?$apply=filter(Country eq 'A' and LocalCurrency eq 'EUR')"
					+ "/groupby((Region))&$count=true&$skip=0&$top=100", {
					"@odata.count" : "3",
					value : [{
						Region : "a"
					}, {
						Region : "b"
					}, {
						Region : "c"
					}]
				})
				.expectChange("level", [,,, 3, 3, 3, 0]);

			// code under test
			oListBinding.getCurrentContexts()[2].expand();

			return that.waitForChanges(assert, "expand node 'A/EUR'");
		}).then(function () {
			checkTable("node 'A/EUR' expanded", assert, oTable, [
				"/BusinessPartners()",
				"/BusinessPartners(Country='A')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR',Region='a')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR',Region='b')",
				"/BusinessPartners(Country='A',LocalCurrency='EUR',Region='c')",
				"/BusinessPartners($isTotal=true)"
			], [
				[undefined, true, true, 0, "", "", "3510", ""],
				[1, true, false, 1, "A", "", "", ""],
				[3, true, false, 2, "A", "", "", "EUR"],
				[undefined, false, false, 3, "A", "a", "", "EUR"],
				[undefined, false, false, 3, "A", "b", "", "EUR"],
				[undefined, false, false, 3, "A", "c", "", "EUR"],
				[undefined, undefined, true, 0, "", "", "3510", ""]
			]);

			that.expectChange("level", [,, 0]);

			// code under test
			oListBinding.getCurrentContexts()[1].collapse();

			// Note: table's content is NOT updated synchronously
			return that.waitForChanges(assert, "collapse node 'A'");
		}).then(function () {
			checkTable("node 'A' collapsed", assert, oTable, [
				"/BusinessPartners()",
				"/BusinessPartners(Country='A')",
				"/BusinessPartners($isTotal=true)"
			], [
				[undefined, true, true, 0, "", "", "3510", ""],
				[1, false, false, 1, "A", "", "", ""],
				[undefined, undefined, true, 0, "", "", "3510", ""]
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation, visual grouping, and grand total at bottom
	// only while just two rows are visible at all: do not confuse data row with grand total row!
	// JIRA: CPOUI5ODATAV4-558
	//
	// Use subtotalsAtBottomOnly w/o subtotals actually being requested. This must not change
	// anything!
	// JIRA: CPOUI5ODATAV4-825
	QUnit.test("Data Aggregation: grandTotalAtBottomOnly=true, just two rows", function (assert) {
		var oModel = this.createAggregationModel(),
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\', parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesNumber : {grandTotal : true}\
			},\
			grandTotalAtBottomOnly : true,\
			groupLevels : [\'Country\',\'Region\'],\
			subtotalsAtBottomOnly : false\
		}\
	}}">\
	<t:rowMode>\
		<trm:Fixed rowCount="2" fixedBottomRowCount="1"/>\
	</t:rowMode>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=concat(aggregate(SalesNumber)"
				+ ",groupby((Country))/concat(aggregate($count as UI5__count),top(101)))", {
				value : [{SalesNumber : 0}, {UI5__count : "1"}, {Country : "Z"}]
			})
			.expectChange("isExpanded", [false, true])
			.expectChange("isTotal", [false, true])
			.expectChange("level", [1, 0])
			.expectChange("country", ["Z", ""])
			.expectChange("salesNumber", [null, "0"]);

		return this.createView(assert, sView, oModel).then(function () {
			assert.deepEqual(that.oView.byId("table").getRows().map(getBindingContextPath), [
				"/BusinessPartners(Country='Z')",
				"/BusinessPartners()"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation and visual grouping.
	// Collapse with placeholders
	// JIRA: CPOUI5ODATAV4-179
	QUnit.test("Data Aggregation: collapse with placeholders", function (assert) {
		var oModel = this.createAggregationModel(),
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\',\
	parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesAmount : {subtotals : true}\
			},\
			group : {\
				Region : {}\
			},\
			groupLevels : [\'Country\']\
		}\
	}}" threshold="0" visibleRowCount="4">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=groupby((Country),aggregate(SalesAmount))"
				+ "&$count=true&$skip=0&$top=4", {
				"@odata.count" : "2",
				value : [
					{Country : "US", SalesAmount : "100"},
					{Country : "UK", SalesAmount : "200"}
				]
			})
			.expectChange("groupLevelCount", [undefined, undefined])
			.expectChange("isExpanded", [false, false])
			.expectChange("isTotal", [true, true])
			.expectChange("level", [1, 1])
			.expectChange("country", ["US", "UK"])
			.expectChange("region", ["", ""])
			.expectChange("salesAmount", ["100", "200"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'UK')"
					+ "/groupby((Region),aggregate(SalesAmount))&$count=true&$skip=0&$top=4", {
					"@odata.count" : "12",
					value : [
						{Region : "Z", SalesAmount : "10"},
						{Region : "Y", SalesAmount : "20"},
						{Region : "X", SalesAmount : "30"},
						{Region : "W", SalesAmount : "40"}
					]
				})
				.expectChange("groupLevelCount", [, 12, undefined, undefined])
				.expectChange("isExpanded", [, true, undefined, undefined])
				.expectChange("isTotal", [,, false, false])
				.expectChange("level", [,, 2, 2])
				.expectChange("country", [,, "UK", "UK"])
				.expectChange("region", [,, "Z", "Y"])
				.expectChange("salesAmount", [,, "10", "20"]);

			// code under test
			oTable.getRows()[1].getBindingContext().expand();

			return that.waitForChanges(assert, "expand 'UK'");
		}).then(function () {
			var oThirdRow = oTable.getRows()[2].getBindingContext();

			that.expectChange("isExpanded", [, false]);

			// code under test
			oTable.getRows()[1].getBindingContext().collapse();

			assert.strictEqual(oTable.getBinding("rows").getContexts().length, 2);

			that.oLogMock.expects("error").withExactArgs("Failed to drill-down into"
				+ " (Country='UK',Region='Z')/Region, invalid segment: (Country='UK',Region='Z')",
				"/aggregation/BusinessPartners"
				+ "?$apply=groupby((Country,Region),aggregate(SalesAmount))",
				"sap.ui.model.odata.v4.lib._Cache");

			// code under test
			assert.strictEqual(oThirdRow.getProperty("Region"), undefined,
				"$byPredicate has been cleaned up");

			return that.waitForChanges(assert, "collapse 'UK'");
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation and visual grouping.
	// Expand three levels and collapse at the root level, then expand root level again, then
	// collapse first level.
	// JIRA: CPOUI5ODATAV4-178
	// JIRA: CPOUI5ODATAV4-179
	// JIRA: CPOUI5ODATAV4-378
	// JIRA: CPOUI5ODATAV4-597
	//
	// Show additional text properties for group levels.
	// JIRA: CPOUI5ODATAV4-680
	//
	// Check download URL.
	// JIRA: CPOUI5ODATAV4-609
	QUnit.test("Data Aggregation: expand three levels, expand after collapse", function (assert) {
		var oModel = this.createAggregationModel(),
			oRowsBinding,
			oTable,
			oUKContext,
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\',\
	parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesAmount : {subtotals : true},\
				SalesNumber : {}\
			},\
			group : {\
				AccountResponsible : {},\
				Country : {additionally : [\'CountryText\']},\
				Region : {additionally : [\'RegionText\']}\
			},\
			groupLevels : [\'Country\', \'Region\', \'Segment\']\
		},\
		$orderby : \'RegionText desc\'\
	}}" threshold="0" visibleRowCount="4">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="countryText" text="{CountryText}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="regionText" text="{RegionText}"/>\
	<Text id="segment" text="{Segment}"/>\
	<Text id="accountResponsible" text="{AccountResponsible}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=groupby((Country,CountryText)"
				+ ",aggregate(SalesAmount))&$count=true&$skip=0&$top=4", {
				"@odata.count" : "26",
				value : [
					{Country : "US", CountryText : "<US>", SalesAmount : "100"},
					{Country : "UK", CountryText : "<UK>", SalesAmount : "200"},
					{Country : "DE", CountryText : "<DE>", SalesAmount : "300"},
					{Country : "IT", CountryText : "<IT>", SalesAmount : "400"}
				]
			})
			.expectChange("groupLevelCount", [undefined, undefined, undefined, undefined])
			.expectChange("isExpanded", [false, false, false, false])
			.expectChange("isTotal", [true, true, true, true])
			.expectChange("level", [1, 1, 1, 1])
			.expectChange("country", ["US", "UK", "DE", "IT"])
			.expectChange("countryText", ["<US>", "<UK>", "<DE>", "<IT>"])
			.expectChange("region", ["", "", "", ""])
			.expectChange("regionText", ["", "", "", ""])
			.expectChange("segment", ["", "", "", ""])
			.expectChange("accountResponsible", ["", "", "", ""])
			.expectChange("salesAmount", ["100", "200", "300", "400"])
			.expectChange("salesNumber", [null, null, null, null]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oRowsBinding = oTable.getBinding("rows");

			assert.strictEqual(oRowsBinding.getDownloadUrl(),
				"/aggregation/BusinessPartners?$apply=groupby((Country,Region,Segment"
					+ ",AccountResponsible,CountryText,RegionText)"
					+ ",aggregate(SalesAmount,SalesNumber))"
				+ "/orderby(RegionText%20desc)",
				"CPOUI5ODATAV4-609");

			assert.strictEqual(oRowsBinding.getLength(), 26);

			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'US')"
					+ "/groupby((Region,RegionText),aggregate(SalesAmount))"
					+ "/orderby(RegionText desc)&$count=true&$skip=0&$top=4", {
					"@odata.count" : "3",
					value : [
						{Region : "Z", RegionText : "<Z>", SalesAmount : "10"},
						{Region : "Y", RegionText : "<Y>", SalesAmount : "20"},
						{Region : "X", RegionText : "<X>", SalesAmount : "30"}
					]
				})
				.expectChange("groupLevelCount", [3])
				.expectChange("isExpanded", [true])
				.expectChange("level", [, 2, 2, 2])
				.expectChange("country", [, "US", "US", "US"])
				.expectChange("countryText", [, "<US>", "<US>", "<US>"])
				.expectChange("region", [, "Z", "Y", "X"])
				.expectChange("regionText", [, "<Z>", "<Y>", "<X>"])
				.expectChange("salesAmount", [, "10", "20", "30"]);

			// code under test
			oTable.getRows()[0].getBindingContext().expand();

			return that.waitForChanges(assert, "first expand 'US'");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 26 + 3);

			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'US' and Region eq 'Z')"
					+ "/groupby((Segment),aggregate(SalesAmount))&$count=true&$skip=0&$top=4", {
					"@odata.count" : "2",
					value : [
						{SalesAmount : "10", Segment : "z"},
						{SalesAmount : "20", Segment : "y"}
					]
				})
				.expectChange("groupLevelCount", [, 2])
				.expectChange("isExpanded", [, true])
				.expectChange("level", [,, 3, 3])
				.expectChange("region", [,, "Z", "Z"])
				.expectChange("regionText", [,, "<Z>", "<Z>"])
				.expectChange("segment", [,, "z", "y"])
				.expectChange("salesAmount", [,, "10", "20"]);

			// code under test
			oTable.getRows()[1].getBindingContext().expand();

			return that.waitForChanges(assert, "second expand 'US-Z'");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 26 + 3 + 2);

			that.expectRequest("BusinessPartners?$apply="
					+ "filter(Country eq 'US' and Region eq 'Z' and Segment eq 'z')"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount,SalesNumber))"
					+ "&$count=true&$skip=0&$top=4", {
					"@odata.count" : "1",
					value : [
						{AccountResponsible : "a", SalesAmount : "10", SalesNumber : 1}
					]
				})
				.expectChange("groupLevelCount", [,, 1])
				.expectChange("isExpanded", [,, true, undefined])
				.expectChange("isTotal", [,,, false])
				.expectChange("level", [,,, 4])
				.expectChange("segment", [,,, "z"])
				.expectChange("accountResponsible", [,,, "a"])
				.expectChange("salesAmount", [,,, "10"])
				.expectChange("salesNumber", [,,, "1"]);

			// code under test
			oTable.getRows()[2].getBindingContext().expand();

			return that.waitForChanges(assert, "third expand 'US-Z-z'");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 26 + 3 + 2 + 1);

			that.expectChange("groupLevelCount", [, undefined, undefined])
				.expectChange("isExpanded", [false, false, false, false])
				.expectChange("isTotal", [,,, true])
				.expectChange("level", [, 1, 1, 1])
				.expectChange("country", [, "UK", "DE", "IT"])
				.expectChange("countryText", [, "<UK>", "<DE>", "<IT>"])
				.expectChange("region", [, "", "", ""])
				.expectChange("regionText", [, "", "", ""])
				.expectChange("segment", [,, "", ""])
				.expectChange("accountResponsible", [,,, ""])
				.expectChange("salesAmount", [, "200", "300", "400"])
				.expectChange("salesNumber", [,,, null]);

			// code under test
			oTable.getRows()[0].getBindingContext().collapse();

			return that.waitForChanges(assert, "collapse 'US'");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 26);
			oUKContext = oRowsBinding.getCurrentContexts()[1];

			// expectation: tree should be restored with all previously expanded nodes
			that.expectChange("groupLevelCount", [, 2, 1])
				.expectChange("isExpanded", [true, true, true, undefined])
				.expectChange("isTotal", [,,, false])
				.expectChange("level", [, 2, 3, 4])
				.expectChange("country", [, "US", "US", "US"])
				.expectChange("countryText", [, "<US>", "<US>", "<US>"])
				.expectChange("region", [, "Z", "Z", "Z"])
				.expectChange("regionText", [, "<Z>", "<Z>", "<Z>"])
				.expectChange("segment", [,, "z", "z"])
				.expectChange("accountResponsible", [,,, "a"])
				.expectChange("salesAmount", [, "10", "10", "10"])
				.expectChange("salesNumber", [,,, "1"]);

			// code under test
			oTable.getRows()[0].getBindingContext().expand();

			return that.waitForChanges(assert, "expand 'US' again");
		}).then(function () {
			var oUKContext0;

			assert.strictEqual(oRowsBinding.getLength(), 26 + 3 + 2 + 1);
			assert.deepEqual(oRowsBinding.getCurrentContexts().map(getPath), [
				"/BusinessPartners(Country='US')",
				"/BusinessPartners(Country='US',Region='Z')",
				"/BusinessPartners(Country='US',Region='Z',Segment='z')",
				"/BusinessPartners(Country='US',Region='Z',Segment='z',AccountResponsible='a')"
			]);

			oUKContext0 = oRowsBinding.getContexts(7, 1)[0];
			assert.strictEqual(oUKContext0.getPath(), oUKContext.getPath());
			assert.ok(oUKContext0 === oUKContext, "'UK' context is still the same instance");
		}).then(function () {
			that.expectChange("groupLevelCount", [,, undefined])
				.expectChange("isExpanded", [, false, false, false])
				.expectChange("isTotal", [,,, true])
				.expectChange("level", [,, 2, 2])
				.expectChange("region", [,, "Y", "X"])
				.expectChange("regionText", [,, "<Y>", "<X>"])
				.expectChange("segment", [,, "", ""])
				.expectChange("accountResponsible", [,,, ""])
				.expectChange("salesAmount", [,, "20", "30"])
				.expectChange("salesNumber", [,,, null]);

			// code under test
			oTable.getRows()[1].getBindingContext().collapse();

			return that.waitForChanges(assert, "collapse 'US-Z'");
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation and visual grouping. Show additional text
	// properties for group levels via navigation. Expand all levels.
	// JIRA: CPOUI5ODATAV4-680
	//
	// Use subtotalsAtBottomOnly w/o subtotals actually being requested. This must not change
	// anything!
	// JIRA: CPOUI5ODATAV4-825
	QUnit.test("Data Aggregation: additionally via navigation", function (assert) {
		var oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/Artists\',\
	parameters : {\
		$$aggregation : {\
			aggregate : {\
				sendsAutographs : {}\
			},\
			group : {\
				ArtistID : {additionally : [\'Address/City\']},\
				IsActiveEntity : {\
					additionally : [\'BestPublication/DraftAdministrativeData/InProcessByUser\']\
				},\
				Name : {additionally : [\'BestFriend/Name\']}\
			},\
			groupLevels : [\'IsActiveEntity\', \'Name\'],\
			subtotalsAtBottomOnly : true\
		},\
		$orderby :\
\'BestPublication/DraftAdministrativeData/InProcessByUser desc,BestFriend/Name,Address/City asc\'\
	}}" threshold="0" visibleRowCount="6">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="isActiveEntity" text="{= %{IsActiveEntity} }"/>\
	<Text id="inProcessByUser" text="{BestPublication/DraftAdministrativeData/InProcessByUser}"/>\
	<Text id="name" text="{Name}"/>\
	<Text id="bestFriendName" text="{BestFriend/Name}"/>\
	<Text id="artistID" text="{ArtistID}"/>\
	<Text id="city" text="{Address/City}"/>\
	<Text id="sendsAutographs" text="{= %{sendsAutographs} }"/>\
</t:Table>',
			that = this;

		this.expectRequest("Artists?$apply=groupby"
				+ "((IsActiveEntity,BestPublication/DraftAdministrativeData/InProcessByUser))"
				+ "/orderby(BestPublication/DraftAdministrativeData/InProcessByUser desc)"
				+ "&$count=true&$skip=0&$top=6", {
				"@odata.count" : "2",
				value : [{
					BestPublication : {
						DraftAdministrativeData : {
							InProcessByUser : "JOHNDOE"
						}
					},
					IsActiveEntity : false
				}, {
					BestPublication : {
						DraftAdministrativeData : {
							InProcessByUser : null
						}
					},
					IsActiveEntity : true
				}]
			})
			.expectChange("groupLevelCount", [undefined, undefined])
			.expectChange("isExpanded", [false, false])
			.expectChange("isTotal", [false, false])
			.expectChange("level", [1, 1])
			.expectChange("isActiveEntity", [false, true])
			.expectChange("inProcessByUser", ["JOHNDOE", ""])
			.expectChange("name", ["", ""])
			.expectChange("bestFriendName", ["", ""])
			.expectChange("artistID", ["", ""])
			.expectChange("city", ["", ""])
			.expectChange("sendsAutographs", [null, null]);

		return this.createView(assert, sView, this.createSpecialCasesModel()).then(function () {
			oTable = that.oView.byId("table");

			that.expectRequest("Artists?$apply=filter(IsActiveEntity eq true)"
					+ "/groupby((Name,BestFriend/Name))/orderby(BestFriend/Name)"
					+ "&$count=true&$skip=0&$top=6", {
					"@odata.count" : "2",
					value : [
						{BestFriend : {Name : "A's best friend"}, Name : "A"},
						{BestFriend : {Name : "B's best friend"}, Name : "B"}
					]
				})
				.expectChange("groupLevelCount", [, 2, undefined, undefined])
				.expectChange("isExpanded", [, true, false, false])
				.expectChange("isTotal", [,, false, false])
				.expectChange("level", [,, 2, 2])
				.expectChange("isActiveEntity", [,, true, true])
				.expectChange("inProcessByUser", [,, "", ""])
				.expectChange("name", [,, "A", "B"])
				.expectChange("bestFriendName", [,, "A's best friend", "B's best friend"])
				.expectChange("artistID", [,, "", ""])
				.expectChange("city", [,, "", ""])
				.expectChange("sendsAutographs", [,, null, null]);

			// code under test
			oTable.getRows()[1].getBindingContext().expand();

			return that.waitForChanges(assert, "1st expand");
		}).then(function () {
			that.expectRequest("Artists?$apply=filter(IsActiveEntity eq true and Name eq 'B')"
					+ "/groupby((ArtistID,Address/City),aggregate(sendsAutographs))"
					+ "/orderby(Address/City asc)&$count=true&$skip=0&$top=6", {
					"@odata.count" : "2",
					value : [{
						Address : {City : "Liverpool"},
						ArtistID : "1",
						// Note: think of "sendsAutographs" as a weird custom aggregate ;-)
						sendsAutographs : false
					}, {
						Address : {City : "London"},
						ArtistID : "2",
						sendsAutographs : true
					}]
				})
				.expectChange("groupLevelCount", [,,, 2, undefined, undefined])
				.expectChange("isExpanded", [,,, true, undefined, undefined])
				.expectChange("isTotal", [,,,, false, false])
				.expectChange("level", [,,,, 3, 3])
				.expectChange("isActiveEntity", [,,,, true, true])
				.expectChange("inProcessByUser", [,,,, "", ""])
				.expectChange("name", [,,,, "B", "B"])
				.expectChange("bestFriendName", [,,,, "B's best friend", "B's best friend"])
				.expectChange("artistID", [,,,, "1", "2"])
				.expectChange("city", [,,,, "Liverpool", "London"])
				.expectChange("sendsAutographs", [,,,, false, true]);

			// code under test
			oTable.getRows()[3].getBindingContext().expand();

			return that.waitForChanges(assert, "2nd expand");
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation and visual grouping.
	// Expand and paging in parallel.
	// JIRA: CPOUI5ODATAV4-336
	//
	// Use subtotalsAtBottomOnly w/o subtotals actually being requested. This must not change
	// anything!
	// JIRA: CPOUI5ODATAV4-825
[false, true].forEach(function (bSecondScroll) {
	var sTitle = "Data Aggregation: expand and paging in parallel. (Second scroll = "
		+ bSecondScroll + ")";

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createAggregationModel(),
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\',\
	parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesAmount : {}\
			},\
			group : {\
				AccountResponsible : {}\
			},\
			groupLevels : [\'Region\'],\
			subtotalsAtBottomOnly : false\
		}\
	}}" threshold="0" visibleRowCount="3">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="accountResponsible" text="{AccountResponsible}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=groupby((Region))&$count=true&$skip=0&$top=3", {
				"@odata.count" : "26",
				value : [
					{Region : "Z"},
					{Region : "Y"},
					{Region : "X"}
				]
			})
			.expectChange("groupLevelCount", [undefined, undefined, undefined])
			.expectChange("isExpanded", [false, false, false])
			.expectChange("isTotal", [false, false, false])
			.expectChange("level", [1, 1, 1])
			.expectChange("region", ["Z", "Y", "X"])
			.expectChange("accountResponsible", ["", "", ""])
			.expectChange("salesAmount", [null, null, null]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			// "client side expand"
			that.expectChange("isExpanded", [, true]);

			if (!bSecondScroll) {
				that.expectChange("region", [,, "X"]) // "client side scrolling"
					// .expectChange("groupLevelCount", [])
					.expectChange("isExpanded", [,, undefined])
					.expectChange("level", [,, 2])
					.expectChange("region", [,, "Y"])
					.expectChange("accountResponsible", [,, "a"])
					.expectChange("salesAmount", [,, "10"]);
			}

			that.expectRequest("BusinessPartners?$apply=filter(Region eq 'Y')"
					+ "/groupby((AccountResponsible),aggregate(SalesAmount))"
					+ "&$count=true&$skip=0&$top=3", {
					"@odata.count" : "1",
					value : [
						{AccountResponsible : "a", SalesAmount : "10", SalesNumber : 1}
					]
				});

			// code under test
			oTable.getRows()[1].getBindingContext().expand();

			that.expectRequest("BusinessPartners?$apply=groupby((Region))&$skip=3&$top="
					+ (bSecondScroll ? "3" : "2"), {
					value : [
						{Region : "W"},
						{Region : "V"}
					]
				});

			if (!bSecondScroll) {
				// that.expectChange("groupLevelCount", [])
				that.expectChange("isExpanded", [,,, false, false])
					.expectChange("isTotal", [,,, false, false])
					.expectChange("level", [,,, 1, 1])
					.expectChange("region", [,,, "X", "W"])
					.expectChange("accountResponsible", [,,, "", ""])
					.expectChange("salesAmount", [,,, null, null])
					.expectCanceledError("Failed to get contexts for /aggregation/BusinessPartners"
							+ " with start index 2 and length 3",
						"Collapse or expand before read has finished");

				// code under test
				oTable.setFirstVisibleRow(2);
			} else {
				that.expectChange("isExpanded", [,,, false, false, false])
					.expectChange("isTotal", [,,, false, false, false])
					.expectChange("level", [,,, 1, 1, 1])
					.expectChange("region", [,,, "X", "W", "V"])
					.expectChange("accountResponsible", [,,, "", "", ""])
					.expectChange("salesAmount", [,,, null, null, null])
					.expectCanceledError("Failed to get contexts for /aggregation/BusinessPartners"
							+ " with start index 3 and length 3",
						"Collapse or expand before read has finished");

				// code under test
				oTable.setFirstVisibleRow(3);
			}

			return that.waitForChanges(assert, "expand and paging in parallel");
		}).then(function () {
			assert.deepEqual(oTable.getBinding("rows").getContexts(0, 6).map(getPath), [
				"/BusinessPartners(Region='Z')",
				"/BusinessPartners(Region='Y')",
				"/BusinessPartners(Region='Y',AccountResponsible='a')",
				"/BusinessPartners(Region='X')",
				"/BusinessPartners(Region='W')",
				"/BusinessPartners(Region='V')"
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation and visual grouping. Expand at the root level
	// and collapse before loading has finished, then expand again. Expand two nodes on 2nd level
	// and collapse at the root level before the 2nd level has finished loading. Then expand again
	// at the root level and find the 2nd level properly expanded as well.
	// JIRA: CPOUI5ODATAV4-378
	QUnit.test("Data Aggregation: collapse while expanding", function (assert) {
		var oModel = this.createAggregationModel(),
			oRowsBinding,
			oTable,
			oUKContext,
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\',\
	parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesAmount : {subtotals : true}\
			},\
			group : {\
				Segment : {}\
			},\
			groupLevels : [\'Country\', \'Region\']\
		}\
	}}" threshold="0" visibleRowCount="8">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="segment" text="{Segment}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=groupby((Country),aggregate(SalesAmount))"
				+ "&$count=true&$skip=0&$top=8", {
				"@odata.count" : "26",
				value : [
					{Country : "US", SalesAmount : "100"},
					{Country : "UK", SalesAmount : "200"},
					{Country : "DE", SalesAmount : "300"},
					{Country : "IT", SalesAmount : "400"},
					{Country : "FR", SalesAmount : "500"},
					{Country : "BE", SalesAmount : "600"},
					{Country : "NL", SalesAmount : "700"},
					{Country : "LU", SalesAmount : "800"}
				]
			})
			.expectChange("groupLevelCount", [undefined, undefined, undefined, undefined, undefined,
				undefined, undefined, undefined])
			.expectChange("isExpanded", [false, false, false, false, false, false, false, false])
			.expectChange("isTotal", [true, true, true, true, true, true, true, true])
			.expectChange("level", [1, 1, 1, 1, 1, 1, 1, 1])
			.expectChange("country", ["US", "UK", "DE", "IT", "FR", "BE", "NL", "LU"])
			.expectChange("region", ["", "", "", "", "", "", "", ""])
			.expectChange("segment", ["", "", "", "", "", "", "", ""])
			.expectChange("salesAmount", ["100", "200", "300", "400", "500", "600", "700", "800"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oRowsBinding = oTable.getBinding("rows");
			assert.strictEqual(oRowsBinding.getLength(), 26);
			oUKContext = oRowsBinding.getCurrentContexts()[1];

			that.expectChange("isExpanded", [true])
				.expectRequest("BusinessPartners?$apply=filter(Country eq 'US')"
					+ "/groupby((Region),aggregate(SalesAmount))&$count=true&$skip=0&$top=8", {
					"@odata.count" : "3",
					value : [
						{Region : "Z", SalesAmount : "10"},
						{Region : "Y", SalesAmount : "20"},
						{Region : "X", SalesAmount : "30"}
					]
				})
				.expectChange("isExpanded", [false]);

			// code under test
			oTable.getRows()[0].getBindingContext().expand();
			oTable.getRows()[0].getBindingContext().collapse();

			return that.waitForChanges(assert, "expand and collapse 'US'");
		}).then(function () {
			var oUKContext0;

			assert.strictEqual(oRowsBinding.getLength(), 26);
			assert.deepEqual(oRowsBinding.getCurrentContexts().map(getPath), [
				"/BusinessPartners(Country='US')",
				"/BusinessPartners(Country='UK')",
				"/BusinessPartners(Country='DE')",
				"/BusinessPartners(Country='IT')",
				"/BusinessPartners(Country='FR')",
				"/BusinessPartners(Country='BE')",
				"/BusinessPartners(Country='NL')",
				"/BusinessPartners(Country='LU')"
			]);

			oUKContext0 = oRowsBinding.getCurrentContexts()[1];
			assert.strictEqual(oUKContext0.getPath(), oUKContext.getPath());
			assert.ok(oUKContext0 === oUKContext, "'UK' context is still the same instance");

			that.expectChange("isExpanded", [true])
				.expectChange("groupLevelCount", [3])
				.expectChange("level", [, 2, 2, 2])
				.expectChange("country", [, "US", "US", "US", "UK", "DE", "IT", "FR"])
				.expectChange("region", [, "Z", "Y", "X"])
				.expectChange("salesAmount", [, "10", "20", "30", "200", "300", "400", "500"]);

			// code under test
			oTable.getRows()[0].getBindingContext().expand();

			return that.waitForChanges(assert, "expand 'US' again");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 26 + 3);

			that.expectChange("isExpanded", [, true, true])
				.expectChange("isExpanded", [false, false, false])
				.expectChange("level", [, 1, 1, 1])
				.expectChange("country", [, "UK", "DE", "IT", "FR", "BE", "NL", "LU"])
				.expectChange("region", [, "", "", ""])
				.expectChange("salesAmount", [, "200", "300", "400", "500", "600", "700", "800"])
				.expectRequest("BusinessPartners?$apply=filter(Country eq 'US' and Region eq 'Z')"
					+ "/groupby((Segment),aggregate(SalesAmount))&$count=true&$skip=0&$top=8", {
					"@odata.count" : "2",
					value : [
						{SalesAmount : "1", Segment : "z"},
						{SalesAmount : "2", Segment : "y"}
					]
				})
				.expectRequest("BusinessPartners?$apply=filter(Country eq 'US' and Region eq 'Y')"
					+ "/groupby((Segment),aggregate(SalesAmount))&$count=true&$skip=0&$top=8", {
					"@odata.count" : "1",
					value : [
						{SalesAmount : "26", Segment : "a"}
					]
				});

			// code under test
			oTable.getRows()[1].getBindingContext().expand();
			oTable.getRows()[2].getBindingContext().expand();
			oTable.getRows()[0].getBindingContext().collapse();

			return that.waitForChanges(assert, "expand 'US-Z' and 'US-Y' and collapse 'US'");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 26);

			/*
				+ US
					+ US-Z
						* US-Z-z
						* US-Z-y
					+ US-Y
						* US-Y-a
					- US-X
				- UK
			 */
			that.expectChange("groupLevelCount", [, 2,,, 1])
				.expectChange("isExpanded", [true, true, undefined, undefined, true, undefined])
				.expectChange("isTotal", [,, false, false,, false])
				.expectChange("level", [, 2, 3, 3, 2, 3, 2])
				.expectChange("country", [, "US", "US", "US", "US", "US", "US", "UK"])
				.expectChange("region", [, "Z", "Z", "Z", "Y", "Y", "X"])
				.expectChange("segment", [,, "z", "y",, "a"])
				.expectChange("salesAmount", [, "10", "1", "2", "20", "26", "30", "200"]);

			// code under test
			oTable.getRows()[0].getBindingContext().expand();

			return that.waitForChanges(assert, "expand 'US' again");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 26 + 3 + 2 + 1);
		});
	});

	//*********************************************************************************************
	// Scenario: sap.ui.table.Table with aggregation and visual grouping. Collapse before paging
	// has finished.
	// JIRA: CPOUI5ODATAV4-378
	QUnit.test("Data Aggregation: collapse while paging", function (assert) {
		var oModel = this.createAggregationModel(),
			oRowsBinding,
			oTable,
			oUSContext,
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\',\
	parameters : {\
		$$aggregation : {\
			aggregate : {\
				SalesAmount : {subtotals : true}\
			},\
			group : {\
				Region : {}\
			},\
			groupLevels : [\'Country\']\
		}\
	}}" threshold="0" visibleRowCount="4">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount} }"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=groupby((Country),aggregate(SalesAmount))"
				+ "&$count=true&$skip=0&$top=4", {
				"@odata.count" : "1",
				value : [
					{Country : "US", SalesAmount : "100"}
				]
			})
			.expectChange("groupLevelCount", [undefined])
			.expectChange("isExpanded", [false])
			.expectChange("isTotal", [true])
			.expectChange("level", [1])
			.expectChange("country", ["US"])
			.expectChange("region", [""])
			.expectChange("salesAmount", ["100"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oRowsBinding = oTable.getBinding("rows");
			assert.strictEqual(oRowsBinding.getLength(), 1);
			oUSContext = oRowsBinding.getCurrentContexts()[0];

			that.expectChange("isExpanded", [true])
				.expectRequest("BusinessPartners?$apply=filter(Country eq 'US')"
					+ "/groupby((Region),aggregate(SalesAmount))&$count=true&$skip=0&$top=4", {
					"@odata.count" : "26",
					value : [
						{Region : "Z", SalesAmount : "10"},
						{Region : "Y", SalesAmount : "20"},
						{Region : "X", SalesAmount : "30"},
						{Region : "W", SalesAmount : "40"}
					]
				})
				.expectChange("groupLevelCount", [26, undefined, undefined, undefined])
				.expectChange("isExpanded", [, undefined, undefined, undefined])
				.expectChange("isTotal", [, false, false, false])
				.expectChange("level", [, 2, 2, 2])
				.expectChange("country", [, "US", "US", "US"])
				.expectChange("region", [, "Z", "Y", "X"])
				.expectChange("salesAmount", [, "10", "20", "30"]);

			// code under test
			oUSContext.expand();

			return that.waitForChanges(assert, "expand 'US'");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 1 + 26);

			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'US')"
					+ "/groupby((Region),aggregate(SalesAmount))&$skip=4&$top=3",
					function () {
						// code under test
						oUSContext.collapse();

						return resolveLater({
							value : [
								{Region : "V", SalesAmount : "50"},
								{Region : "U", SalesAmount : "60"},
								{Region : "T", SalesAmount : "70"}
							]
						});
					})
				.expectCanceledError("Failed to get contexts for /aggregation/BusinessPartners"
					+ " with start index 4 and length 4", "Collapse before read has finished")
				.expectChange("groupLevelCount", [26])
				.expectChange("isExpanded", [false])
				.expectChange("isTotal", [true])
				.expectChange("level", [1])
				.expectChange("country", ["US"])
				.expectChange("region", [""])
				.expectChange("salesAmount", ["100"]);

			// code under test
			oTable.setFirstVisibleRow(4);

			return that.waitForChanges(assert, "collapse 'US' while paging");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 1);

			that.expectChange("isExpanded", [true])
				.expectChange("isTotal", [, false, false, false])
				.expectChange("level", [, 2, 2, 2])
				.expectChange("country", [, "US", "US", "US"])
				.expectChange("region", [, "Z", "Y", "X"])
				.expectChange("salesAmount", [, "10", "20", "30"]);

			// code under test
			oUSContext.expand();

			return that.waitForChanges(assert, "expand 'US' again");
		}).then(function () {
			assert.strictEqual(oRowsBinding.getLength(), 1 + 26);

			// Note: we only see the delta of row content compared to above, but then with a
			// different row index!
			that.expectChange("groupLevelCount", [,,,, undefined])
				.expectChange("isExpanded", [,,,, undefined])
				.expectChange("isTotal", [,,,, false])
				.expectChange("level", [,,,, 2])
				.expectChange("region", [,,,, "W", "V", "U", "T"])
				.expectChange("salesAmount", [,,,, "40", "50", "60", "70"]);

			// code under test
			oTable.setFirstVisibleRow(4);

			return that.waitForChanges(assert, "just paging");
		}).then(function () {
			assert.deepEqual(oRowsBinding.getContexts(0, 8).map(getPath), [
				"/BusinessPartners(Country='US')",
				"/BusinessPartners(Country='US',Region='Z')",
				"/BusinessPartners(Country='US',Region='Y')",
				"/BusinessPartners(Country='US',Region='X')",
				"/BusinessPartners(Country='US',Region='W')",
				"/BusinessPartners(Country='US',Region='V')",
				"/BusinessPartners(Country='US',Region='U')",
				"/BusinessPartners(Country='US',Region='T')"
			]);
			assert.strictEqual(oRowsBinding.getContexts(0, 1)[0], oUSContext);
		});
	});

	//*********************************************************************************************
	// Scenario: Binding-specific parameter $$aggregation is used; no visual grouping,
	// but a grand total row (CPOUI5UISERVICESV3-1418) which is fixed at the top; first visible
	// row starts at 1 and then we scroll up; headerContext>$count is also used
	// JIRA: CPOUI5ODATAV4-297
	//
	// Avoid virtual context for $$aggregation
	// JIRA: CPOUI5ODATAV4-320
[false, true].forEach(function (bAutoExpandSelect) {
	[false, true].forEach(function (bCount) {
		var sTitle = "Data Aggregation: $$aggregation grandTotal w/o groupLevels; $count : "
				+ bCount + "; autoExpandSelect : " + bAutoExpandSelect;

		QUnit.test(sTitle, function (assert) {
			var oListBinding,
				oModel = this.createAggregationModel({autoExpandSelect : bAutoExpandSelect}),
				aResponse = [
					{SalesNumber : 351, "SalesNumber@odata.type" : "#Int32"},
					{UI5__count : "26", "UI5__count@odata.type" : "#Decimal"},
					{Country : "b", Region : "Y", SalesNumber : 2},
					{Country : "c", Region : "X", SalesNumber : 3},
					{Country : "d", Region : "W", SalesNumber : 4},
					{Country : "e", Region : "V", SalesNumber : 5}
				],
				oTable,
				sView = '\
<Text id="count" text="{$count}"/>\
<t:Table firstVisibleRow="1" id="table" rows="{\
			path : \'/BusinessPartners\',\
			parameters : {\
				$$aggregation : {\
					aggregate : {\
						SalesNumber : {grandTotal : true}\
					},\
					group : {\
						Country : {},\
						Region : {}\
					}\
				},\
				$count : ' + bCount + ',\
				$orderby : \'Region desc\'\
			},\
			filters : {path : \'AmountPerSale\', operator : \'GT\', value1 : 99}}"\
		threshold="0">\
	<t:rowMode>\
		<trm:Fixed rowCount="5" fixedTopRowCount="1"/>\
	</t:rowMode>\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
				that = this;

			this.expectRequest("BusinessPartners?$apply=filter(AmountPerSale gt 99)"
					+ "/concat(aggregate(SalesNumber)"
					+ ",groupby((Country,Region),aggregate(SalesNumber))/orderby(Region desc)"
					+ "/concat(aggregate($count as UI5__count),skip(1)/top(4)))", {
					value : aResponse
				})
				.expectChange("count")
				.expectChange("country", ["",, "b", "c", "d", "e"])
				.expectChange("region", ["",, "Y", "X", "W", "V"])
				.expectChange("salesNumber", ["351",, "2", "3", "4", "5"]);

			return this.createView(assert, sView, oModel).then(function () {
				oTable = that.oView.byId("table");
				oListBinding = oTable.getBinding("rows");

				assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
				assert.strictEqual(oListBinding.getLength(), 27, "length includes grand total row");
				// Note: header context gives count of leaves (w/o grand total)
				that.expectChange("count", "26");

				that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());

				return that.waitForChanges(assert);
			}).then(function () {
				assert.deepEqual(oListBinding.getCurrentContexts().map(getPath), [
					"/BusinessPartners(Country='b',Region='Y')",
					"/BusinessPartners(Country='c',Region='X')",
					"/BusinessPartners(Country='d',Region='W')",
					"/BusinessPartners(Country='e',Region='V')"
				]);

				that.expectRequest("BusinessPartners?$apply=filter(AmountPerSale gt 99)"
						+ "/groupby((Country,Region),aggregate(SalesNumber))"
						+ "/orderby(Region desc)/top(1)", {
						value : [
							{Country : "a", Region : "Z", SalesNumber : 1}
						]
					})
					.expectChange("country", [, "a", "b", "c", "d"])
					.expectChange("region", [, "Z", "Y", "X", "W"])
					.expectChange("salesNumber", [, "1", "2", "3", "4"]);

				oTable.setFirstVisibleRow(0);

				return that.waitForChanges(assert);
			}).then(function () {
				assert.deepEqual(oListBinding.getCurrentContexts().map(getPath), [
					"/BusinessPartners()",
					"/BusinessPartners(Country='a',Region='Z')",
					"/BusinessPartners(Country='b',Region='Y')",
					"/BusinessPartners(Country='c',Region='X')",
					"/BusinessPartners(Country='d',Region='W')"
				]);
			});
		});
	});
});

	//*********************************************************************************************
	// Scenario: Binding-specific parameter $$aggregation is used; no visual grouping,
	// but a grand total row (CPOUI5UISERVICESV3-1418) which is not fixed at the top; first visible
	// row starts at 1 and then we scroll up; headerContext>$count is also used
	[false, true].forEach(function (bCount) {
		var sTitle = "Data Aggregation: $$aggregation grandTotal w/o groupLevels; $count : "
				+ bCount + "; grandTotal row not fixed";

		QUnit.test(sTitle, function (assert) {
			var oListBinding,
				oModel = this.createAggregationModel({autoExpandSelect : true}),
				oTable,
				aValues = [
					{SalesNumber : 351, "SalesNumber@odata.type" : "#Int32"},
					{UI5__count : "26", "UI5__count@odata.type" : "#Decimal"},
					{Country : "a", Region : "Z", SalesNumber : 1},
					{Country : "b", Region : "Y", SalesNumber : 2},
					{Country : "c", Region : "X", SalesNumber : 3},
					{Country : "d", Region : "W", SalesNumber : 4},
					{Country : "e", Region : "V", SalesNumber : 5}
				],
				sView = '\
<Text id="count" text="{$count}"/>\
<t:Table firstVisibleRow="1" id="table" rows="{\
			path : \'/BusinessPartners\',\
			parameters : {\
				$$aggregation : {\
					aggregate : {\
						SalesNumber : {grandTotal : true}\
					},\
					group : {\
						Country : {},\
						Region : {}\
					}\
				},\
				$count : ' + bCount + ',\
				$orderby : \'Region desc\'\
			},\
			filters : {path : \'AmountPerSale\', operator : \'GT\', value1 : 99}}"\
		threshold="0" visibleRowCount="5">\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
				that = this;

			this.expectRequest("BusinessPartners?$apply=filter(AmountPerSale gt 99)"
					+ "/concat(aggregate(SalesNumber)"
					+ ",groupby((Country,Region),aggregate(SalesNumber))"
					+ "/orderby(Region desc)/concat(aggregate($count as UI5__count),top(5)))",
					{value : aValues})
				.expectChange("count")
				.expectChange("country", [, "a", "b", "c", "d", "e"])
				.expectChange("region", [, "Z", "Y", "X", "W", "V"])
				.expectChange("salesNumber", [, "1", "2", "3", "4", "5"]);

			return this.createView(assert, sView, oModel).then(function () {
				oTable = that.oView.byId("table");
				oListBinding = oTable.getBinding("rows");

				assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
				assert.strictEqual(oListBinding.getLength(), 27, "length includes grand total row");
				assert.strictEqual(oListBinding.getCount(), 26, "count of leaves");

				// Note: header context gives count of leaves (w/o grand total)
				that.expectChange("count", "26");

				that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());

				return that.waitForChanges(assert);
			}).then(function () {
				assert.deepEqual(oListBinding.getCurrentContexts().map(getPath), [
					"/BusinessPartners(Country='a',Region='Z')",
					"/BusinessPartners(Country='b',Region='Y')",
					"/BusinessPartners(Country='c',Region='X')",
					"/BusinessPartners(Country='d',Region='W')",
					"/BusinessPartners(Country='e',Region='V')"
				]);

				// Note: no request, grand total row already available
				that.expectChange("country", ["", "a", "b", "c", "d"])
					.expectChange("region", ["", "Z", "Y", "X", "W"])
					.expectChange("salesNumber", ["351", "1", "2", "3", "4"]);

				oTable.setFirstVisibleRow(0);

				return that.waitForChanges(assert);
			}).then(function () {
				assert.deepEqual(oListBinding.getCurrentContexts().map(getPath), [
					"/BusinessPartners()",
					"/BusinessPartners(Country='a',Region='Z')",
					"/BusinessPartners(Country='b',Region='Y')",
					"/BusinessPartners(Country='c',Region='X')",
					"/BusinessPartners(Country='d',Region='W')"
				]);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Binding-specific parameter $$aggregation is used; no visual grouping,
	// but a grand total row using with/as (CPOUI5UISERVICESV3-1418) and a unit (CPOUI5ODATAV4-583).
	// Check the download URL(CPOUI5ODATAV4-609).
	QUnit.test("Data Aggregation: $$aggregation grandTotal w/o groupLevels using with/as/unit",
			function (assert) {
		var oModel = this.createAggregationModel({autoExpandSelect : true}),
			sView = '\
<t:Table id="table" rows="{\
			path : \'/BusinessPartners\',\
			parameters : {\
				$$aggregation : {\
					aggregate : {\
						SalesAmountSum : {\
							grandTotal : true,\
							name : \'SalesAmount\',\
							unit : \'Currency\',\
							with : \'sum\'\
						},\
						SalesNumber : {}\
					},\
					group : {\
						Region : {}\
					}\
				},\
				$orderby : \'SalesAmountSum asc\'\
			},\
			filters : {path : \'AmountPerSale\', operator : \'GT\', value1 : 99}}"\
		threshold="0" visibleRowCount="5">\
	<Text id="region" text="{Region}"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
	<Text id="salesAmountSum" text="{= %{SalesAmountSum} }"/>\
	<Text id="currency" text="{Currency}"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=filter(AmountPerSale gt 99)/concat("
				+ "aggregate(SalesAmount with sum as SalesAmountSum,Currency),groupby((Region)"
				+ ",aggregate(SalesAmount with sum as SalesAmountSum,Currency,SalesNumber))"
				+ "/orderby(SalesAmountSum asc)/concat(aggregate($count as UI5__count),top(4)))", {
				value : [{
					Currency : "EUR",
					SalesAmountSum : "351",
					//TODO this should be used by auto type detection
					"SalesAmountSum@odata.type" : "#Decimal"
				}, {
					UI5__count : "26",
					"UI5__count@odata.type" : "#Decimal"
				}, {
					Currency : "EUR",
					Region : "Z",
					SalesNumber : 1,
					SalesAmountSum : "1"
				}, {
					Currency : "EUR",
					Region : "Y",
					SalesNumber : 2,
					SalesAmountSum : "2"
				}, {
					Currency : "EUR",
					Region : "X",
					SalesNumber : 3,
					SalesAmountSum : "3"
				}, {
					Currency : "EUR",
					Region : "W",
					SalesNumber : 4,
					SalesAmountSum : "4"
				}]
			})
			.expectChange("region", ["", "Z", "Y", "X", "W"])
			.expectChange("salesNumber", [null, "1", "2", "3", "4"])
			.expectChange("salesAmountSum", ["351", "1", "2", "3", "4"])
			.expectChange("currency", ["EUR", "EUR", "EUR", "EUR", "EUR"]);

		return this.createView(assert, sView, oModel).then(function () {
			assert.strictEqual(that.oView.byId("table").getBinding("rows").getDownloadUrl(),
				"/aggregation/BusinessPartners?$apply=filter(AmountPerSale%20gt%2099)"
				+ "/groupby((Region)"
				+ ",aggregate(SalesAmount%20with%20sum%20as%20SalesAmountSum,Currency,SalesNumber))"
				+ "/orderby(SalesAmountSum%20asc)",
				"CPOUI5ODATAV4-609");
		});
	});

	//*********************************************************************************************
	// Scenario: Calling the API functions filter, sort, changeParameters, setAggregation on an
	// unresolved binding are stored. As soon as the binding gets resolved and requests data
	// they reflect inside the request.
	// BCP: 2070187260
	QUnit.test("API calls before binding is resolved", function (assert) {
		var that = this;

		return this.createView(assert, "", this.createAggregationModel()).then(function () {
			var oListBinding = that.oModel.bindList("BusinessPartners");

			// code under test
			oListBinding.setAggregation({
				aggregate : {
					SalesNumber : {grandTotal : true}
				},
				group : {
					Region : {}
				}
			});

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {
					SalesNumber : {grandTotal : true}
				},
				group : {
					Region : {}
				},
				groupLevels : []
			}, "JIRA: CPOUI5ODATAV4-1825");

			// code under test
			oListBinding.filter([
				new Filter("Name", FilterOperator.EQ, "Foo"),
				new Filter("Region", FilterOperator.NE, "Bar")
			]);

			// code under test
			oListBinding.sort(new Sorter("SalesNumber"));

			// code under test
			oListBinding.changeParameters({custom : "foo"});

			// resolve the binding to see that the API changes work
			oListBinding.setContext(that.oModel.createBindingContext("/"));

			that.expectRequest("BusinessPartners?custom=foo"
					+ "&$apply=filter(Name eq 'Foo' and Region ne 'Bar')"
					+ "/concat(aggregate(SalesNumber),groupby((Region),aggregate(SalesNumber))"
					+ "/orderby(SalesNumber)/concat(aggregate($count as UI5__count),top(99)))", {
					value : [
						{SalesNumber : 0},
						{UI5__count : "26", "UI5__count@odata.type" : "#Decimal"}
						// ... (don't care)
					]
				});

			return Promise.all([
				oListBinding.requestContexts(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Filtering on a list binding with data aggregation splits the filters in two parts:
	// - those filters that can be applied before aggregating
	// - those filters that must be applied after aggregating
	// JIRA: CPOUI5ODATAV4-119
	QUnit.test("JIRA: CPOUI5ODATAV4-119 with _MinMaxHelper", function (assert) {
		var oModel = this.createAggregationModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oListBinding = that.oModel.bindList("/BusinessPartners", null, null, [
					new Filter("Name", FilterOperator.EQ, "Foo"),
					new Filter("SalesNumber", FilterOperator.GT, 0)
				], {
					$$aggregation : {
						aggregate : {
							SalesNumber : {min : true}
						},
						group : {
							Region : {}
						}
					}
				});

			that.expectRequest("BusinessPartners?$apply=filter(Name eq 'Foo')"
					+ "/groupby((Region),aggregate(SalesNumber))/filter(SalesNumber gt 0)"
					+ "/concat(aggregate(SalesNumber with min as UI5min__SalesNumber),top(100))", {
					value : [
						{UI5min__SalesNumber : 0, "UI5min__SalesNumber@odata.type" : "#Int32"}
						// ... (don't care)
					]
				});

			return Promise.all([
				oListBinding.requestContexts(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Filtering on a list binding with data aggregation splits the filters in two parts:
	// - those filters that can be applied before aggregating
	// - those filters that must be applied after aggregating (Note: this is currently unsupported
	//   with grand total)
	// JIRA: CPOUI5ODATAV4-119
	//
	// Add searching before aggregating and sorting.
	// JIRA: CPOUI5ODATAV4-1030
	QUnit.test("JIRA: CPOUI5ODATAV4-119 with _AggregationCache", function (assert) {
		var oModel = this.createAggregationModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oListBinding = that.oModel.bindList("/BusinessPartners", null, null, [
					new Filter("Name", FilterOperator.EQ, "Foo")
					//TODO new Filter("SalesNumber", FilterOperator.GT, 0)
				], {
					$$aggregation : {
						aggregate : {
							SalesNumber : {grandTotal : true}
						},
						group : {
							Region : {}
						},
						search : "covfefe"
					},
					$orderby : "Region asc,SalesNumber desc"
				});

			that.expectRequest("BusinessPartners?$apply=filter(Name eq 'Foo')/search(covfefe)"
					+ "/concat(aggregate(SalesNumber),groupby((Region),aggregate(SalesNumber))"
					+ "/orderby(Region asc,SalesNumber desc)"
					// Note: $count is requested automatically
					+ "/concat(aggregate($count as UI5__count),top(99)))", {
					value : [
						{SalesNumber : 351, "SalesNumber@odata.type" : "#Int32"},
						{UI5__count : "26", "UI5__count@odata.type" : "#Decimal"}
						// ... (don't care)
					]
				});

			return Promise.all([
				oListBinding.requestContexts(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Filtering on a list binding with data aggregation splits the filters in two parts:
	// - those filters that can be applied before aggregating
	// - those filters that must be applied after aggregating
	// JIRA: CPOUI5ODATAV4-119
	//
	// Add $count as well as searching before and after aggregating.
	// JIRA: CPOUI5ODATAV4-1030
	QUnit.test("JIRA: CPOUI5ODATAV4-119 with _Cache.CollectionCache", function (assert) {
		var oModel = this.createAggregationModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oListBinding = that.oModel.bindList("/BusinessPartners", null, null, [
					new Filter("Name", FilterOperator.EQ, "Foo"),
					new Filter("SalesNumber", FilterOperator.GT, 0)
				], {
					$$aggregation : {
						aggregate : {
							SalesNumber : {}
						},
						group : {
							Region : {}
						},
						search : "tee"
					},
					$count : true,
					$search : "covfefe"
				});

			that.expectRequest("BusinessPartners?$count=true&$search=covfefe&$apply"
					+ "=filter(Name eq 'Foo')/search(tee)/groupby((Region),aggregate(SalesNumber))"
					+ "&$filter=SalesNumber gt 0&$skip=0&$top=100", {
					"@odata.count" : "0",
					value : [
						// ... (don't care)
					]
				});

			return Promise.all([
				oListBinding.requestContexts(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Filtering by aggregated properties was supported in 1.84.0 even if grand totals
	// were needed (at least w/o visual grouping).
	// BCP: 2170032897
	// JIRA: CPOUI5ODATAV4-119
	//
	// Add searching before aggregating and sorting.
	// JIRA: CPOUI5ODATAV4-1030
	QUnit.test("BCP: 2170032897 with UI5 filters", function (assert) {
		var oListBinding,
			oModel = this.createAggregationModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			oListBinding = that.oModel.bindList("/BusinessPartners", null, [
				new Sorter("Region")
			], [
				new Filter("Name", FilterOperator.EQ, "Foo"),
				new Filter("SalesAmount", FilterOperator.GT, 0)
			], {
				$$aggregation : {
					aggregate : {
						SalesAmount : {grandTotal : true, unit : "Currency"}
					},
					group : {
						Region : {}
					},
					"grandTotal like 1.84" : true, // code under test
					search : "covfefe"
				}
			});

			that.expectRequest("BusinessPartners?$apply=filter(Name eq 'Foo')/search(covfefe)"
					+ "/groupby((Region),aggregate(SalesAmount,Currency))"
					+ "/filter(SalesAmount gt 0)/orderby(Region)"
					+ "/concat(aggregate(SalesAmount,Currency),aggregate($count as UI5__count)"
						+ ",top(2))", {
					value : [
						{Currency : "DEM",
							SalesAmount : "0", "SalesAmount@odata.type" : "#Decimal"},
						{UI5__count : "26", "UI5__count@odata.type" : "#Decimal"},
						{Region : "A", SalesAmount : "100"},
						{Region : "B", SalesAmount : "200"}
					]
				});

			return Promise.all([
				oListBinding.requestContexts(0, 3),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			var aContexts = aResults[0];

			assert.strictEqual(oListBinding.getHeaderContext().getProperty("$count"), 26);
			assert.deepEqual(aContexts.map(getObject), [{
				"@$ui5.node.isExpanded" : true,
				"@$ui5.node.isTotal" : true,
				"@$ui5.node.level" : 0,
				Currency : "DEM",
				Region : null,
				SalesAmount : "0",
				"SalesAmount@odata.type" : "#Decimal"
			}, {
				"@$ui5.node.isTotal" : false,
				"@$ui5.node.level" : 1,
				Currency : null,
				Region : "A",
				SalesAmount : "100"
			}, {
				"@$ui5.node.isTotal" : false,
				"@$ui5.node.level" : 1,
				Currency : null,
				Region : "B",
				SalesAmount : "200"
			}]);
			assert.deepEqual(aContexts.map(getPath), [
				"/BusinessPartners()",
				"/BusinessPartners(Region='A')",
				"/BusinessPartners(Region='B')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Filtering by aggregated properties was supported in 1.84.0 even if grand totals
	// were needed (at least w/o visual grouping).
	// BCP: 2170032897
	// JIRA: CPOUI5ODATAV4-119
	QUnit.test("BCP: 2170032897 with $filter", function (assert) {
		var oListBinding,
			oModel = this.createAggregationModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			oListBinding = that.oModel.bindList("/BusinessPartners", null, [], [
				new Filter("Name", FilterOperator.EQ, "Foo")
			], {
				$$aggregation : {
					aggregate : {
						SalesAmountSum : {
							grandTotal : true,
							name : "SalesAmount",
							unit : "Currency", // Note: unsupported in 1.84
							with : "sum"
						}
					},
					"grandTotal like 1.84" : true, // code under test
					group : {
						Region : {}
					}
				},
				$count : true, // Note: not by default in 1.84
				$filter : "SalesAmountSum gt 0",
				$orderby : "Region"
			});

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {
					SalesAmountSum : {
						grandTotal : true,
						name : "SalesAmount",
						unit : "Currency", // Note: unsupported in 1.84
						with : "sum"
					}
				},
				"grandTotal like 1.84" : true,
				group : {
					Region : {}
				},
				groupLevels : []
			}, "JIRA: CPOUI5ODATAV4-1825");

			that.expectRequest("BusinessPartners?$apply=filter(Name eq 'Foo')/groupby((Region)"
						+ ",aggregate(SalesAmount with sum as SalesAmountSum,Currency))"
					+ "/filter(SalesAmountSum gt 0)/orderby(Region)/concat("
						+ "aggregate(SalesAmountSum with sum as UI5grand__SalesAmountSum,Currency)"
						+ ",aggregate($count as UI5__count),top(2))", {
					value : [{
						Currency : "DEM",
						UI5grand__SalesAmountSum : "0",
						"UI5grand__SalesAmountSum@odata.type" : "#Decimal"
					}, { // Note: in 1.84, this is part of the grand total row
						UI5__count : "26",
						"UI5__count@odata.type" : "#Decimal"
					}, {
						Region : "A",
						SalesAmountSum : "100"
					}, {
						Region : "B",
						SalesAmountSum : "200"
					}]
				});

			return Promise.all([
				oListBinding.requestContexts(0, 3),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			var aContexts = aResults[0];

			assert.strictEqual(oListBinding.getHeaderContext().getProperty("$count"), 26);
			assert.deepEqual(aContexts.map(getObject), [{
				"@$ui5.node.isExpanded" : true,
				"@$ui5.node.isTotal" : true,
				"@$ui5.node.level" : 0,
				Currency : "DEM",
				Region : null,
				SalesAmountSum : "0",
				"SalesAmountSum@odata.type" : "#Decimal"
			}, {
				"@$ui5.node.isTotal" : false,
				"@$ui5.node.level" : 1,
				Currency : null,
				Region : "A",
				SalesAmountSum : "100"
			}, {
				"@$ui5.node.isTotal" : false,
				"@$ui5.node.level" : 1,
				Currency : null,
				Region : "B",
				SalesAmountSum : "200"
			}]);
			assert.deepEqual(aContexts.map(getPath), [
				"/BusinessPartners()",
				"/BusinessPartners(Region='A')",
				"/BusinessPartners(Region='B')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Binding-specific parameter $$aggregation is used without group or groupLevels
	// Note: usage of min/max simulates a Chart, which would actually call ODLB#updateAnalyticalInfo
	// JIRA: CPOUI5UISERVICESV3-1479
	[false, true].forEach(function (bCount) {
		var sTitle = "Data Aggregation: $$aggregation, aggregate but no group; $count : "
				+ bCount;

		QUnit.test(sTitle, function (assert) {
			var oListBinding,
				oMinMaxElement = {
					UI5min__AGE : 42,
					UI5max__AGE : 77
				},
				oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
				oTable,
				sView = '\
<Text id="count" text="{$count}"/>\
<t:Table id="table" rows="{path : \'/SalesOrderList\',\
		parameters : {\
			$$aggregation : {\
				aggregate : {\
					GrossAmount : {\
						min : true,\
						max : true\
					}\
				}\
			},\
			$count : ' + bCount + '\
		}}" threshold="0" visibleRowCount="1">\
	<Text id="grossAmount" text="{= %{GrossAmount}}"/>\
</t:Table>',
				that = this;

			if (bCount) {
				oMinMaxElement["UI5__count"] = "26";
				oMinMaxElement["UI5__count@odata.type"] = "#Decimal";
			}
			this.expectRequest("SalesOrderList?$apply=aggregate(GrossAmount)"
					+ "/concat(aggregate(GrossAmount with min as UI5min__GrossAmount,"
					+ "GrossAmount with max as UI5max__GrossAmount"
					+ (bCount ? ",$count as UI5__count" : "") + "),top(1))", {
					value : [oMinMaxElement, {GrossAmount : "1"}]
				})
				.expectChange("count")
				.expectChange("grossAmount", ["1"]);

			return this.createView(assert, sView, oModel).then(function () {
				oTable = that.oView.byId("table");
				oListBinding = oTable.getBinding("rows");

				if (bCount) {
					assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
					assert.strictEqual(oListBinding.getLength(), 26);

					that.expectChange("count", "26");

					that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());
				}

				return that.waitForChanges(assert);
			}).then(function () {
				var oResponse = {
						value : [{GrossAmount : "2"}]
					};

				if (bCount) {
					oResponse["@odata.count"] = "13";
					that.expectChange("count", "13");
				}
				// w/o min/max: no _MinMaxHelper, system query options are used
				that.expectRequest("SalesOrderList?" + (bCount ? "$count=true&" : "")
						+ "$apply=aggregate(GrossAmount)&$skip=0&$top=1", oResponse)
					.expectChange("grossAmount", ["2"]);

				oTable.getBinding("rows").setAggregation({
					aggregate : {GrossAmount : {}}
				});

				return that.waitForChanges(assert);
			}).then(function () {
				if (bCount) {
					assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
					assert.strictEqual(oListBinding.getLength(), 13);
				}
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Data aggregation with visual grouping, grand total and subtotals, leaf count,
	// sorting; filtering and searching before aggregation; expand and paging.
	//
	// JIRA: CPOUI5ODATAV4-1030
	QUnit.test("Data Aggregation: search before aggregation", function (assert) {
		var oListBinding,
			oModel = this.createAggregationModel(),
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/BusinessPartners\',\
		parameters : {\
			$$aggregation : {\
				aggregate : {\
					SalesNumber : {grandTotal : true, subtotals : true}\
				},\
				group : {\
					Region : {}\
				},\
				groupLevels : [\'Country\'],\
				search : \'covfefe\'\
			},\
			$count : true,\
			$orderby : \'Country asc,Region,SalesNumber desc\'\
		},\
		filters : {path : \'Name\', operator : \'EQ\', value1 : \'Foo\'}\
	}" threshold="0" visibleRowCount="3">\
	<Text id="groupLevelCount" text="{= %{@$ui5.node.groupLevelCount} }"/>\
	<Text id="isExpanded" text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text id="isTotal" text="{= %{@$ui5.node.isTotal} }"/>\
	<Text id="level" text="{= %{@$ui5.node.level} }"/>\
	<Text id="country" text="{Country}"/>\
	<Text id="region" text="{Region}"/>\
	<Text id="salesNumber" text="{SalesNumber}"/>\
</t:Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=filter(Name eq 'Foo')/search(covfefe)"
				+ "/concat(groupby((Country,Region))/aggregate($count as UI5__leaves)"
				+ ",aggregate(SalesNumber),groupby((Country),aggregate(SalesNumber))"
				+ "/orderby(Country asc,SalesNumber desc)"
				+ "/concat(aggregate($count as UI5__count),top(2)))", {
				value : [
					{UI5__leaves : "42", "UI5__leaves@odata.type" : "#Decimal"},
					{SalesNumber : 351, "SalesNumber@odata.type" : "#Int32"},
					{UI5__count : "26", "UI5__count@odata.type" : "#Decimal"},
					{Country : "A", SalesNumber : 101},
					{Country : "B", SalesNumber : 102}
				]
			})
			.expectChange("groupLevelCount", [undefined, undefined, undefined])
			.expectChange("isExpanded", [true, false, false])
			.expectChange("isTotal", [true, true, true])
			.expectChange("level", [0, 1, 1])
			.expectChange("country", ["", "A", "B"])
			.expectChange("region", ["", "", ""])
			.expectChange("salesNumber", ["351", "101", "102"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("rows");

			assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
			assert.strictEqual(oListBinding.getLength(), 1 + 26, "flat list as currently expanded");
			assert.strictEqual(oListBinding.getCount(), 42, "count of leaves");

			that.expectChange("isExpanded", [, true])
				.expectRequest("BusinessPartners?$apply=filter(Country eq 'A' and (Name eq 'Foo'))"
					+ "/search(covfefe)/groupby((Region),aggregate(SalesNumber))"
					+ "/orderby(Region,SalesNumber desc)&$count=true&$skip=0&$top=3", {
					"@odata.count" : "12",
					value : [
						{Region : "a", SalesNumber : 1},
						{Region : "b", SalesNumber : 2},
						{Region : "c", SalesNumber : 3}
					]
				})
				.expectChange("groupLevelCount", [, 12])
				.expectChange("isExpanded", [,, undefined])
				.expectChange("isTotal", [,, false])
				.expectChange("level", [,, 2])
				.expectChange("country", [,, "A"])
				.expectChange("region", [,, "a"])
				.expectChange("salesNumber", [,, "1"]);

			// code under test
			oTable.getRows()[1].getBindingContext().expand();

			return that.waitForChanges(assert, "expand");
		}).then(function () {
			assert.strictEqual(oListBinding.isLengthFinal(), true, "length is final");
			assert.strictEqual(oListBinding.getLength(), 1 + 26 + 12,
				"flat list as currently expanded");
			assert.strictEqual(oListBinding.getCount(), 42, "count of leaves");

			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'A' and (Name eq 'Foo'))"
				+ "/search(covfefe)/groupby((Region),aggregate(SalesNumber))"
				+ "/orderby(Region,SalesNumber desc)&$skip=5&$top=3", {
					value : [
						{Region : "f", SalesNumber : 6},
						{Region : "g", SalesNumber : 7},
						{Region : "h", SalesNumber : 8}
					]
				})
				// .expectChange("isExpanded", [])
				.expectChange("isTotal", [,,,,,,, false, false, false])
				.expectChange("level", [,,,,,,, 2, 2, 2])
				.expectChange("country", [,,,,,,, "A", "A", "A"])
				.expectChange("region", [,,,,,,, "f", "g", "h"])
				.expectChange("salesNumber", [,,,,,,, "6", "7", "8"]);

			// scroll down
			oTable.setFirstVisibleRow(7);

			return that.waitForChanges(assert, "paging");
		});
	});

	//*********************************************************************************************
	// Scenario: check that $$aggregation can be removed again
	// Note: Key properties are omitted from response data to improve readability.
	// BCP: 2080047558
	QUnit.test("BCP: 2080047558", function (assert) {
		var oListBinding,
			oModel = this.createSalesOrdersModel(),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="grossAmount" text="{= %{GrossAmount}}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$skip=0&$top=100", {
				value : [{GrossAmount : "1"}]
			})
			.expectChange("grossAmount", ["1"]);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("SalesOrderList?$apply=aggregate(GrossAmount)&$skip=0&$top=100", {
					value : [{GrossAmount : "2"}]
				})
				.expectChange("grossAmount", ["2"]);

			// code under test
			oListBinding.setAggregation({
				aggregate : {GrossAmount : {}}
			});

			assert.throws(function () {
				// code under test
				oListBinding.changeParameters({
					$apply : "A.P.P.L.E."
				});
			}, new Error("Cannot combine $$aggregation and $apply"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$skip=0&$top=100", {
					value : [{GrossAmount : "3"}]
				})
				.expectChange("grossAmount", ["3"]);

			assert.throws(function () {
				// code under test
				oListBinding.setAggregation(null); // Note: null is not supported
			}); // TypeError("Cannot read property 'groupLevels' of null")

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {
					GrossAmount : {}
				},
				group : {},
				groupLevels : []
			}, "JIRA: CPOUI5ODATAV4-1825");

			// code under test
			oListBinding.setAggregation({});

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {},
				group : {},
				groupLevels : []
			}, "JIRA: CPOUI5ODATAV4-1825");

			assert.throws(function () {
				// code under test
				oListBinding.changeParameters({
					$apply : "A.P.P.L.E."
				});
			}, new Error("Cannot combine $$aggregation and $apply"));

			assert.throws(function () {
				// code under test
				oListBinding.changeParameters({
					$$aggregation : {groupLevels : ["n/a"]}
				});
			}, new Error("Unsupported parameter: $$aggregation"));

			return that.waitForChanges(assert);
		}).then(function () {
			// code under test (Note: no request!)
			oListBinding.setAggregation();

			// code under test
			assert.strictEqual(oListBinding.getAggregation(), undefined,
				"JIRA: CPOUI5ODATAV4-1825");

			that.expectRequest("SalesOrderList"
					+ "?$apply=groupby((LifecycleStatus),aggregate(GrossAmount))"
					+ "&$skip=0&$top=100", {
					value : [{GrossAmount : "4"}]
				})
				.expectChange("grossAmount", ["4"]);

			// code under test
			oListBinding.changeParameters({
				$apply : "groupby((LifecycleStatus),aggregate(GrossAmount))"
			});

			return that.waitForChanges(assert);
		}).then(function () {
			// code under test (Note: no request!)
			oListBinding.setAggregation();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$skip=0&$top=100", {
					value : [{GrossAmount : "5"}]
				})
				.expectChange("grossAmount", ["5"]);

			// code under test
			oListBinding.changeParameters({$apply : undefined});
		}).then(function () {
			// code under test (Note: no request!)
			oListBinding.setAggregation({});

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: check that 'subtotals' can be changed and that $$aggregation can be removed again,
	// each time refreshing the UI.
	// BCP: 2070044134
	QUnit.test("BCP: 2070044134", function (assert) {
		var oListBinding,
			oModel = this.createSalesOrdersModel(),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="lifecycleStatus" text="{LifecycleStatus}"/>\
	<Text id="grossAmount" text="{= %{GrossAmount}}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$skip=0&$top=100", {
				value : [{GrossAmount : "1", LifecycleStatus : "Z"}]
			})
			.expectChange("grossAmount", ["1"])
			.expectChange("lifecycleStatus", ["Z"]);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("SalesOrderList?$apply=groupby((LifecycleStatus))&$count=true"
					+ "&$skip=0&$top=100", {
					"@odata.count" : "1",
					value : [{LifecycleStatus : "Y"}]
				})
				.expectChange("grossAmount", [null])
				.expectChange("lifecycleStatus", ["Y"]);

			// code under test
			oListBinding.setAggregation({
				aggregate : {GrossAmount : {}},
				groupLevels : ["LifecycleStatus"]
			});

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList"
					+ "?$apply=groupby((LifecycleStatus),aggregate(GrossAmount))"
					+ "&$count=true&$skip=0&$top=100", {
					"@odata.count" : "1",
					value : [{GrossAmount : "3", LifecycleStatus : "X"}]
				})
				.expectChange("grossAmount", ["3"])
				.expectChange("lifecycleStatus", ["X"]);

			// code under test
			oListBinding.setAggregation({
				aggregate : {GrossAmount : {subtotals : true}},
				groupLevels : ["LifecycleStatus"]
			});

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$skip=0&$top=100", {
					value : [{GrossAmount : "4", LifecycleStatus : "W"}]
				})
				.expectChange("grossAmount", ["4"])
				.expectChange("lifecycleStatus", ["W"]);

			// code under test
			oListBinding.setAggregation();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Call requestSideEffects on a list binding with data aggregation. See that the
	// request is not influenced by $select/$sexpand, but by $apply.
	// JIRA: CPOUI5ODATAV4-337
	//
	// Use subtotalsAtBottomOnly w/o subtotals actually being requested. This must not change
	// anything!
	// JIRA: CPOUI5ODATAV4-825
	QUnit.test("requestSideEffects and $$aggregation", function (assert) {
		var oBinding,
			oHeaderContext,
			oModel = this.createAggregationModel(),
			sView = '\
<Table id="table" items="{path : \'/BusinessPartners\',\
		parameters : {\
			$$aggregation : {\
				aggregate : {SalesAmount : {}},\
				groupLevels : [\'Region\'],\
				subtotalsAtBottomOnly : true\
			}\
		}}">\
	<Text id="region" text="{Region}"/>\
	<Text id="salesAmount" text="{= %{SalesAmount}}"/>\
</Table>',
			that = this;

		this.expectRequest("BusinessPartners?$apply=groupby((Region))&$count=true&$skip=0&$top=100",
				{"@odata.count" : "1", value : [{Region : "A"}]})
			.expectChange("region", ["A"])
			.expectChange("salesAmount", [null]);

		return this.createView(assert, sView, oModel).then(function () {
			// expect no request

			oBinding = that.oView.byId("table").getBinding("items");
			oHeaderContext = oBinding.getHeaderContext();

			return Promise.all([
				oHeaderContext.requestSideEffects([{$PropertyPath : "AccountResponsible"}]),
				that.waitForChanges(assert, "AccountResponsible (unused)")
			]);
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply=groupby((Region))&$count=true"
					+ "&$skip=0&$top=100", {"@odata.count" : "1", value : [{Region : "A"}]});

			return Promise.all([
				oHeaderContext.requestSideEffects([{$NavigationPropertyPath : ""}]),
				that.waitForChanges(assert, "entity")
			]);
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply=groupby((Region))&$count=true"
					+ "&$skip=0&$top=100", {"@odata.count" : "1", value : [{Region : "A"}]});

			return Promise.all([
				oHeaderContext.requestSideEffects([{$PropertyPath : "SalesAmount"}]),
				that.waitForChanges(assert, "SalesAmount (aggregate)")
			]);
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply=groupby((Region))&$count=true"
					+ "&$skip=0&$top=100", {"@odata.count" : "1", value : [{Region : "A"}]});

			return Promise.all([
				oHeaderContext.requestSideEffects([{$PropertyPath : "Region"}]),
				that.waitForChanges(assert, "Region (group level)")
			]);
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'US')"
					+ "/groupby((Region))&$count=true&$skip=0&$top=100",
					{"@odata.count" : "1", value : [{Region : "A"}]});

			oBinding.filter(new Filter("Country", FilterOperator.EQ, "US"));

			return that.waitForChanges(assert, "filter");
		}).then(function () {
			that.expectRequest("BusinessPartners?$apply=filter(Country eq 'US')"
					+ "/groupby((Region))&$count=true&$skip=0&$top=100",
					{"@odata.count" : "1", value : [{Region : "A"}]});

			return Promise.all([
				oHeaderContext.requestSideEffects([{$PropertyPath : "Country"}]),
				that.waitForChanges(assert, "Country (filter)")
			]);
		}).then(function () {
			return that.oView.byId("table").getItems()[0].getBindingContext()
				.requestSideEffects([{$PropertyPath : "Country"}])
				.then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message,
						"Must not request side effects when using data aggregation");
				});
		});
	});

	//*********************************************************************************************
	// Scenario: Show the single root node of a recursive hierarchy, which happens to be a leaf.
	// Show that auto-$expand/$select and late property requests work.
	// JIRA: CPOUI5ODATAV4-1643
	//
	// Request various side effects that do not affect the hierarchy (JIRA: CPOUI5ODATAV4-1785).
	// Check that refresh is not supported (JIRA: CPOUI5ODATAV4-1851).
	// Additionally, ODLB#getDownloadUrl is tested (JIRA: CPOUI5ODATAV4-1920, BCP: 2370011296).
	// Retrieve "DistanceFromRoot" property path via ODLB#getAggregation (JIRA: CPOUI5ODATAV4-1961).
	// See that Filter.NONE is not allowed (JIRA: CPOUI5ODATAV4-2321).
	//
	// NodeID is selected automatically, even w/o UI, but "parent node ID" is not.
	// JIRA: CPOUI5ODATAV4-1849
	//
	// Selection on header and root context (JIRA: CPOUI5ODATAV4-1943).
	// Data binding for selection (JIRA: CPOUI5ODATAV4-1944).
	//
	// Use $count (JIRA: CPOUI5ODATAV4-1855).
	// Old vs. new format of RecursiveHierarchy annotation (JIRA: CPOUI5ODATAV4-2401).
	//
	// Root is kept alive and requests messages, then list is refreshed and the kept-alive node is
	// neither the root nor a leaf anymore ;-) A side-effects refresh fails and the new root is
	// expanded to reveal the kept-alive node.
	// JIRA: CPOUI5ODATAV4-2030
	//
	// The whole tree is expanded to -two-all levels (JIRA: CPOUI5ODATAV4-2095/-2151).
	// Selection keeps a context implicitly alive (JIRA: CPOUI5ODATAV4-2053).
	// Ensure that unchanged $$aggregation is ignored (BCP: 2370045709).
	//
	// Retrieve "DrillState" property path via verbose ODLB#getAggregation & include it in the
	// downloadUrl
	// JIRA: CPOUI5ODATAV4-2275
[false, true].forEach(function (bKeepAlive) {
	["OldChart", "OrgChart"].forEach((sHierarchyQualifier) => {
		var sTitle = "Recursive Hierarchy: root is leaf; bKeepAlive=" + bKeepAlive
				+ ", hierarchyQualifier : " + sHierarchyQualifier;

	QUnit.test(sTitle, function (assert) {
		var sExpectedDownloadUrl
				= "/special/cases/Artists?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
				+ "HierarchyNodes=$root/Artists,HierarchyQualifier='" + sHierarchyQualifier
				+ "',NodeProperty='_/NodeID')"
				+ "&$select=ArtistID,IsActiveEntity,_/DistanceFromRoot,_/DrillState,_/NodeID"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)",
			oHeaderContext,
			oKeptAliveNode,
			oListBinding,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oRoot,
			oTable,
			sView = `
<Text id="count" text="{$count}"/>
<t:Table id="table" rows="{path : '/Artists',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : '${sHierarchyQualifier}'
			},
			$count : true
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.context.isSelected} }"/>
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{BestFriend/Name}"/>
</t:Table>`,
			that = this;

		this.expectRequest({
				batchNo : 1,
				url : "Artists/$count"
			}, 1)
			.expectRequest({
				batchNo : 1,
				url : "Artists?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/Artists,HierarchyQualifier='"
					+ sHierarchyQualifier + "',NodeProperty='_/NodeID',Levels=1)"
					+ "&$select=ArtistID,IsActiveEntity,_/DrillState,_/NodeID"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
					+ "&$count=true&$skip=0&$top=3"
			}, {
				"@odata.count" : "1",
				value : [{
					"@odata.etag" : "etag0.0",
					ArtistID : "0",
					BestFriend : {
						ArtistID : "01",
						IsActiveEntity : true,
						Name : "Friend #01"
					},
					IsActiveEntity : true,
					_ : {
						// DescendantCount : "0", // not needed w/o expandTo
						// DistanceFromRoot : "0", // not needed w/o expandTo
						DrillState : "leaf",
						NodeID : "0,true"
					}
				}]
			})
			.expectChange("count");

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oRoot = oTable.getRows()[0].getBindingContext();
			oListBinding = oRoot.getBinding();
			oHeaderContext = oListBinding.getHeaderContext();

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				expandTo : 1,
				hierarchyQualifier : sHierarchyQualifier
			}, "JIRA: CPOUI5ODATAV4-1825");
			// code under test
			assert.deepEqual(oListBinding.getAggregation(/*bVerbose*/true), {
				expandTo : 1,
				hierarchyQualifier : sHierarchyQualifier,
				$DistanceFromRoot : "_/DistanceFromRoot",
				$DrillState : "_/DrillState",
				$NodeProperty : "_/NodeID"
			}, "JIRA: CPOUI5ODATAV4-1961, CPOUI5ODATAV4-2275");
			// code under test
			assert.strictEqual(oListBinding.getDownloadUrl(), sExpectedDownloadUrl,
				"JIRA: CPOUI5ODATAV4-1920, CPOUI5ODATAV4-2275");

			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-2337)
				oHeaderContext.isAncestorOf(oRoot);
			}, new Error("Not currently part of a recursive hierarchy: /Artists"));
			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-2337)
				oRoot.isAncestorOf(oHeaderContext);
			}, new Error("Not currently part of a recursive hierarchy: /Artists"));
			assert.throws(() => {
				// code under test (JIRA: CPOUI5ODATAV4-2321)
				oListBinding.filter(Filter.NONE);
			}, new Error("Cannot combine Filter.NONE with $$aggregation"));
			// code under test
			assert.strictEqual(oRoot.isAncestorOf(oRoot), true, "JIRA: CPOUI5ODATAV4-2337");

			checkTable("root is leaf", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=true)"
			], [
				["", undefined, 1, "Friend #01"]
			]);
			assert.strictEqual(oListBinding.getCount(), 1, "count of nodes"); // code under test
			assert.deepEqual(oRoot.getObject(), {
					"@$ui5.node.level" : 1,
					"@odata.etag" : "etag0.0",
					ArtistID : "0",
					BestFriend : {
						ArtistID : "01",
						IsActiveEntity : true,
						Name : "Friend #01"
					},
					IsActiveEntity : true,
					_ : {
						NodeID : "0,true"
					}
				}, "technical properties have been removed");

			// code under test
			checkSelected(assert, oRoot, undefined);
			checkSelected(assert, oHeaderContext, false);

			// code under test
			oRoot.setSelected(true);
			checkSelected(assert, oRoot, true);

			assert.strictEqual(oRoot.toString(),
				"/Artists(ArtistID='0',IsActiveEntity=true)[0;selected]");

			// code under test
			oHeaderContext.setSelected(true);
			checkSelected(assert, oHeaderContext, true);

			that.expectChange("count", "1");

			// code under test
			that.oView.byId("count").setBindingContext(oHeaderContext);

			return that.waitForChanges(assert, "$count");
		}).then(function () {
			checkTable("selected root", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=true)"
			], [
				[true, undefined, 1, "Friend #01"]
			]);

			// Since CPOUI5ODATAV4-2493 selecting a header context will select all row contexts.
			// This behavior is undesired for this test scenario. Remove the selection but select
			// back the root node.
			oHeaderContext.setSelected(false);
			oRoot.setSelected(true);

			assert.strictEqual(oListBinding.getCount(), 1, "count of nodes"); // code under test

			that.expectRequest("Artists(ArtistID='0',IsActiveEntity=true)?$select=defaultChannel", {
					"@odata.etag" : "etag0.0",
					defaultChannel : "60"
				});

			return Promise.all([
				// code under test
				oRoot.requestProperty("defaultChannel"),
				// code under test
				oListBinding.requestDownloadUrl(),
				that.waitForChanges(assert, "late property")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], "60");
			assert.strictEqual(aResults[1], sExpectedDownloadUrl,
				"JIRA: CPOUI5ODATAV4-1920, CPOUI5ODATAV4-2275");

			that.expectRequest("Artists"
						+ "?$select=ArtistID,IsActiveEntity,Messages,_/NodeID,defaultChannel"
					+ "&$filter=ArtistID eq '0' and IsActiveEntity eq true", {
					value : [{
						"@odata.etag" : "etag0.1",
						ArtistID : "0",
						IsActiveEntity : true,
						Messages : [],
						_ : {
							NodeID : "0,true"
						},
						defaultChannel : "160"
					}]
				});

			return Promise.all([
				// code under test
				oRoot.requestSideEffects(["*"]),
				that.waitForChanges(assert, "side effect: * for single row")
			]);
		}).then(function () {
			assert.strictEqual(oRoot.getProperty("defaultChannel"), "160");

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,_/NodeID,defaultChannel"
					+ "&$filter=ArtistID eq '0' and IsActiveEntity eq true", {
					value : [{
						"@odata.etag" : "etag0.2",
						ArtistID : "0",
						IsActiveEntity : true,
						_ : {
							NodeID : "0,true"
						},
						defaultChannel : "260"
					}]
				});

			return Promise.all([
				// code under test
				oRoot.requestSideEffects(["defaultChannel"]),
				that.waitForChanges(assert, "side effect: defaultChannel for single row")
			]);
		}).then(function () {
			assert.strictEqual(oRoot.getProperty("defaultChannel"), "260");

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,_/NodeID"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
					+ "&$filter=ArtistID eq '0' and IsActiveEntity eq true", {
					value : [{
						"@odata.etag" : "etag0.2",
						ArtistID : "0",
						BestFriend : {
							ArtistID : "01",
							IsActiveEntity : true,
							Name : "Friend #01 (updated)"
						},
						IsActiveEntity : true,
						_ : {
							NodeID : "0,true"
						}
					}]
				});

			return Promise.all([
				// code under test
				oHeaderContext.requestSideEffects(["BestFriend/Name"]),
				that.waitForChanges(assert, "side effect: BestFriend/Name for all rows")
			]);
		}).then(function () {
			var sErrorMessage
				= 'Unexpected structural change: _/NodeID from "0,true" to "-0,true-"';

			checkTable("side effect: BestFriend/Name for all rows", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=true)"
			], [
				[true, undefined, 1, "Friend #01 (updated)"]
			]);
			assert.strictEqual(oListBinding.getCount(), 1, "count of nodes"); // code under test

			assert.throws(function () {
				// code under test (JIRA: CPOUI5ODATAV4-1851)
				oRoot.requestRefresh();
			}, new Error("Cannot refresh " + oRoot + " when using data aggregation"));

			that.expectRequest("Artists"
						+ "?$select=ArtistID,IsActiveEntity,Messages,_/NodeID,defaultChannel"
					+ "&$filter=ArtistID eq '0' and IsActiveEntity eq true", {
					value : [{
						"@odata.etag" : "etag0.3",
						ArtistID : "0",
						IsActiveEntity : true,
						Messages : [],
						_ : { // in case we get a value, we will happily check it :-)
							NodeID : "-0,true-"
						},
						defaultChannel : "360"
					}]
				})
				.expectMessages([{
					message : sErrorMessage,
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to request side effects",
					sinon.match(/Unexpected structural change: _\/NodeID/), sODLB);

			return Promise.all([
				// code under test
				oRoot.requestSideEffects(["*"])
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message, sErrorMessage);
					}),
				that.waitForChanges(assert, "side effect: * for single row w/ hierarchy change")
			]);
		}).then(function () {
			checkTable("after side effect", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=true)"
			], [
				[true, undefined, 1, "Friend #01 (updated)"]
			]);
			assert.strictEqual(oListBinding.getCount(), 1, "count of nodes"); // code under test
			assert.strictEqual(oRoot.getProperty("defaultChannel"), "260", "360 has been ignored");

			that.expectMessages([]);
			Messaging.removeAllMessages(); // clean up

			// Note: why is there no separate GET? because we have already loaded messages above!
			// that.expectRequest("Artists(ArtistID='0',IsActiveEntity=true)?$select=Messages");

			if (bKeepAlive) {
				// code under test
				oRoot.setKeepAlive(true, /*fnOnBeforeDestroy*/null, /*bRequestMessages*/true);
			} // else: implicitly keep alive due to selection

			oKeptAliveNode = oRoot;

			return that.waitForChanges(assert, "keep alive");
		}).then(function () {
			that.expectRequest({
					batchNo : 7,
					url : "Artists?$select=ArtistID,IsActiveEntity"
							+ (bKeepAlive ? ",Messages" : "") + ",defaultChannel"
						+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
						+ "&$filter=ArtistID eq '0' and IsActiveEntity eq true"
				}, {
					value : [{
						"@odata.etag" : "etag0.4",
						ArtistID : "0",
						BestFriend : {
							ArtistID : "01",
							IsActiveEntity : true,
							Name : "Friend #01 (updated again)"
						},
						IsActiveEntity : true,
						// Messages : [],
						defaultChannel : "460"
					}]
				})
				.expectRequest({
					batchNo : 7,
					url : "Artists/$count"
				}, 3)
				.expectRequest({
					batchNo : 7,
					url : "Artists?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/Artists,HierarchyQualifier='"
						+ sHierarchyQualifier + "',NodeProperty='_/NodeID',Levels=1)"
						+ "&$select=ArtistID,IsActiveEntity,_/DrillState,_/NodeID"
						+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
						+ "&$count=true&$skip=0&$top=3"
				}, {
					"@odata.count" : "1",
					value : [{
						"@odata.etag" : "etag1.0",
						ArtistID : "1",
						BestFriend : null,
						IsActiveEntity : true,
						_ : {
							DrillState : "collapsed",
							NodeID : "1,true"
						}
					}]
				})
				.expectChange("count", "3");

			return Promise.all([
				// Note: "Cannot refresh " + oRoot + " when using data aggregation"
				// code under test
				oListBinding.requestRefresh(),
				that.waitForChanges(assert, "refresh w/ kept-alive root")
			]);
		}).then(function () {
			var oError = new Error("418 I'm a teapot");

			checkTable("after refresh w/ kept-alive root", assert, oTable, [
				"/Artists(ArtistID='1',IsActiveEntity=true)",
				"/Artists(ArtistID='0',IsActiveEntity=true)"
			], [
				["", false, 1, ""]
			], 1);
			assert.strictEqual(oListBinding.getCount(), 3, "count of nodes"); // code under test
			assert.strictEqual(oListBinding.getAllCurrentContexts()[1], oKeptAliveNode,
				"still kept alive");
			assert.deepEqual(oKeptAliveNode.getObject(), {
					"@$ui5.context.isSelected" : true,
					"@odata.etag" : "etag0.4",
					ArtistID : "0",
					BestFriend : {
						ArtistID : "01",
						IsActiveEntity : true,
						Name : "Friend #01 (updated again)"
					},
					IsActiveEntity : true,
					Messages : [],
					_ : {
						NodeID : "0,true"
					},
					defaultChannel : "460"
				}, "after refresh");

			// refresh via side effect fails
			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity"
						+ (bKeepAlive ? ",Messages" : "") + ",defaultChannel"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
					+ "&$filter=ArtistID eq '0' and IsActiveEntity eq true", oError)
				.expectRequest("Artists/$count", oError)
				.expectRequest("Artists?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/Artists,HierarchyQualifier='" + sHierarchyQualifier
					+ "',NodeProperty='_/NodeID',Levels=1)"
					+ "&$select=ArtistID,IsActiveEntity,_/DrillState,_/NodeID"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
					+ "&$count=true&$skip=0&$top=3", oError)
				.expectMessages([{
					message : oError.message,
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to refresh kept-alive elements", sinon.match(oError.message),
					sODLB);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to get contexts for /special/cases/Artists with start index"
					+ " 0 and length 3", sinon.match(oError.message), sODLB);

			return Promise.all([
				// code under test
				// Note: $direct avoids "HTTP request was not processed because $batch failed"
				oHeaderContext.requestSideEffects([""], "$direct")
					.then(mustFail(assert), function (oError0) {
						assert.strictEqual(oError0, oError);
					}),
				that.waitForChanges(assert, "failed side-effects refresh w/ kept-alive node")
			]);
		}).then(function () {
			checkTable("after failed side-effects refresh w/ kept-alive node", assert, oTable, [
				"/Artists(ArtistID='1',IsActiveEntity=true)",
				"/Artists(ArtistID='0',IsActiveEntity=true)"
			], [
				["", false, 1, ""]
			], 1);
			assert.strictEqual(oListBinding.getCount(), 3, "count of nodes"); // code under test
			assert.strictEqual(oListBinding.getAllCurrentContexts()[1], oKeptAliveNode,
				"still kept alive");

			that.expectRequest("Artists?$apply=descendants($root/Artists," + sHierarchyQualifier
						+ ",_/NodeID,filter(ArtistID eq '1' and IsActiveEntity eq true),1)"
					+ "&$select=ArtistID,IsActiveEntity,_/DrillState,_/NodeID"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
					+ "&$count=true&$skip=0&$top=3", {
					"@odata.count" : "1",
					value : [{
						"@odata.etag" : "etag0.4",
						ArtistID : "0",
						BestFriend : {
							ArtistID : "01",
							IsActiveEntity : true,
							Name : "Friend #01 (updated once more)"
						},
						IsActiveEntity : true,
						_ : {
							DrillState : "collapsed",
							NodeID : "0,true"
						}
					}]
				});

			// code under test
			oListBinding.getCurrentContexts()[0].expand();

			return that.waitForChanges(assert, "expand");
		}).then(function () {
			checkTable("after expand", assert, oTable, [
				"/Artists(ArtistID='1',IsActiveEntity=true)",
				"/Artists(ArtistID='0',IsActiveEntity=true)"
			], [
				["", true, 1, ""],
				[true, false, 2, "Friend #01 (updated once more)"],
				["", "", "", ""]
			]);
			assert.strictEqual(oListBinding.getAllCurrentContexts()[1], oKeptAliveNode,
				"still kept alive");
			assert.deepEqual(oKeptAliveNode.getObject(), {
					"@$ui5.context.isSelected" : true,
					"@$ui5.node.isExpanded" : false,
					"@$ui5.node.level" : 2,
					"@odata.etag" : "etag0.4",
					ArtistID : "0",
					BestFriend : {
						ArtistID : "01",
						IsActiveEntity : true,
						Name : "Friend #01 (updated once more)"
					},
					IsActiveEntity : true,
					Messages : [],
					_ : {
						NodeID : "0,true"
					},
					defaultChannel : "460"
				}, "after expand");

			that.expectRequest({
					batchNo : 12,
					url : "Artists/$count"
				}, 3)
				.expectRequest({
					batchNo : 12,
					url : "Artists?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/Artists,HierarchyQualifier='" + sHierarchyQualifier
						+ "',NodeProperty='_/NodeID')&$select=ArtistID,IsActiveEntity"
						+ ",_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID"
						+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
						+ "&$count=true&$skip=0&$top=3"
				}, {
					"@odata.count" : "3",
					value : [{
						"@odata.etag" : "etag1.1",
						ArtistID : "1",
						BestFriend : {
							ArtistID : "01",
							IsActiveEntity : true,
							Name : "Friend #01 (no more)"
						},
						IsActiveEntity : true,
						_ : {
							DescendantCount : "2",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							NodeID : "1,true"
						}
					}, {
						"@odata.etag" : "etag0.4",
						ArtistID : "0",
						BestFriend : null,
						IsActiveEntity : true,
						_ : {
							DescendantCount : "1",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							NodeID : "0,true"
						}
					}, {
						"@odata.etag" : "etag2.0",
						ArtistID : "2",
						BestFriend : null,
						IsActiveEntity : true,
						_ : {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							NodeID : "2,true"
						}
					}]
				});

			// code under test
			// Note: overall count must not change here, just the "expansion state"
			oListBinding.setAggregation({
				expandTo : Number.MAX_SAFE_INTEGER,
				hierarchyQualifier : sHierarchyQualifier
			});

			return that.waitForChanges(assert, "expandTo");
		}).then(function () {
			checkTable("after expandTo", assert, oTable, [
				"/Artists(ArtistID='1',IsActiveEntity=true)",
				"/Artists(ArtistID='0',IsActiveEntity=true)",
				"/Artists(ArtistID='2',IsActiveEntity=true)"
			], [
				["", true, 1, "Friend #01 (no more)"],
				[true, true, 2, ""],
				["", undefined, 3, ""]
			]);
			assert.strictEqual(oListBinding.getCount(), 3, "count of nodes"); // code under test
			assert.strictEqual(oListBinding.getAllCurrentContexts()[1], oKeptAliveNode,
				"still kept alive");
			checkSelected(assert, oKeptAliveNode, true);
			assert.deepEqual(oKeptAliveNode.getObject(), {
					"@$ui5.context.isSelected" : true,
					"@$ui5.node.isExpanded" : true,
					"@$ui5.node.level" : 2,
					"@odata.etag" : "etag0.4",
					ArtistID : "0",
					BestFriend : null,
					IsActiveEntity : true,
					Messages : [],
					_ : {
						NodeID : "0,true"
					},
					defaultChannel : "460"
				}, "after expandTo");

			// no additional request for same aggregation data
			// code under test (BCP: 2370045709)
			oListBinding.setAggregation({
				expandTo : Number.MAX_SAFE_INTEGER,
				hierarchyQualifier : sHierarchyQualifier
			});
			// code under test (BCP: 2370045709)
			oListBinding.changeParameters({
				$$aggregation : {
					expandTo : Number.MAX_SAFE_INTEGER,
					hierarchyQualifier : sHierarchyQualifier
				}
			});
			assert.strictEqual(oListBinding.getAggregation().expandTo, Number.MAX_SAFE_INTEGER);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: With binding parameter $$clearSelectionOnFilter set, the selection state of a
	// hierarchy is reset on changing "$$aggregation.search" parameter. Test with "select all" and
	// with selecting two nodes explicitly.
	//
	// JIRA: CPOUI5ODATAV4-2203
	// SNOW: CS20240007001494
	QUnit.test("CPOUI5ODATAV4-2203: $$aggregation.search", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart'
			},
			$$clearSelectionOnFilter : true
		}}" threshold="0" visibleRowCount="3">
	<Text id="selected" text="{= %{@$ui5.context.isSelected} }"/>
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
</t:Table>`;
		const sUrl = "EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
			+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID'"
			+ ",Levels=1)"
			+ "&$select=DrillState,ID&$count=true&$skip=0&$top=3";
		const oResponse = {
			"@odata.count" : "2",
			value : [{
				ID : "0",
				DrillState : "leaf"
			}, {
				ID : "1",
				DrillState : "leaf"
			}]
		};

		this.expectRequest(sUrl, oResponse)
			.expectChange("selected", [undefined, undefined]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oListBinding = oTable.getBinding("rows");
		const [oNode0, oNode1] = oListBinding.getCurrentContexts();
		const oHeaderContext = oListBinding.getHeaderContext();

		this.expectChange("selected", [true, true]);

		// prepare selection
		oHeaderContext.setSelected(true);

		checkSelected(assert, oHeaderContext, true);
		checkSelected(assert, oNode0, true);
		checkSelected(assert, oNode1, true);

		this.expectChange("selected", [false, false])
			.expectRequest("EMPLOYEES?$apply="
				+ "ancestors($root/EMPLOYEES,OrgChart,ID,search(covfefe),keep start)"
				+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels("
				+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID'"
				+ ",Levels=1)"
				+ "&$select=DrillState,ID&$count=true&$skip=0&$top=3",
				oResponse)
			.expectChange("selected", [undefined, undefined]);

		// code under test
		oListBinding.setAggregation({...oListBinding.getAggregation(), search : "covfefe"});

		await this.waitForChanges(assert, "set $$aggregation.search");

		// code under test
		checkSelected(assert, oHeaderContext, false);
		checkSelected(assert, oNode0, undefined);
		checkSelected(assert, oNode1, undefined);

		this.expectChange("selected", [true, true]);

		// select two row contexts (no "select all")
		oNode0.setSelected(true);
		oNode1.setSelected(true);

		checkSelected(assert, oHeaderContext, false);
		checkSelected(assert, oNode0, true);
		checkSelected(assert, oNode1, true);

		this.expectChange("selected", [false, false])
			.expectRequest(sUrl, oResponse)
			.expectChange("selected", [undefined, undefined]);

		// code under test (search value does not matter)
		oListBinding.setAggregation({...oListBinding.getAggregation(), search : undefined});

		await this.waitForChanges(assert, "set $$aggregation.search to undefined");

		// code under test
		checkSelected(assert, oHeaderContext, false);
		checkSelected(assert, oNode0, undefined);
		checkSelected(assert, oNode1, undefined);
	});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 2. Scroll down
	// and request a side effect for all rows. Scroll up again and check that unexpected structural
	// changes are properly detected.
	// JIRA: CPOUI5ODATAV4-1849
	//
	// With RAP, NodeID is not available for side effects (BCP: 2380047659).
[ //TODO "DescendantCount"
	undefined, "ArtistID", "DistanceFromRoot", "DrillState", "IsActiveEntity", "NodeID", "order"
].forEach(function (sStructuralChange) {
	var sTitle = "Recursive Hierarchy: beforeOverwritePlaceholder; Unexpected structural change: "
			+ sStructuralChange;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oTable,
			sUrlPrefix = "Artists?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
				+ "HierarchyNodes=$root/Artists,HierarchyQualifier='OrgChart'"
				+ ",NodeProperty='_/NodeID',Levels=2)&$select=ArtistID,IsActiveEntity,Name"
				+ ",_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID",
			sView = '\
<t:Table id="table" rows="{path : \'/Artists\',\
		parameters : {\
			$$aggregation : {\
				expandTo : 2,\
				hierarchyQualifier : \'OrgChart\'\
			}\
		}}" threshold="0" visibleRowCount="2">\
	<Text text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text text="{= %{@$ui5.node.level} }"/>\
	<Text text="{ArtistID}"/>\
	<Text text="{Name}"/>\
</t:Table>',
			that = this;

		this.expectRequest(sUrlPrefix + "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "4",
				value : [{
					ArtistID : "0",
					IsActiveEntity : true,
					Name : "Alpha",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "0,true"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : true,
					Name : "Beta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "1,true"
					}
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			checkTable("initial page", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=true)",
				"/Artists(ArtistID='1',IsActiveEntity=true)"
			], [
				[true, 1, "0", "Alpha"],
				[undefined, 2, "1", "Beta"]
			], 4);

			that.expectRequest(sUrlPrefix + "&$skip=2&$top=2", {
					value : [{
						ArtistID : "2",
						IsActiveEntity : true,
						Name : "Gamma",
						_ : {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							NodeID : "2,true"
						}
					}, {
						ArtistID : "3",
						IsActiveEntity : true,
						Name : "Delta",
						_ : {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							NodeID : "3,true"
						}
					}]
				});

			// code under test
			oTable.setFirstVisibleRow(2);

			return that.waitForChanges(assert, "scroll down");
		}).then(function () {
			checkTable("initial page", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=true)",
				"/Artists(ArtistID='1',IsActiveEntity=true)",
				"/Artists(ArtistID='2',IsActiveEntity=true)",
				"/Artists(ArtistID='3',IsActiveEntity=true)"
			], [
				[undefined, 2, "2", "Gamma"],
				[undefined, 2, "3", "Delta"]
			], 4);

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name,_/NodeID"
					+ "&$filter=ArtistID eq '2' and IsActiveEntity eq true"
					+ " or ArtistID eq '3' and IsActiveEntity eq true&$top=2", {
					value : [{
						ArtistID : "2",
						IsActiveEntity : true,
						Name : "Gamma (updated)",
						_ : null // not available w/ RAP for a non-hierarchical request
					}, {
						ArtistID : "3",
						IsActiveEntity : true,
						Name : "Delta (updated)",
						_ : null // not available w/ RAP for a non-hierarchical request
					}]
				});

			return Promise.all([
				// code under test
				oTable.getBinding("rows").getHeaderContext().requestSideEffects(["Name"]),
				that.waitForChanges(assert, "side effects")
			]);
		}).then(function () {
			var oAlpha = {
					ArtistID : "0",
					IsActiveEntity : true,
					Name : "Alpha (updated)",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "0,true"
					}
				},
				oBeta = {
					ArtistID : sStructuralChange === "ArtistID" ? "-1-" : "1",
					IsActiveEntity : sStructuralChange !== "IsActiveEntity",
					Name : "Beta (updated)",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : sStructuralChange === "DistanceFromRoot" ? "2" : "1",
						DrillState : sStructuralChange === "DrillState" ? "collapsed" : "leaf",
						NodeID : sStructuralChange === "NodeID" ? "-1,true-" : "1,true"
					}
				},
				sErrorMessage = "???";

			switch (sStructuralChange) {
				case "ArtistID":
				case "IsActiveEntity":
					sErrorMessage = "Unexpected structural change: predicate";
					break;
				case "DistanceFromRoot":
				case "order":
					sErrorMessage = "Wrong placeholder";
					break;
				case "DrillState":
					sErrorMessage = "Not a leaf anymore (or vice versa)";
					break;
				case "NodeID":
					sErrorMessage
						= 'Unexpected structural change: _/NodeID from "1,true" to "-1,true-"';
				// no default
			}

			checkTable("initial page", assert, oTable, [
				"/Artists(ArtistID='2',IsActiveEntity=true)",
				"/Artists(ArtistID='3',IsActiveEntity=true)"
			], [
				[undefined, 2, "2", "Gamma (updated)"],
				[undefined, 2, "3", "Delta (updated)"]
			], 4);

			that.expectRequest(sUrlPrefix + "&$skip=0&$top=2", {
					value : sStructuralChange === "order"
					? [oBeta, oAlpha]
					: [oAlpha, oBeta]
				});
			if (sStructuralChange) {
				that.expectMessages([{
						message : sErrorMessage,
						persistent : true,
						technical : true,
						type : "Error"
					}]);
				that.oLogMock.expects("error")
					.withExactArgs("Failed to get contexts for /special/cases/Artists"
						+ " with start index 0 and length 2",
						sinon.match(sErrorMessage), sODLB);
			}

			// code under test
			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert, "scroll up");
		}).then(function () {
			if (sStructuralChange) {
				return; // no use to check state after error
			}

			checkTable("initial page", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=true)",
				"/Artists(ArtistID='1',IsActiveEntity=true)",
				"/Artists(ArtistID='2',IsActiveEntity=true)",
				"/Artists(ArtistID='3',IsActiveEntity=true)"
			], [
				[true, 1, "0", "Alpha (updated)"],
				[undefined, 2, "1", "Beta (updated)"]
			], 4);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Show a recursive hierarchy with a single root node, expand to show a single child.
	// Edit non-hierarchy property with associated currency, also w/o sending a PATCH, for both root
	// and child. Invoke a bound action for both root and child to see that it updates the node.
	// JIRA: CPOUI5ODATAV4-1851
	//
	// Use relative ODLB with an initially suspended parent (JIRA: CPOUI5ODATAV4-1985 etc.)
	// Additionally, ODLB#getDownloadUrl is tested (JIRA: CPOUI5ODATAV4-1920. BCP: 2370011296).
	// #setAggregation before resolving the ODLB (JIRA: CPOUI5ODATAV4-2408)
	//
	// Ensure that a Return Value Context is created and the structure of the path is same like the
	// binding parameter
	// JIRA: CPOUI5ODATAV4-2096
	QUnit.test("Recursive Hierarchy: edit w/ currency", function (assert) {
		var sAction = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
			oChild,
			oChildAmountBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oRoot,
			oRootAmountBinding,
			oTable,
			sView = '\
<FlexBox id="form" binding="{path : \'/TEAMS(\\\'42\\\')\', suspended : true}" />\
<t:Table id="table" rows="{TEAM_2_EMPLOYEES}" threshold="0" visibleRowCount="2">\
	<Text text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text text="{= %{@$ui5.node.level} }"/>\
	<Text text="{ID}"/>\
	<Text text="{MANAGER_ID}"/>\
	<Input value="{SALARY/YEARLY_BONUS_AMOUNT}"/>\
	<Text text="{SALARY/BONUS_CURR}"/>\
	<Text text="{TEAM_ID}"/>\
</t:Table>',
			that = this;

		return this.createView(assert, sView, oModel).then(function () {
			var oContextBinding = that.oView.byId("form").getObjectBinding();

			oTable = that.oView.byId("table");

			that.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES"
					+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/TEAMS('42')/TEAM_2_EMPLOYEES"
						+ ",HierarchyQualifier='OrgChart',NodeProperty='ID',Levels=1)"
					+ "&$select=DrillState,ID,MANAGER_ID,SALARY/BONUS_CURR"
						+ ",SALARY/YEARLY_BONUS_AMOUNT,TEAM_ID"
					+ "&$count=true&$skip=0&$top=2", {
					"@odata.count" : "1",
					value : [{
						DrillState : "collapsed",
						ID : "0",
						MANAGER_ID : null,
						SALARY : {
							BONUS_CURR : "EUR",
							YEARLY_BONUS_AMOUNT : "1234"
						},
						TEAM_ID : "TEAM_0"
					}]
				});

			const oBinding = oTable.getBinding("rows");
			// code under test (JIRA: CPOUI5ODATAV4-2408)
			oBinding.setAggregation({hierarchyQualifier : "OrgChart"});
			oBinding.setContext(oContextBinding.getBoundContext());

			return Promise.all([
				oContextBinding.resumeAsync(), // Note: resume*Async* makes a big difference
				that.waitForChanges(assert, "setContext, resume")
			]);
		}).then(function () {
			oRootAmountBinding = oTable.getRows()[0].getCells()[4].getBinding("value");
			oRoot = oRootAmountBinding.getContext();

			checkTable("root is collapsed", assert, oTable, [
				"/TEAMS('42')/TEAM_2_EMPLOYEES('0')"
			], [
				[false, 1, "0", "", "1,234", "EUR", "TEAM_0"]
			]);

			// code under test
			assert.strictEqual(oRoot.getBinding().getDownloadUrl(),
				sTeaBusi + "TEAMS('42')/TEAM_2_EMPLOYEES"
				+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/TEAMS('42')/TEAM_2_EMPLOYEES"
					+ ",HierarchyQualifier='OrgChart',NodeProperty='ID')"
				+ "&$select=DistanceFromRoot,DrillState,ID,MANAGER_ID,SALARY/BONUS_CURR"
					+ ",SALARY/YEARLY_BONUS_AMOUNT,TEAM_ID",
				"JIRA: CPOUI5ODATAV4-1920, CPOUI5ODATAV4-2275");

			that.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES"
					+ "?$apply=descendants($root/TEAMS('42')/TEAM_2_EMPLOYEES,OrgChart,ID"
						+ ",filter(ID eq '0'),1)"
					+ "&$select=DrillState,ID,MANAGER_ID,SALARY/BONUS_CURR"
						+ ",SALARY/YEARLY_BONUS_AMOUNT,TEAM_ID"
					+ "&$count=true&$skip=0&$top=2", {
					"@odata.count" : "1",
					value : [{
						DrillState : "leaf",
						ID : "1",
						MANAGER_ID : "0",
						SALARY : {
							BONUS_CURR : "DEM",
							YEARLY_BONUS_AMOUNT : "500"
						},
						TEAM_ID : "TEAM_1"
					}]
				});

			oRoot.expand();

			return that.waitForChanges(assert, "expand");
		}).then(function () {
			oChildAmountBinding = oTable.getRows()[1].getCells()[4].getBinding("value");
			oChild = oChildAmountBinding.getContext();

			checkTable("root is expanded", assert, oTable, [
				"/TEAMS('42')/TEAM_2_EMPLOYEES('0')",
				"/TEAMS('42')/TEAM_2_EMPLOYEES('1')"
			], [
				[true, 1, "0", "", "1,234", "EUR", "TEAM_0"],
				[undefined, 2, "1", "0", "500", "DEM", "TEAM_1"]
			]);

			that.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('0')",
					payload : {
						SALARY : {
							BONUS_CURR : "EUR",
							YEARLY_BONUS_AMOUNT : "2345"
						}
					}
				}) // 204 No Content
				.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('1')",
					payload : {
						SALARY : {
							BONUS_CURR : "DEM",
							YEARLY_BONUS_AMOUNT : "700"
						}
					}
				}); // 204 No Content

			// code under test
			oRootAmountBinding.setValue("2345");
			oChildAmountBinding.setValue("700");

			return that.waitForChanges(assert, "PATCH");
		}).then(function () {
			checkTable("after editing", assert, oTable, [
				"/TEAMS('42')/TEAM_2_EMPLOYEES('0')",
				"/TEAMS('42')/TEAM_2_EMPLOYEES('1')"
			], [
				[true, 1, "0", "", "2,345", "EUR", "TEAM_0"],
				[undefined, 2, "1", "0", "700", "DEM", "TEAM_1"]
			]);

			// code under test
			oRoot.setProperty("SALARY/YEARLY_BONUS_AMOUNT", "3456", null);
			oChild.setProperty("SALARY/YEARLY_BONUS_AMOUNT", "900", null);

			assert.strictEqual(oRootAmountBinding.getValue(), "3456");
			assert.strictEqual(oChildAmountBinding.getValue(), "900");

			that.expectRequest({
					method : "POST",
					url : "TEAMS('42')/TEAM_2_EMPLOYEES('0')/" + sAction
						+ "?$expand=EMPLOYEE_2_TEAM($select=Team_Id)",
					payload : {TeamID : "TEAM_23"}
				}, {
					EMPLOYEE_2_TEAM : {
						Team_Id : "23"
					},
					ID : "0",
					MANAGER_ID : null,
					SALARY : { // "side effect"
						BONUS_CURR : "GBP",
						YEARLY_BONUS_AMOUNT : "23.23"
					},
					TEAM_ID : "23" // "side effect"
				})
				.expectRequest({
					method : "POST",
					url : "TEAMS('42')/TEAM_2_EMPLOYEES('1')/" + sAction
						+ "?$expand=EMPLOYEE_2_TEAM($select=Team_Id)",
					payload : {TeamID : "TEAM_42"}
				}, {
					EMPLOYEE_2_TEAM : {
						Team_Id : "42"
					},
					ID : "1",
					MANAGER_ID : "0",
					SALARY : { // "side effect"
						BONUS_CURR : "USD",
						YEARLY_BONUS_AMOUNT : "42.42"
					},
					TEAM_ID : "42" // "side effect"
				});

			return Promise.all([
				oModel.bindContext(sAction + "(...)", oRoot)
					.setParameter("TeamID", "TEAM_23")
					.invoke()
					.then(function (oReturnValueContext) {
						assert.strictEqual(oRoot.getPath(),
							"/TEAMS('42')/TEAM_2_EMPLOYEES('0')");
						assert.strictEqual(oReturnValueContext.getPath(),
							"/TEAMS('23')/TEAM_2_EMPLOYEES('0')");
					}),
				oModel.bindContext(sAction + "(...)", oChild)
					.setParameter("TeamID", "TEAM_42")
					.invoke()
					.then(function (oReturnValueContext) {
						// Note: RVC has iGeneration === 2 instead of 0
						assert.notStrictEqual(oReturnValueContext, oChild);
						assert.strictEqual(oChild.getPath(),
							"/TEAMS('42')/TEAM_2_EMPLOYEES('1')");
						assert.strictEqual(oReturnValueContext.getPath(),
							"/TEAMS('42')/TEAM_2_EMPLOYEES('1')");
					}),
				that.waitForChanges(assert, "action")
			]);
		}).then(function () {
			checkTable("after action", assert, oTable, [
				"/TEAMS('42')/TEAM_2_EMPLOYEES('0')",
				"/TEAMS('42')/TEAM_2_EMPLOYEES('1')"
			], [
				[true, 1, "0", "", "23.23", "GBP", "23"],
				[undefined, 2, "1", "0", "42.42", "USD", "42"]
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 2; first visible
	// row starts at 1 and then we scroll up. Collapse and expand the root node. Expand an initially
	// collapsed node. Scroll to the end and collapse the root node again.
	// JIRA: CPOUI5ODATAV4-1643
	//
	// Use a sort order (JIRA: CPOUI5ODATAV4-1675).
	// Edit name as a non-hierarchy property (JIRA: CPOUI5ODATAV4-1742).
	//
	// Request a side effect for a single row that does not affect the hierarchy.
	// JIRA: CPOUI5ODATAV4-1785
	//
	// Use $count (JIRA: CPOUI5ODATAV4-1855).
	//
	// Additionally ODLB#getDownloadUrl is tested w/ sort.
	// JIRA: CPOUI5ODATAV4-1920
	// BCP: 2370011296
	//
	// While the root node 0 (Alpha) is still collapsed, a new root 9 (Aleph) is created and a side
	// effect for all rows (within the same $batch, JIRA: CPOUI5ODATAV4-2380) turns spliced nodes
	// into placeholders. Then 0 (Alpha) is expanded again and we scroll down to check that
	// placeholders still cause proper requests w.r.t. indices.
	// JIRA: CPOUI5ODATAV4-2355
	//
	// Use LimitedRank after #create (JIRA: CPOUI5ODATAV4-2430)
	QUnit.test("Recursive Hierarchy: expand to 2, collapse & expand root etc.", function (assert) {
		var oCollapsed,
			oListBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oNewRoot,
			oRoot,
			oTable,
			sTopLevelsUrl = "EMPLOYEES?$apply=orderby(AGE desc)"
				+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
					+ ",HierarchyQualifier='OrgChart',NodeProperty='ID',Levels=2)",
			sTopLevelsSelectUrl = sTopLevelsUrl
				+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name",
			sView = '\
<Text id="count" text="{$count}"/>\
<t:Table firstVisibleRow="1" id="table" rows="{path : \'/EMPLOYEES\',\
		parameters : {\
			$$aggregation : {\
				expandTo : 2,\
				hierarchyQualifier : \'OrgChart\'\
			},\
			$$patchWithoutSideEffects : true,\
			$count : true,\
			$orderby : \'AGE desc\'\
		}}" threshold="0" visibleRowCount="3">\
	<Text text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text text="{= %{@$ui5.node.level} }"/>\
	<Text text="{ID}"/>\
	<Text text="{MANAGER_ID}"/>\
	<Input value="{Name}"/>\
	<Text text="{AGE}"/>\
</t:Table>',
			that = this;

		// 0 Alpha
		//   1 Beta (initially collapsed)
		//     1.1 Gamma
		//     1.2 Zeta
		//   2 Kappa
		//   3 Lambda
		//   4 Mu
		//   5 Xi
		// 9 Aleph (created later)
		this.expectRequest({
				batchNo : 1,
				url : "EMPLOYEES/$count"
			}, 24)
			.expectRequest({
				batchNo : 1,
				url : sTopLevelsSelectUrl + "&$count=true&$skip=1&$top=3"
			}, {
				"@odata.count" : "6",
				value : [{
					AGE : 55,
					DescendantCount : "0", // Edm.Int64
					DistanceFromRoot : "1", // Edm.Int64
					DrillState : "collapsed",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					"@odata.etag" : "etag_kappa",
					AGE : 56,
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					MANAGER_ID : "0",
					Name : "Kappa"
				}, {
					AGE : 57,
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					MANAGER_ID : "0",
					Name : "Lambda"
				}]
			})
			.expectChange("count");

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("rows");

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				expandTo : 2,
				hierarchyQualifier : "OrgChart"
			}, "JIRA: CPOUI5ODATAV4-1825");

			checkTable("initial page", assert, oTable, [
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[false, 2, "1", "0", "Beta", 55],
				[undefined, 2, "2", "0", "Kappa", 56],
				[undefined, 2, "3", "0", "Lambda", 57]
			], 6); // Note: length is not count
			assert.strictEqual(oListBinding.getCount(), 24, "count of nodes"); // code under test
			assert.deepEqual(oTable.getRows()[1].getBindingContext().getObject(), {
					"@odata.etag" : "etag_kappa",
					// "@$ui5.node.isExpanded" : undefined, // lost by _Helper.publicClone?!
					"@$ui5.node.level" : 2,
					AGE : 56,
					ID : "2",
					MANAGER_ID : "0",
					Name : "Kappa"
				}, "technical properties have been removed");

			// code under test
			assert.strictEqual(oListBinding.getDownloadUrl(), sTeaBusi + "EMPLOYEES"
				+ "?$apply=orderby(AGE%20desc)"
				+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
					+ ",HierarchyQualifier='OrgChart',NodeProperty='ID')"
				+ "&$select=AGE,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name",
				"JIRA: CPOUI5ODATAV4-1920, CPOUI5ODATAV4-2275");

			that.expectChange("count", "24");

			// code under test
			that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());

			return that.waitForChanges(assert, "$count");
		}).then(function () {
			that.expectRequest(sTopLevelsSelectUrl + "&$skip=0&$top=1", {
					value : [{
						AGE : 60,
						DescendantCount : "5",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						ID : "0",
						MANAGER_ID : null,
						Name : "Alpha"
					}]
				});

			// code under test
			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert, "scroll up");
		}).then(function () {
			var oNameBinding;

			oRoot = oTable.getRows()[0].getBindingContext();

			checkTable("scrolled up", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[false, 2, "1", "0", "Beta", 55],
				[undefined, 2, "2", "0", "Kappa", 56]
			], 6);
			assert.deepEqual(oRoot.getObject(), {
					"@$ui5.node.isExpanded" : true,
					"@$ui5.node.level" : 1,
					AGE : 60,
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, "technical properties have been removed");

			that.expectRequest({
					batchNo : 3,
					method : "PATCH",
					headers : {
						"If-Match" : "etag_kappa",
						Prefer : "return=minimal"
					},
					url : "EMPLOYEES('2')",
					payload : {Name : " (Kappa)"}
				}) // 204 No Content
				.expectRequest({
					batchNo : 3,
					url : "EMPLOYEES?$select=AGE,ID,Name&$filter=ID eq '2'"
				}, {
					value : [{
						AGE : 66, // artificial side effect
						ID : "2",
						Name : "Kappa: "
					}]
				});

			oNameBinding = oTable.getRows()[2].getCells()[4].getBinding("value");
			// code under test
			oNameBinding.setValue(" (Kappa)");

			return Promise.all([
				// code under test
				oNameBinding.getContext().requestSideEffects(["AGE", "Name"]),
				that.waitForChanges(assert, "edit Kappa w/ side effects")
			]);
		}).then(function () {
			checkTable("edit Kappa w/ side effects", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[false, 2, "1", "0", "Beta", 55],
				[undefined, 2, "2", "0", "Kappa: ", 66]
			], 6);

			// code under test
			oRoot.collapse();

			return that.waitForChanges(assert, "collapse root");
		}).then(function () {
			checkTable("root collapsed", assert, oTable, [
				"/EMPLOYEES('0')"
			], [
				[false, 1, "0", "", "Alpha", 60]
			]);

			// code under test
			assert.strictEqual(oListBinding.getCount(), 24);

			// code under test
			oRoot.expand();

			return that.waitForChanges(assert, "expand root");
		}).then(function () {
			checkTable("root expanded", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[false, 2, "1", "0", "Beta", 55],
				[undefined, 2, "2", "0", "Kappa: ", 66]
			], 6);
			oCollapsed = oTable.getRows()[1].getBindingContext();

			that.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
					+ "/orderby(AGE desc)"
					+ "&$select=AGE,DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=3", {
					"@odata.count" : "2",
					value : [{
						AGE : 41,
						DrillState : "collapsed",
						ID : "1.1",
						MANAGER_ID : "1",
						Name : "Gamma"
					}, {
						AGE : 42,
						DrillState : "collapsed",
						ID : "1.2",
						MANAGER_ID : "1",
						Name : "Zeta"
					}]
				});

			// code under test
			oCollapsed.expand();

			return that.waitForChanges(assert, "expand initially collapsed node");
		}).then(function () {
			checkTable("initially collapsed node expanded", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.2')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[true, 2, "1", "0", "Beta", 55],
				[false, 3, "1.1", "1", "Gamma", 41]
			], 8);
			assert.deepEqual(oCollapsed.getObject(), {
					"@$ui5.node.groupLevelCount" : 2,
					"@$ui5.node.isExpanded" : true,
					"@$ui5.node.level" : 2,
					AGE : 55,
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, "technical properties have been removed");

			that.expectRequest(sTopLevelsSelectUrl + "&$skip=4&$top=2", {
					value : [{
						AGE : 58,
						DescendantCount : "0", // Note: this is LimitedDescendantCountProperty!
						DistanceFromRoot : "1",
						DrillState : "collapsed",
						ID : "4",
						MANAGER_ID : "0",
						Name : "Mu"
					}, {
						AGE : 59,
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "collapsed",
						ID : "5",
						MANAGER_ID : "0",
						Name : "Xi"
					}]
				});

			// code under test
			oTable.setFirstVisibleRow(5);

			return that.waitForChanges(assert, "scroll to the end");
		}).then(function () {
			checkTable("scroll to the end", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.2')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('5')"
			], [
				[undefined, 2, "3", "0", "Lambda", 57],
				[false, 2, "4", "0", "Mu", 58],
				[false, 2, "5", "0", "Xi", 59]
			]);

			// code under test
			oRoot.collapse();

			return Promise.all([
				resolveLater(undefined, 0), // table update takes a moment
				that.waitForChanges(assert, "collapse root again")
			]);
		}).then(function () {
			checkTable("root collapsed", assert, oTable, [
				"/EMPLOYEES('0')"
			], [
				[false, 1, "0", "", "Alpha", 60]
			]);

			that.expectRequest({
					batchNo : 6,
					method : "POST",
					url : "EMPLOYEES",
					payload : {
						// not needed: "EMPLOYEE_2_MANAGER@odata.bind" : null,
						AGE : 99,
						Name : "Aleph"
					}
				}, {
					AGE : 199, // side effect
					ID : "9",
					MANAGER_ID : null,
					Name : "Aleph: " // side effect
				})
				.expectRequest({
					batchNo : 6,
					url : "EMPLOYEES?$select=AGE,ID&$filter=ID eq '0'"
				}, {
					value : [{
						AGE : 160,
						ID : "0"
					}]
				})
				.expectRequest({
					batchNo : 7,
					url : sTopLevelsUrl + "&$filter=ID eq '9'&$select=LimitedRank"
				}, {
					value : [{
						ID : "9",
						LimitedRank : "6" // Edm.Int64
					}]
				});

			// code under test (JIRA: CPOUI5ODATAV4-2355)
			oNewRoot = oListBinding.create({AGE : 99, Name : "Aleph"}, /*bSkipRefresh*/true);

			assert.strictEqual(oNewRoot.getIndex(), 0);

			return Promise.all([
				oNewRoot.created(),
				// code under test
				oListBinding.getHeaderContext().requestSideEffects(["AGE"]),
				that.waitForChanges(assert, "create new root, side effect: AGE for all rows")
			]);
		}).then(function () {
			checkTable("new root created, after side effect: AGE for all rows", assert, oTable, [
				"/EMPLOYEES('9')",
				"/EMPLOYEES('0')"
			], [
				[undefined, 1, "9", "", "Aleph: ", 199],
				[false, 1, "0", "", "Alpha", 160]
			]);
			checkCreatedPersisted(assert, oNewRoot);

			that.expectRequest(sTopLevelsSelectUrl + "&$skip=1&$top=1", {
					value : [{
						AGE : 155,
						DescendantCount : "0", // Edm.Int64
						DistanceFromRoot : "1", // Edm.Int64
						DrillState : "collapsed", // Note: overridden by client-side tree state!
						ID : "1",
						MANAGER_ID : "0",
						Name : "Beta"
					}]
				});

			// code under test
			oRoot.expand();

			return that.waitForChanges(assert, "expand 0 (Alpha) again");
		}).then(function () {
			checkTable("after expand 0 (Alpha) again", assert, oTable, [
				"/EMPLOYEES('9')",
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')"
			], [
				[undefined, 1, "9", "", "Aleph: ", 199],
				[true, 1, "0", "", "Alpha", 160],
				[true, 2, "1", "0", "Beta", 155]
			], 9);

			that.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
					+ "/orderby(AGE desc)"
					+ "&$select=AGE,DrillState,ID,MANAGER_ID,Name&$skip=0&$top=2", {
					value : [{
						AGE : 141,
						DrillState : "collapsed",
						ID : "1.1",
						MANAGER_ID : "1",
						Name : "Gamma"
					}, {
						AGE : 142,
						DrillState : "collapsed",
						ID : "1.2",
						MANAGER_ID : "1",
						Name : "Zeta"
					}]
				})
				.expectRequest(sTopLevelsSelectUrl + "&$skip=2&$top=1", {
					value : [{
						AGE : 166,
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						MANAGER_ID : "0",
						Name : "Kappa: "
					}]
				});

			// code under test
			oTable.setFirstVisibleRow(3);

			return that.waitForChanges(assert, "scroll down");
		}).then(function () {
			checkTable("after scroll down", assert, oTable, [
				"/EMPLOYEES('9')",
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.2')",
				"/EMPLOYEES('2')"
			], [
				[false, 3, "1.1", "1", "Gamma", 141],
				[false, 3, "1.2", "1", "Zeta", 142],
				[undefined, 2, "2", "0", "Kappa: ", 166]
			], 9);
		});
	});

	//*********************************************************************************************
	// Scenario: A list with $$getKeepAliveContext would show the top pyramid of a recursive
	// hierarchy, expanded to level 2, but is initially suspended or unresolved.
	// ODataModel#getKeepAliveContext is used to show more properties in a form. The list merges
	// this entity later when requesting nodes. The property MANAGER_ID is only used in the list,
	// AGE and ROOM_ID only in the form, and Name is used in both.
	// JIRA: CPOUI5ODATAV4-2030
	//
	// Note: This currently does not work with a t:Table!
	// @see QUnit.skip("ODLB: resume/refresh/filter w/ submitBatch on a t:Table"
	//
	// #setAggregation before resolving the ODLB (JIRA: CPOUI5ODATAV4-2408)
[false, true].forEach(function (bSuspended) {
	var sTitle = "Recursive Hierarchy: getKeepAliveContext, suspended = " + bSuspended;

	QUnit.test(sTitle, function (assert) {
		var oContext,
			oListBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="list" growing="true" growingThreshold="3" items="{\
		parameters : {$$getKeepAliveContext : true, $$ownRequest : true},\
		path : \'' + (bSuspended ? "/" : "") + "EMPLOYEES',\
		suspended : " + bSuspended + '}">\
	<Text text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text text="{= %{@$ui5.node.level} }"/>\
	<Text text="{ID}"/>\
	<Text text="{MANAGER_ID}"/>\
	<Text text="{Name}"/>\
</Table>\
<FlexBox id="form">\
	<Text id="age" text="{AGE}"/>\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("age")
			.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("list");
			oListBinding = oTable.getBinding("items");

			that.expectRequest({
					groupId : "$auto.heroes",
					url : "EMPLOYEES('3')"
						+ "?$select=AGE,ID,Name,ROOM_ID,__CT__FAKE__Message/__FAKE__Messages"
				}, {
					"@odata.etag" : "etag3",
					AGE : 57,
					ID : "3",
					ROOM_ID : "3.0",
					Name : "Lambda",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							message : "You're looking younger than ever!",
							numericSeverity : 2,
							target : "AGE",
							transition : false
						}]
					}
				})
				.expectChange("age", "57")
				.expectChange("name", "Lambda")
				.expectMessages([{
					message : "You're looking younger than ever!",
					persistent : false,
					target : "/EMPLOYEES('3')/AGE",
					type : "Information"
				}]);

			// code under test
			oContext = oModel.getKeepAliveContext("/EMPLOYEES('3')", /*bRequestMessages*/true,
				{$$groupId : "$auto.heroes"});

			that.oView.byId("form").setBindingContext(oContext);

			return Promise.all([
				oContext.requestProperty("ROOM_ID"), // addt'l GET to be merged
				that.waitForChanges(assert, "show form")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], "3.0", "ROOM_ID");

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=2)"
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$count=true&$skip=0&$top=3", {
					"@odata.count" : "3",
					value : [{
						"@odata.etag" : "etag1",
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "collapsed",
						ID : "1",
						MANAGER_ID : "0",
						Name : "Beta"
					}, {
						"@odata.etag" : "etag2",
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						MANAGER_ID : "0",
						Name : "Kappa"
					}, {
						"@odata.etag" : "etag3",
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "3",
						MANAGER_ID : "0",
						Name : "Lambda"
					}]
				});

			// code under test (JIRA: CPOUI5ODATAV4-2408)
			oListBinding.setAggregation({expandTo : 2, hierarchyQualifier : "OrgChart"});

			if (bSuspended) {
				// code under test
				oListBinding.resume();
			} else {
				// code under test
				oListBinding.setContext(oModel.createBindingContext("/"));
			}

			return that.waitForChanges(assert, "request nodes");
		}).then(function () {
			checkTable("after request nodes", assert, oTable, [
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[false, 2, "1", "0", "Beta"],
				[undefined, 2, "2", "0", "Kappa"],
				[undefined, 2, "3", "0", "Lambda"]
			]);
			assert.strictEqual(oListBinding.getAllCurrentContexts()[2], oContext, "reused");
			assert.strictEqual(oContext.isKeepAlive(), true, "still kept alive");
			assert.deepEqual(oContext.getObject(), {
					"@odata.etag" : "etag3",
					// "@$ui5.node.isExpanded" : undefined,
					"@$ui5.node.level" : 2,
					AGE : 57,
					ID : "3",
					MANAGER_ID : "0",
					Name : "Lambda",
					ROOM_ID : "3.0",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							message : "You're looking younger than ever!",
							numericSeverity : 2,
							target : "AGE",
							transition : false
						}]
					}
				}, "merged");

			//TODO what a stupid request :-(
			that.expectRequest("EMPLOYEES('5')?$select=ID", {
					ID : "5"
				});

			// code under test
			oModel.getKeepAliveContext("/EMPLOYEES('5')");

			return that.waitForChanges(assert, "ODLB#getKeepAliveContext");
		});
	});
});

	//*********************************************************************************************
	// Scenario: Show the single root node of a recursive hierarchy and expand it. Use a filter and
	// a search as well as a sort order.
	// JIRA: CPOUI5ODATAV4-1675
	//
	// Use $count w/ $direct (JIRA: CPOUI5ODATAV4-1855).
	//
	// Additionally ODLB#getDownloadUrl is tested w/ filter/sort.
	// JIRA: CPOUI5ODATAV4-1920
	// BCP: 2370011296
	//
	// Use a filter with spaces (BCP: 2380032202).
	// Check prefetch for expand (JIRA: CPOUI5ODATAV4-2432)
	QUnit.test("Recursive Hierarchy: expand root, w/ filter, search & orderby", function (assert) {
		var oModel = this.createTeaBusiModel123({autoExpandSelect : true, groupId : "$direct"}),
			oTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<t:Table id="table" rows="{path : \'/EMPLOYEES\',\
		filters : {path : \'AGE\', operator : \'GE\', value1 : 0},\
		parameters : {\
			$$aggregation : {\
				hierarchyQualifier : \'OrgChart\',\
				search : \'covfefe\'\
			},\
			$count : true,\
			$filter : \'Is_Manager\',\
			$orderby : \'AGE desc\'\
		}}" threshold="4" visibleRowCount="2">\
	<Text id="id" text="{ID}"/>\
</t:Table>',
			that = this;

		this.expectRequest("EMPLOYEES/$count?sap-client=123&$filter=AGE ge 0 and (Is_Manager)"
				+ "&$search=covfefe", 2)
			.expectRequest("EMPLOYEES?sap-client=123&$apply=ancestors($root/EMPLOYEES,OrgChart,ID"
				+ ",filter(AGE ge 0 and (Is_Manager))/search(covfefe),keep start)"
				+ "/orderby(AGE desc)/com.sap.vocabularies.Hierarchy.v1.TopLevels("
				+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID'"
				+ ",Levels=1)&$select=DrillState,ID&$count=true&$skip=0&$top=6", {
				"@odata.count" : "1",
				value : [{
					DrillState : "collapsed",
					ID : "0"
				}]
			})
			.expectChange("count")
			.expectChange("id", ["0"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oListBinding;

			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("rows");

			assert.strictEqual(oListBinding.getCount(), 2, "count of nodes"); // code under test

			// code under test
			assert.strictEqual(oListBinding.getDownloadUrl(), sTeaBusi + "EMPLOYEES?sap-client=123"
				+ "&$apply=ancestors($root/EMPLOYEES,OrgChart,ID"
					+ ",filter(AGE%20ge%200%20and%20(Is_Manager))/search(covfefe),keep%20start)"
				+ "/orderby(AGE%20desc)"
				+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
					+ ",HierarchyQualifier='OrgChart',NodeProperty='ID')"
				+ "&$select=DistanceFromRoot,DrillState,ID",
				"JIRA: CPOUI5ODATAV4-1920, CPOUI5ODATAV4-2275");

			that.expectChange("count", "2");

			 // code under test
			that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());

			return that.waitForChanges(assert, "$count");
		}).then(function () {
			var oRoot = oTable.getRows()[0].getBindingContext();

			that.expectRequest("EMPLOYEES?sap-client=123"
					+ "&$apply=ancestors($root/EMPLOYEES,OrgChart,ID"
					+ ",filter(AGE ge 0 and (Is_Manager))/search(covfefe),keep start)"
					+ "/descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
					+ "/orderby(AGE desc)"
					+ "&$select=DrillState,ID&$count=true&$skip=0&$top=6", {
					"@odata.count" : "2",
					value : [
						{DrillState : "leaf", ID : "1"},
						{DrillState : "leaf", ID : "2"}
					]
				})
				.expectChange("id", [, "1"]);

			// code under test
			oRoot.expand();

			return that.waitForChanges(assert, "expand root");
		}).then(function () {
			that.expectChange("id", [, "1", "2"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert, "scroll down");
		});
	});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 3. Collapse nested
	// initially expanded nodes 1 (Beta) and 0 (Alpha). See that an additional root node becomes
	// visible!
	// JIRA: CPOUI5ODATAV4-1743
	//
	// Create new child and cancel immediately via deletion (JIRA: CPOUI5ODATAV4-2359)
	//
	// While the root node 0 (Alpha) is still collapsed, a new root (Beth) is created; a side effect
	// for all rows turns spliced nodes into placeholders, then 0 (Alpha) is expanded again to check
	// that placeholders still cause proper requests w.r.t. indices.
	// JIRA: CPOUI5ODATAV4-2355
	//
	// A new child (Gimel) for 0 (Alpha) is created, then 0 (Alpha) is collapsed again to check
	// that the internal "limited descendant count" has been updated correctly. Finally, 0 (Alpha)
	// is expanded again to check that internal "rank" handling is correct.
	// JIRA: CPOUI5ODATAV4-2359
	//
	// Use LimitedRank after #create (JIRA: CPOUI5ODATAV4-2430)
	QUnit.test("Recursive Hierarchy: collapse nested initially expanded nodes", function (assert) {
		var oAlpha,
			oBeta,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oNewChild,
			oNewRoot,
			oTable,
			sTopLevelsUrl = "EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
				+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
				+ ",NodeProperty='ID',Levels=3)",
			sTopLevelsSelectUrl = sTopLevelsUrl
				+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name",
			sView = '\
<t:Table id="table" rows="{path : \'/EMPLOYEES\',\
		parameters : {\
			$$aggregation : {\
				expandTo : 3,\
				hierarchyQualifier : \'OrgChart\'\
			}\
		}}" threshold="0" visibleRowCount="5">\
	<Text text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text text="{= %{@$ui5.node.level} }"/>\
	<Text text="{ID}"/>\
	<Text text="{MANAGER_ID}"/>\
	<Input value="{Name}"/>\
	<Text text="{AGE}"/>\
</t:Table>',
			that = this;

		// B Beth (created later)
		// 0 Alpha
		//   1 Beta
		//     1.1 Gamma
		//     1.2 Zeta
		//   C Gimel (created later)
		//   2 Kappa
		//   3 Lambda
		//   4 Mu
		//     4.1 Nu
		//   5 Xi
		//     5.1 Omicron
		// 9 Aleph
		this.expectRequest(sTopLevelsSelectUrl + "&$count=true&$skip=0&$top=5", {
				"@odata.count" : "11",
				value : [{
					AGE : 60,
					DescendantCount : "9", // Edm.Int64
					DistanceFromRoot : "0", // Edm.Int64
					DrillState : "expanded",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					AGE : 55,
					DescendantCount : "2",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					AGE : 41,
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "collapsed",
					ID : "1.1",
					MANAGER_ID : "1",
					Name : "Gamma"
				}, {
					AGE : 42,
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "collapsed",
					ID : "1.2",
					MANAGER_ID : "1",
					Name : "Zeta"
				}, {
					AGE : 56,
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					MANAGER_ID : "0",
					Name : "Kappa"
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oAlpha = oTable.getRows()[0].getBindingContext();
			assert.strictEqual(oAlpha.getProperty("Name"), "Alpha");
			oBeta = oTable.getRows()[1].getBindingContext();
			assert.strictEqual(oBeta.getProperty("Name"), "Beta");

			checkTable("initial page", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.2')",
				"/EMPLOYEES('2')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[true, 2, "1", "0", "Beta", 55],
				[false, 3, "1.1", "1", "Gamma", 41],
				[false, 3, "1.2", "1", "Zeta", 42],
				[undefined, 2, "2", "0", "Kappa", 56]
			], 11);

			// code under test (JIRA: CPOUI5ODATAV4-2359)
			const oLostChild = oAlpha.getBinding().create({
				"@$ui5.node.parent" : oAlpha,
				Name : "n/a"
			}, /*bSkipRefresh*/true);
			const oDeletePromise = oLostChild.delete();

			that.expectRequest(sTopLevelsSelectUrl + "&$skip=5&$top=2", {
					value : [{
						AGE : 57,
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "3",
						MANAGER_ID : "0",
						Name : "Lambda"
					}, {
						AGE : 58,
						DescendantCount : "2",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						ID : "4",
						MANAGER_ID : "0",
						Name : "Mu"
					}]
				});

			oBeta.collapse();

			return Promise.all([
				checkCanceled(assert, oLostChild.created()),
				oDeletePromise,
				that.waitForChanges(assert, "collapse 1 (Beta)")
			]);
		}).then(function () {
			checkTable("after collapse 1 (Beta) ", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[false, 2, "1", "0", "Beta", 55],
				[undefined, 2, "2", "0", "Kappa", 56],
				[undefined, 2, "3", "0", "Lambda", 57],
				[true, 2, "4", "0", "Mu", 58]
			], 9);

			that.expectRequest(sTopLevelsSelectUrl + "&$skip=10&$top=1", {
					value : [{
						AGE : 69,
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						ID : "9",
						MANAGER_ID : null,
						Name : "Aleph"
					}]
				});

			oAlpha.collapse();

			return that.waitForChanges(assert, "collapse 0 (Alpha)");
		}).then(function () {
			checkTable("after collapse 0 (Alpha)", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('9')"
			], [
				[false, 1, "0", "", "Alpha", 60],
				[undefined, 1, "9", "", "Aleph", 69]
			], 2);
			const oAleph = oTable.getRows()[1].getBindingContext();

			// code under test
			assert.strictEqual(oAlpha.isAncestorOf(oAleph), false, "JIRA: CPOUI5ODATAV4-2337");
			assert.strictEqual(oAleph.isAncestorOf(oAlpha), false, "JIRA: CPOUI5ODATAV4-2337");

			that.expectRequest({
					batchNo : 4,
					method : "POST",
					url : "EMPLOYEES",
					payload : {
						// not needed: "EMPLOYEE_2_MANAGER@odata.bind" : null,
						Name : "Beth"
					}
				}, {
					AGE : 70,
					ID : "B",
					MANAGER_ID : null,
					Name : "Beth, not Beta" // side effect
				})
				.expectRequest({
					batchNo : 5,
					url : sTopLevelsUrl + "&$filter=ID eq 'B'&$select=LimitedRank"
				}, {
					value : [{
						ID : "B",
						LimitedRank : "0" // Edm.Int64
					}]
				});

			// code under test (JIRA: CPOUI5ODATAV4-2355)
			oNewRoot = oAlpha.getBinding().create({Name : "Beth"}, /*bSkipRefresh*/true);

			assert.strictEqual(oNewRoot.getIndex(), 0);

			return Promise.all([
				oNewRoot.created(),
				that.waitForChanges(assert, "create new root")
			]);
		}).then(function () {
			checkTable("after create new root", assert, oTable, [
				"/EMPLOYEES('B')",
				"/EMPLOYEES('0')",
				"/EMPLOYEES('9')"
			], [
				[undefined, 1, "B", "", "Beth, not Beta", 70],
				[false, 1, "0", "", "Alpha", 60],
				[undefined, 1, "9", "", "Aleph", 69]
			]);
			checkCreatedPersisted(assert, oNewRoot);

			that.expectRequest("EMPLOYEES?$select=AGE,ID"
					+ "&$filter=ID eq 'B' or ID eq '0' or ID eq '9'&$top=3", {
					value : [{
						AGE : 170,
						ID : "B" // Beth
					}, {
						AGE : 160,
						ID : "0" // Alpha
					}, {
						AGE : 169,
						ID : "9" // Aleph
					}]
				});

			return Promise.all([
				// code under test
				oAlpha.getBinding().getHeaderContext().requestSideEffects(["AGE"]),
				that.waitForChanges(assert, "side effect: AGE for all rows")
			]);
		}).then(function () {
			checkTable("after side effect: AGE for all rows", assert, oTable, [
				"/EMPLOYEES('B')",
				"/EMPLOYEES('0')",
				"/EMPLOYEES('9')"
			], [
				[undefined, 1, "B", "", "Beth, not Beta", 170],
				[false, 1, "0", "", "Alpha", 160],
				[undefined, 1, "9", "", "Aleph", 169]
			]);

			that.expectRequest({batchNo : 7,
					url : sTopLevelsSelectUrl + "&$skip=2&$top=1"}, {
					value : [{
						AGE : 155,
						DescendantCount : "2",
						DistanceFromRoot : "1",
						DrillState : "expanded", // Note: overridden by client-side tree state!
						ID : "1",
						MANAGER_ID : "0",
						Name : "Beta"
					}]
				})
				.expectRequest({batchNo : 7,
					url : sTopLevelsSelectUrl + "&$skip=5&$top=2"}, {
					value : [{
						AGE : 156,
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						MANAGER_ID : "0",
						Name : "Kappa"
					}, {
						AGE : 157,
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "3",
						MANAGER_ID : "0",
						Name : "Lambda"
					}]
				});

			// code under test
			oAlpha.expand();

			return that.waitForChanges(assert, "expand 0 (Alpha)");
		}).then(function () {
			checkTable("after expand 0 (Alpha)", assert, oTable, [
				"/EMPLOYEES('B')",
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('9')"
			], [
				[undefined, 1, "B", "", "Beth, not Beta", 170],
				[true, 1, "0", "", "Alpha", 160],
				[false, 2, "1", "0", "Beta", 155],
				[undefined, 2, "2", "0", "Kappa", 156],
				[undefined, 2, "3", "0", "Lambda", 157]
			], 10);

			that.expectRequest({
					batchNo : 8,
					method : "POST",
					url : "EMPLOYEES",
					payload : {
						"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('0')",
						Name : "gIMEL"
					}
				}, {
					AGE : 180,
					ID : "C",
					MANAGER_ID : "0", // side effect
					Name : "Gimel" // side effect
				})
				.expectRequest({
					batchNo : 9,
					url : sTopLevelsUrl + "&$filter=ID eq 'C'&$select=LimitedRank"
				}, {
					value : [{
						ID : "C",
						LimitedRank : "5" // Edm.Int64
					}]
				});

			// code under test (JIRA: CPOUI5ODATAV4-2359)
			oNewChild = oAlpha.getBinding().create({
				"@$ui5.node.parent" : oAlpha,
				Name : "gIMEL"
			}, /*bSkipRefresh*/true);

			assert.strictEqual(oNewChild.getIndex(), 2);
			assert.strictEqual(oNewChild.getProperty("@$ui5.node.level"), 2);
			assert.deepEqual(oNewChild.getObject(), {
				"@$ui5.context.isTransient" : true,
				"@$ui5.node.level" : 2,
				// "@$ui5.node.parent" : oAlpha, // removed by #create
				Name : "gIMEL"
			});

			return Promise.all([
				oNewChild.created(),
				that.waitForChanges(assert, "create new child beneath 0 (Alpha)")
			]);
		}).then(function () {
			checkTable("after create new child beneath 0 (Alpha)", assert, oTable, [
				"/EMPLOYEES('B')",
				"/EMPLOYEES('0')",
				"/EMPLOYEES('C')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('9')"
			], [
				[undefined, 1, "B", "", "Beth, not Beta", 170],
				[true, 1, "0", "", "Alpha", 160],
				[undefined, 2, "C", "0", "Gimel", 180],
				[false, 2, "1", "0", "Beta", 155],
				[undefined, 2, "2", "0", "Kappa", 156]
			], 11);
			checkCreatedPersisted(assert, oNewChild);

			// code under test
			oAlpha.collapse();

			return that.waitForChanges(assert, "collapse 0 (Alpha) again");
		}).then(function () {
			checkTable("after collapse 0 (Alpha) again", assert, oTable, [
				"/EMPLOYEES('B')",
				"/EMPLOYEES('0')",
				"/EMPLOYEES('9')"
			], [
				[undefined, 1, "B", "", "Beth, not Beta", 170],
				[false, 1, "0", "", "Alpha", 160],
				[undefined, 1, "9", "", "Aleph", 169]
			]);

			// code under test
			oAlpha.expand();

			return that.waitForChanges(assert, "expand 0 (Alpha) again");
		}).then(function () {
			checkTable("after create new child beneath 0 (Alpha)", assert, oTable, [
				"/EMPLOYEES('B')",
				"/EMPLOYEES('0')",
				"/EMPLOYEES('C')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('9')"
			], [
				[undefined, 1, "B", "", "Beth, not Beta", 170],
				[true, 1, "0", "", "Alpha", 160],
				[undefined, 2, "C", "0", "Gimel", 180],
				[false, 2, "1", "0", "Beta", 155],
				[undefined, 2, "2", "0", "Kappa", 156]
			], 11);
			assert.strictEqual(oNewChild.getBinding().getCurrentContexts()[2], oNewChild,
				"still the same");
			checkCreatedPersisted(assert, oNewChild);
		});
	});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 4. Collapse nested
	// initially expanded nodes 1.1 (Gamma) and 1 (Beta). Page down to load more data than visible.
	// Expand the initially collapsed node 4.1.1 (Xi). Request side effects for all rows that do not
	// affect the hierarchy. Scroll down to load 4.1.1.1 (Omicron) again. Scroll up and expand
	// 1 (Beta) and 1.1 (Gamma) again (the latter w/ or w/o an "Unexpected structural change" of
	// a certain property).
	// JIRA: CPOUI5ODATAV4-1785
[
	undefined, "DistanceFromRoot", "DrillState", "ID", "order"
].forEach(function (sStructuralChange) {
	var sTitle = "Recursive Hierarchy: side effects for all rows; Unexpected structural change: "
			+ sStructuralChange;

	QUnit.test(sTitle, function (assert) {
		var oBeta,
			oGamma,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/EMPLOYEES\',\
		parameters : {\
			$$aggregation : {\
				expandTo : 4,\
				hierarchyQualifier : \'OrgChart\'\
			}\
		}}" threshold="0" visibleRowCount="5">\
	<Text text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text text="{= %{@$ui5.node.level} }"/>\
	<Text text="{ID}"/>\
	<Text text="{MANAGER_ID}"/>\
	<Input value="{Name}"/>\
	<Text text="{AGE}"/>\
</t:Table>',
			oXi,
			that = this;

		// Note: 1.2 (Zeta) is omitted in this scenario; 4.1.1 (Xi) is used as a child of 4.1 (Nu):
		// 0 Alpha
		//   1 Beta
		//     1.1 Gamma
		//       1.1.1 Delta
		//       1.1.2 Epsilon
		//   2 Kappa
		//   3 Lambda
		//   4 Mu
		//     4.1 Nu
		//       4.1.1 Xi
		//         4.1.1.1 Omicron
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=4)"
				+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$count=true&$skip=0&$top=5", {
				"@odata.count" : "10",
				value : [{
					AGE : 60,
					DescendantCount : "9",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					AGE : 55,
					DescendantCount : "3",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					AGE : 41,
					DescendantCount : "2",
					DistanceFromRoot : "2",
					DrillState : "expanded",
					ID : "1.1",
					MANAGER_ID : "1",
					Name : "Gamma"
				}, {
					AGE : 38,
					DescendantCount : "0",
					DistanceFromRoot : "3",
					DrillState : "leaf",
					ID : "1.1.1",
					MANAGER_ID : "1.1",
					Name : "Delta"
				}, {
					AGE : 39,
					DescendantCount : "0",
					DistanceFromRoot : "3",
					DrillState : "leaf",
					ID : "1.1.2",
					MANAGER_ID : "1.1",
					Name : "Epsilon"
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBeta = oTable.getRows()[1].getBindingContext();
			assert.strictEqual(oBeta.getProperty("Name"), "Beta");
			oGamma = oTable.getRows()[2].getBindingContext();
			assert.strictEqual(oGamma.getProperty("Name"), "Gamma");

			checkTable("initial page", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.1.1')",
				"/EMPLOYEES('1.1.2')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[true, 2, "1", "0", "Beta", 55],
				[true, 3, "1.1", "1", "Gamma", 41],
				[undefined, 4, "1.1.1", "1.1", "Delta", 38],
				[undefined, 4, "1.1.2", "1.1", "Epsilon", 39]
			], 10);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=4)"
					+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=5&$top=2", {
					value : [{
						AGE : 56,
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						MANAGER_ID : "0",
						Name : "Kappa"
					}, {
						AGE : 57,
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "3",
						MANAGER_ID : "0",
						Name : "Lambda"
					}]
				});

			oGamma.collapse();

			return that.waitForChanges(assert, "collapse 1.1 (Gamma)");
		}).then(function () {
			checkTable("after collapse 1.1 (Gamma)", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[true, 2, "1", "0", "Beta", 55],
				[false, 3, "1.1", "1", "Gamma", 41],
				[undefined, 2, "2", "0", "Kappa", 56],
				[undefined, 2, "3", "0", "Lambda", 57]
			], 8);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=4)"
					+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=7&$top=1", {
					value : [{
						AGE : 58,
						DescendantCount : "2",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						ID : "4",
						MANAGER_ID : "0",
						Name : "Mu"
					}]
				});

			oBeta.collapse(); // Note: this eventually destroys oGamma!
			oGamma = null;

			return that.waitForChanges(assert, "collapse 1 (Beta)");
		}).then(function () {
			checkTable("after collapse 1 (Beta)", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[false, 2, "1", "0", "Beta", 55],
				[undefined, 2, "2", "0", "Kappa", 56],
				[undefined, 2, "3", "0", "Lambda", 57],
				[true, 2, "4", "0", "Mu", 58]
			], 7);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=4)"
					+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=8&$top=2", {
					value : [{
						AGE : 41,
						DescendantCount : "1",
						DistanceFromRoot : "2",
						DrillState : "expanded",
						ID : "4.1",
						MANAGER_ID : "4",
						Name : "Nu"
					}, {
						AGE : 59,
						DescendantCount : "0",
						DistanceFromRoot : "3",
						DrillState : "collapsed",
						ID : "4.1.1",
						MANAGER_ID : "4.1",
						Name : "Xi"
					}]
				});

			oTable.setFirstVisibleRow(2);

			return that.waitForChanges(assert, "page down");
		}).then(function () {
			oXi = oTable.getRows()[4].getBindingContext();
			assert.strictEqual(oXi.getProperty("Name"), "Xi");

			checkTable("paged down", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('4.1')",
				"/EMPLOYEES('4.1.1')"
			], [
				[undefined, 2, "2", "0", "Kappa", 56],
				[undefined, 2, "3", "0", "Lambda", 57],
				[true, 2, "4", "0", "Mu", 58],
				[true, 3, "4.1", "4", "Nu", 41],
				[false, 4, "4.1.1", "4.1", "Xi", 59]
			], 7);

			that.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '4.1.1'),1)"
					+ "&$select=AGE,DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=5", {
					"@odata.count" : "1",
					value : [{
						AGE : 41,
						DrillState : "collapsed",
						ID : "4.1.1.1",
						MANAGER_ID : "4.1.1",
						Name : "Omicron"
					}]
				});

			oXi.expand();

			return that.waitForChanges(assert, "expand 4.1.1 (Xi)");
		}).then(function () {
			checkTable("after expand 4.1.1 (Xi)", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('4.1')",
				"/EMPLOYEES('4.1.1')",
				"/EMPLOYEES('4.1.1.1')"
			], [
				[undefined, 2, "2", "0", "Kappa", 56],
				[undefined, 2, "3", "0", "Lambda", 57],
				[true, 2, "4", "0", "Mu", 58],
				[true, 3, "4.1", "4", "Nu", 41],
				[true, 4, "4.1.1", "4.1", "Xi", 59]
			], 8);

			that.expectRequest("EMPLOYEES?$select=AGE,ID,MANAGER_ID,Name&$filter=ID eq '2'"
					+ " or ID eq '3' or ID eq '4' or ID eq '4.1' or ID eq '4.1.1'&$top=5", {
					value : [{
						AGE : 156,
						ID : "2",
						MANAGER_ID : "0",
						Name : "Kappa #1"
					}, {
						AGE : 157,
						ID : "3",
						MANAGER_ID : "0",
						Name : "Lambda #1"
					}, {
						AGE : 158,
						ID : "4",
						MANAGER_ID : "0",
						Name : "Mu #1"
					}, {
						AGE : 141,
						ID : "4.1",
						MANAGER_ID : "4",
						Name : "Nu #1"
					}, {
						AGE : 159,
						ID : "4.1.1",
						MANAGER_ID : "4.1",
						Name : "Xi #1"
					}]
				});

			// Note: side effect eventually destroys oBeta!
			oBeta = null;

			return Promise.all([
				// code under test
				oXi.getBinding().getHeaderContext().requestSideEffects(["*"]),
				that.waitForChanges(assert, "request side effects")
			]);
		}).then(function () {
			checkTable("after request side effects", assert, oTable, [
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('4.1')",
				"/EMPLOYEES('4.1.1')"
			], [
				[undefined, 2, "2", "0", "Kappa #1", 156],
				[undefined, 2, "3", "0", "Lambda #1", 157],
				[true, 2, "4", "0", "Mu #1", 158],
				[true, 3, "4.1", "4", "Nu #1", 141],
				[true, 4, "4.1.1", "4.1", "Xi #1", 159]
			], 8);

			assert.strictEqual(oXi.getProperty("AGE"), 159);

			that.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '4.1.1'),1)"
					+ "&$select=AGE,DrillState,ID,MANAGER_ID,Name&$skip=0&$top=1", {
					value : [{
						AGE : 141,
						DrillState : "collapsed",
						ID : "4.1.1.1",
						MANAGER_ID : "4.1.1",
						Name : "Omicron #1"
					}]
				});

			// code under test
			oTable.setFirstVisibleRow(3);

			return that.waitForChanges(assert, "scroll to the end");
		}).then(function () {
			checkTable("after scroll to the end", assert, oTable, [
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('4.1')",
				"/EMPLOYEES('4.1.1')",
				"/EMPLOYEES('4.1.1.1')"
			], [
				[undefined, 2, "3", "0", "Lambda #1", 157],
				[true, 2, "4", "0", "Mu #1", 158],
				[true, 3, "4.1", "4", "Nu #1", 141],
				[true, 4, "4.1.1", "4.1", "Xi #1", 159],
				[false, 5, "4.1.1.1", "4.1.1", "Omicron #1", 141]
			], 8);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=4)"
					+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=0&$top=2", {
					value : [{
						AGE : 160,
						DescendantCount : "9",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						ID : "0",
						MANAGER_ID : null,
						Name : "Alpha #1"
					}, {
						AGE : 155,
						DescendantCount : "3",
						DistanceFromRoot : "1",
						DrillState : "expanded", // Note: overridden by client-side tree state!
						ID : "1",
						MANAGER_ID : "0",
						Name : "Beta #1"
					}]
				});

			// code under test
			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert, "scroll to the top");
		}).then(function () {
			oBeta = oTable.getRows()[1].getBindingContext();

			checkTable("after scroll to the top", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('4.1')",
				"/EMPLOYEES('4.1.1')",
				"/EMPLOYEES('4.1.1.1')"
			], [
				[true, 1, "0", "", "Alpha #1", 160],
				[false, 2, "1", "0", "Beta #1", 155], // Note: still collapsed!
				[undefined, 2, "2", "0", "Kappa #1", 156],
				[undefined, 2, "3", "0", "Lambda #1", 157],
				[true, 2, "4", "0", "Mu #1", 158]
			], 8);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=4)"
					+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=2&$top=1", {
					value : [{
						AGE : 141,
						DescendantCount : "2",
						DistanceFromRoot : "2",
						DrillState : "expanded", // Note: overridden by client-side tree state!
						ID : "1.1",
						MANAGER_ID : "1",
						Name : "Gamma #1"
					}]
				});

			// code under test
			oBeta.expand();

			return that.waitForChanges(assert, "expand 1 (Beta) again");
		}).then(function () {
			var oDelta = {
					AGE : 138,
					DescendantCount : "0",
					DistanceFromRoot : sStructuralChange === "DistanceFromRoot" ? "4" : "3",
					DrillState : sStructuralChange === "DrillState" ? "collapsed" : "leaf",
					ID : sStructuralChange === "ID" ? "1-1-1" : "1.1.1",
					MANAGER_ID : "1.1",
					Name : "Delta #1"
				},
				oEpsilon = {
					AGE : 139,
					DescendantCount : "0",
					DistanceFromRoot : "3",
					DrillState : "leaf",
					ID : "1.1.2",
					MANAGER_ID : "1.1",
					Name : "Epsilon #1"
				},
				sErrorMessage = "???";

			switch (sStructuralChange) {
				case "DistanceFromRoot":
					sErrorMessage = "Wrong placeholder";
					break;
				case "DrillState":
					sErrorMessage = "Not a leaf anymore (or vice versa)";
					break;
				case "ID":
				case "order":
					sErrorMessage = "Unexpected structural change: predicate";
					break;
				// no default
			}

			oGamma = oTable.getRows()[2].getBindingContext(); // access new instance
			assert.strictEqual(oGamma.getProperty("Name"), "Gamma #1");

			checkTable("after expand 1 (Beta) again", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('4.1')",
				"/EMPLOYEES('4.1.1')",
				"/EMPLOYEES('4.1.1.1')"
			], [
				[true, 1, "0", "", "Alpha #1", 160],
				[true, 2, "1", "0", "Beta #1", 155],
				[false, 3, "1.1", "1", "Gamma #1", 141], // Note: still collapsed!
				[undefined, 2, "2", "0", "Kappa #1", 156],
				[undefined, 2, "3", "0", "Lambda #1", 157]
			], 9);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=4)"
					+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=3&$top=2", {
					value : sStructuralChange === "order"
					? [oEpsilon, oDelta]
					: [oDelta, oEpsilon]
				});
			if (sStructuralChange) {
				that.expectMessages([{
						message : sErrorMessage,
						persistent : true,
						technical : true,
						type : "Error"
					}]);
				that.oLogMock.expects("error")
					.withExactArgs("Failed to get contexts for " + sTeaBusi
						+ "EMPLOYEES with start index 0 and length 5",
						sinon.match(sErrorMessage), sODLB);
			}

			// code under test
			oGamma.expand();

			return that.waitForChanges(assert, "expand 1.1 (Gamma) again");
		}).then(function () {
			if (sStructuralChange) {
				return; // no use to check state after error
			}

			checkTable("after expand 1.1 (Gamma) again", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.1.1')",
				"/EMPLOYEES('1.1.2')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('4.1')",
				"/EMPLOYEES('4.1.1')",
				"/EMPLOYEES('4.1.1.1')"
			], [
				[true, 1, "0", "", "Alpha #1", 160],
				[true, 2, "1", "0", "Beta #1", 155],
				[true, 3, "1.1", "1", "Gamma #1", 141],
				[undefined, 4, "1.1.1", "1.1", "Delta #1", 138],
				[undefined, 4, "1.1.2", "1.1", "Epsilon #1", 139]
			], 11);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 3. Collapse
	// initially expanded nodes 1 (Beta) and 0 (Alpha). Request side effects for all rows that do
	// not affect the hierarchy. Expand 0 (Alpha) again. 1 (Beta) must still be collapsed and its
	// children must not yet be loaded, causing a "split gap" when reading inside the top pyramid.
	// JIRA: CPOUI5ODATAV4-1785
	QUnit.test("Recursive Hierarchy: split gap", function (assert) {
		var oAlpha,
			oBeta,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/EMPLOYEES\',\
		parameters : {\
			$$aggregation : {\
				expandTo : 3,\
				hierarchyQualifier : \'OrgChart\'\
			}\
		}}" threshold="0" visibleRowCount="4">\
	<Text text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text text="{= %{@$ui5.node.level} }"/>\
	<Text text="{ID}"/>\
	<Text text="{MANAGER_ID}"/>\
	<Text text="{Name}"/>\
</t:Table>',
			that = this;

		// 0 Alpha
		//   1 Beta
		//     1.1 Gamma
		//     1.2 Zeta
		//   2 Kappa
		//   3 Lambda
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$count=true&$skip=0&$top=4", {
				"@odata.count" : "6",
				value : [{
					DescendantCount : "5",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					DescendantCount : "2",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "collapsed",
					ID : "1.1",
					MANAGER_ID : "1",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "collapsed",
					ID : "1.2",
					MANAGER_ID : "1",
					Name : "Zeta"
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oAlpha = oTable.getRows()[0].getBindingContext();
			assert.strictEqual(oAlpha.getProperty("Name"), "Alpha");
			oBeta = oTable.getRows()[1].getBindingContext();
			assert.strictEqual(oBeta.getProperty("Name"), "Beta");

			checkTable("initial page", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.2')"
			], [
				[true, 1, "0", "", "Alpha"],
				[true, 2, "1", "0", "Beta"],
				[false, 3, "1.1", "1", "Gamma"],
				[false, 3, "1.2", "1", "Zeta"]
			], 6);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=3)"
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=4&$top=2", {
					value : [{
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						MANAGER_ID : "0",
						Name : "Kappa"
					}, {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "3",
						MANAGER_ID : "0",
						Name : "Lambda"
					}]
				});

			oBeta.collapse();

			return that.waitForChanges(assert, "collapse 1 (Beta)");
		}).then(function () {
			checkTable("after collapse 1 (Beta)", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha"],
				[false, 2, "1", "0", "Beta"],
				[undefined, 2, "2", "0", "Kappa"],
				[undefined, 2, "3", "0", "Lambda"]
			], 4);

			oAlpha.collapse();

			return that.waitForChanges(assert, "collapse 0 (Alpha)");
		}).then(function () {
			checkTable("after collapse 0 (Alpha)", assert, oTable, [
				"/EMPLOYEES('0')"
				// Note: collapse kills ;-)
			], [
				[false, 1, "0", "", "Alpha"]

			], 1);

			that.expectRequest("EMPLOYEES?$select=ID,Name&$filter=ID eq '0'", {
					value : [{
						ID : "0",
						Name : "Alpha #1"
					}]
				});

			return Promise.all([
				// code under test
				oAlpha.getBinding().getHeaderContext().requestSideEffects(["Name"]),
				that.waitForChanges(assert, "request side effects")
			]);
		}).then(function () {
			checkTable("after request side effects", assert, oTable, [
				"/EMPLOYEES('0')"
			], [
				[false, 1, "0", "", "Alpha #1"]
			], 1);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=3)"
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=1&$top=1", {
					value : [{
						DescendantCount : "2",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						ID : "1",
						MANAGER_ID : "0",
						Name : "Beta #1"
					}]
				})
				.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=3)"
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=4&$top=2", {
					value : [{
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						MANAGER_ID : "0",
						Name : "Kappa #1"
					}, {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "3",
						MANAGER_ID : "0",
						Name : "Lambda #1"
					}]
				});

			// code under test
			oAlpha.expand();

			return that.waitForChanges(assert, "expand 0 (Alpha) again");
		}).then(function () {
			checkTable("after expand 0 (Alpha) again", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha #1"],
				[false, 2, "1", "0", "Beta #1"],
				[undefined, 2, "2", "0", "Kappa #1"],
				[undefined, 2, "3", "0", "Lambda #1"]
			], 4);
		});
	});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 2. Expand the
	// initially collapsed node 1 (Beta). Request side effects for all rows that do not affect the
	// hierarchy. Collapse 1 (Beta) again and check that its siblings become visible.
	// JIRA: CPOUI5ODATAV4-1785
	QUnit.test("Recursive Hierarchy: collapse needs level", function (assert) {
		var oBeta,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<t:Table id="table" rows="{path : \'/EMPLOYEES\',\
		parameters : {\
			$$aggregation : {\
				expandTo : 2,\
				hierarchyQualifier : \'OrgChart\'\
			}\
		}}" threshold="0" visibleRowCount="4">\
	<Text text="{= %{@$ui5.node.isExpanded} }"/>\
	<Text text="{= %{@$ui5.node.level} }"/>\
	<Text text="{ID}"/>\
	<Text text="{MANAGER_ID}"/>\
	<Text text="{Name}"/>\
</t:Table>',
			that = this;

		// 0 Alpha
		//   1 Beta
		//     1.1 Gamma
		//     1.2 Zeta
		//   2 Kappa
		//   3 Lambda
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=2)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$count=true&$skip=0&$top=4", {
				"@odata.count" : "4",
				value : [{
					DescendantCount : "3",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "collapsed",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					MANAGER_ID : "0",
					Name : "Kappa"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					MANAGER_ID : "0",
					Name : "Lambda"
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBeta = oTable.getRows()[1].getBindingContext();
			assert.strictEqual(oBeta.getProperty("Name"), "Beta");

			checkTable("initial page", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha"],
				[false, 2, "1", "0", "Beta"],
				[undefined, 2, "2", "0", "Kappa"],
				[undefined, 2, "3", "0", "Lambda"]
			], 4);

			that.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
					+ "&$select=DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=4", {
					"@odata.count" : "2",
					value : [{
						DrillState : "collapsed",
						ID : "1.1",
						MANAGER_ID : "1",
						Name : "Gamma"
					}, {
						DrillState : "collapsed",
						ID : "1.2",
						MANAGER_ID : "1",
						Name : "Zeta"
					}]
				});

			oBeta.expand();

			return that.waitForChanges(assert, "expand 1 (Beta)");
		}).then(function () {
			checkTable("after expand 1 (Beta)", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.2')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha"],
				[true, 2, "1", "0", "Beta"],
				[false, 3, "1.1", "1", "Gamma"],
				[false, 3, "1.2", "1", "Zeta"]
			], 6);

			that.expectRequest("EMPLOYEES?$select=ID,Name"
					+ "&$filter=ID eq '0' or ID eq '1' or ID eq '1.1' or ID eq '1.2'&$top=4", {
					value : [{
						ID : "0",
						Name : "Alpha #1"
					}, {
						ID : "1",
						Name : "Beta #1"
					}, {
						ID : "1.1",
						Name : "Gamma #1"
					}, {
						ID : "1.2",
						Name : "Zeta #1"
					}]
				});

			return Promise.all([
				// code under test
				oBeta.getBinding().getHeaderContext().requestSideEffects(["Name"]),
				that.waitForChanges(assert, "request side effects")
			]);
		}).then(function () {
			checkTable("after request side effects", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('1.1')",
				"/EMPLOYEES('1.2')"
			], [
				[true, 1, "0", "", "Alpha #1"],
				[true, 2, "1", "0", "Beta #1"],
				[false, 3, "1.1", "1", "Gamma #1"],
				[false, 3, "1.2", "1", "Zeta #1"]
			], 6);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
						+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
						+ ",NodeProperty='ID',Levels=2)"
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
					+ "&$skip=2&$top=2", {
					value : [{
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						MANAGER_ID : "0",
						Name : "Kappa #1"
					}, {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "3",
						MANAGER_ID : "0",
						Name : "Lambda #1"
					}]
				});

			// code under test
			oBeta.collapse();

			return that.waitForChanges(assert, "collapse 1 (Beta) again");
		}).then(function () {
			checkTable("after collapse 1 (Beta) again", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			], [
				[true, 1, "0", "", "Alpha #1"],
				[false, 2, "1", "0", "Beta #1"],
				[undefined, 2, "2", "0", "Kappa #1"],
				[undefined, 2, "3", "0", "Lambda #1"]
			], 4);
		});
	});

	//*********************************************************************************************
	// Scenario: "Select all" in a table runs into server-driven paging. No contexts must be
	// created for placeholders.
	// BCP: 2370039138
	QUnit.test("Recursive Hierarchy: @odata.nextLink", function (assert) {
		var oListBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<t:Table id="table" rows="{path : \'/EMPLOYEES\',\
		parameters : {\
			$$aggregation : {\
				hierarchyQualifier : \'OrgChart\'\
			}\
		}}" threshold="0" visibleRowCount="2">\
	<Text text="{ID}"/>\
</t:Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
				+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID'"
				+ ",Levels=1)&$select=DrillState,ID&$count=true&$skip=0&$top=2", {
				"@odata.count" : "6",
				value : [{
					DrillState : "leaf",
					ID : "0"
				}, {
					DrillState : "leaf",
					ID : "1"
				}]
			});

		return this.createView(assert, sView, oModel).then(function () {
			var oTable = that.oView.byId("table");

			oListBinding = oTable.getBinding("rows");

			checkTable("initial page", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')"
			], [
				["0"],
				["1"]
			], 6);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)&$select=DrillState,ID&$skip=2&$top=4", {
					"@odata.nextLink" : "n/a",
					value : [{
						DrillState : "leaf",
						ID : "2"
					}, {
						DrillState : "leaf",
						ID : "3"
					}]
				});

			return Promise.all([
				// code under test
				oListBinding.requestContexts(0, 6),
				that.waitForChanges(assert, "select all")
			]);
		}).then(function (aResults) {
			assert.deepEqual(aResults[0].map(getPath), [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			]);

			that.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)&$select=DrillState,ID&$skip=4&$top=2", {
					value : [{
						DrillState : "leaf",
						ID : "4"
					}, {
						DrillState : "leaf",
						ID : "5"
					}]
				});

			return Promise.all([
				// code under test
				oListBinding.requestContexts(0, 6),
				that.waitForChanges(assert, "select all")
			]);
		}).then(function (aResults) {
			assert.deepEqual(aResults[0].map(getPath), [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('5')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete a top-level node in a recursive hierarchy. The binding has only one node, so
	// that the parent would have to become a leaf if there was one.
	// JIRA: CPOUI5ODATAV4-2224
	QUnit.test("Recursive Hierarchy: delete top-level", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<Table id="table" items="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart'
			}
		}}">
	<Text text="{ID}"/>
	<Text id="name" text="{Name}"/>
</Table>`;

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
				+ "&$select=DrillState,ID,Name&$count=true&$skip=0&$top=100", {
				"@odata.count" : "1",
				value : [{
					ID : "0",
					Name : "Alpha"
				}]
			})
			.expectChange("name", ["Alpha"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oAlpha = oTable.getItems()[0].getBindingContext();

		assert.throws(function () {
			oAlpha.delete("deferred"); // code under test
		}, new Error("Unsupported group ID: deferred"));

		this.expectRequest("DELETE EMPLOYEES('0')");

		await Promise.all([
			oAlpha.delete(), // code under test
			this.waitForChanges(assert, "delete")
		]);

		checkTable("after delete", assert, oTable, [], [], 0);
	});

	//*********************************************************************************************
	// Scenario: Delete Gamma, a leaf in a recursive hierarchy which is not the only child of its
	// parent. Before the delete ensure that there are two invisible elements (Delta, Epsilon).
	// Request side effects so that Epsilon is removed again. Scroll down to see that Epsilon and
	// Zeta are requested correctly. Scroll down to the end to see that Eta and Theta are requested
	// correctly.
	// ("Pi" is attached to a name when it is read a second time.)
	// JIRA: CPOUI5ODATAV4-2224
	// JIRA: CPOUI5ODATAV4-2345
	QUnit.test("Recursive Hierarchy: delete second leaf", function (assert) {
		var oTable;

		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="3" >
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
	<Text text="{MANAGER_ID}"/>
	<Text id="name" text="{Name}"/>
</t:Table>`;
		const that = this;

		// 0 Alpha
		//    1 Beta
		//    2 Gamma (deleted)
		//    3 Delta (read via expand, comes into view due to delete)
		//    4 Epsilon (exists hidden when deleting, then dropped and read again via paging)
		//    5 Zeta (read via paging after delete)
		//    6 Eta (read via paging after delete)
		// 7 Theta
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
				+ "&$select=DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=3", {
				"@odata.count" : "2",
				value : [{
					DrillState : "collapsed",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					DrillState : "collapsed",
					ID : "7",
					MANAGER_ID : null,
					Name : "Theta"
				}]
			})
			.expectChange("name", ["Alpha", "Theta"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectRequest("EMPLOYEES?"
					+ "$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
					+ "&$select=DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=3", {
					"@odata.count" : "6",
					value : [{
						DrillState : "collapsed",
						ID : "1",
						MANAGER_ID : "0",
						Name : "Beta"
					}, {
						DrillState : "leaf",
						ID : "2",
						MANAGER_ID : "0",
						Name : "Gamma"
					}, {
						DrillState : "leaf",
						ID : "3",
						MANAGER_ID : "0",
						Name : "Delta"
					}]
				})
				.expectChange("name", [, "Beta", "Gamma"]);

			oTable.getRows()[0].getBindingContext().expand();

			return that.waitForChanges(assert, "expand");
		}).then(function () {
			that.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
					+ "&$select=DrillState,ID,MANAGER_ID,Name&$skip=3&$top=1", {
					value : [{
						DrillState : "leaf",
						ID : "4",
						MANAGER_ID : "0",
						Name : "Epsilon"
					}]
				})
				.expectChange("name", [,, "Gamma", "Delta", "Epsilon"]);

			// code under test
			oTable.setFirstVisibleRow(2);

			return that.waitForChanges(assert, "scroll down");
		}).then(function () {
			that.expectChange("name", ["Alpha", "Beta", "Gamma"]);

			// code under test
			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert, "scroll up");
		}).then(function () {
			checkTable("before delete", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('7')"
			], [
				[true, 1, "0", "", "Alpha"],
				[false, 2, "1", "0", "Beta"],
				[undefined, 2, "2", "0", "Gamma"]
			], 8);

			that.expectRequest("DELETE EMPLOYEES('2')")
				.expectChange("name", [,, "Delta"]);

			return Promise.all([
				oTable.getRows()[2].getBindingContext().delete(), // code under test
				that.waitForChanges(assert, "delete")
			]);
		}).then(function () {
			checkTable("after delete", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('7')"
			], [
				[true, 1, "0", "", "Alpha"],
				[false, 2, "1", "0", "Beta"],
				[undefined, 2, "3", "0", "Delta"]
			], 7);

			that.expectRequest("EMPLOYEES?$select=ID,Name"
					+ "&$filter=ID eq '0' or ID eq '1' or ID eq '3'&$top=3", {
					value : [{
						ID : "0",
						Name : "Alpha Pi"
					}, {
						ID : "1",
						Name : "Beta Pi"
					}, {
						ID : "3",
						Name : "Delta Pi"
					}]
				})
				.expectChange("name", ["Alpha Pi", "Beta Pi", "Delta Pi"]);

			return Promise.all([
				// code under test
				oTable.getBinding("rows").getHeaderContext().requestSideEffects(["Name"]),
				that.waitForChanges(assert, "side effects")
			]);
		}).then(function () {
			that.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
					+ "&$select=DrillState,ID,MANAGER_ID,Name&$skip=2&$top=2", {
					"@odata.count" : "5",
					value : [{
						DrillState : "leaf",
						ID : "4",
						MANAGER_ID : "0",
						Name : "Epsilon Pi"
					}, {
						DrillState : "collapsed",
						ID : "5",
						MANAGER_ID : "0",
						Name : "Zeta"
					}]
				})
				.expectChange("name", [,, "Delta Pi", "Epsilon Pi", "Zeta"]);

			// code under test
			oTable.setFirstVisibleRow(2);

			return that.waitForChanges(assert, "scroll after delete");
		}).then(function () {
			that.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
					+ "&$select=DrillState,ID,MANAGER_ID,Name&$skip=4&$top=1", {
					value : [{
						DrillState : "collapsed",
						ID : "6",
						MANAGER_ID : "0",
						Name : "Eta"
					}]
				})
				.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels"
					+ "(HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
					+ "&$select=DrillState,ID,MANAGER_ID,Name&$skip=1&$top=1", {
					value : [{
						DrillState : "collapsed",
						ID : "7",
						MANAGER_ID : null,
						Name : "Theta Pi"
					}]
				})
				.expectChange("name", [,,,, "Zeta", "Eta", "Theta Pi"]);

			// code under test
			oTable.setFirstVisibleRow(4);

			return that.waitForChanges(assert, "scroll to bottom");
		}).then(function () {
			checkTable("after scroll to bottom", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('4')",
				"/EMPLOYEES('5')",
				"/EMPLOYEES('6')",
				"/EMPLOYEES('7')"
			], [
				[false, 2, "5", "0", "Zeta"],
				[false, 2, "6", "0", "Eta"],
				[false, 1, "7", "", "Theta Pi"]
			], 7);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete a non-leaf node with loaded children in a recursive hierarchy which is the
	// only child of its parent. Two variants: delete while collapsed and while expanded.
	// * Expand Alpha and Beta.
	// * Collapse Beta (in variant 1).
	// * Delete Beta and let the request fail. See that it is expanded again in variant 2.
	// * Delete Beta again. See that Alpha becomes a leaf.
	// JIRA: CPOUI5ODATAV4-2224
	// JIRA: CPOUI5ODATAV4-2345
[false, true].forEach(function (bExpanded) {
	const sState = bExpanded ? "expanded" : "collapsed";
	QUnit.test(`Recursive Hierarchy: delete single ${sState} child`, async function (assert) {
		var oTable;

		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<Table id="table" items="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart'
			}
		}}">
	<Text id="expanded" text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
	<Text text="{MANAGER_ID}"/>
	<Text id="name" text="{Name}"/>
</Table>`;

		function expectTable(sTitle, bExpanded) {
			if (bExpanded) {
				checkTable(sTitle, assert, oTable, [
					"/EMPLOYEES('0')",
					"/EMPLOYEES('1')",
					"/EMPLOYEES('2')",
					"/EMPLOYEES('3')"
				], [
					[true, 1, "0", "", "Alpha"],
					[true, 2, "1", "0", "Beta"],
					[false, 3, "2", "1", "Gamma"],
					[false, 1, "3", "", "Delta"]
				], 4);
			} else {
				checkTable(sTitle, assert, oTable, [
					"/EMPLOYEES('0')",
					"/EMPLOYEES('1')",
					"/EMPLOYEES('3')"
				], [
					[true, 1, "0", "", "Alpha"],
					[false, 2, "1", "0", "Beta"],
					[false, 1, "3", "", "Delta"]
				], 3);
			}
		}

		// 0 Alpha
		//   1 Beta (deleted while Gamma is loaded)
		//     2 Gamma (allows expanding Beta)
		// 3 Delta (only helps with the eventing)
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels"
				+ "(HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID'"
				+ ",Levels=1)"
				+ "&$select=DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=100", {
				"@odata.count" : "2",
				value : [{
					DrillState : "collapsed",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					DrillState : "collapsed",
					ID : "3",
					MANAGER_ID : null,
					Name : "Delta"
				}]
			})
			.expectChange("expanded", [false, false])
			.expectChange("name", ["Alpha", "Delta"]);

		await this.createView(assert, sView, oModel);

		this.expectRequest("EMPLOYEES"
				+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
				+ "&$select=DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=100", {
				"@odata.count" : "1",
				value : [{
					DrillState : "collapsed",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}]
			})
			.expectChange("expanded", [true,, false])
			.expectChange("name", [, "Beta", "Delta"]);

		oTable = this.oView.byId("table");
		oTable.getItems()[0].getBindingContext().expand();

		await this.waitForChanges(assert, "expand Alpha");

		this.expectRequest("EMPLOYEES"
				+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
				+ "&$select=DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=100", {
				"@odata.count" : "1",
				value : [{
					DrillState : "collapsed",
					ID : "2",
					MANAGER_ID : "1",
					Name : "Gamma"
				}]
			})
			.expectChange("expanded", [, true,, false])
			.expectChange("name", [,, "Gamma", "Delta"]);

		const oBeta = oTable.getItems()[1].getBindingContext();
		oBeta.expand();

		await this.waitForChanges(assert, "expand Beta");

		expectTable("after expand", true);

		if (bExpanded) {
			this.expectChange("expanded", [, false]) // Beta is collapsed before being deleted
				.expectChange("expanded", [, true]); // ...and expanded again after the error
		} else {
			this.expectChange("expanded", [, false])
				.expectChange("name", [,, "Delta"]);

			oBeta.collapse();

			await this.waitForChanges(assert, "collapse Beta");

			expectTable("after collapse", false);
		}

		this.oLogMock.expects("error").withArgs("Failed to delete /EMPLOYEES('1')");
		this.expectRequest("DELETE EMPLOYEES('1')", createErrorInsideBatch())
			.expectMessages([{
				code : "CODE",
				message : "Request intentionally failed",
				persistent : true,
				technical : true,
				type : "Error"
			}]);

		await Promise.all([
			// code under test
			oBeta.delete().then(mustFail(assert), function (_oError) {}),
			this.waitForChanges(assert, "failing to delete Beta")
		]);

		expectTable("after failed delete", bExpanded);

		if (bExpanded) {
			this.expectChange("expanded", [, false]); // Beta is collapsed before being deleted
		}
		this.expectRequest("DELETE EMPLOYEES('1')")
			.expectChange("expanded", [undefined]) // Alpha is now a leaf
			.expectChange("name", [, "Delta"]);

		await Promise.all([
			oBeta.delete(), // code under test
			this.waitForChanges(assert, "delete Beta")
		]);

		checkTable("after delete", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('3')"
		], [
			[undefined, 1, "0", "", "Alpha"], // now a leaf
			[false, 1, "3", "", "Delta"]
		], 2);
	});
});

	//*********************************************************************************************
	// Scenario: Delete multiple nodes in a recursive hierarchy
	// JIRA: CPOUI5ODATAV4-2302
	QUnit.test("Recursive Hierarchy: delete multiple nodes", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<Table id="table" items="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart'
			}
		}}">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
	<Text text="{MANAGER_ID}"/>
	<Text text="{Name}"/>
</Table>`;

		// 0 Alpha
		//   1 Beta (deleted)
		//   2 Gamma (deleted)
		//   3 Delta
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels"
				+ "(HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID'"
				+ ",Levels=1)"
				+ "&$select=DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=100", {
				"@odata.count" : "1",
				value : [{
					DrillState : "collapsed",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}]
			});

		await this.createView(assert, sView, oModel);

		this.expectRequest("EMPLOYEES"
				+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
				+ "&$select=DrillState,ID,MANAGER_ID,Name&$count=true&$skip=0&$top=100", {
				"@odata.count" : "3",
				value : [{
					DrillState : "leaf",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					DrillState : "leaf",
					ID : "2",
					MANAGER_ID : "0",
					Name : "Gamma"
				}, {
					DrillState : "leaf",
					ID : "3",
					MANAGER_ID : "0",
					Name : "Delta"
				}]
			});

		const oTable = this.oView.byId("table");
		oTable.getItems()[0].getBindingContext().expand();

		await this.waitForChanges(assert, "expand Alpha");

		checkTable("after expand Alpha", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "0", "", "Alpha"],
			[undefined, 2, "1", "0", "Beta"],
			[undefined, 2, "2", "0", "Gamma"],
			[undefined, 2, "3", "0", "Delta"]
		]);

		this.expectRequest("DELETE EMPLOYEES('1')")
			.expectRequest("DELETE EMPLOYEES('2')");

		await Promise.all([
			// code under test
			oTable.getItems()[1].getBindingContext().delete(),
			oTable.getItems()[2].getBindingContext().delete(),
			this.waitForChanges(assert, "delete Beta and Gamma")
		]);

		checkTable("after delete", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "0", "", "Alpha"],
			[undefined, 2, "3", "0", "Delta"]
		]);
	});

	//*********************************************************************************************
	// Scenario: Delete a non-leaf node with descendants loaded partially via expandTo in a
	// recursive hierarchy which is the only child of its parent.
	//
	// JIRA: CPOUI5ODATAV4-2302
	QUnit.test("Recursive Hierarchy: delete & expandTo, one ancestor", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 4,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="4">
	<Text id="expanded" text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
	<Text text="{MANAGER_ID}"/>
	<Text id="name" text="{Name}"/>
</t:Table>`;

		// 0 Alpha
		//   1 Beta (deleted)
		//     2 Gamma (visible during the delete)
		//        3 Delta (visible during the delete)
	    //     4 Epsilon (invisible during the delete)
		//  5 Zeta (only helps with the eventing)
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=4)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$count=true&$skip=0&$top=4", {
				"@odata.count" : "6",
				value : [{
					DescendantCount : "4",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					DescendantCount : "3",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					DescendantCount : "1",
					DistanceFromRoot : "2",
					DrillState : "expanded",
					ID : "2",
					MANAGER_ID : "1",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "3",
					DrillState : "collapsed",
					ID : "3",
					MANAGER_ID : "2",
					Name : "Delta"
				}]
			})
			.expectChange("expanded", [true, true, true, false])
			.expectChange("name", ["Alpha", "Beta", "Gamma", "Delta"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initially", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "0", "", "Alpha"],
			[true, 2, "1", "0", "Beta"],
			[true, 3, "2", "1", "Gamma"],
			[false, 4, "3", "2", "Delta"]
		], 6);

		this.expectChange("expanded", [, false]) // Beta is collapsed before being deleted
			.expectRequest("DELETE EMPLOYEES('1')")
			.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=4)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=1&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "5",
					MANAGER_ID : null,
					Name : "Zeta"
				}]
			})
			.expectChange("expanded", [undefined]) // Alpha is now a leaf
			.expectChange("name", [, "Zeta"]);

		await Promise.all([
			oTable.getRows()[1].getBindingContext().delete(), // code under test
			this.waitForChanges(assert, "delete Beta")
		]);

		checkTable("finally", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('5')"
		], [
			[undefined, 1, "0", "", "Alpha"], // now a leaf
			[undefined, 1, "5", "", "Zeta"]
		]);
	});

	//*********************************************************************************************
	// Scenario: Delete node Epsilon in a recursive hierarchy, preloaded via expandTo. The parent
	// node Gamma has not been loaded yet, but the grandparent Beta has. Load Gamma and Delta,
	// delete Delta, so that two ancestors need to be adjusted. In the end, collapse Beta to see
	// that it was adjusted correctly.
	// JIRA: CPOUI5ODATAV4-2302
	QUnit.test("Recursive Hierarchy: delete & expandTo, two ancestors", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 3,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="2">
	<Text id="expanded" text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
	<Text text="{MANAGER_ID}"/>
	<Text id="name" text="{Name}"/>
</t:Table>`;

		// 0 Alpha
		// 1 Beta (grandparent)
		//    2 Gamma (invisible during the 1st delete)
		//       3 Delta (invisible during the 1st delete, deleted later)
		//       4 Epsilon (deleted)
		// 5 Zeta
		//    6 Eta
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "7",
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					DescendantCount : "3",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					MANAGER_ID : null,
					Name : "Beta"
				}]
			})
			.expectChange("expanded", [undefined, true])
			.expectChange("name", ["Alpha", "Beta"]);

		await this.createView(assert, sView, oModel);

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID'" + ",Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=4&$top=2", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "collapsed",
					ID : "4",
					MANAGER_ID : "3",
					Name : "Epsilon"
				}, {
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "5",
					MANAGER_ID : null,
					Name : "Zeta"
				}]
			})
			.expectChange("expanded", [,,,, false, true])
			.expectChange("name", [,,,, "Epsilon", "Zeta"]);

		const oTable = this.oView.byId("table");
		oTable.setFirstVisibleRow(4);

		await this.waitForChanges(assert, "scroll down creating gap");

		checkTable("before delete", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('4')",
			"/EMPLOYEES('5')"
		], [
			[false, 3, "4", "3", "Epsilon"],
			[true, 1, "5", "", "Zeta"]
		], 7);

		this.expectRequest("DELETE EMPLOYEES('4')")
			.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=5&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "6",
					MANAGER_ID : "5",
					Name : "Eta"
				}]
			})
			.expectChange("expanded", [,,,, true])
			.expectChange("name", [,,,, "Zeta", "Eta"]);

		await Promise.all([
			// code under test
			oTable.getRows()[0].getBindingContext().delete(),
			this.waitForChanges(assert, "1st delete")
		]);

		checkTable("after 1st delete", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[true, 1, "5", "", "Zeta"],
			[undefined, 2, "6", "5", "Eta"]
		], 6);

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=2&$top=2", {
				value : [
					{
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						ID : "2",
						MANAGER_ID : "1",
						Name : "Gamma"
					}, {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "collapsed", // "leaf" is similar (nothing to do)
						ID : "3",
						MANAGER_ID : "2",
						Name : "Delta"
					}
				]
			})
			.expectChange("expanded", [, , true, false])
			.expectChange("name", [, , "Gamma", "Delta"]);

		oTable.setFirstVisibleRow(2);

		await this.waitForChanges(assert, "scroll up closing gap");

		checkTable("before 2nd delete", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[true, 2, "2", "1", "Gamma"],
			[false, 3, "3", "2", "Delta"]
		]);

		this.expectRequest("DELETE EMPLOYEES('3')")
			.expectChange("expanded", [,, undefined, true]) // Gamma becomes leaf
			.expectChange("name", [,,, "Zeta"]);

		await Promise.all([
			oTable.getRows()[1].getBindingContext().delete(), // code under test
			this.waitForChanges(assert, "2nd delete")
		]);

		checkTable("after 2nd delete", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[undefined, 2, "2", "1", "Gamma"],
			[true, 1, "5", "", "Zeta"]
		]);

		this.expectChange("expanded", [, true, undefined])
			.expectChange("name", [, "Beta", "Gamma"]);

		oTable.setFirstVisibleRow(1);

		await this.waitForChanges(assert, "make Beta visible");

		checkTable("after making Beta visible", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[true, 1, "1", "", "Beta"],
			[undefined, 2, "2", "1", "Gamma"]
		]);

		this.expectChange("expanded", [, false, true])
			.expectChange("name", [,, "Zeta"]);

		oTable.getRows()[0].getBindingContext().collapse();

		await this.waitForChanges(assert, "collapse Beta");

		checkTable("after collapse", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[false, 1, "1", "", "Beta"],
			[true, 1, "5", "", "Zeta"]
		]);
	});

	//*********************************************************************************************
	// Scenario: Delete node Epsilon, preloaded via expandTo and expanded manually. Its parent Delta
	// is not loaded yet. Collapse Beta to see that it is not accidentally adjusted instead of
	// Delta. Collapse Alpha to see that it has been adjusted.
	// JIRA: CPOUI5ODATAV4-2302
	QUnit.test("Recursive Hierarchy: delete & expandTo, invisible parent", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 3,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="3">
	<Text id="expanded" text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
	<Text text="{MANAGER_ID}"/>
	<Text id="name" text="{Name}"/>
</t:Table>`;

		// 0 Alpha
		//    1 Beta
		//       2 Gamma
		//    3 Delta (invisible parent)
		//       4 Epsilon (deleted)
		//          4.1 Omega
		// 5 Zeta
		// 6 Theta
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "7",
				value : [{
					DescendantCount : "4",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					DescendantCount : "1",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "2",
					MANAGER_ID : "1",
					Name : "Gamma"
				}]
			})
			.expectChange("expanded", [true, true, undefined])
			.expectChange("name", ["Alpha", "Beta", "Gamma"]);

		await this.createView(assert, sView, oModel);

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',"
					+ "NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=4&$top=3", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "collapsed",
					ID : "4",
					MANAGER_ID : "3",
					Name : "Epsilon"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "5",
					MANAGER_ID : null,
					Name : "Zeta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "6",
					MANAGER_ID : null,
					Name : "Theta"
				}]
			})
			.expectChange("expanded", [,,,, false])
			.expectChange("name", [,,,, "Epsilon", "Zeta", "Theta"]);

		const oTable = this.oView.byId("table");
		oTable.setFirstVisibleRow(4);

		await this.waitForChanges(assert, "scroll down creating gap");

		this.expectRequest("EMPLOYEES?$apply=descendants($root/EMPLOYEES,OrgChart,ID"
				+ ",filter(ID eq '4'),1)&$select=DrillState,ID,MANAGER_ID,Name&$count=true"
				+ "&$skip=0&$top=3", {
				"@odata.count" : "1",
				value : [{
					DrillState : "leaf",
					ID : "4.1",
					MANAGER_ID : "4",
					Name : "Omega"
				}]
			})
			.expectChange("expanded", [,,,, true])
			.expectChange("name", [,,,,, "Omega", "Zeta"]);

		await Promise.all([
			oTable.getRows()[0].getBindingContext().expand(),
			this.waitForChanges(assert, "expand Epsilon")
		]);

		checkTable("after expanding Epsilon", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('4')",
			"/EMPLOYEES('4.1')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[true, 3, "4", "3", "Epsilon"],
			[undefined, 4, "4.1", "4", "Omega"],
			[undefined, 1, "5", "", "Zeta"]
		], 8);

		this.expectRequest("DELETE EMPLOYEES('4')")
			// Note: the table sets the first visible row to 3 due to the length
			.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=3&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					MANAGER_ID : "0",
					Name : "Delta"
				}]
			})
			.expectChange("expanded", [,,,, false]) // Epsilon is collapsed before the delete
			.expectChange("name", [,,, "Delta", "Zeta", "Theta"]);

		await Promise.all([
			oTable.getRows()[0].getBindingContext().delete(),
			this.waitForChanges(assert, "delete")
		]);

		checkTable("after delete", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[undefined, "2", "3", "0", "Delta"],
			[undefined, "1", "5", "", "Zeta"],
			[undefined, "1", "6", "", "Theta"]
		]);

		this.expectChange("expanded", [true, true])
			.expectChange("name", ["Alpha", "Beta", "Gamma"]);

		oTable.setFirstVisibleRow(0);

		await this.waitForChanges(assert, "make Alpha & Beta visible");

		this.expectChange("expanded", [, false])
			.expectChange("name", [,, "Delta"]);

		oTable.getRows()[1].getBindingContext().collapse();

		await this.waitForChanges(assert, "collapse Beta");

		checkTable("after collapsing Beta", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[true, 1, "0", "", "Alpha"],
			[false, 2, "1", "0", "Beta"],
			[undefined, 2, "3", "0", "Delta"]
		]);

		this.expectChange("expanded", [false, undefined])
			.expectChange("name", [, "Zeta", "Theta"]);

		oTable.getRows()[0].getBindingContext().collapse();

		await this.waitForChanges(assert, "collapse Alpha");

		checkTable("after collapsing Alpha", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[false, 1, "0", "", "Alpha"],
			[undefined, 1, "5", "", "Zeta"],
			[undefined, 1, "6", "", "Theta"]
		]);
	});

	//*********************************************************************************************
	// Scenario: Delete node Beta, preloaded via expandTo. Its parent is not loaded yet, hence no
	// ancestor can be found at all. Before the deletion collapse Gamma manually. See that after the
	// deletion Epsilon is requested correctly when Gamma is expanded again.
	// JIRA: CPOUI5ODATAV4-2302
	QUnit.test("Recursive Hierarchy: delete & expandTo, parent missing", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table firstVisibleRow="1" id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 3,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="3">
	<Text id="expanded" text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
	<Text text="{MANAGER_ID}"/>
	<Text id="name" text="{Name}"/>
</t:Table>`;

		// 0 Alpha (invisible parent)
		//    1 Beta (delete)
		//    2 Gamma (manually collapsed before delete)
		//       3 Delta (loaded before the delete)
		//       4 Epsilon (loaded when re-expanding after the delete)
		//    5 Zeta
		//    6 Eta
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$count=true&$skip=1&$top=3", {
				"@odata.count" : "7",
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					DescendantCount : "2",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "2",
					MANAGER_ID : "0",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "3",
					MANAGER_ID : "2",
					Name : "Delta"
				}]
			})
			.expectChange("expanded", [, undefined, true, undefined])
			.expectChange("name", [, "Beta", "Gamma", "Delta"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[undefined, 2, "1", "0", "Beta"],
			[true, 2, "2", "0", "Gamma"],
			[undefined, 3, "3", "2", "Delta"]
		], 7);

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=5&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "5",
					MANAGER_ID : "0",
					Name : "Zeta"
				}]
			})
			.expectChange("expanded", [,, false])
			.expectChange("name", [,,, "Zeta"]);

		oTable.getRows()[1].getBindingContext().collapse();

		await this.waitForChanges(assert, "collapse Gamma");

		checkTable("after collapsing Gamma", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('5')"
		], [
			[undefined, 2, "1", "0", "Beta"],
			[false, 2, "2", "0", "Gamma"],
			[undefined, 2, "5", "0", "Zeta"]
		], 5);

		this.expectRequest("DELETE EMPLOYEES('1')")
			.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=5&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "6",
					MANAGER_ID : "0",
					Name : "Eta"
				}]
			})
			.expectChange("expanded", [, false, undefined])
			.expectChange("name", [, "Gamma", "Zeta", "Eta"]);

		await Promise.all([
			oTable.getRows()[0].getBindingContext().delete(),
			this.waitForChanges(assert, "delete Beta")
		]);

		checkTable("after delete Beta", assert, oTable, [
			"/EMPLOYEES('2')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[false, 2, "2", "0", "Gamma"],
			[undefined, 2, "5", "0", "Zeta"],
			[undefined, 2, "6", "0", "Eta"]
		], 4);

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=3)"
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$skip=3&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "4",
					MANAGER_ID : "2",
					Name : "Epsilon"
				}]
			})
			.expectChange("expanded", [, true])
			.expectChange("name", [,, "Delta", "Epsilon"]);

		oTable.getRows()[0].getBindingContext().expand();

		await this.waitForChanges(assert, "expand Gamma");

		checkTable("after expand Gamma", assert, oTable, [
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[true, 2, "2", "0", "Gamma"],
			[undefined, 3, "3", "2", "Delta"],
			[undefined, 3, "4", "2", "Epsilon"]
		], 6);
	});

	//*********************************************************************************************
	// Scenario: Show the single root node of a recursive hierarchy, which happens to be a leaf.
	// Create two new child nodes ("Beta", "Gamma") underneath.
	// Note: The "_Friend" navigation property is misused in order to have an artist play the role
	// of a hierarchy directory. This way, a draft root object is available (as needed by real
	// services).
	// JIRA: CPOUI5ODATAV4-2225
	//
	// Create new child and cancel immediately (JIRA: CPOUI5ODATAV4-2272)
	// @odata.bind in POST relative to resource path (BCP: 2380119648)
	//
	// Move "Gamma" so that "Beta" becomes its parent, then move it back again. Collapse the root,
	// request a side effect for all rows (two times, JIRA: CPOUI5ODATAV4-2385), and expand the root
	// again. Start a move, but cancel it. Move "Beta" so that "Gamma" becomes its parent (no change
	// to context's index). Observe property change events for "@odata.etag".
	// JIRA: CPOUI5ODATAV4-2226
	//
	// Create a new root via "@$ui5.node.parent" : null (JIRA: CPOUI5ODATAV4-2355)
	// Move "Beta" to make it a root node (JIRA: CPOUI5ODATAV4-2399)
	// Display NodeID on UI, request NodeID after creation (JIRA: CPOUI5ODATAV4-2381)
	// NodeID must ignore list's filters (SNOW: DINC0087713)
	//
	// "Refresh single" for stale elements; keep same context instance for created nodes throughout
	// collapse and side effects.
	// JIRA: CPOUI5ODATAV4-2374
	//
	// Selection survives a move (JIRA: CPOUI5ODATAV4-1944)
	//
	// Nodes affected by a move are "in place"; use "expand all" to avoid side-effects refresh
	// JIRA: CPOUI5ODATAV4-2466
[false, true].forEach(function (bResetViaModel) {
	const sTitle = `Recursive Hierarchy: create new children, move 'em, model=${bResetViaModel}`;
	QUnit.test(sTitle, function (assert) {
		var oBeta, oBetaCreated, oGamma, oGammaCreated, oListBinding, oNewRoot, fnRespond, oRoot,
			oTable;

		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sFriend = "/Artists(ArtistID='99',IsActiveEntity=false)/_Friend";
		const sBaseUrl = sFriend.slice(1) + "?$apply=ancestors($root" + sFriend
			+ ",OrgChart,_/NodeID,filter(sendsAutographs),keep start)"
			+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
			+ ",HierarchyQualifier='OrgChart',NodeProperty='_/NodeID')";
		// no "filter(sendsAutographs)" (SNOW: DINC0087713)
		const sBaseUrlNoFilter = sFriend.slice(1)
			+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
			+ ",HierarchyQualifier='OrgChart',NodeProperty='_/NodeID')";
		const sView = `
<FlexBox id="form" binding="{/Artists(ArtistID='99',IsActiveEntity=false)}">
<t:Table id="table" rows="{path : '_Friend',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : 'OrgChart'
			},
			$$ownRequest : true,
			$filter : 'sendsAutographs'
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.context.isTransient} }"/>
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text id="etag" text="{= %{@odata.etag} }"/>
	<Text id="name" text="{Name}"/>
	<Text id="id" text="{_/NodeID}"/>
</t:Table>
</FlexBox>`;
		const that = this;

		this.expectRequest(sBaseUrl + "&$select=ArtistID,IsActiveEntity,Name"
				+ ",_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "1",
				value : [{
					"@odata.etag" : "etag0.0",
					ArtistID : "0",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "0,false"
					}
				}]
			})
			.expectChange("etag", ["etag0.0"])
			.expectChange("name", ["Alpha"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oRoot = oTable.getRows()[0].getBindingContext();
			oListBinding = oRoot.getBinding();
			assert.throws(function () {
				// code under test
				oListBinding.getHeaderContext().move({parent : null});
			}, new Error("Cannot move " + sFriend));
			assert.throws(function () {
				// code under test
				oRoot.move({parent : oListBinding.getHeaderContext()});
			}, new Error("Cannot move to " + sFriend));

			checkTable("root is leaf", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)"
			], [
				[undefined, undefined, 1, "etag0.0", "Alpha", "0,false"]
			]);
			assert.strictEqual(oRoot.getIndex(), 0);
			assert.deepEqual(oRoot.getObject("_"), {NodeID : "0,false"});

			// code under test (JIRA: CPOUI5ODATAV4-2272)
			const oLostChild = oListBinding.create({
				"@$ui5.node.parent" : oRoot,
				Name : "n/a"
			}, /*bSkipRefresh*/true);

			assert.ok(oModel.hasPendingChanges());
			assert.ok(oListBinding.getContext().hasPendingChanges());

			return Promise.all([
				// code under test (SNOW: DINC0100326)
				(bResetViaModel ? oModel : oListBinding.getContext()).resetChanges(),
				that.waitForChanges(assert, "reset changes"),
				checkCanceled(assert, oLostChild.created())
			]);
		}).then(function () {
			assert.notOk(oModel.hasPendingChanges());
			assert.notOk(oListBinding.getContext().hasPendingChanges());

			that.expectChange("etag", [, undefined])
				.expectChange("name", [, "Beta"])
				.expectRequest({
					method : "POST",
					url : sFriend.slice(1),
					payload : {
						"BestFriend@odata.bind" : "../Artists(ArtistID='0',IsActiveEntity=false)",
						Name : "Beta"
					}
				}, new Promise(function (resolve) {
					fnRespond = resolve.bind(null, {
						"@odata.etag" : "etag1.0",
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "Beta: ", // side effect
						_ : null // not available w/ RAP for a non-hierarchical request
					});
				}));

			// code under test
			oBeta = oListBinding.create({
				"@$ui5.node.parent" : oRoot,
				Name : "Beta"
			}, /*bSkipRefresh*/true);
			oBetaCreated = oBeta.created();
			assert.throws(function () {
				// code under test
				oBeta.move({parent : null});
			}, new Error("Cannot move " + oBeta), "too early");
			assert.throws(function () {
				// code under test
				oRoot.move({parent : oBeta});
			}, new Error("Cannot move to " + oBeta), "too early");

			return that.waitForChanges(assert, "create 1st child");
		}).then(function () {
			checkTable("during creation", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "($uid=...)"
			], [
				[undefined, true, 1, "etag0.0", "Alpha", "0,false"],
				[true, undefined, 2, "", "Beta", ""]
			]);
			assert.strictEqual(oBeta.getIndex(), 1);

			that.expectRequest({
					batchNo : 3,
					url : sBaseUrl + "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
						+ "&$select=_/Limited_Rank"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							Limited_Rank : "1"
						}
					}]
				})
				.expectRequest({ // no "filter(sendsAutographs)" (SNOW: DINC0087713)
					batchNo : 3,
					url : sBaseUrlNoFilter + "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
						+ "&$select=_/NodeID"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							NodeID : "1,false"
						}
					}]
				})
				.expectChange("etag", [, "etag1.0"])
				.expectChange("name", [, "Beta: "]);

			fnRespond();

			return Promise.all([
				oBetaCreated,
				that.waitForChanges(assert, "respond")
			]);
		}).then(function () {
			checkTable("after creation", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='1',IsActiveEntity=false)"
			], [
				[undefined, true, 1, "etag0.0", "Alpha", "0,false"],
				[false, undefined, 2, "etag1.0", "Beta: ", "1,false"]
			]);
			assert.strictEqual(oBeta.getIndex(), 1);
			assert.deepEqual(oBeta.getObject(), {
				"@$ui5.context.isTransient" : false,
				"@$ui5.node.level" : 2,
				"@odata.etag" : "etag1.0",
				ArtistID : "1",
				IsActiveEntity : false,
				Name : "Beta: ",
				_ : {
					NodeID : "1,false"
				}
			});
			checkCreatedPersisted(assert, oBeta, oBetaCreated);

			// code under test (JIRA: CPOUI5ODATAV4-2272)
			const oLostChild = oListBinding.create({
				"@$ui5.node.parent" : oRoot,
				Name : "n/a"
			}, /*bSkipRefresh*/true);
			oModel.resetChanges();

			that.expectChange("etag", [, undefined, "etag1.0"])
				.expectChange("name", [, "Gamma", "Beta: "])
				.expectRequest({
					batchNo : 4,
					method : "POST",
					url : sFriend.slice(1),
					payload : {
						"BestFriend@odata.bind" : "../Artists(ArtistID='0',IsActiveEntity=false)",
						Name : "Gamma"
					}
				}, {
					"@odata.etag" : "etag2.0",
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Gamma: ", // side effect
					_ : null // not available w/ RAP for a non-hierarchical request
				})
				.expectRequest({
					batchNo : 5,
					url : sBaseUrl + "&$filter=ArtistID eq '2' and IsActiveEntity eq false"
						+ "&$select=_/Limited_Rank"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							Limited_Rank : "2"
						}
					}]
				})
				.expectRequest({ // no "filter(sendsAutographs)" (SNOW: DINC0087713)
					batchNo : 5,
					url : sBaseUrlNoFilter + "&$filter=ArtistID eq '2' and IsActiveEntity eq false"
						+ "&$select=_/NodeID"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							NodeID : "2,false"
						}
					}]
				})
				.expectChange("etag", [, "etag2.0"])
				.expectChange("name", [, "Gamma: "]);

			// code under test
			oGamma = oListBinding.create({
				"@$ui5.node.parent" : oRoot,
				Name : "Gamma"
			}, /*bSkipRefresh*/true);
			oGammaCreated = oGamma.created();
			oGamma.setSelected(true);

			assert.strictEqual(oGamma.getIndex(), 1);

			return Promise.all([
				checkCanceled(assert, oLostChild.created()),
				oGammaCreated,
				that.waitForChanges(assert, "create 2nd child")
			]);
		}).then(function () {
			checkTable("after 2nd creation", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='2',IsActiveEntity=false)",
				sFriend + "(ArtistID='1',IsActiveEntity=false)"
			], [
				[undefined, true, 1, "etag0.0", "Alpha", "0,false"],
				[false, undefined, 2, "etag2.0", "Gamma: ", "2,false"],
				[false, undefined, 2, "etag1.0", "Beta: ", "1,false"]
			]);
			checkCreatedPersisted(assert, oGamma, oGammaCreated);

			that.expectRequest({
					batchNo : 6,
					headers : {
						"If-Match" : "etag2.0",
						Prefer : "return=minimal"
					},
					method : "PATCH",
					url : "Artists(ArtistID='2',IsActiveEntity=false)",
					payload : {
						"BestFriend@odata.bind" : "Artists(ArtistID='1',IsActiveEntity=false)"
					}
				}, null, {ETag : "n/a"}) // 204 No Content
				.expectRequest({ // side-effects refresh
					batchNo : 6,
					url : sBaseUrl + "&$filter=ArtistID eq '2' and IsActiveEntity eq false"
						+ "&$select=_/Limited_Rank"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							Limited_Rank : "2" // Edm.Int64
						}
					}]
				})
				.expectRequest({ // implicitly kept alive by selection
					batchNo : 6,
					url : sFriend.slice(1) + "?$filter=ArtistID eq '2' and IsActiveEntity eq false"
						+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				}, {
					value : [{
						"@odata.etag" : "etag2.1*",
						ArtistID : "2",
						IsActiveEntity : false,
						Name : "Gamma: ",
						_ : {
							NodeID : "2,false"
						}
					}]
				})
				.expectRequest({ // side-effects refresh
					batchNo : 6,
					url : sBaseUrl + "&$select=ArtistID,IsActiveEntity,Name"
						+ ",_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID"
						+ "&$count=true&$skip=0&$top=3"
				}, {
					"@odata.count" : "3",
					value : [{
						"@odata.etag" : "etag0.1",
						ArtistID : "0",
						IsActiveEntity : false,
						Name : "Alpha: ",
						_ : {
							DescendantCount : "2",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							NodeID : "0,false"
						}
					}, {
						"@odata.etag" : "etag1.1",
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "Beta: ",
						_ : {
							DescendantCount : "1",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							NodeID : "1,false"
						}
					}, {
						"@odata.etag" : "etag2.1",
						ArtistID : "2",
						IsActiveEntity : false,
						Name : "Gamma: ",
						_ : {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							NodeID : "2,false"
						}
					}]
				})
				.expectChange("etag", [, "etag2.1*"]) // Note: property changed before context moved
				.expectChange("name", [, "Gamma: "])
				.expectChange("etag", ["etag0.1", "etag1.1", "etag2.1"])
				.expectChange("name", ["Alpha: ", "Beta: ", "Gamma: "]);

			return Promise.all([
				// code under test
				oGamma.move({parent : oBeta}),
				that.waitForChanges(assert, "move")
			]);
		}).then(function () {
			checkTable("after move", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='1',IsActiveEntity=false)",
				sFriend + "(ArtistID='2',IsActiveEntity=false)"
			], [
				[undefined, true, 1, "etag0.1", "Alpha: ", "0,false"],
				[undefined, true, 2, "etag1.1", "Beta: ", "1,false"],
				[undefined, undefined, 3, "etag2.1", "Gamma: ", "2,false"]
			]);

			assert.strictEqual(oBeta.getIndex(), 1);
			assert.deepEqual(oBeta.getObject(), {
				"@$ui5.node.isExpanded" : true,
				"@$ui5.node.level" : 2,
				"@odata.etag" : "etag1.1",
				ArtistID : "1",
				IsActiveEntity : false,
				Name : "Beta: ",
				_ : {
					NodeID : "1,false"
				}
			});
			checkPersisted(assert, oBeta);

			assert.strictEqual(oGamma.getIndex(), 2);
			checkSelected(assert, oGamma, true);
			assert.deepEqual(oGamma.getObject(), {
				"@$ui5.context.isSelected" : true,
				"@$ui5.node.level" : 3,
				"@odata.etag" : "etag2.1",
				ArtistID : "2",
				IsActiveEntity : false,
				Name : "Gamma: ",
				_ : {
					NodeID : "2,false"
				}
			});
			checkPersisted(assert, oGamma);

			assert.throws(function () {
				// code under test
				oRoot.move({parent : oGamma});
			}, new Error("Unsupported parent context: " + oGamma));

			that.expectRequest({
					batchNo : 7,
					headers : {
						"If-Match" : "etag2.1",
						Prefer : "return=minimal"
					},
					method : "PATCH",
					url : "Artists(ArtistID='2',IsActiveEntity=false)",
					payload : {
						"BestFriend@odata.bind" : "Artists(ArtistID='0',IsActiveEntity=false)"
					}
				}, null, {ETag : "etag2.2"}) // 204 No Content
				.expectRequest({
					batchNo : 7,
					url : sBaseUrl + "&$filter=ArtistID eq '2' and IsActiveEntity eq false"
						+ "&$select=_/Limited_Rank"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							Limited_Rank : "1" // moved *before* "Beta"
						}
					}]
				})
				.expectChange("etag", [,, "etag2.2"]) // Note: property changed before context moved
				.expectChange("etag", [, "etag2.2", "etag1.1"])
				.expectChange("name", [, "Gamma: ", "Beta: "]);

			return Promise.all([
				// code under test
				oGamma.move({parent : oRoot}),
				that.waitForChanges(assert, "move back")
			]);
		}).then(function () {
			checkTable("after move back", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='2',IsActiveEntity=false)",
				sFriend + "(ArtistID='1',IsActiveEntity=false)"
			], [
				[undefined, true, 1, "etag0.1", "Alpha: ", "0,false"],
				[undefined, undefined, 2, "etag2.2", "Gamma: ", "2,false"],
				[undefined, undefined, 2, "etag1.1", "Beta: ", "1,false"]
			]);

			assert.strictEqual(oGamma.getIndex(), 1);
			assert.deepEqual(oGamma.getObject(), {
				"@$ui5.context.isSelected" : true,
				"@$ui5.node.level" : 2,
				"@odata.etag" : "etag2.2",
				ArtistID : "2",
				IsActiveEntity : false,
				Name : "Gamma: ",
				_ : {
					NodeID : "2,false"
				}
			});
			checkPersisted(assert, oGamma);
			oGamma.setSelected(false); //TODO does not work together with collapse...

			assert.strictEqual(oBeta.getIndex(), 2);
			assert.deepEqual(oBeta.getObject(), {
				"@$ui5.node.level" : 2,
				"@odata.etag" : "etag1.1",
				ArtistID : "1",
				IsActiveEntity : false,
				Name : "Beta: ",
				_ : {
					NodeID : "1,false"
				}
			});
			checkPersisted(assert, oBeta);

			// code under test
			oRoot.collapse();

			return that.waitForChanges(assert, "collapse root");
		}).then(function () {
			checkTable("after collapse", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)"
			], [
				[undefined, false, 1, "etag0.1", "Alpha: ", "0,false"]
			], 1);
			// Note: this holds only for "created (persisted)"!
			assert.strictEqual(oBeta.getModel(), undefined, "destroyed by collapse");
			assert.strictEqual(oGamma.getModel(), undefined, "destroyed by collapse");
			oBeta = null;
			oGamma = null;

			that.expectRequest(sFriend.slice(1)
					+ "?$filter=ArtistID eq '0' and IsActiveEntity eq false"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID", {
					value : [{
						"@odata.etag" : "etag0.2",
						ArtistID : "0",
						IsActiveEntity : false,
						Name : "Alpha #1", // "side effect"
						_ : null // not available w/ RAP for a non-hierarchical request
					}]
				})
				.expectChange("etag", ["etag0.2"])
				.expectChange("name", ["Alpha #1"]);

			return Promise.all([
				// code under test
				oListBinding.getHeaderContext().requestSideEffects(["Name"]),
				that.waitForChanges(assert, "side effect: Name for all rows")
			]);
		}).then(function () {
			// NodeID is not lost after requesting side effects with non-hierarchical requests
			assert.deepEqual(oRoot.getObject("_"), {NodeID : "0,false"});

			that.expectRequest(sBaseUrl + "&$select=ArtistID,IsActiveEntity,Name"
					+ ",_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID"
					+ "&$skip=1&$top=2", {
					value : [{
						"@odata.etag" : "etag2.3",
						ArtistID : "2",
						IsActiveEntity : false,
						Name : "Gamma #1", // "side effect"
						_ : {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							NodeID : "2,false"
						}
					}, {
						"@odata.etag" : "etag1.3",
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "Beta #1", // "side effect"
						_ : {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							NodeID : "1,false"
						}
					}]
				})
				.expectChange("etag", [, "etag2.3", "etag1.3"])
				.expectChange("name", [, "Gamma #1", "Beta #1"]);

			// code under test
			oRoot.expand();

			return that.waitForChanges(assert, "expand root again");
		}).then(function () {
			checkTable("after expand root again", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='2',IsActiveEntity=false)",
				sFriend + "(ArtistID='1',IsActiveEntity=false)"
			], [
				[undefined, true, 1, "etag0.2", "Alpha #1", "0,false"],
				[undefined, undefined, 2, "etag2.3", "Gamma #1", "2,false"],
				[undefined, undefined, 2, "etag1.3", "Beta #1", "1,false"]
			]);
			const aCurrentContexts = oListBinding.getCurrentContexts();
			assert.strictEqual(oRoot, aCurrentContexts[0]);
			//TODO assert.strictEqual(oGamma, aCurrentContexts[1]);
			oGamma = aCurrentContexts[1];
			oBeta = aCurrentContexts[2];

			assert.strictEqual(oGamma.getIndex(), 1);
			assert.deepEqual(oGamma.getObject(), {
				//TODO "@$ui5.context.isSelected" : true,
				"@$ui5.node.level" : 2,
				"@odata.etag" : "etag2.3",
				ArtistID : "2",
				IsActiveEntity : false,
				Name : "Gamma #1",
				_ : {
					NodeID : "2,false"
				}
			});
			checkPersisted(assert, oGamma);

			assert.strictEqual(oBeta.getIndex(), 2);
			assert.deepEqual(oBeta.getObject(), {
				"@$ui5.node.level" : 2,
				"@odata.etag" : "etag1.3",
				ArtistID : "1",
				IsActiveEntity : false,
				Name : "Beta #1",
				_ : {
					NodeID : "1,false"
				}
			});
			checkPersisted(assert, oBeta);

			that.expectRequest(sBaseUrl + "&$filter=ArtistID eq '2' and IsActiveEntity eq false"
					+ "&$select=_/Limited_Rank", {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							Limited_Rank : "1" //TODO should be canceled as well?
						}
					}]
				});

			return Promise.all([
				checkCanceled(assert, oGamma.move({parent : oBeta})),
				// code under test
				oModel.resetChanges(),
				that.waitForChanges(assert, "move canceled")
			]);
		}).then(function () {
			that.expectRequest({
					batchNo : 11,
					headers : {
						"If-Match" : "etag1.3",
						Prefer : "return=minimal"
					},
					method : "PATCH",
					url : "Artists(ArtistID='1',IsActiveEntity=false)",
					payload : {
						"BestFriend@odata.bind" : "Artists(ArtistID='2',IsActiveEntity=false)"
					}
				}, null, {ETag : "etag1.4"}) // 204 No Content
				.expectRequest({
					batchNo : 11,
					url : sBaseUrl + "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
						+ "&$select=_/Limited_Rank"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							Limited_Rank : "2"
						}
					}]
				})
				.expectChange("etag", [,, "etag1.4"]);

			return Promise.all([
				// code under test
				oBeta.move({parent : oGamma}), // Note: child's index does not change!
				that.waitForChanges(assert, "new parent already right before child")
			]);
		}).then(function () {
			checkTable("after 'new parent already right before child'", assert, oTable, [
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='2',IsActiveEntity=false)",
				sFriend + "(ArtistID='1',IsActiveEntity=false)"
			], [
				[undefined, true, 1, "etag0.2", "Alpha #1", "0,false"],
				[undefined, true, 2, "etag2.3", "Gamma #1", "2,false"],
				[undefined, undefined, 3, "etag1.4", "Beta #1", "1,false"]
			]);
			const aCurrentContexts = oListBinding.getCurrentContexts();
			assert.strictEqual(oRoot, aCurrentContexts[0]);
			assert.strictEqual(oGamma, aCurrentContexts[1]);
			assert.strictEqual(oBeta, aCurrentContexts[2], "same instance");

			assert.strictEqual(oGamma.getIndex(), 1);
			assert.deepEqual(oGamma.getObject(), {
				//TODO "@$ui5.context.isSelected" : true,
				"@$ui5.node.isExpanded" : true,
				"@$ui5.node.level" : 2,
				"@odata.etag" : "etag2.3",
				ArtistID : "2",
				IsActiveEntity : false,
				Name : "Gamma #1",
				_ : {
					NodeID : "2,false"
				}
			});
			checkPersisted(assert, oGamma);

			assert.strictEqual(oBeta.getIndex(), 2); // unchanged by #move
			assert.deepEqual(oBeta.getObject(), {
				"@$ui5.node.level" : 3,
				"@odata.etag" : "etag1.4",
				ArtistID : "1",
				IsActiveEntity : false,
				Name : "Beta #1",
				_ : {
					NodeID : "1,false"
				}
			});
			checkPersisted(assert, oBeta);

			that.expectChange("etag", [undefined, "etag0.2", "etag2.3"])
				.expectChange("name", ["Aleph", "Alpha #1", "Gamma #1"])
				.expectRequest({
					batchNo : 12,
					method : "POST",
					url : sFriend.slice(1),
					payload : {
						// not needed: "BestFriend@odata.bind" : null,
						Name : "Aleph"
					}
				}, {
					"@odata.etag" : "etag9.0",
					ArtistID : "9",
					IsActiveEntity : false,
					Name : "Aleph: ", // side effect
					_ : null // not available w/ RAP for a non-hierarchical request
				})
				.expectChange("etag", ["etag9.0"])
				.expectChange("name", ["Aleph: "])
				.expectRequest({
					batchNo : 13,
					url : sBaseUrl + "&$filter=ArtistID eq '9' and IsActiveEntity eq false"
						+ "&$select=_/Limited_Rank"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							Limited_Rank : "3" // Note: out of place on UI
						}
					}]
				})
				.expectRequest({ // no "filter(sendsAutographs)" (SNOW: DINC0087713)
					batchNo : 13,
					url : sBaseUrlNoFilter + "&$filter=ArtistID eq '9' and IsActiveEntity eq false"
						+ "&$select=_/NodeID"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							NodeID : "9,false"
						}
					}]
				});

			// code under test (JIRA: CPOUI5ODATAV4-2355)
			oNewRoot = oListBinding.create({
				"@$ui5.node.parent" : null,
				Name : "Aleph"
			}, /*bSkipRefresh*/true);

			assert.strictEqual(oNewRoot.getIndex(), 0);

			return Promise.all([
				oNewRoot.created(),
				that.waitForChanges(assert, "create new root")
			]);
		}).then(function () {
			checkTable("after create new root", assert, oTable, [
				sFriend + "(ArtistID='9',IsActiveEntity=false)",
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='2',IsActiveEntity=false)",
				sFriend + "(ArtistID='1',IsActiveEntity=false)"
			], [
				[false, undefined, 1, "etag9.0", "Aleph: ", "9,false"],
				[undefined, true, 1, "etag0.2", "Alpha #1", "0,false"],
				[undefined, true, 2, "etag2.3", "Gamma #1", "2,false"]
			]);
			checkCreatedPersisted(assert, oNewRoot);

			that.expectRequest(sFriend.slice(1)
					+ "?$filter=ArtistID eq '9' and IsActiveEntity eq false"
					+ " or ArtistID eq '0' and IsActiveEntity eq false"
					+ " or ArtistID eq '2' and IsActiveEntity eq false"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
					+ "&$top=3", {
					value : [{
						"@odata.etag" : "etag9.1",
						ArtistID : "9",
						IsActiveEntity : false,
						Name : "Aleph #2",
						_ : null // not available w/ RAP for a non-hierarchical request
					}, {
						"@odata.etag" : "etag0.3",
						ArtistID : "0",
						IsActiveEntity : false,
						Name : "Alpha #2",
						_ : null // not available w/ RAP for a non-hierarchical request
					}, {
						"@odata.etag" : "etag2.4",
						ArtistID : "2",
						IsActiveEntity : false,
						Name : "Gamma #2",
						_ : null // not available w/ RAP for a non-hierarchical request
					}]
				})
				.expectChange("etag", ["etag9.1", "etag0.3", "etag2.4"])
				.expectChange("name", ["Aleph #2", "Alpha #2", "Gamma #2"]);

			return Promise.all([
				// code under test
				oListBinding.getHeaderContext().requestSideEffects(["Name"]),
				// Note: no new request expected, it's merged with the 1st one
				oListBinding.getHeaderContext().requestSideEffects(["Name"]),
				that.waitForChanges(assert, "side effect again (2x): Name for all rows")
			]);
		}).then(function () {
			checkTable("after side effect again (2x): Name for all rows", assert, oTable, [
				sFriend + "(ArtistID='9',IsActiveEntity=false)",
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='2',IsActiveEntity=false)"
			], [
				[false, undefined, 1, "etag9.1", "Aleph #2", "9,false"],
				[undefined, true, 1, "etag0.3", "Alpha #2", "0,false"],
				[undefined, true, 2, "etag2.4", "Gamma #2", "2,false"]
			], 4);
			oBeta = null;

			that.expectRequest(sBaseUrl + "&$select=ArtistID,IsActiveEntity,Name"
					+ ",_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID"
					+ "&$skip=2&$top=1", {
					value : [{
						"@odata.etag" : "etag1.5",
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "Beta #2",
						_ : {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							NodeID : "1,false"
						}
					}]
				})
				.expectChange("etag", [, "etag0.3", "etag2.4", "etag1.5"])
				.expectChange("name", [, "Alpha #2", "Gamma #2", "Beta #2"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert, "scroll down to Beta");
		}).then(function () {
			checkTable("after scroll down to Beta", assert, oTable, [
				sFriend + "(ArtistID='9',IsActiveEntity=false)",
				sFriend + "(ArtistID='0',IsActiveEntity=false)",
				sFriend + "(ArtistID='2',IsActiveEntity=false)",
				sFriend + "(ArtistID='1',IsActiveEntity=false)"
			], [
				[undefined, true, 1, "etag0.3", "Alpha #2", "0,false"],
				[undefined, true, 2, "etag2.4", "Gamma #2", "2,false"],
				[undefined, undefined, 3, "etag1.5", "Beta #2", "1,false"]
			]);
			oBeta = oListBinding.getCurrentContexts()[2];

			that.expectRequest({
					batchNo : 16,
					headers : {
						"If-Match" : "etag1.5",
						Prefer : "return=minimal"
					},
					method : "PATCH",
					url : "Artists(ArtistID='1',IsActiveEntity=false)",
					payload : {
						"BestFriend@odata.bind" : null
					}
				}, null, {ETag : "etag1.6"}) // 204 No Content
				.expectRequest({
					batchNo : 16,
					url : sBaseUrl + "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
						+ "&$select=_/Limited_Rank"
				}, {
					value : [{
						"@odata.etag" : "n/a",
						_ : {
							Limited_Rank : "0"
						}
					}]
				})
				.expectChange("etag", [,,, "etag1.6"])
				.expectChange("etag", [, "etag1.6", "etag0.3", "etag2.4"])
				.expectChange("name", [, "Beta #2", "Alpha #2", "Gamma #2"]);

			return Promise.all([
				// code under test
				oBeta.move({parent : null}),
				that.waitForChanges(assert, "move Beta to make it a root node")
			]);
		}).then(function () {
			checkCreatedPersisted(assert, oNewRoot);
			assert.strictEqual(oNewRoot.getIndex(), 0, "still out-of-place");
			assert.strictEqual(oBeta.getIndex(), 1);

			return that.checkAllContexts("after move Beta to make it a root node", assert,
				oListBinding, ["@$ui5.context.isTransient", "@$ui5.node.isExpanded",
					"@$ui5.node.level", "@odata.etag", "Name", "_/NodeID"], [
					[false, undefined, 1, "etag9.1", "Aleph #2", "9,false"], // still out-of-place
					[undefined, undefined, 1, "etag1.6", "Beta #2", "1,false"],
					[undefined, true, 1, "etag0.3", "Alpha #2", "0,false"],
					[undefined, undefined, 2, "etag2.4", "Gamma #2", "2,false"]
				]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Create a new node when all levels are expanded, observe a GET for LimitedRank. The
	// created node is inserted on the second sibling position on back end, but is shown on the
	// client on first position. Use a filter and a search as well as a sort order. Before creation,
	// a sibling is collapsed and after creation it is expanded again. The root is collapsed and
	// immediately expanded again. Finally, the new node is deleted again.
	// JIRA: CPOUI5ODATAV4-2393
	//
	// Old vs. new format of RecursiveHierarchy annotation (JIRA: CPOUI5ODATAV4-2401)
	// Display NodeID on UI, request NodeID after creation (JIRA: CPOUI5ODATAV4-2381)
	// NodeID must ignore list's filters (SNOW: DINC0087713)
	//
	// At first, create a new root node with a LimitedRank beyond all currently loaded nodes.
	// Finally, it is also deleted.
	// JIRA: CPOUI5ODATAV4-2412
["OldChart", "OrgChart"].forEach((sHierarchyQualifier) => {
	const sTitle = `Recursive Hierarchy: expand all and create for ${sHierarchyQualifier}`;
	const sLimitedRank = sHierarchyQualifier === "OldChart" ? "LimitedRank" : "Limited_Rank";

	QUnit.test(sTitle, async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sFriend = "/Artists(ArtistID='99',IsActiveEntity=false)/_Friend";
		const sBaseUrl = sFriend.slice(1) + "?$apply=ancestors"
			+ "($root/Artists(ArtistID='99',IsActiveEntity=false)/_Friend," + sHierarchyQualifier
			+ ",_/NodeID,filter(IsActiveEntity eq false)/search(covfefe),keep start)"
			+ "/orderby(ArtistID)"
			+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
			+ ",HierarchyQualifier='" + sHierarchyQualifier + "',NodeProperty='_/NodeID')";
		const sReadUrl = sBaseUrl + "&$select=ArtistID,IsActiveEntity,Name"
			+ ",_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID";
		const sView = `
<t:Table id="table" rows="{path : '/Artists(ArtistID=\\'99\\',IsActiveEntity=false)/_Friend',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : '${sHierarchyQualifier}',
				search : 'covfefe'
			},
			$filter : 'IsActiveEntity eq false',
			$orderby : 'ArtistID'
		}}" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ArtistID}"/>
	<Text text="{Name}"/>
	<Text id="id" text="{_/NodeID}"/>
</t:Table>`;

		// Note: hierarchy in server perspective
		// 0 Alpha
		//   1 Beta
		//   2 Gamma (loaded later)
		//   3 Delta (loaded later)
		//       <-- insert new on server: 9 New
		//   4 Epsilon (loaded later)
		//   5 Zeta (loaded soon)
		//     5.1 Eta (loaded soon)
		//     5.2 Theta (loaded later)
		//   6 Iota (loaded soon)
		//   7 Kappa (loaded later)
		// <-- insert new root on server: 8 Aleph
		this.expectRequest(sReadUrl + "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "10",
				value : [{
					ArtistID : "0",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "9",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "0,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "1,false"
					}
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			sFriend + "(ArtistID='0',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)"
		], [
			[true, 1, "0", "Alpha", "0,false"],
			[undefined, 2, "1", "Beta", "1,false"]
		], 10);
		const oListBinding = oTable.getBinding("rows");
		const oAlpha = oListBinding.getCurrentContexts()[0];

		// 0 Alpha
		//   1 Beta
		//   2 Gamma (loaded later)
		//   3 Delta (loaded later)
		//   4 Epsilon (loaded later)
		//   5 Zeta (loaded soon)
		//     5.1 Eta (loaded soon)
		//     5.2 Theta (loaded later)
		//   6 Iota (loaded soon)
		//   7 Kappa (loaded later)
		// 8 Aleph (created)
		this.expectRequest({
				method : "POST",
				url : sFriend.slice(1),
				payload : {
					// not needed: "BestFriend@odata.bind" : null,
					Name : "Aleph"
				}
			}, {
				ArtistID : "8",
				IsActiveEntity : false,
				Name : "Aleph",
				_ : null // not available w/ RAP for a non-hierarchical request
			})
			.expectRequest({
				batchNo : 3,
				url : sBaseUrl + "&$filter=ArtistID eq '8' and IsActiveEntity eq false"
					+ "&$select=_/" + sLimitedRank
			}, {
				value : [{
					_ : {
						[sLimitedRank] : "10" // Edm.Int64
					}
				}]
			})
			.expectRequest({
				batchNo : 3,
				// no "filter(...)/search(...)" (SNOW: DINC0087713)
				url : sFriend.slice(1) + "?$apply="
					+ "com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
					+ ",HierarchyQualifier='" + sHierarchyQualifier + "',NodeProperty='_/NodeID')"
					+ "&$filter=ArtistID eq '8' and IsActiveEntity eq false&$select=_/NodeID"
			}, {
				value : [{
					_ : {
						NodeID : "8,false"
					}
				}]
			});

		// code under test
		const oNewRoot = oListBinding.create({Name : "Aleph"}, /*bSkipRefresh*/true);

		await Promise.all([
			oNewRoot.created(),
			this.waitForChanges(assert, "create new root Aleph")
		]);

		checkTable("after create new root Aleph", assert, oTable, [
			sFriend + "(ArtistID='8',IsActiveEntity=false)",
			sFriend + "(ArtistID='0',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)"
		], [
			[undefined, 1, "8", "Aleph", "8,false"],
			[true, 1, "0", "Alpha", "0,false"]
		], 11);

		// 0 Alpha
		//   1 Beta
		//   2 Gamma (loaded later)
		//   3 Delta (loaded later)
		//   4 Epsilon (loaded later)
		//   5 Zeta
		//     5.1 Eta
		//     5.2 Theta (loaded later)
		//   6 Iota (loaded soon)
		//   7 Kappa (loaded later)
		// 8 Aleph (created)
		this.expectRequest(sReadUrl + "&$skip=5&$top=2", {
				value : [{
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Zeta",
					_ : {
						DescendantCount : "2",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "5,false"
					}
				}, {
					ArtistID : "5.1",
					IsActiveEntity : false,
					Name : "Eta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "5.1,false"
					}
				}]
			});

		oTable.setFirstVisibleRow(6);

		await this.waitForChanges(assert, "scroll to Zeta");

		checkTable("after scroll to Zeta", assert, oTable, [
			sFriend + "(ArtistID='8',IsActiveEntity=false)",
			sFriend + "(ArtistID='0',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='5.1',IsActiveEntity=false)"
		], [
			[true, 2, "5", "Zeta", "5,false"],
			[undefined, 3, "5.1", "Eta", "5.1,false"]
		], 11);
		const oZeta = oListBinding.getCurrentContexts()[0];

		// 0 Alpha
		//   1 Beta
		//   2 Gamma (loaded later)
		//   3 Delta (loaded later)
		//   4 Epsilon (loaded later)
		//   5 Zeta
		//     5.1 Eta
		//     5.2 Theta (loaded later)
		//   6 Iota
		//   7 Kappa (loaded later)
		// 8 Aleph (created)
		this.expectRequest(sReadUrl + "&$skip=8&$top=1", {
				value : [{
					ArtistID : "6",
					IsActiveEntity : false,
					Name : "Iota",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "6,false"
					}
				}]
			});

		oZeta.collapse();

		await this.waitForChanges(assert, "collapse Zeta");

		checkTable("after collapse Zeta", assert, oTable, [
			sFriend + "(ArtistID='8',IsActiveEntity=false)",
			sFriend + "(ArtistID='0',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='6',IsActiveEntity=false)"
		], [
			[false, 2, "5", "Zeta", "5,false"],
			[undefined, 2, "6", "Iota", "6,false"]
		], 9);

		oTable.setFirstVisibleRow(1); // back to Alpha (Note: Aleph outside of view!)

		// 0 Alpha
		//   1 Beta
		//   2 Gamma (loaded later)
		//   3 Delta (loaded later)
		//   9 New (created)
		//   4 Epsilon (loaded later)
		//   5 Zeta
		//     5.1 Eta
		//     5.2 Theta (loaded later)
		//   6 Iota
		//   7 Kappa (loaded later)
		// 8 Aleph (created)
		this.expectRequest({
				method : "POST",
				url : sFriend.slice(1),
				payload : {
					"BestFriend@odata.bind" : "../Artists(ArtistID='0',IsActiveEntity=false)",
					Name : "New"
				}
			}, {
				ArtistID : "9",
				IsActiveEntity : false,
				Name : "New",
				_ : null // not available w/ RAP for a non-hierarchical request
			})
			.expectRequest({
				batchNo : 7,
				url : sBaseUrl + "&$filter=ArtistID eq '9' and IsActiveEntity eq false"
					+ "&$select=_/" + sLimitedRank
			}, {
				value : [{
					_ : {
						[sLimitedRank] : "4" // Edm.Int64
					}
				}]
			})
			.expectRequest({
				batchNo : 7,
				// no "filter(...)/search(...)" (SNOW: DINC0087713)
				url : sFriend.slice(1) + "?$apply="
					+ "com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
					+ ",HierarchyQualifier='" + sHierarchyQualifier + "',NodeProperty='_/NodeID')"
					+ "&$filter=ArtistID eq '9' and IsActiveEntity eq false&$select=_/NodeID"
			}, {
				value : [{
					_ : {
						NodeID : "9,false"
					}
				}]
			});

		// code under test
		const oNewChild = oListBinding.create({
			"@$ui5.node.parent" : oAlpha,
			Name : "New"
		}, /*bSkipRefresh*/true);

		await Promise.all([
			oNewChild.created(),
			this.waitForChanges(assert, "create New")
		]);

		checkTable("after create New", assert, oTable, [
			sFriend + "(ArtistID='8',IsActiveEntity=false)",
			sFriend + "(ArtistID='0',IsActiveEntity=false)",
			sFriend + "(ArtistID='9',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='6',IsActiveEntity=false)"
		], [
			[true, 1, "0", "Alpha", "0,false"],
			[undefined, 2, "9", "New", "9,false"]
		], 10);
		assert.deepEqual(oNewChild.getObject("_"), {NodeID : "9,false"});

		// code under test
		oZeta.expand();
		oAlpha.collapse();
		oAlpha.expand();

		// 0 Alpha
		//   1 Beta
		//   2 Gamma
		//   3 Delta
		//   9 New (created)
		//   4 Epsilon
		//   5 Zeta
		//     5.1 Eta
		//     5.2 Theta
		//   6 Iota
		//   7 Kappa
		// 8 Aleph (created)
		this.expectRequest(sReadUrl + "&$skip=2&$top=2", {
				value : [{
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Gamma",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "2,false"
					}
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Delta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "3,false"
					}
				}]
			})
			.expectRequest(sReadUrl + "&$skip=5&$top=1", {
				value : [{
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}]
			})
			.expectRequest(sReadUrl + "&$skip=8&$top=1", {
				value : [{
					ArtistID : "5.2",
					IsActiveEntity : false,
					Name : "Theta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "5.2,false"
					}
				}]
			})
			.expectRequest(sReadUrl + "&$skip=10&$top=1", {
				value : [{
					ArtistID : "7",
					IsActiveEntity : false,
					Name : "Kappa",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "7,false"
					}
				}]
			});

		await this.checkAllContexts("after loading all rows", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[undefined, 1, "8", "Aleph"],
				[true, 1, "0", "Alpha"],
				[undefined, 2, "9", "New"],
				[undefined, 2, "1", "Beta"],
				[undefined, 2, "2", "Gamma"],
				[undefined, 2, "3", "Delta"],
				[undefined, 2, "4", "Epsilon"],
				[true, 2, "5", "Zeta"],
				[undefined, 3, "5.1", "Eta"],
				[undefined, 3, "5.2", "Theta"],
				[undefined, 2, "6", "Iota"],
				[undefined, 2, "7", "Kappa"]
			]);

		this.expectRequest("DELETE Artists(ArtistID='8',IsActiveEntity=false)")
			.expectRequest("DELETE Artists(ArtistID='9',IsActiveEntity=false)");

		// code under test
		const oDeleteNewRootPromise = oNewRoot.delete();

		assert.throws(function () {
			// code under test
			oNewRoot.move({parent : null});
		}, new Error("Cannot move " + oNewRoot), "too late");
		assert.throws(function () {
			// code under test
			oNewChild.move({parent : oNewRoot});
		}, new Error("Cannot move to " + oNewRoot), "too late");

		await Promise.all([
			oDeleteNewRootPromise,
			// code under test
			oNewChild.delete(),
			this.waitForChanges(assert, "delete New")
		]);

		await this.checkAllContexts("after deleting new nodes", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name", "_/NodeID"], [
				[true, 1, "0", "Alpha", "0,false"],
				[undefined, 2, "1", "Beta", "1,false"],
				[undefined, 2, "2", "Gamma", "2,false"],
				[undefined, 2, "3", "Delta", "3,false"],
				[undefined, 2, "4", "Epsilon", "4,false"],
				[true, 2, "5", "Zeta", "5,false"],
				[undefined, 3, "5.1", "Eta", "5.1,false"],
				[undefined, 3, "5.2", "Theta", "5.2,false"],
				[undefined, 2, "6", "Iota", "6,false"],
				[undefined, 2, "7", "Kappa", "7,false"]
			]);
	});
});

	//*********************************************************************************************
	// Scenario: Expand all levels of a recursive hierarchy with two roots ("Alpha", "Omega").
	// Collapse "Beta". Move "Alpha" so that "Omega" becomes its parent, either as an expanded node
	// with children or by first collapsing and later expanding. Check that its children are moved
	// as well.
	// JIRA: CPOUI5ODATAV4-2325
	//
	// Move "Kappa" so that "Beta" becomes its parent, thus expanding it again, then check the
	// level of the latter's children.
	// JIRA: CPOUI5ODATAV4-2326
	//
	// A failed move must not leave the node collapsed (JIRA: CPOUI5ODATAV4-2343)
	//
	// Nodes affected by a move are "in place"; use "expand all" to avoid side-effects refresh
	// JIRA: CPOUI5ODATAV4-2466
	//
	// Determine the parent nodes of "Alpha", "Beta", "Kappa", and "Omega".
	// JIRA: CPOUI5ODATAV4-2323
[false, true].forEach((bMoveCollapsed) => {
	const sTitle = `Recursive Hierarchy: move node w/ children, collapsed=${bMoveCollapsed}`;

	QUnit.test(sTitle, async function (assert) {
		const sBaseUrl = "EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
			+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID')";
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="7">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text id="id" text="{ID}"/>
	<Text text="{MANAGER_ID}"/>
	<Text text="{Name}"/>
	<Text text="{AGE}"/>
</t:Table>`;

		// 0 Alpha
		//   1 Beta
		//     1.1 Gamma
		//     1.2 Zeta
		//   2 Kappa
		//   3 Lambda
		// 9 Omega
		this.expectRequest(sBaseUrl
				+ "&$select=AGE,DescendantCount,DistanceFromRoot,DrillState,ID,MANAGER_ID,Name"
				+ "&$count=true&$skip=0&$top=7", {
				"@odata.count" : "7",
				value : [{
					AGE : 60,
					DescendantCount : "5",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					MANAGER_ID : null,
					Name : "Alpha"
				}, {
					AGE : 55,
					DescendantCount : "2",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "1",
					MANAGER_ID : "0",
					Name : "Beta"
				}, {
					AGE : 41,
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "1.1",
					MANAGER_ID : "1",
					Name : "Gamma"
				}, {
					AGE : 42,
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "1.2",
					MANAGER_ID : "1",
					Name : "Zeta"
				}, {
					AGE : 56,
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					MANAGER_ID : "0",
					Name : "Kappa"
				}, {
					AGE : 57,
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					MANAGER_ID : "0",
					Name : "Lambda"
				}, {
					AGE : 69,
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "9",
					MANAGER_ID : null,
					Name : "Omega"
				}]
			})
			.expectChange("id", ["0", "1", "1.1", "1.2", "2", "3", "9"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('1.1')",
			"/EMPLOYEES('1.2')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('9')"
		], [
			[true, 1, "0", "", "Alpha", 60],
			[true, 2, "1", "0", "Beta", 55],
			[undefined, 3, "1.1", "1", "Gamma", 41],
			[undefined, 3, "1.2", "1", "Zeta", 42],
			[undefined, 2, "2", "0", "Kappa", 56],
			[undefined, 2, "3", "0", "Lambda", 57],
			[undefined, 1, "9", "", "Omega", 69]
		]);
		const oAlpha = oTable.getRows()[0].getBindingContext();
		let oBeta = oTable.getRows()[1].getBindingContext();
		const oOmega = oTable.getRows()[6].getBindingContext();

		this.expectChange("id", [,, "2", "3", "9"]);

		oBeta.collapse();

		await this.waitForChanges(assert, "collapse 1 (Beta)");

		checkTable("after collapse 1 (Beta)", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('9')"
		], [
			[true, 1, "0", "", "Alpha", 60],
			[false, 2, "1", "0", "Beta", 55],
			[undefined, 2, "2", "0", "Kappa", 56],
			[undefined, 2, "3", "0", "Lambda", 57],
			[undefined, 1, "9", "", "Omega", 69]
		]);

		if (bMoveCollapsed) {
			this.expectChange("id", [, "9"]);
			oAlpha.collapse();
			oBeta = null;
		} else { // "A failed move must not leave the node collapsed"
			this.expectEvents(assert, "sap.ui.model.odata.v4.ODataListBinding: /EMPLOYEES", [])
				.expectRequest({
					batchNo : 2,
					headers : {
						Prefer : "return=minimal"
					},
					method : "PATCH",
					url : "EMPLOYEES('0')",
					payload : {
						"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('9')"
					}
				}, createErrorInsideBatch())
				.expectRequest({
					batchNo : 2,
					url : sBaseUrl + "&$filter=ID eq '0'&$select=LimitedRank"
				}); // no response required

			await Promise.all([
				oAlpha.move({parent : oOmega}).then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, "Request intentionally failed");
				}), // (JIRA: CPOUI5ODATAV4-2343)
				this.waitForChanges(assert, "move 0 (Alpha) to 9 (Omega) *FAILS*")
			]);

			this.expectEvents(assert, "sap.ui.model.odata.v4.ODataListBinding: /EMPLOYEES", [
					[, "change", {reason : "change"}] // caused by ODLB#getAllCurrentContexts
				]);
			checkTable("after failed move", assert, oTable, [
				"/EMPLOYEES('0')",
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('9')"
			], [
				[true, 1, "0", "", "Alpha", 60],
				[false, 2, "1", "0", "Beta", 55],
				[undefined, 2, "2", "0", "Kappa", 56],
				[undefined, 2, "3", "0", "Lambda", 57],
				[undefined, 1, "9", "", "Omega", 69]
			]);
			assert.strictEqual(oTable.getRows()[1].getBindingContext(), oBeta, "unchanged");

			// wait for UI changes caused by "change" event above
			await resolveLater(undefined, /*iDelay*/1);
		}

		checkPersisted(assert, oAlpha);

		// 9 Omega
		//   0 Alpha (moved here)
		//     1 Beta
		//       1.1 Gamma
		//       1.2 Zeta
		//     2 Kappa
		//     3 Lambda
		this.expectEvents(assert, "sap.ui.model.odata.v4.ODataListBinding: /EMPLOYEES", [
				[, "change", {reason : "change"}]
			])
			.expectRequest({
				batchNo : bMoveCollapsed ? 2 : 3,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "EMPLOYEES('0')",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('9')"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : bMoveCollapsed ? 2 : 3,
				url : sBaseUrl + "&$filter=ID eq '0'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "1" // Edm.Int64
				}]
			})
			.expectChange("id", bMoveCollapsed ? ["9", "0"] : ["9", "0", "1", "2", "3"]);

		await Promise.all([
			oAlpha.move({parent : oOmega}),
			this.waitForChanges(assert, "move 0 (Alpha) to 9 (Omega)")
		]);

		checkPersisted(assert, oAlpha);
		assert.strictEqual(oAlpha.getIndex(), 1);
		assert.strictEqual(oOmega.getIndex(), 0);

		if (bMoveCollapsed) {
			this.expectEvents(assert, "sap.ui.model.odata.v4.ODataListBinding: /EMPLOYEES", [
					[, "change", {reason : "change"}]
				])
				.expectChange("id", [,, "1", "2", "3"]);
			oAlpha.expand();

			await this.waitForChanges(assert, "expand 0 (Alpha)");
		}

		checkTable("after move 0 (Alpha) to 9 (Omega)", assert, oTable, [
			"/EMPLOYEES('9')",
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "9", "", "Omega", 69],
			[true, 2, "0", ""/*TODO "9"*/, "Alpha", 60],
			[false, 3, "1", "0", "Beta", 55],
			[undefined, 3, "2", "0", "Kappa", 56],
			[undefined, 3, "3", "0", "Lambda", 57]
		]);
		oBeta = oTable.getRows()[2].getBindingContext();
		const oKappa = oTable.getRows()[3].getBindingContext();
		checkPersisted(assert, oKappa);
		assert.strictEqual(oAlpha.getIndex(), 1);

		// 9 Omega
		//   0 Alpha
		//     1 Beta
		//       1.1 Gamma
		//       2 Kappa (moved here)
		//       1.2 Zeta
		//     3 Lambda
		this.expectEvents(assert, "sap.ui.model.odata.v4.ODataListBinding: /EMPLOYEES", [
				[, "change", {reason : "change"}]
			])
			.expectRequest({
				batchNo : bMoveCollapsed ? 3 : 4,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "EMPLOYEES('2')",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : bMoveCollapsed ? 3 : 4,
				url : sBaseUrl + "&$filter=ID eq '2'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "4" // Edm.Int64
				}]
			})
			.expectChange("id", [,,, "1.1", "2", "1.2", "3"]);

		await Promise.all([
			oKappa.move({parent : oBeta}),
			this.waitForChanges(assert, "move 2 (Kappa) to collapsed 1 (Beta)")
		]);

		checkPersisted(assert, oKappa);

		checkTable("after move 2 (Kappa) to collapsed 1 (Beta)", assert, oTable, [
			"/EMPLOYEES('9')",
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('1.1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('1.2')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "9", "", "Omega", 69],
			[true, 2, "0", ""/*TODO "9"*/, "Alpha", 60],
			[true, 3, "1", "0", "Beta", 55],
			[undefined, 4, "1.1", "1", "Gamma", 41],
			[undefined, 4, "2", "0"/*TODO "1"*/, "Kappa", 56],
			[undefined, 4, "1.2", "1", "Zeta", 42],
			[undefined, 3, "3", "0", "Lambda", 57]
		]);
		assert.strictEqual(oKappa.getIndex(), 4);
		assert.strictEqual(oBeta.getIndex(), 2);
		assert.strictEqual(oAlpha.getIndex(), 1);
		assert.strictEqual(oOmega.getIndex(), 0);

		// code under test
		assert.strictEqual(oBeta.isAncestorOf(oKappa), true, "JIRA: CPOUI5ODATAV4-2337");
		assert.strictEqual(oOmega.isAncestorOf(oKappa), true, "JIRA: CPOUI5ODATAV4-2337");
		assert.strictEqual(oKappa.isAncestorOf(oOmega), false, "JIRA: CPOUI5ODATAV4-2337");

		// code under test
		assert.strictEqual(oKappa.getParent(), oBeta, "JIRA: CPOUI5ODATAV4-2323");
		assert.strictEqual(oBeta.getParent(), oAlpha, "JIRA: CPOUI5ODATAV4-2323");
		assert.strictEqual(oAlpha.getParent(), oOmega, "JIRA: CPOUI5ODATAV4-2323");
		assert.strictEqual(oOmega.getParent(), null, "JIRA: CPOUI5ODATAV4-2323");
	});
});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 2. Expand a node,
	// collapse another. Move a leaf; this causes a side-effects refresh in order to turn the cache
	// into a unified cache. Afterwards, move a node with children first to a collapsed new parent,
	// then to a leaf at the edge of the top pyramid. Finally, collapse that former leaf, move
	// another node to it, and request a side-effects refresh to check the tree state.
	// JIRA: CPOUI5ODATAV4-2466
	QUnit.test("Recursive Hierarchy: move w/ expandTo : 2", async function (assert) {
		const sBaseUrl = "EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
			+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID'"
			+ ",Levels=2)";
		const oModel = this.createTeaBusiModel({
			autoExpandSelect : true,
			updateGroupId : "update"
		});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 2,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="10">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text id="id" text="{ID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 0 Alpha (finally moved to collapsed Theta)
		//   1 Beta (expanded, "afterwards" moved to Eta, "then" to Theta)
		//     1.1 Gamma
		//     1.2 Delta
		//   2 Epsilon
		//   3 Zeta (later moved to Beta)
		// 8 Eta (collapsed)
		//   9 Theta
		this.expectRequest(sBaseUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$count=true&$skip=0&$top=10", {
				"@odata.count" : "6",
				value : [{
					DescendantCount : "3",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "collapsed",
					ID : "1",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Epsilon"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Zeta"
				}, {
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "8",
					Name : "Eta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "9",
					Name : "Theta"
				}]
			})
			.expectChange("id", ["0", "1", "2", "3", "8", "9"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('8')",
			"/EMPLOYEES('9')"
		], [
			[true, 1, "0", "Alpha"],
			[false, 2, "1", "Beta"],
			[undefined, 2, "2", "Epsilon"],
			[undefined, 2, "3", "Zeta"],
			[true, 1, "8", "Eta"],
			[undefined, 2, "9", "Theta"]
		], 6);
		const oBeta = oTable.getRows()[1].getBindingContext();
		const oEta = oTable.getRows()[4].getBindingContext();

		this.expectRequest("EMPLOYEES"
				+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
				+ "&$select=DrillState,ID,Name&$count=true&$skip=0&$top=10", {
				"@odata.count" : "2",
				value : [{
					DrillState : "leaf",
					ID : "1.1",
					Name : "Gamma"
				}, {
					DrillState : "leaf",
					ID : "1.2",
					Name : "Delta"
				}]
			})
			.expectChange("id", [,, "1.1", "1.2", "2", "3", "8"]);

		oEta.collapse();
		oBeta.expand();

		await this.waitForChanges(assert, "collapse 8 (Eta), expand 1 (Beta)");

		checkTable("initial collapse 8 (Eta), expand 1 (Beta)", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('1.1')",
			"/EMPLOYEES('1.2')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('8')"
		], [
			[true, 1, "0", "Alpha"],
			[true, 2, "1", "Beta"],
			[undefined, 3, "1.1", "Gamma"],
			[undefined, 3, "1.2", "Delta"],
			[undefined, 2, "2", "Epsilon"],
			[undefined, 2, "3", "Zeta"],
			[false, 1, "8", "Eta"]
		]);
		const oZeta = oTable.getRows()[5].getBindingContext();

		// 0 Alpha
		//   1 Beta
		//     1.1 Gamma
		//     3 Zeta (moved here)
		//     1.2 Delta
		//   2 Epsilon
		// 8 Eta
		//   9 Theta
		this.expectRequest({
				batchNo : 3,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "EMPLOYEES('3')",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : 3,
				url : sBaseUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "8", Levels : 0}, {NodeID : "1", Levels : 1}])
					+ ")&$filter=ID eq '3'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "3" // Edm.Int64
				}]
			})
			.expectRequest({
				batchNo : 3,
				url : sBaseUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "8", Levels : 0}, {NodeID : "1", Levels : 1}])
					+ ")&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$count=true&$skip=0&$top=10"
			}, {
				"@odata.count" : "7",
				value : [{
					DescendantCount : "5",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					Name : "Alpha"
				}, {
					DescendantCount : "3",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "1",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "1.1",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "3",
					Name : "Zeta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "1.2",
					Name : "Delta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Epsilon"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "collapsed",
					ID : "8",
					Name : "Eta"
				}]
			})
			.expectChange("id", [,,, "3", "1.2", "2"]);

		await Promise.all([
			// code under test
			oZeta.move({parent : oBeta}),
			oModel.submitBatch("update"),
			this.waitForChanges(assert, "move 3 (Zeta) to 1 (Beta)")
		]);

		assert.strictEqual(oZeta.getIndex(), 3);
		checkTable("after move 3 (Zeta) to 1 (Beta)", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('1.1')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('1.2')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('8')"
		], [
			[true, 1, "0", "Alpha"],
			[true, 2, "1", "Beta"],
			[undefined, 3, "1.1", "Gamma"],
			[undefined, 3, "3", "Zeta"],
			[undefined, 3, "1.2", "Delta"],
			[undefined, 2, "2", "Epsilon"],
			[false, 1, "8", "Eta"]
		]);

		// 0 Alpha
		//   2 Epsilon
		// 8 Eta (expanded by move)
		//   9 Theta
		//   1 Beta (moved here)
		//     1.1 Gamma
		//     3 Zeta
		//     1.2 Delta
		this.expectRequest({
				batchNo : 4,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "EMPLOYEES('1')",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('8')"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : 4,
				url : sBaseUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "1", Levels : 1}])
					+ ")&$filter=ID eq '1'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "4" // Edm.Int64
				}]
			})
			.expectRequest({
				batchNo : 4,
				url : sBaseUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "1", Levels : 1}])
					+ ")&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$count=true&$skip=0&$top=10"
			}, {
				"@odata.count" : "8",
				value : [{
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Epsilon"
				}, {
					DescendantCount : "5",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "8",
					Name : "Eta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "9",
					Name : "Theta"
				}, {
					DescendantCount : "3",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "1",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "1.1",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "3",
					Name : "Zeta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "2",
					DrillState : "leaf",
					ID : "1.2",
					Name : "Delta"
				}]
			})
			.expectChange("id", [, "2", "8", "9", "1", "1.1", "3", "1.2"]);

		await Promise.all([
			// code under test
			oBeta.move({parent : oEta}),
			oModel.submitBatch("update"),
			this.waitForChanges(assert, "move 1 (Beta) to collapsed 8 (Eta)")
		]);

		assert.strictEqual(oBeta.getIndex(), 4);
		checkTable("after move 1 (Beta) to collapsed 8 (Eta)", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('8')",
			"/EMPLOYEES('9')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('1.1')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('1.2')"
		], [
			[true, 1, "0", "Alpha"],
			[undefined, 2, "2", "Epsilon"],
			[true, 1, "8", "Eta"],
			[undefined, 2, "9", "Theta"],
			[true, 2, "1", "Beta"],
			[undefined, 3, "1.1", "Gamma"],
			[undefined, 3, "3", "Zeta"],
			[undefined, 3, "1.2", "Delta"]
		]);
		const oTheta = oTable.getRows()[3].getBindingContext();
		assert.strictEqual(oTheta.getProperty("Name"), "Theta",
			"double check that index was right");

		// 0 Alpha
		//   2 Epsilon
		// 8 Eta
		//   9 Theta (not a leaf anymore)
		//     1 Beta (moved here)
		//       1.1 Gamma
		//       3 Zeta
		//       1.2 Delta
		this.expectRequest({
				batchNo : 5,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "EMPLOYEES('1')",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('9')"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : 5,
				url : sBaseUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "1", Levels : 1}, {NodeID : "9", Levels : 1}])
					+ ")&$filter=ID eq '1'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "4" // Edm.Int64
				}]
			})
			.expectRequest({
				batchNo : 5,
				// Note: Levels=2
				url : sBaseUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "1", Levels : 1}, {NodeID : "9", Levels : 1}])
					+ ")&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$count=true&$skip=0&$top=10"
			}, {
				"@odata.count" : "8",
				value : [{
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Epsilon"
				}, {
					DescendantCount : "5",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "8",
					Name : "Eta"
				}, {
					DescendantCount : "4",
					DistanceFromRoot : "1",
					DrillState : "expanded",
					ID : "9",
					Name : "Theta"
				}, {
					DescendantCount : "3",
					DistanceFromRoot : "2",
					DrillState : "expanded",
					ID : "1",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "3",
					DrillState : "leaf",
					ID : "1.1",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "3",
					DrillState : "leaf",
					ID : "3",
					Name : "Zeta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "3",
					DrillState : "leaf",
					ID : "1.2",
					Name : "Delta"
				}]
			});

		await Promise.all([
			// code under test
			oBeta.move({parent : oTheta}),
			oModel.submitBatch("update"),
			this.waitForChanges(assert, "move 1 (Beta) to leaf 9 (Theta)")
		]);

		assert.strictEqual(oBeta.getIndex(), 4);
		checkTable("after move 1 (Beta) to leaf 9 (Theta)", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('8')",
			"/EMPLOYEES('9')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('1.1')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('1.2')"
		], [
			[true, 1, "0", "Alpha"],
			[undefined, 2, "2", "Epsilon"],
			[true, 1, "8", "Eta"],
			[true, 2, "9", "Theta"],
			[true, 3, "1", "Beta"],
			[undefined, 4, "1.1", "Gamma"],
			[undefined, 4, "3", "Zeta"],
			[undefined, 4, "1.2", "Delta"]
		]);

		oTheta.collapse();

		await this.waitForChanges(assert, "collapse 9 (Theta)"); // table update takes a moment

		checkTable("after collapse 9 (Theta)", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('8')",
			"/EMPLOYEES('9')"
		], [
			[true, 1, "0", "Alpha"],
			[undefined, 2, "2", "Epsilon"],
			[true, 1, "8", "Eta"],
			[false, 2, "9", "Theta"]
		]);
		const oAlpha = oTable.getRows()[0].getBindingContext();

		// 8 Eta
		//   9 Theta (expanded by move)
		//     1 Beta
		//       1.1 Gamma
		//       3 Zeta
		//       1.2 Delta
		//     0 Alpha (moved here)
		//       2 Epsilon
		this.expectRequest({
				batchNo : 6,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "EMPLOYEES('0')",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('9')"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : 6,
				// Note: Levels=2
				url : sBaseUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "1", Levels : 1}, {NodeID : "9", Levels : 1}])
					+ ")&$filter=ID eq '0'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "6" // Edm.Int64
				}]
			})
			.expectChange("id", ["8", "9", "1", "1.1", "3", "1.2", "0", "2"]);

		await Promise.all([
			// code under test
			oAlpha.move({parent : oTheta}),
			oModel.submitBatch("update"),
			this.waitForChanges(assert, "move 0 (Alpha) to collapsed 9 (Theta)")
		]);

		checkTable("after move 0 (Alpha) to collapsed 9 (Theta)", assert, oTable, [
			"/EMPLOYEES('8')",
			"/EMPLOYEES('9')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('1.1')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('1.2')",
			"/EMPLOYEES('0')",
			"/EMPLOYEES('2')"
		], [
			[true, 1, "8", "Eta"],
			[true, 2, "9", "Theta"],
			[true, 3, "1", "Beta"],
			[undefined, 4, "1.1", "Gamma"],
			[undefined, 4, "3", "Zeta"],
			[undefined, 4, "1.2", "Delta"],
			[true, 3, "0", "Alpha"],
			[undefined, 4, "2", "Epsilon"]
		]);

		this.expectRequest({
				batchNo : 7,
				// Note: Levels=2; Theta properly expanded (again)
				url : sBaseUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "1", Levels : 1}, {NodeID : "9", Levels : 1}])
					+ ")&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$count=true&$skip=0&$top=10"
			}, {
				"@odata.count" : "0",
				value : []
			});

		await Promise.all([
			// code under test
			oAlpha.getBinding().getHeaderContext().requestSideEffects([""]),
			oModel.submitBatch("update"),
			this.waitForChanges(assert, "side-effects refresh")
		]);

		checkTable("after side-effects refresh", assert, oTable, [], [
			[undefined, undefined, "", ""] // all empty
		]);
	});

	//*********************************************************************************************
	// Scenario: Nodes affected by a move are "in place".
	// 1. Moving a node (Beta) into a hierarchy of created nodes (Delta, Epsilon, Zeta, Eta) makes
	//    all of them "in place".
	// 2. Moving a hierarchy of created nodes makes all of them "in place".
	// 3. Moving part of a hierarchy of created nodes makes all of the moved ones "in place", but no
	//    others.
	// 4. Move a created node to make it a root (JIRA: CPOUI5ODATAV4-2400).
	// 5. Move a created node to another created node.
	// 6. Move a created node to another created node. All nodes that were previously out of place
	//    do not match an imaginary filter when becoming "in place". Check #getIndex for those
	//    contexts.
	// 7. Move a node (Beta) before a next sibling which is a created node (Delta) makes that node
	//    and all of its descendants "in place" (JIRA: CPOUI5ODATAV4-2581).
	// JIRA: CPOUI5ODATAV4-2466
[1, 2, 3, 4, 5, 6, 7].forEach(function (iScenario) {
	const sTitle = `Recursive Hierarchy: nodes affected by a move; #${iScenario}`;

	QUnit.test(sTitle, async function (assert) {
		const sBaseUrl = "EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
			+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID')";
		const sReadUrl = sBaseUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name";
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0">
	<Text text="{= %{@$ui5.context.isTransient} }"/>
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 0 Alpha
		//   1 Beta <-- 2. Delta moved here; 3. Epsilon moved here
		//   2 Gamma
		//   3 Delta (created) <-- 7. Beta moved before here
		//     3.1 Epsilon (created) <-- 4. moved to make it a root
		//       3.1.1 Zeta (created) <-- 1. Beta moved here
		//     3.2 Eta (created) <-- 5. Epsilon moved here; 6. dito
		this.expectRequest(sReadUrl + "&$count=true&$skip=0&$top=10", {
				"@odata.count" : "3",
				value : [{
					DescendantCount : "2",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "1",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Gamma"
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')"
		], [
			[undefined, true, 1, "0", "Alpha"],
			[undefined, undefined, 2, "1", "Beta"],
			[undefined, undefined, 2, "2", "Gamma"]
		]);
		const oListBinding = oTable.getBinding("rows");
		const [oAlpha, oBeta, oGamma] = oListBinding.getCurrentContexts();

		const create = async (oParent, sId, sName, iLimitedRank) => {
			this.expectRequest({
					method : "POST",
					payload : {
						"EMPLOYEE_2_MANAGER@odata.bind"
							: `EMPLOYEES('${oParent.getProperty("ID")}')`,
						Name : sName
					},
					url : "EMPLOYEES"
				}, {
					ID : sId,
					Name : sName
				})
				.expectRequest(sBaseUrl + `&$filter=ID eq '${sId}'&$select=LimitedRank`, {
					value : [{
						LimitedRank : "" + iLimitedRank // Edm.Int64
					}]
				});

			const oCreated = oListBinding.create({
				"@$ui5.node.parent" : oParent,
				Name : sName
			}, /*bSkipRefresh*/true);

			await Promise.all([
				oCreated.created(),
				this.waitForChanges(assert, `create ${sId} (${sName})`)
			]);

			return oCreated;
		};

		const oDelta = await create(oAlpha, "3", "Delta", 3);
		const oEpsilon = await create(oDelta, "3.1", "Epsilon", 4);
		const oZeta = await create(oEpsilon, "3.1.1", "Zeta", 5);
		const oEta = await create(oDelta, "3.2", "Eta", 6);

		checkTable("after creates", assert, oTable, [
			oAlpha, // "/EMPLOYEES('0')",
			oDelta, // "/EMPLOYEES('3')",
			oEta, // "/EMPLOYEES('3.2')", // out-of-place at its best ;-)
			oEpsilon, // "/EMPLOYEES('3.1')",
			oZeta, // "/EMPLOYEES('3.1.1')",
			oBeta, // "/EMPLOYEES('1')",
			oGamma // "/EMPLOYEES('2')"
		], [
			[undefined, true, 1, "0", "Alpha"],
			[false, true, 2, "3", "Delta"],
			[false, undefined, 3, "3.2", "Eta"],
			[false, true, 3, "3.1", "Epsilon"],
			[false, undefined, 4, "3.1.1", "Zeta"],
			[undefined, undefined, 2, "1", "Beta"],
			[undefined, undefined, 2, "2", "Gamma"]
		]);

		switch (iScenario) {
			case 1: // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
				// 0 Alpha
				//   2 Gamma
				//   3 Delta
				//     3.1 Epsilon
				//       3.1.1 Zeta
				//         1 Beta (moved here)
				//     3.2 Eta
				this.expectRequest({
						batchNo : 10,
						headers : {
							Prefer : "return=minimal"
						},
						method : "PATCH",
						payload : {
							"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('3.1.1')"
						},
						url : "EMPLOYEES('1')"
					}) // 204 No Content
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl + "&$filter=ID eq '1'&$select=LimitedRank"
					}, {
						value : [{
							LimitedRank : "5" // Edm.Int64
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : sReadUrl + "&$count=true&$skip=0&$top=10"
					}, {
						"@odata.count" : "7",
						value : [{
							DescendantCount : "6",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							Name : "Alpha"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "2",
							Name : "Gamma"
						}, {
							DescendantCount : "4",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "3",
							Name : "Delta"
						}, {
							DescendantCount : "2",
							DistanceFromRoot : "2",
							DrillState : "expanded",
							ID : "3.1",
							Name : "Epsilon"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "3",
							DrillState : "expanded",
							ID : "3.1.1",
							Name : "Zeta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "4",
							DrillState : "leaf",
							ID : "1",
							Name : "Beta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							ID : "3.2",
							Name : "Eta"
						}]
					});

				await Promise.all([
					// code under test
					oBeta.move({parent : oZeta}),
					this.waitForChanges(assert, "move 1 (Beta) to 3.1.1 (Zeta)")
				]);

				assert.strictEqual(oBeta.getIndex(), 5);
				checkTable("after move 1 (Beta) to 3.1.1 (Zeta)", assert, oTable, [
					oAlpha, // "/EMPLOYEES('0')",
					oGamma, // "/EMPLOYEES('2')",
					oDelta, // "/EMPLOYEES('3')",
					oEpsilon, // "/EMPLOYEES('3.1')",
					oZeta, // "/EMPLOYEES('3.1.1')",
					oBeta, // "/EMPLOYEES('1')", // moved here
					oEta // "/EMPLOYEES('3.2')"
				], [
					[undefined, true, 1, "0", "Alpha"],
					[undefined, undefined, 2, "2", "Gamma"],
					[undefined, true, 2, "3", "Delta"],
					[undefined, true, 3, "3.1", "Epsilon"],
					[undefined, true, 4, "3.1.1", "Zeta"],
					[undefined, undefined, 5, "1", "Beta"],
					[undefined, undefined, 3, "3.2", "Eta"]
				]);
			break;

			case 2: // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
				// 0 Alpha
				//   1 Beta
				//     3 Delta (moved here)
				//       3.1 Epsilon
				//         3.1.1 Zeta
				//       3.2 Eta
				//   2 Gamma
				this.expectRequest({
						batchNo : 10,
						headers : {
							Prefer : "return=minimal"
						},
						method : "PATCH",
						payload : {
							"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')"
						},
						url : "EMPLOYEES('3')"
					}) // 204 No Content
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl + "&$filter=ID eq '3'&$select=LimitedRank"
					}, {
						value : [{
							LimitedRank : "2" // Edm.Int64
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : sReadUrl + "&$count=true&$skip=0&$top=10"
					}, {
						"@odata.count" : "7",
						value : [{
							DescendantCount : "6",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							Name : "Alpha"
						}, {
							DescendantCount : "4",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "1",
							Name : "Beta"
						}, {
							DescendantCount : "3",
							DistanceFromRoot : "2",
							DrillState : "expanded",
							ID : "3",
							Name : "Delta"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "3",
							DrillState : "expanded",
							ID : "3.1",
							Name : "Epsilon"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "4",
							DrillState : "leaf",
							ID : "3.1.1",
							Name : "Zeta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "3",
							DrillState : "leaf",
							ID : "3.2",
							Name : "Eta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "2",
							Name : "Gamma"
						}]
					});

				await Promise.all([
					// code under test
					oDelta.move({parent : oBeta}),
					this.waitForChanges(assert, "move 3 (Delta) to 1 (Beta)")
				]);

				assert.strictEqual(oDelta.getIndex(), 2);
				checkTable("after move 3 (Delta) to 1 (Beta)", assert, oTable, [
					oAlpha, // "/EMPLOYEES('0')",
					oBeta, // "/EMPLOYEES('1')",
					oDelta, // "/EMPLOYEES('3')", // moved here
					oEpsilon, // "/EMPLOYEES('3.1')"
					oZeta, // "/EMPLOYEES('3.1.1')"
					oEta, // "/EMPLOYEES('3.2')"
					oGamma // "/EMPLOYEES('2')"
				], [
					[undefined, true, 1, "0", "Alpha"],
					[undefined, true, 2, "1", "Beta"],
					[undefined, true, 3, "3", "Delta"],
					[undefined, true, 4, "3.1", "Epsilon"],
					[undefined, undefined, 5, "3.1.1", "Zeta"],
					[undefined, undefined, 4, "3.2", "Eta"],
					[undefined, undefined, 2, "2", "Gamma"]
				]);
			break;

			case 3: // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
				// 0 Alpha
				//   1 Beta
				//     3.1 Epsilon (moved here)
				//       3.1.1 Zeta
				//   2 Gamma
				//   3 Delta
				//     3.2 Eta
				this.expectRequest({
						batchNo : 10,
						headers : {
							Prefer : "return=minimal"
						},
						method : "PATCH",
						payload : {
							"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')"
						},
						url : "EMPLOYEES('3.1')"
					}) // 204 No Content
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl + "&$filter=ID eq '3.1'&$select=LimitedRank"
					}, {
						value : [{
							LimitedRank : "2" // Edm.Int64
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : sReadUrl + "&$count=true&$skip=0&$top=10"
					}, {
						"@odata.count" : "7",
						value : [{
							DescendantCount : "6",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							Name : "Alpha"
						}, {
							DescendantCount : "2",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "1",
							Name : "Beta"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "2",
							DrillState : "expanded",
							ID : "3.1",
							Name : "Epsilon"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "3",
							DrillState : "leaf",
							ID : "3.1.1",
							Name : "Zeta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "2",
							Name : "Gamma"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "3",
							Name : "Delta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							ID : "3.2",
							Name : "Eta"
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl
							+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,LimitedRank"
							+ "&$filter=ID eq '0' or ID eq '3' or ID eq '3.2'&$top=3"
					}, {
						value : [{
							DescendantCount : "6",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							LimitedRank : "0"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "3",
							LimitedRank : "5"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							ID : "3.2",
							LimitedRank : "6"
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : "EMPLOYEES"
							+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
							+ "&$select=ID,Name&$filter=ID eq '3'&$top=1"
					}, {
						value : [{
							ID : "3",
							Name : "Delta"
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : "EMPLOYEES"
							+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '3'),1)"
							+ "&$select=ID,Name&$filter=ID eq '3.2'&$top=1"
					}, {
						value : [{
							ID : "3.2",
							Name : "Eta"
						}]
					});

				await Promise.all([
					// code under test
					oEpsilon.move({parent : oBeta}),
					this.waitForChanges(assert, "move 3.1 (Epsilon) to 1 (Beta)")
				]);

				assert.strictEqual(oEpsilon.getIndex(), 4, "out-of-place nodes taken into account");
				checkTable("after move 3.1 (Epsilon) to 1 (Beta)", assert, oTable, [
					oAlpha, // "/EMPLOYEES('0')",
					oDelta, // "/EMPLOYEES('3')", // still out-of-place
					oEta, // "/EMPLOYEES('3.2')",
					oBeta, // "/EMPLOYEES('1')",
					oEpsilon, // "/EMPLOYEES('3.1')", // moved here
					oZeta, // "/EMPLOYEES('3.1.1')"
					oGamma // "/EMPLOYEES('2')"
				], [
					[undefined, true, 1, "0", "Alpha"],
					[/*TODO false*/undefined, true, 2, "3", "Delta"], // still created
					[/*TODO false*/undefined, undefined, 3, "3.2", "Eta"], // still created
					[undefined, true, 2, "1", "Beta"],
					[undefined, true, 3, "3.1", "Epsilon"], // now "in place"...
					[undefined, undefined, 4, "3.1.1", "Zeta"], // ...and not created anymore
					[undefined, undefined, 2, "2", "Gamma"]
				]);
			break;

			case 4: // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
				// 0 Alpha
				//   1 Beta
				//   2 Gamma
				//   3 Delta
				//     3.2 Eta
				// 3.1 Epsilon (moved here)
				//   3.1.1 Zeta
				this.expectRequest({
						batchNo : 10,
						headers : {
							Prefer : "return=minimal"
						},
						method : "PATCH",
						payload : {
							"EMPLOYEE_2_MANAGER@odata.bind" : null
						},
						url : "EMPLOYEES('3.1')"
					}) // 204 No Content
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl + "&$filter=ID eq '3.1'&$select=LimitedRank"
					}, {
						value : [{
							LimitedRank : "5" // Edm.Int64
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : sReadUrl + "&$count=true&$skip=0&$top=10"
					}, {
						"@odata.count" : "7",
						value : [{
							DescendantCount : "4",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							Name : "Alpha"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "1",
							Name : "Beta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "2",
							Name : "Gamma"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "3",
							Name : "Delta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							ID : "3.2",
							Name : "Eta"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "3.1",
							Name : "Epsilon"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "3.1.1",
							Name : "Zeta"
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl
							+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,LimitedRank"
							+ "&$filter=ID eq '0' or ID eq '3' or ID eq '3.2'&$top=3"
					}, {
						value : [{
							DescendantCount : "6",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							LimitedRank : "0"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "3",
							LimitedRank : "3"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							ID : "3.2",
							LimitedRank : "4"
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : "EMPLOYEES"
							+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '0'),1)"
							+ "&$select=ID,Name&$filter=ID eq '3'&$top=1"
					}, {
						value : [{
							ID : "3",
							Name : "Delta"
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : "EMPLOYEES"
							+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '3'),1)"
							+ "&$select=ID,Name&$filter=ID eq '3.2'&$top=1"
					}, {
						value : [{
							ID : "3.2",
							Name : "Eta"
						}]
					});

				await Promise.all([
					// code under test
					oEpsilon.move({parent : null}),
					this.waitForChanges(assert, "move 3.1 (Epsilon) to make it a root")
				]);

				assert.strictEqual(oEpsilon.getIndex(), 5, "out-of-place nodes make no difference");
				checkTable("after move 3.1 (Epsilon) to make it a root", assert, oTable, [
					oAlpha, // "/EMPLOYEES('0')",
					oDelta, // "/EMPLOYEES('3')", // still out-of-place
					oEta, // "/EMPLOYEES('3.2')",
					oBeta, // "/EMPLOYEES('1')",
					oGamma, // "/EMPLOYEES('2')",
					oEpsilon, // "/EMPLOYEES('3.1')", // moved here
					oZeta // "/EMPLOYEES('3.1.1')"
				], [
					[undefined, true, 1, "0", "Alpha"],
					[/*TODO false*/undefined, true, 2, "3", "Delta"], // still created
					[/*TODO false*/undefined, undefined, 3, "3.2", "Eta"], // still created
					[undefined, undefined, 2, "1", "Beta"],
					[undefined, undefined, 2, "2", "Gamma"],
					[undefined, true, 1, "3.1", "Epsilon"], // now "in place"...
					[undefined, undefined, 2, "3.1.1", "Zeta"] // ...and not created anymore
				]);
			break;

			case 5: // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
				// 0 Alpha
				//   1 Beta
				//   2 Gamma
				//   3 Delta
				//     3.2 Eta
				//       3.1 Epsilon (moved here)
				//         3.1.1 Zeta
				this.expectRequest({
						batchNo : 10,
						headers : {
							Prefer : "return=minimal"
						},
						method : "PATCH",
						payload : {
							"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('3.2')"
						},
						url : "EMPLOYEES('3.1')"
					}) // 204 No Content
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl + "&$filter=ID eq '3.1'&$select=LimitedRank"
					}, {
						value : [{
							LimitedRank : "5" // Edm.Int64
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : sReadUrl + "&$count=true&$skip=0&$top=10"
					}, {
						"@odata.count" : "7",
						value : [{
							DescendantCount : "6",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							Name : "Alpha"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "1",
							Name : "Beta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "2",
							Name : "Gamma"
						}, {
							DescendantCount : "3",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "3",
							Name : "Delta"
						}, {
							DescendantCount : "2",
							DistanceFromRoot : "2",
							DrillState : "expanded",
							ID : "3.2",
							Name : "Eta"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "3",
							DrillState : "expanded",
							ID : "3.1",
							Name : "Epsilon"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "4",
							DrillState : "leaf",
							ID : "3.1.1",
							Name : "Zeta"
						}]
					});

				await Promise.all([
					// code under test
					oEpsilon.move({parent : oEta}),
					this.waitForChanges(assert, "move 3.1 (Epsilon) to 3.2 (Eta)")
				]);

				assert.strictEqual(oEpsilon.getIndex(), 5);
				checkTable("after move 3.1 (Epsilon) to 3.2 (Eta)", assert, oTable, [
					oAlpha, // "/EMPLOYEES('0')",
					oBeta, // "/EMPLOYEES('1')",
					oGamma, // "/EMPLOYEES('2')",
					oDelta, // "/EMPLOYEES('3')",
					oEta, // "/EMPLOYEES('3.2')",
					oEpsilon, // "/EMPLOYEES('3.1')", // moved here
					oZeta // "/EMPLOYEES('3.1.1')"
				], [
					[undefined, true, 1, "0", "Alpha"],
					[undefined, undefined, 2, "1", "Beta"],
					[undefined, undefined, 2, "2", "Gamma"],
					[undefined, true, 2, "3", "Delta"], // now "in place"...
					[undefined, true, 3, "3.2", "Eta"], // ...
					[undefined, true, 4, "3.1", "Epsilon"], // ...
					[undefined, undefined, 5, "3.1.1", "Zeta"] // ...and not created anymore
				]);
			break;

			case 6: // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
				// 0 Alpha
				//   1 Beta
				//   2 Gamma
				//   (3 Delta (filtered out))
				//     (3.2 Eta)
				//       (3.1 Epsilon (moved here))
				//         (3.1.1 Zeta)
				this.expectRequest({
						batchNo : 10,
						headers : {
							Prefer : "return=minimal"
						},
						method : "PATCH",
						payload : {
							"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('3.2')"
						},
						url : "EMPLOYEES('3.1')"
					}) // 204 No Content
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl + "&$filter=ID eq '3.1'&$select=LimitedRank"
					}, {
						value : [] // filtered out
					})
					.expectRequest({
						batchNo : 10,
						url : sReadUrl + "&$count=true&$skip=0&$top=10"
					}, {
						"@odata.count" : "3",
						value : [{
							DescendantCount : "2",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							Name : "Alpha"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "1",
							Name : "Beta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "2",
							Name : "Gamma"
						}]
					});

				await Promise.all([
					// code under test
					oEpsilon.move({parent : oEta}),
					this.waitForChanges(assert, "move 3.1 (Epsilon) to 3.2 (Eta)")
				]);

				assert.strictEqual(oDelta.getIndex(), 1);
				assert.strictEqual(oEta.getIndex(), 2);
				assert.strictEqual(oEpsilon.getIndex(), undefined);
				assert.strictEqual(oZeta.getIndex(), 4);
				[oDelta, oEta, oEpsilon, oZeta].forEach((oNode) => {
					assert.strictEqual(oNode.getModel(), undefined, "destroyed");
				});
				checkTable("after move 3.1 (Epsilon) to 3.2 (Eta)", assert, oTable, [
					oAlpha, // "/EMPLOYEES('0')",
					oBeta, // "/EMPLOYEES('1')",
					oGamma // "/EMPLOYEES('2')"
				], [
					[undefined, true, 1, "0", "Alpha"],
					[undefined, undefined, 2, "1", "Beta"],
					[undefined, undefined, 2, "2", "Gamma"]
				]);
			break;

			case 7: // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
				// 0 Alpha
				//   2 Gamma
				//   1 Beta (moved here)
				//   3 Delta
				//     3.1 Epsilon
				//       3.1.1 Zeta
				//     3.2 Eta
				this.expectRequest({
						batchNo : 10,
						headers : {
							Prefer : "return=minimal"
						},
						method : "PATCH",
						payload : {
							"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('0')"
						},
						url : "EMPLOYEES('1')"
					}) // 204 No Content
					.expectRequest({
						batchNo : 10,
						headers : {
							Prefer : "return=minimal"
						},
						method : "POST",
						payload : {
							NextSibling : {ID : "3"}
						},
						url : "EMPLOYEES('1')" + sNextSiblingAction
					}) // 204 No Content
					.expectRequest({
						batchNo : 10,
						url : sBaseUrl + "&$filter=ID eq '1'&$select=LimitedRank"
					}, {
						value : [{
							LimitedRank : "2" // Edm.Int64
						}]
					})
					.expectRequest({
						batchNo : 10,
						url : sReadUrl + "&$count=true&$skip=0&$top=10"
					}, {
						"@odata.count" : "7",
						value : [{
							DescendantCount : "6",
							DistanceFromRoot : "0",
							DrillState : "expanded",
							ID : "0",
							Name : "Alpha"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "2",
							Name : "Gamma"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "1",
							DrillState : "leaf",
							ID : "1",
							Name : "Beta"
						}, {
							DescendantCount : "3",
							DistanceFromRoot : "1",
							DrillState : "expanded",
							ID : "3",
							Name : "Delta"
						}, {
							DescendantCount : "1",
							DistanceFromRoot : "2",
							DrillState : "expanded",
							ID : "3.1",
							Name : "Epsilon"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "3",
							DrillState : "leaf",
							ID : "3.1.1",
							Name : "Zeta"
						}, {
							DescendantCount : "0",
							DistanceFromRoot : "2",
							DrillState : "leaf",
							ID : "3.2",
							Name : "Eta"
						}]
					});

				await Promise.all([
					// code under test
					oBeta.move({nextSibling : oDelta, parent : oAlpha}),
					this.waitForChanges(assert, "move 1 (Beta) before 3 (Delta)")
				]);

				assert.strictEqual(oBeta.getIndex(), 2);
				assert.strictEqual(oDelta.getIndex(), 3);
				checkTable("after move 1 (Beta) before 3 (Delta)", assert, oTable, [
					oAlpha, // "/EMPLOYEES('0')",
					oGamma, // "/EMPLOYEES('2')",
					oBeta, // "/EMPLOYEES('1')",
					oDelta, // "/EMPLOYEES('3')",
					oEpsilon, // "/EMPLOYEES('3.1')",
					oZeta, // "/EMPLOYEES('3.1.1')",
					oEta // "/EMPLOYEES('3.2')",
				], [
					[undefined, true, 1, "0", "Alpha"],
					[undefined, undefined, 2, "2", "Gamma"],
					[undefined, undefined, 2, "1", "Beta"],
					[undefined, true, 2, "3", "Delta"], // now "in place"...
					[undefined, true, 3, "3.1", "Epsilon"], // ...
					[undefined, undefined, 4, "3.1.1", "Zeta"], // ...
					[undefined, undefined, 3, "3.2", "Eta"] // ...and not created anymore
				]);
			break;

			default: // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
				assert.ok(false);
		}
	});
});

	//*********************************************************************************************
	// Scenario: A node is moved to root level, outside of view, but is still shown in the right
	// position when scrolling.
	// JIRA: CPOUI5ODATAV4-2547
	QUnit.test("Recursive Hierarchy: move outside of view", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sUrl = "EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
			+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart',NodeProperty='ID')";
		const sSelect = "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name";
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		//   2 Beta
		// 3 Gamma
		// 4 Delta
		this.expectRequest(sUrl + sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "4",
				value : [{
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"],
			[undefined, 1, "Gamma"]
		], 4);
		const oListBinding = oTable.getBinding("rows");
		const oBeta = oListBinding.getCurrentContexts()[1];

		this.expectRequest({
				batchNo : 2,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : null
				},
				url : "EMPLOYEES('2')"
			}) // 204 No Content
			.expectRequest({
				batchNo : 2,
				url : sUrl + "&$filter=ID eq '2'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "3"
				}]
			})
			// 1 Alpha
			// 3 Gamma
			// 4 Delta
			// 2 Beta (moved here)
			.expectRequest({
				batchNo : 3,
				url : sUrl + sSelect + "&$skip=2&$top=1"
			}, {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}]
			});

		await Promise.all([
			// code under test
			oBeta.move({parent : null}),
			this.waitForChanges(assert, "move 2 (Beta) to root")
		]);

		checkTable("after move 2 (Beta) to root", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')",
			"/EMPLOYEES('2')"
		], [
			[undefined, 1, "Alpha"],
			[undefined, 1, "Gamma"],
			[undefined, 1, "Delta"]
		]);
		assert.strictEqual(oBeta.getIndex(), 3);

		// "The index of the first visible row is too high. The value has been set to 1."
		oTable.setFirstVisibleRow(/*3*/ 1);

		await Promise.all([
			resolveLater(undefined, 0), // table update takes a moment
			this.waitForChanges(assert, "scroll to 2 (Beta)")
		]);

		checkTable("after scroll to 2 (Beta)", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')",
			"/EMPLOYEES('2')"
		], [
			[undefined, 1, "Gamma"],
			[undefined, 1, "Delta"],
			[undefined, 1, "Beta"]
		], 4);
	});

	//*********************************************************************************************
	// Scenario: A hierarchy has an initial expandTo=1 and three visible rows. Expand and collapse
	// various nodes and request side effects.
	// (1) Expand Alpha (1 child Beta)
	// (2) Request side effects -> Alpha gets a bonus item Delta
	// (3) Expand Beta (1 child Gamma)
	// (4) Check getDownloadUrl
	// (5) Collapse Alpha
	// (6) Expand Alpha (no request, Beta is still expanded)
	// (7) Collapse Alpha
	// (8) Request side effects -> swap position of Alpha and Epsilon
	// (9) Expand Alpha -> Child Beta is expanded too, Beta and Delta swap positions
	// (10) Scroll down, Gamma becomes visible
	// JIRA: CPOUI5ODATAV4-2032
	QUnit.test("Recursive Hierarchy: side-effects refresh (expandTo=1)", async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sFriend = "/Artists(ArtistID='99',IsActiveEntity=false)/_Friend";
		const baseUrl = (sExpandLevels) => sFriend.slice(1)
			+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
			+ ",HierarchyQualifier='OrgChart',NodeProperty='_/NodeID',Levels=1"
			+ (sExpandLevels ? ",ExpandLevels=" + sExpandLevels : "") + ")";
		const sSelect = "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID";
		const sFullSelect = "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,"
			+ "_/DistanceFromRoot,_/DrillState,_/NodeID";
		const sView = `
<t:Table id="table" rows="{path : '/Artists(ArtistID=\\'99\\',IsActiveEntity=false)/_Friend',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ArtistID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha (collapsed)
		// 5 Epsilon
		this.expectRequest(baseUrl() + sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "2",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DrillState : "collapsed",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DrillState : "leaf",
						NodeID : "5,false"
					}
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oBinding = oTable.getBinding("rows");
		checkTable("initial page", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[false, 1, "1", "Alpha"],
			[undefined, 1, "5", "Epsilon"]
		]);

		const oAlpha = oTable.getRows()[0].getBindingContext();

		// 1 Alpha
		//   2 Beta (collapsed)
		// 5 Epsilon
		this.expectRequest(sFriend.slice(1) + "?$apply=descendants($root/Artists"
				+ "(ArtistID='99',IsActiveEntity=false)/_Friend,OrgChart,_/NodeID,"
				+ "filter(ArtistID eq '1' and IsActiveEntity eq false),1)"
				+ sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "1",
				value : [{
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DrillState : "collapsed",
						NodeID : "2,false"
					}
				}]
			});

		oAlpha.expand();

		await this.waitForChanges(assert, "(1) expand Alpha");

		checkTable("after (1)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[true, 1, "1", "Alpha"],
			[false, 2, "2", "Beta"],
			[undefined, 1, "5", "Epsilon"]
		]);

		const oBeta = oTable.getRows()[1].getBindingContext();

		// 1 Alpha
		//   2 Beta (collapsed)
		//   4 Delta (via side effect)
		// 5 Epsilon
		this.expectRequest(baseUrl('[{"NodeID":"1,false","Levels":1}]')
				+ sFullSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "4",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "2",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "collapsed",
						NodeID : "2,false"
					}
				}, {
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Delta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(2) request side effects")
		]);

		checkTable("after (2)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='4',IsActiveEntity=false)"
		], [
			[true, 1, "1", "Alpha"],
			[false, 2, "2", "Beta"],
			[undefined, 2, "4", "Delta"]
		], 4);

		// 1 Alpha
		//   2 Beta
		//     3 Gamma
		//   4 Delta
		// 5 Epsilon
		this.expectRequest(
				baseUrl('[{"NodeID":"1,false","Levels":1},{"NodeID":"2,false","Levels":1}]')
				+ sFullSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "5",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "2,false"
					}
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "3,false"
					}
				}]
			});

		// code under test: side-effects expand
		oBeta.expand();

		await this.waitForChanges(assert, "(3) expand Beta");

		checkTable("after (3)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='3',IsActiveEntity=false)"
		], [
			[true, 1, "1", "Alpha"],
			[true, 2, "2", "Beta"],
			[undefined, 3, "3", "Gamma"]
		], 5);

		assert.strictEqual(oBinding.getDownloadUrl(),
			"/special/cases/" + sFriend.slice(1)
			+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root"
			+ "/Artists(ArtistID='99',IsActiveEntity=false)/_Friend,HierarchyQualifier='OrgChart'"
			+ ",NodeProperty='_/NodeID')"
			+ "&$select=ArtistID,IsActiveEntity,Name,_/DistanceFromRoot,_/DrillState,_/NodeID",
			"(4) getDownloadUrl");

		// 1 Alpha (collapsed)
		// 5 Epsilon
		this.expectRequest(
				baseUrl('[{"NodeID":"1,false","Levels":1},{"NodeID":"2,false","Levels":1}]')
				+ sFullSelect + "&$skip=4&$top=1", {
				value : [{
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "5,false"
					}
				}]
			});

		// code under test: collapse in unified cache
		oAlpha.collapse();

		await this.waitForChanges(assert, "(5) collapse Alpha");

		checkTable("after (5)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[false, 1, "1", "Alpha"],
			[undefined, 1, "5", "Epsilon"]
		]);

		// 1 Alpha
		//   2 Beta
		//     3 Gamma
		//   4 Delta
		// 5 Epsilon

		// code under test: expand and insert spliced children
		oAlpha.expand();

		await this.waitForChanges(assert, "(6) expand Alpha");

		checkTable("after (6)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='3',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[true, 1, "1", "Alpha"],
			[true, 2, "2", "Beta"],
			[undefined, 3, "3", "Gamma"]
		], 5);

		// 1 Alpha (collapsed)
		// 5 Epsilon

		// code under test: collapse in unified cache
		oAlpha.collapse();

		await this.waitForChanges(assert, "(7) collapse Alpha");

		checkTable("after (7)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[false, 1, "1", "Alpha"],
			[undefined, 1, "5", "Epsilon"]
		]);

		// 5 Epsilon
		// 1 Alpha (collapsed)
		this.expectRequest(baseUrl('[{"NodeID":"2,false","Levels":1}]')
				+ sFullSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "2",
				value : [{
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "5,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "collapsed",
						NodeID : "1,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(8) request side effects")
		]);

		checkTable("after (8)", assert, oTable, [
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)"
		], [
			[undefined, 1, "5", "Epsilon"],
			[false, 1, "1", "Alpha"]
		]);

		// 5 Epsilon
		// 1 Alpha
		//   4 Delta
		//   2 Beta
		//     3 Gamma
		this.expectRequest(
				baseUrl('[{"NodeID":"2,false","Levels":1},{"NodeID":"1,false","Levels":1}]')
				+ sFullSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "5",
				value : [{
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "5,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Delta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}]
			});

		// code under test
		oAlpha.expand();

		await this.waitForChanges(assert, "(9) expand Alpha");

		checkTable("after (9)", assert, oTable, [
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='4',IsActiveEntity=false)"
		], [
			[undefined, 1, "5", "Epsilon"],
			[true, 1, "1", "Alpha"],
			[undefined, 2, "4", "Delta"]
		], 5);

		// 5 Epsilon
		// 1 Alpha
		//   4 Delta
		//   2 Beta
		//     3 Gamma
		this.expectRequest(
				baseUrl('[{"NodeID":"2,false","Levels":1},{"NodeID":"1,false","Levels":1}]')
				+ sFullSelect + "&$skip=3&$top=2", {
				value : [{
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "2,false"
					}
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "3,false"
					}
				}]
			});

		// code under test
		oTable.setFirstVisibleRow(2);

		await this.waitForChanges(assert, "(10) scroll down");

		checkTable("after (10)", assert, oTable, [
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='4',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='3',IsActiveEntity=false)"
		], [
			[undefined, 2, "4", "Delta"],
			[true, 2, "2", "Beta"],
			[undefined, 3, "3", "Gamma"]
		]);
	});

	//*********************************************************************************************
	// Scenario: A hierarchy has an initial expand all and three visible rows. Expand and collapse
	// various nodes and request side effects.
	// (1) Collapse Beta -> Alpha, Beta, Delta
	// (2) Request side effects -> Delta is removed -> Alpha, Beta, Epsilon
	// (3) Collapse Alpha -> Alpha, Epsilon
	// (4) Check getDownloadUrl
	// (5) Expand Alpha (no Request, Beta is still collapsed)
	// (6) Collapse Alpha
	// (7) Request side effects -> swap position of Alpha and Epsilon
	// (8) Expand Alpha -> Beta is still collapsed
	// (9) Expand Beta -> ExpandLevels is removed from TopLevels
	// JIRA: CPOUI5ODATAV4-2032
	QUnit.test("Recursive Hierarchy: side-effects refresh (expand all)", async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sFriend = "/Artists(ArtistID='99',IsActiveEntity=false)/_Friend";
		const baseUrl = (sExpandLevels) => sFriend.slice(1)
			+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
			+ ",HierarchyQualifier='OrgChart',NodeProperty='_/NodeID'"
			+ (sExpandLevels ? ",ExpandLevels=" + sExpandLevels : "") + ")";
		const sSelect = "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,"
			+ "_/DistanceFromRoot,_/DrillState,_/NodeID";
		const sView = `
<t:Table id="table" rows="{path : '/Artists(ArtistID=\\'99\\',IsActiveEntity=false)/_Friend',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ArtistID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		//   2 Beta
		//     3 Gamma
		//   4 Delta
		// 5 Epsilon
		this.expectRequest(baseUrl() + sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "5",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "2,false"
					}
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "3,false"
					}
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oBinding = oTable.getBinding("rows");
		checkTable("initial page", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='3',IsActiveEntity=false)"
		], [
			[true, 1, "1", "Alpha"],
			[true, 2, "2", "Beta"],
			[undefined, 3, "3", "Gamma"]
		], 5);

		// Note: this context is later destroyed by a refresh while Alpha is collapsed
		let oBeta = oTable.getRows()[1].getBindingContext();

		// 1 Alpha
		//   2 Beta (collapsed)
		//     3 Gamma (spliced)
		//   4 Delta
		// 5 Epsilon
		this.expectRequest(baseUrl()
				+ "&$select=ArtistID,IsActiveEntity,Name,"
				+ "_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID"
				+ "&$skip=3&$top=1", {
				value : [{
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Delta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}]
			});

		// code under test
		oBeta.collapse();

		await this.waitForChanges(assert, "(1) collapse Beta");

		checkTable("after (1)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='4',IsActiveEntity=false)"
		], [
			[true, 1, "1", "Alpha"],
			[false, 2, "2", "Beta"],
			[undefined, 2, "4", "Delta"]
		], 4);

		// 1 Alpha
		//   2 Beta (collapsed)
		// 5 Epsilon
		this.expectRequest(baseUrl('[{"NodeID":"2,false","Levels":0}]')
				+ sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "3",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "collapsed",
						NodeID : "2,false"
					}
				}, {
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "5,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(2) request side effects")
		]);

		checkTable("after (2)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[true, 1, "1", "Alpha"],
			[false, 2, "2", "Beta"],
			[undefined, 1, "5", "Epsilon"]
		]);

		// 1 Alpha (collapsed)
		//   2 Beta (spliced)
		// 5 Epsilon

		const oAlpha = oTable.getRows()[0].getBindingContext();
		// code under test
		oAlpha.collapse();

		await this.waitForChanges(assert, "(3) collapse Alpha");

		checkTable("after (3)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[false, 1, "1", "Alpha"],
			[undefined, 1, "5", "Epsilon"]
		]);

		assert.strictEqual(
			oBinding.getDownloadUrl(),
			"/special/cases/" + baseUrl()
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DistanceFromRoot,_/DrillState,_/NodeID",
			"(4) getDownloadUrl");

		// 1 Alpha
		//   2 Beta (collapsed)
		// 5 Epsilon

		// code under test
		oAlpha.expand();

		await this.waitForChanges(assert, "(5) expand Alpha");

		checkTable("after (5)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[true, 1, "1", "Alpha"],
			[false, 2, "2", "Beta"],
			[undefined, 1, "5", "Epsilon"]
		]);

		// 1 Alpha (collapsed)
		//   2 Beta (spliced)
		// 5 Epsilon

		// code under test
		oAlpha.collapse();

		await this.waitForChanges(assert, "(6) collapse Alpha");

		checkTable("after (6)", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='5',IsActiveEntity=false)"
		], [
			[false, 1, "1", "Alpha"],
			[undefined, 1, "5", "Epsilon"]
		]);

		// 5 Epsilon
		// 1 Alpha (collapsed)
		this.expectRequest(
			baseUrl('[{"NodeID":"2,false","Levels":0},{"NodeID":"1,false","Levels":0}]')
			+ sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "2",
				value : [{
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "5,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "collapsed",
						NodeID : "1,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(7) request side effects")
		]);

		checkTable("after (7)", assert, oTable, [
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)"
		], [
			[undefined, 1, "5", "Epsilon"],
			[false, 1, "1", "Alpha"]
		]);

		// 5 Epsilon
		// 1 Alpha
		//   2 Beta (collapsed)
		this.expectRequest(baseUrl('[{"NodeID":"2,false","Levels":0}]')
				+ sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "3",
				value : [{
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "5,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "collapsed",
						NodeID : "2,false"
					}
				}]
			});

		// code under test
		oAlpha.expand();

		await this.waitForChanges(assert, "(8) expand Alpha");

		checkTable("after (8)", assert, oTable, [
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)"
		], [
			[undefined, 1, "5", "Epsilon"],
			[true, 1, "1", "Alpha"],
			[false, 2, "2", "Beta"]
		]);

		oBeta = oTable.getRows()[2].getBindingContext();

		// 5 Epsilon
		// 1 Alpha
		//   2 Beta
		//     3 Gamma
		this.expectRequest(baseUrl() + sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "4",
				value : [{
					ArtistID : "5",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "5,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "2",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "2,false"
					}
				}]
			});

		// code under test
		oBeta.expand();

		await this.waitForChanges(assert, "(9) expand Beta");

		checkTable("after (9)", assert, oTable, [
			sFriend + "(ArtistID='5',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)"
		], [
			[undefined, 1, "5", "Epsilon"],
			[true, 1, "1", "Alpha"],
			[true, 2, "2", "Beta"]
		], 4);
	});

	//*********************************************************************************************
	// Scenario: A hierarchy has an initial expandTo=1 and three visible rows.
	// (1) Expand Alpha
	// (2) Create New1, New2, New3 below Alpha; create New4 below Beta; create New5 below Gamma;
	//     create New6 below New3
	// (3) Side-effects refresh (-> unified cache; New2 is already read in-place, it is shifted when
	//     moving New1 to its out-of-place position; Beta is already read in-place, but shifted
	//     when moving New1 and New3; Gamma is only placeholder when moving New5).
	//     Additionally request the first row in parallel just like the tree table occasionally
	//     does, this must not cause further requests.
	// (4) Check all contexts
	// (5) Delete New1 (no longer requested as out-of-place node afterward)
	// (6) Side-effects refresh (moves New3 below Gamma)
	// (7) Check all contexts
	// (8) Side-effects refresh (New3 and New6 are no longer requested as out-of-place nodes)
	// (9) Delete Alpha
	// (10) Side-effects refresh (expand state and out-of-place information are dropped for Alpha's
	//      descendants)
	// (11) Refresh the binding (out-of-place information is no longer kept, tree is collapsed again
	//      to 1 level)
	// JIRA: CPOUI5ODATAV4-2454
	QUnit.test("Recursive Hierarchy: out of place", async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sFriend = "Artists(ArtistID='99',IsActiveEntity=false)/_Friend";
		const sFilterSearchPrefix = "ancestors("
			+ "$root/" + sFriend + ",OrgChart,_/NodeID,"
			+ "filter(IsActiveEntity eq false)/search(covfefe),keep start)/";
		const baseUrl = (sExpandLevels) => sFriend
			+ "?custom=foo&$apply=" + sFilterSearchPrefix + "orderby(defaultChannel)"
			+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/" + sFriend
			+ ",HierarchyQualifier='OrgChart',NodeProperty='_/NodeID',Levels=1"
			+ (sExpandLevels ? ",ExpandLevels=" + sExpandLevels : "") + ")";
		const sCountUrl = sFriend + "/$count?$filter=IsActiveEntity eq false&custom=foo"
			+ "&$search=covfefe";
		const sExpandLevels = JSON.stringify([
			{NodeID : "1,false", Levels : 1},
			{NodeID : "2,false", Levels : 1},
			{NodeID : "3,false", Levels : 1},
			{NodeID : "13,false", Levels : 1}
		]);
		const sExpandLevelsAfterDelete = JSON.stringify([
			{NodeID : "3,false", Levels : 1},
			{NodeID : "13,false", Levels : 1}
		]);
		const sView = `
<t:Table id="table" rows="{path : '/Artists(ArtistID=\\'99\\',IsActiveEntity=false)/_Friend',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart',
				search : 'covfefe'
			},
			$count : true,
			$filter : 'IsActiveEntity eq false',
			$orderby : 'defaultChannel',
			custom : 'foo'
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ArtistID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// Server:               UI:
		// 1 Alpha               1 Alpha
		//   12 New2               13 New3
		//    2 Beta                  16 New6
		//      14 New4            12 New2
		//   11 New1               11 New1
		//   13 New3                2 Beta
		//      16 New6               14 New4
		// 3 Gamma               3 Gamma
		//   15 New5               15 New5
		// 4 Delta               4 Delta
		this.expectRequest(sCountUrl, 4)
			.expectRequest(baseUrl()
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "3",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DrillState : "collapsed",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma",
					_ : {
						DrillState : "leaf",
						NodeID : "3,false"
					}
				}, {
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Delta",
					_ : {
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oBinding = oTable.getBinding("rows");
		checkTable("initial page", assert, oTable, [
			`/${sFriend}(ArtistID='1',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='3',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='4',IsActiveEntity=false)`
		], [
			[false, 1, "1", "Alpha"],
			[undefined, 1, "3", "Gamma"],
			[undefined, 1, "4", "Delta"]
		]);
		const oAlpha = oTable.getRows()[0].getBindingContext();
		const oGamma = oTable.getRows()[1].getBindingContext();

		this.expectRequest(sFriend + "?custom=foo&$apply=" + sFilterSearchPrefix
				+ "descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '1' and IsActiveEntity eq false),1)"
				+ "/orderby(defaultChannel)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "1",
				value : [{
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DrillState : "leaf",
						NodeID : "2,false"
					}
				}]
			});

		oAlpha.expand();

		await this.waitForChanges(assert, "(1) expand Alpha");

		checkTable("after (1)", assert, oTable, [
			`/${sFriend}(ArtistID='1',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='2',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='3',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='4',IsActiveEntity=false)`
		], [
			[true, 1, "1", "Alpha"],
			[undefined, 2, "2", "Beta"],
			[undefined, 1, "3", "Gamma"]
		]);
		const oBeta = oTable.getRows()[1].getBindingContext();

		const create = async (sId, sName, oParent) => {
			const sParentId = oParent.getProperty("ArtistID");
			this.expectRequest({
					method : "POST",
					url : sFriend + "?custom=foo",
					payload : {
						"BestFriend@odata.bind" :
							`../Artists(ArtistID='${sParentId}',IsActiveEntity=false)`,
						Name : sName
					}
				}, {
					ArtistID : sId,
					IsActiveEntity : false,
					Name : sName,
					_ : null // not available w/ RAP for a non-hierarchical request
				})
				// no sFilterSearchPrefix (SNOW: DINC0087713)
				.expectRequest(sFriend + "?custom=foo&$apply=descendants($root/" + sFriend
					+ ",OrgChart,_/NodeID,filter(ArtistID eq '" + sParentId
					+ "' and IsActiveEntity eq false),1)"
					+ "&$filter=ArtistID eq '" + sId
					+ "' and IsActiveEntity eq false&$select=_/NodeID", {
					value : [{
						_ : {
							NodeID : `${sId},false`
						}
					}]
				});

			const oContext = oBinding.create({
				"@$ui5.node.parent" : oParent,
				Name : sName
			}, /*bSkipRefresh*/true);

			await Promise.all([
				oContext.created(),
				this.waitForChanges(assert, `(2) create ${sName}`)
			]);

			return oContext;
		};

		await create("11", "New1", oAlpha);
		await create("12", "New2", oAlpha);
		const oNew3 = await create("13", "New3", oAlpha);
		await create("14", "New4", oBeta);
		await create("15", "New5", oGamma);
		const oNew6 = await create("16", "New6", oNew3); // nested below New3

		checkTable("after (2)", assert, oTable, [
			`/${sFriend}(ArtistID='1',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='13',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='16',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='12',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='11',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='2',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='14',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='3',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='15',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='4',IsActiveEntity=false)`
		], [
			[true, 1, "1", "Alpha"],
			[true, 2, "13", "New3"],
			[undefined, 3, "16", "New6"]
		]);

		this.expectRequest(sCountUrl, 10)
			.expectRequest({
				batchNo : 15,
				url : baseUrl(sExpandLevels)
					+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
					+ ",_/DrillState,_/NodeID"
					+ "&$count=true&$skip=0&$top=3"
			}, {
				"@odata.count" : "10",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha*",
					_ : {
						DescendantCount : "6",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "12",
					IsActiveEntity : false,
					Name : "New2*",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "12,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta*",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "2,false"
					}
				}]
			})
			.expectRequest({
				batchNo : 15,
				url : baseUrl(sExpandLevels)
					+ "&$select=ArtistID,IsActiveEntity,_/DescendantCount,_/DistanceFromRoot"
					+ ",_/DrillState,_/Limited_Rank"
					+ "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
					+ " or ArtistID eq '11' and IsActiveEntity eq false"
					+ " or ArtistID eq '12' and IsActiveEntity eq false"
					+ " or ArtistID eq '13' and IsActiveEntity eq false"
					+ " or ArtistID eq '14' and IsActiveEntity eq false"
					+ " or ArtistID eq '15' and IsActiveEntity eq false"
					+ " or ArtistID eq '16' and IsActiveEntity eq false"
					+ " or ArtistID eq '2' and IsActiveEntity eq false"
					+ " or ArtistID eq '3' and IsActiveEntity eq false"
					+ "&$top=9"
			}, {
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "6",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "0"
					}
				}, {
					ArtistID : "12",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						Limited_Rank : "1"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "2"
					}
				}, {
					ArtistID : "14",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						Limited_Rank : "3"
					}
				}, {
					ArtistID : "11",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						Limited_Rank : "4"
					}
				}, {
					ArtistID : "13",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						Limited_Rank : "5"
					}
				}, {
					ArtistID : "16",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						Limited_Rank : "6"
					}
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "7"
					}
				}, {
					ArtistID : "15",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						Limited_Rank : "8"
					}
				}]
			})
			.expectRequest({
				batchNo : 15,
				url : sFriend + "?custom=foo&$apply=descendants($root/" + sFriend
					+ ",OrgChart,_/NodeID,filter(ArtistID eq '1' and IsActiveEntity eq false),1)"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
					+ "&$filter=ArtistID eq '11' and IsActiveEntity eq false"
					+ " or ArtistID eq '12' and IsActiveEntity eq false"
					+ " or ArtistID eq '13' and IsActiveEntity eq false"
					+ "&$top=3"
			}, {
				value : [{
					ArtistID : "11",
					IsActiveEntity : false,
					Name : "New1*",
					_ : {
						NodeID : "11,false"
					}
				}, {
					ArtistID : "12",
					IsActiveEntity : false,
					Name : "New2*",
					_ : {
						NodeID : "12,false"
					}
				}, {
					ArtistID : "13",
					IsActiveEntity : false,
					Name : "New3*",
					_ : {
						NodeID : "13,false"
					}
				}]
			})
			.expectRequest({
				batchNo : 15,
				url : sFriend + "?custom=foo&$apply=descendants($root/" + sFriend
					+ ",OrgChart,_/NodeID,filter(ArtistID eq '2' and IsActiveEntity eq false),1)"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
					+ "&$filter=ArtistID eq '14' and IsActiveEntity eq false"
					+ "&$top=1"
			}, {
				value : [{
					ArtistID : "14",
					IsActiveEntity : false,
					Name : "New4*",
					_ : {
						NodeID : "14,false"
					}
				}]
			})
			.expectRequest({
				batchNo : 15,
				url : sFriend + "?custom=foo&$apply=descendants($root/" + sFriend
					+ ",OrgChart,_/NodeID,filter(ArtistID eq '3' and IsActiveEntity eq false),1)"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
					+ "&$filter=ArtistID eq '15' and IsActiveEntity eq false"
					+ "&$top=1"
			}, {
				value : [{
					ArtistID : "15",
					IsActiveEntity : false,
					Name : "New5*",
					_ : {
						NodeID : "15,false"
					}
				}]
			})
			.expectRequest({
				batchNo : 15,
				url : sFriend + "?custom=foo&$apply=descendants($root/" + sFriend
					+ ",OrgChart,_/NodeID,filter(ArtistID eq '13' and IsActiveEntity eq false),1)"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
					+ "&$filter=ArtistID eq '16' and IsActiveEntity eq false"
					+ "&$top=1"
			}, {
				value : [{
					ArtistID : "16",
					IsActiveEntity : false,
					Name : "New6*",
					_ : {
						NodeID : "16,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			// code under test: requesting one row already covered by side-effects refresh
			oBinding.getContexts(0, 1),
			this.waitForChanges(assert, "(3) side-effects refresh")
		]);

		checkTable("after (3)", assert, oTable, [
			`/${sFriend}(ArtistID='1',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='13',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='16',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='12',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='11',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='2',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='14',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='15',IsActiveEntity=false)`
		], [
			[true, 1, "1", "Alpha*"],
			[true, 2, "13", "New3*"],
			[undefined, 3, "16", "New6*"]
		], 10);
		assert.strictEqual(oBinding.getCurrentContexts()[1], oNew3);
		assert.strictEqual(oBinding.getCurrentContexts()[2], oNew6);

		this.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$skip=7&$top=1", {
				value : [{
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma*",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "3,false"
					}
				}]
			})
			.expectRequest(
				baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$skip=9&$top=1", {
				value : [{
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Delta*",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}]
			});

		await this.checkAllContexts("(4) check all contexts", assert, oBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[true, 1, "1", "Alpha*"],
				[true, 2, "13", "New3*"],
				[undefined, 3, "16", "New6*"],
				[undefined, 2, "12", "New2*"],
				[undefined, 2, "11", "New1*"],
				[true, 2, "2", "Beta*"],
				[undefined, 3, "14", "New4*"],
				[true, 1, "3", "Gamma*"],
				[undefined, 2, "15", "New5*"],
				[undefined, 1, "4", "Delta*"]
			]);

		// this context has been destroyed by the refresh because it was not visible
		const [oNew1] = await oBinding.requestContexts(4, 1);

		this.expectRequest("DELETE Artists(ArtistID='11',IsActiveEntity=false)");

		await Promise.all([
			// code under test
			oNew1.delete(),
			this.waitForChanges(assert, "(5) delete New1")
		]);

		// After deleting New1 & side-effects refresh
		// Server:                          UI:
		// 1 Alpha                          1 Alpha
		//   12 New2                          12 New2 (out of place)
		//    2 Beta                           2 Beta
		//      14 New4                          14 New4 (out of place)
		// 3 Gamma                          3 Gamma
		//   13 New3 (moved)                  15 New5 (out of place)
		//      16 New6                       13 New3 (moved)
		//   15 New5                             16 New6
		// 4 Delta                          4 Delta

		this.expectRequest(sCountUrl, 9)
			.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "9",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha**",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "12",
					IsActiveEntity : false,
					Name : "New2**",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "12,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta**",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "2,false"
					}
				}]
			})
			.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/Limited_Rank"
				+ "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
				+ " or ArtistID eq '12' and IsActiveEntity eq false"
				+ " or ArtistID eq '13' and IsActiveEntity eq false"
				+ " or ArtistID eq '14' and IsActiveEntity eq false"
				+ " or ArtistID eq '15' and IsActiveEntity eq false"
				+ " or ArtistID eq '16' and IsActiveEntity eq false"
				+ " or ArtistID eq '2' and IsActiveEntity eq false"
				+ " or ArtistID eq '3' and IsActiveEntity eq false"
				+ "&$top=8", {
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "0"
					}
				}, {
					ArtistID : "12",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						Limited_Rank : "1"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "2"
					}
				}, {
					ArtistID : "14",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						Limited_Rank : "3"
					}
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "4"
					}
				}, {
					ArtistID : "13",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						Limited_Rank : "5"
					}
				}, {
					ArtistID : "16",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						Limited_Rank : "6"
					}
				}, {
					ArtistID : "15",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						Limited_Rank : "7"
					}
				}]
			})
			.expectRequest(sFriend
				+ "?custom=foo&$apply=descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '1' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				+ "&$filter=ArtistID eq '12' and IsActiveEntity eq false"
				+ " or ArtistID eq '13' and IsActiveEntity eq false"
				+ "&$top=2", {
				value : [{
					ArtistID : "12",
					IsActiveEntity : false,
					Name : "New2**",
					_ : {
						NodeID : "12,false"
					}
				}]
			})
			.expectRequest(sFriend
				+ "?custom=foo&$apply=descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '2' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				+ "&$filter=ArtistID eq '14' and IsActiveEntity eq false"
				+ "&$top=1", {
				value : [{
					ArtistID : "14",
					IsActiveEntity : false,
					Name : "New4**",
					_ : {
						NodeID : "14,false"
					}
				}]
			})
			.expectRequest(sFriend
				+ "?custom=foo&$apply=descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '3' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				+ "&$filter=ArtistID eq '15' and IsActiveEntity eq false"
				+ "&$top=1", {
				value : [{
					ArtistID : "15",
					IsActiveEntity : false,
					Name : "New5**",
					_ : {
						NodeID : "15,false"
					}
				}]
			})
			.expectRequest(sFriend
				+ "?custom=foo&$apply=descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '13' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				+ "&$filter=ArtistID eq '16' and IsActiveEntity eq false"
				+ "&$top=1", {
				value : [{
					ArtistID : "16",
					IsActiveEntity : false,
					Name : "New6**",
					_ : {
						NodeID : "16,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(6) side-effects refresh")
		]);

		this.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$skip=4&$top=1", {
				value : [{
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma**",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "3,false"
					}
				}]
			})
			.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$skip=5&$top=1", {
				value : [{
					ArtistID : "13",
					IsActiveEntity : false,
					Name : "New3**",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "13,false"
					}
				}]
			})
			.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$skip=8&$top=1", {
				value : [{
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Delta**",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}]
			});

		await this.checkAllContexts("(7) check all contexts", assert, oBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[true, 1, "1", "Alpha**"],
				[undefined, 2, "12", "New2**"],
				[true, 2, "2", "Beta**"],
				[undefined, 3, "14", "New4**"],
				[true, 1, "3", "Gamma**"],
				[undefined, 2, "15", "New5**"],
				[true, 2, "13", "New3**"],
				[undefined, 3, "16", "New6**"],
				[undefined, 1, "4", "Delta**"]
			]);

		this.expectRequest(sCountUrl, 9)
			.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "9",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha**",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "12",
					IsActiveEntity : false,
					Name : "New2**",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "12,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta**",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "2,false"
					}
				}]
			})
			.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/Limited_Rank"
				+ "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
				+ " or ArtistID eq '12' and IsActiveEntity eq false"
				+ " or ArtistID eq '14' and IsActiveEntity eq false"
				+ " or ArtistID eq '15' and IsActiveEntity eq false"
				+ " or ArtistID eq '2' and IsActiveEntity eq false"
				+ " or ArtistID eq '3' and IsActiveEntity eq false"
				+ "&$top=6", {
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "0"
					}
				}, {
					ArtistID : "12",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						Limited_Rank : "1"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "2"
					}
				}, {
					ArtistID : "14",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						Limited_Rank : "3"
					}
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "4"
					}
				}, {
					ArtistID : "15",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						Limited_Rank : "7"
					}
				}]
			})
			.expectRequest(sFriend
				+ "?custom=foo&$apply=descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '1' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				+ "&$filter=ArtistID eq '12' and IsActiveEntity eq false"
				+ "&$top=1", {
				value : [{
					ArtistID : "12",
					IsActiveEntity : false,
					Name : "New2**",
					_ : {
						NodeID : "12,false"
					}
				}]
			})
			.expectRequest(sFriend
				+ "?custom=foo&$apply=descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '2' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				+ "&$filter=ArtistID eq '14' and IsActiveEntity eq false"
				+ "&$top=1", {
				value : [{
					ArtistID : "14",
					IsActiveEntity : false,
					Name : "New4**",
					_ : {
						NodeID : "14,false"
					}
				}]
			})
			.expectRequest(sFriend
				+ "?custom=foo&$apply=descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '3' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				+ "&$filter=ArtistID eq '15' and IsActiveEntity eq false"
				+ "&$top=1", {
				value : [{
					ArtistID : "15",
					IsActiveEntity : false,
					Name : "New5**",
					_ : {
						NodeID : "15,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(8) side-effects refresh")
		]);

		this.expectRequest("DELETE Artists(ArtistID='1',IsActiveEntity=false)")
			.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$skip=0&$top=1", {
				value : [{
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma**",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "3,false"
					}
				}]
			})
			.expectRequest(baseUrl(sExpandLevels)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$skip=1&$top=1", {
				value : [{
					ArtistID : "13",
					IsActiveEntity : false,
					Name : "New3**",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "13,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oAlpha.delete(),
			this.waitForChanges(assert, "(9) delete Alpha")
		]);

		checkTable("after (9)", assert, oTable, [
			`/${sFriend}(ArtistID='3',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='15',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='13',IsActiveEntity=false)`
		], [
			[true, 1, "3", "Gamma**"],
			[undefined, 2, "15", "New5**"],
			[true, 2, "13", "New3**"]
		], 5);

		this.expectRequest(sCountUrl, 5)
			.expectRequest(baseUrl(sExpandLevelsAfterDelete)
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/NodeID"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "5",
				value : [{
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma**",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "3,false"
					}
				}, {
					ArtistID : "13",
					IsActiveEntity : false,
					Name : "New3**",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "13,false"
					}
				}, {
					ArtistID : "16",
					IsActiveEntity : false,
					Name : "New6**",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "16,false"
					}
				}]
			})
			.expectRequest(baseUrl(sExpandLevelsAfterDelete)
				+ "&$select=ArtistID,IsActiveEntity,_/DescendantCount,_/DistanceFromRoot"
				+ ",_/DrillState,_/Limited_Rank"
				+ "&$filter=ArtistID eq '15' and IsActiveEntity eq false"
				+ " or ArtistID eq '3' and IsActiveEntity eq false"
				+ "&$top=2", {
				value : [{
					ArtistID : "3",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "n/a", // parent's DistanceFromRoot is not yet relevant
						DrillState : "expanded",
						Limited_Rank : "0"
					}
				}, {
					ArtistID : "15",
					IsActiveEntity : false,
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						Limited_Rank : "3"
					}
				}]
			})
			.expectRequest(sFriend
				+ "?custom=foo&$apply=descendants($root/" + sFriend
				+ ",OrgChart,_/NodeID,filter(ArtistID eq '3' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/NodeID"
				+ "&$filter=ArtistID eq '15' and IsActiveEntity eq false"
				+ "&$top=1", {
				value : [{
					ArtistID : "15",
					IsActiveEntity : false,
					Name : "New5**",
					_ : {
						NodeID : "15,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(10) side-effects refresh")
		]);

		checkTable("after (10)", assert, oTable, [
			`/${sFriend}(ArtistID='3',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='15',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='13',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='16',IsActiveEntity=false)`
		], [
			[true, 1, "3", "Gamma**"],
			[undefined, 2, "15", "New5**"],
			[true, 2, "13", "New3**"]
		], 5);

		this.expectRequest(sCountUrl, 5)
			.expectRequest(baseUrl()
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID"
				+ "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "2",
				value : [{
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Gamma***",
					_ : {
						DrillState : "collapsed",
						NodeID : "3,false"
					}
				}, {
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Delta***",
					_ : {
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}]
			});

		await Promise.all([
			oBinding.requestRefresh(),
			this.waitForChanges(assert, "(11) refresh the binding")
		]);

		checkTable("after (11)", assert, oTable, [
			`/${sFriend}(ArtistID='3',IsActiveEntity=false)`,
			`/${sFriend}(ArtistID='4',IsActiveEntity=false)`
		], [
			[false, 1, "3", "Gamma***"],
			[undefined, 1, "4", "Delta***"]
		]);
	});

	//*********************************************************************************************
	// Scenario: A hierarchy has two visible rows, expandTo 2, and first visible row 2.
	// (1) Collapse Gamma
	// (2) Create root nodes Zeta and Eta which the server puts at the end; create Theta below Alpha
	// (3) Side-effects refresh (-> unified cache; after having read the in-place data, the created
	//     nodes are moved to the front and the in-place range is shifted)
	// (4) Check all contexts
	// JIRA: CPOUI5ODATAV4-2454
	QUnit.test("Recursive Hierarchy: out of place, root, expandTo > 1", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sCountUrl = "EMPLOYEES/$count?$filter=AGE gt 20&custom=foo&$search=covfefe";
		const sFilterSearchPrefix = "ancestors($root/EMPLOYEES,OrgChart,ID,filter(AGE gt 20)"
			+ "/search(covfefe),keep start)/";
		const sUrl = "EMPLOYEES"
			+ "?custom=foo&$apply=" + sFilterSearchPrefix + "orderby(ENTRYDATE)"
			+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
			+ ",HierarchyQualifier='OrgChart',NodeProperty='ID',Levels=2)";
		const sUrlWithExpandLevels = sUrl.slice(0, -1) + ",ExpandLevels="
			+ JSON.stringify([{NodeID : "3", Levels : 0}]) + ")";
		const sView = `
<t:Table id="table" firstVisibleRow="2" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 2,
				hierarchyQualifier : 'OrgChart',
				search : 'covfefe'
			},
			$count : true,
			$filter : 'AGE gt 20',
			$orderby : 'ENTRYDATE',
			custom : 'foo'
		}}" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		//   8 Theta (created)
		// 2 Beta
		// 3 Gamma (first visible row)
		//   4 Delta
		// 5 Epsilon (w/o this, the first visible row would be decreased)
		// 6 Zeta (created)
		// 7 Eta (created)
		this.expectRequest(sCountUrl, 5)
			.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$count=true&$skip=2&$top=2", {
				"@odata.count" : "5",
				value : [{
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "3",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oBinding = oTable.getBinding("rows");
		const oGamma = oTable.getRows()[0].getBindingContext();
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')"
		], [
			[true, 1, "Gamma"],
			[undefined, 2, "Delta"]
		], 5);

		this.expectRequest(sUrl
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name&$skip=4&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "5",
					Name : "Epsilon"
				}]
			});

		oGamma.collapse();

		await this.waitForChanges(assert, "(1) collapse Gamma");

		checkTable("after (1)", assert, oTable, [
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')"
		], [
			[false, 1, "Gamma"],
			[undefined, 1, "Epsilon"]
		], 4);

		this.expectRequest(
				{method : "POST", url : "EMPLOYEES?custom=foo", payload : {Name : "Zeta"}},
				{ID : "6", Name : "Zeta"})
			// Beta becomes visible, but oFirstLevel reads more due to the transient element Zeta
			.expectRequest(sUrl
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name&$skip=0&$top=2", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}]
			})
			.expectRequest(sUrl + "&$filter=ID eq '6'&$select=LimitedRank",
				{value : [{LimitedRank : "5"}]});

		const oZeta = oBinding.create({Name : "Zeta"}, /*bSkipRefresh*/true);

		await Promise.all([
			oZeta.created(), // must not interleave two creates
			this.waitForChanges(assert, "(2a) create Zeta")
		]);

		this.expectRequest(
				{method : "POST", url : "EMPLOYEES?custom=foo", payload : {Name : "Eta"}},
				{ID : "7", Name : "Eta"})
			.expectRequest(sUrl + "&$filter=ID eq '7'&$select=LimitedRank",
				{value : [{LimitedRank : "6"}]});

		const oEta = oBinding.create({Name : "Eta"}, /*bSkipRefresh*/true);

		await Promise.all([
			oEta.created(),
			this.waitForChanges(assert, "(2b) create Eta")
		]);

		this.expectRequest({
				method : "POST",
				url : "EMPLOYEES?custom=foo",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')",
					Name : "Theta"
				}
			}, {ID : "8", Name : "Theta"})
			.expectRequest(sUrl + "&$filter=ID eq '8'&$select=LimitedRank",
				{value : [{LimitedRank : "1"}]});

		const oAlpha = oTable.getRows()[0].getBindingContext();
		const oTheta = oBinding.create({
			"@$ui5.node.parent" : oAlpha,
			Name : "Theta"
		}, /*bSkipRefresh*/true);

		await Promise.all([
			oTheta.created(),
			this.waitForChanges(assert, "(2c) create Theta")
		]);

		checkTable("after (2)", assert, oTable, [
			"/EMPLOYEES('7')",
			"/EMPLOYEES('6')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('8')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Theta"]
		]);

		this.expectRequest(sCountUrl, 8)
			.expectRequest({
				batchNo : 9,
				url : sUrlWithExpandLevels
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$count=true&$skip=0&$top=4"
			}, {
				"@odata.count" : "7",
				value : [{
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha*"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "8",
					Name : "Theta*"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta*"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "collapsed",
					ID : "3",
					Name : "Gamma*"
				}]
			})
			.expectRequest({
				batchNo : 9,
				url : sUrlWithExpandLevels
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,LimitedRank"
					+ "&$filter=ID eq '1' or ID eq '6' or ID eq '7' or ID eq '8'&$top=4"
			}, {
				value : [{
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					LimitedRank : "0"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "8",
					LimitedRank : "1"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "6",
					LimitedRank : "5"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "7",
					LimitedRank : "6"
				}]
			})
			.expectRequest({
				batchNo : 9,
				// Important: this request contains no Levels=2 and no ExpandLevels
				url : "EMPLOYEES?custom=foo&$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels"
					+ "(HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
					+ "&$select=ID,Name"
					+ "&$filter=ID eq '6' or ID eq '7'&$top=2"
			}, {
				value : [
					{ID : "6", Name : "Zeta*"},
					{ID : "7", Name : "Eta*"}
				]
			})
			.expectRequest({
				batchNo : 9,
				// Important: this request contains no Levels=2 and no ExpandLevels
				url : "EMPLOYEES?custom=foo&$apply=descendants($root/EMPLOYEES"
					+ ",OrgChart,ID,filter(ID eq '1'),1)"
					+ "&$select=ID,Name"
					+ "&$filter=ID eq '8'"
					+ "&$top=1"
			}, {
				value : [{ID : "8", Name : "Theta*"}]
			});

		await Promise.all([
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(3) side-effects refresh")
		]);

		checkTable("after (3)", assert, oTable, [
			"/EMPLOYEES('7')",
			"/EMPLOYEES('6')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('8')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "Alpha*"],
			[undefined, 2, "Theta*"]
		], 7);

		this.expectRequest(sUrlWithExpandLevels
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$skip=4&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "5",
					Name : "Epsilon*"
				}]
			});

		await this.checkAllContexts("(4) check all contexts", assert, oBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "Name"], [
				[undefined, 1, "Eta*"],
				[undefined, 1, "Zeta*"],
				[true, 1, "Alpha*"],
				[undefined, 2, "Theta*"],
				[undefined, 1, "Beta*"],
				[false, 1, "Gamma*"],
				[undefined, 1, "Epsilon*"]
			]);
	});

	//*********************************************************************************************
	// Scenario: A hierarchy has two visible rows and is completely expanded.
	// (1) Create New1 below Alpha; create New2 below New1
	// (2) Side-effects refresh (delivers new nested "bonus items" below New1)
	// (3) Check all contexts
	// (4) Collapse Alpha
	// (5) Side-effects refresh
	// (6) Expand Alpha (restores out-of-place positions)
	// (7) Check all contexts
	// JIRA: CPOUI5ODATAV4-2510
	QUnit.test("Recursive Hierarchy: out of place, bonus item, collapse", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sUrl = "EMPLOYEES"
			+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
			+ ",HierarchyQualifier='OrgChart',NodeProperty='ID')";
		const sUrlWithExpandLevelsCollapsed = sUrl.slice(0, -1) + ",ExpandLevels="
			+ JSON.stringify([{NodeID : "1", Levels : 0}]) + ")";
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		//    2 Beta
		//   11 New1 (created)
		//      21 NewFromServer1 ("bonus item")
		//         22 NewFromServer2 ("bonus item")
		//      12 New2 (created)
		// 3 Gamma
		this.expectRequest(sUrl
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "3",
				value : [{
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oBinding = oTable.getBinding("rows");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"]
		], 3);
		const oAlpha = oBinding.getCurrentContexts()[0];

		this.expectRequest({
				method : "POST",
				url : "EMPLOYEES",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')",
					Name : "New1"
				}
			}, {
				ID : "11",
				Name : "New1"
			})
			.expectRequest(sUrl + "&$filter=ID eq '11'&$select=LimitedRank", {
				value : [{
					LimitedRank : "2"
				}]
			});

		const oNew1 = oBinding.create({
			"@$ui5.node.parent" : oAlpha,
			Name : "New1"
		}, /*bSkipRefresh*/true);

		await Promise.all([
			oNew1.created(),
			this.waitForChanges(assert, "(1) create New1")
		]);

		this.expectRequest({
				method : "POST",
				url : "EMPLOYEES",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('11')",
					Name : "New2"
				}
			}, {
				ID : "12",
				Name : "New2"
			})
			.expectRequest(sUrl + "&$filter=ID eq '12'&$select=LimitedRank", {
				value : [{
					LimitedRank : "3"
				}]
			});

		const oNew2 = oBinding.create({
			"@$ui5.node.parent" : oNew1,
			Name : "New2"
		}, /*bSkipRefresh*/true);

		await Promise.all([
			oNew2.created(),
			this.waitForChanges(assert, "(1) create New2")
		]);

		checkTable("after (1)", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('11')",
			"/EMPLOYEES('12')",
			"/EMPLOYEES('2')"
		], [
			[true, 1, "Alpha"],
			[true, 2, "New1"]
		], 5);

		const expectSideEffectsRequests = () => {
			this.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$count=true&$skip=0&$top=2", {
					"@odata.count" : "7",
					value : [{
						DescendantCount : "5",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						ID : "1",
						Name : "Alpha*"
					}, {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						Name : "Beta*"
					}]
				})
				.expectRequest(sUrl
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,LimitedRank"
					+ "&$filter=ID eq '1' or ID eq '11' or ID eq '12'&$top=3", {
					value : [{
						DescendantCount : "5",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						ID : "1",
						LimitedRank : "0"
					}, {
						DescendantCount : "3",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						ID : "11",
						LimitedRank : "2"
					}, {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						ID : "12",
						LimitedRank : "5"
					}]
				})
				.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
					+ "&$select=ID,Name&$filter=ID eq '11'&$top=1", {
					value : [
						{ID : "11", Name : "New1*"}
					]
				})
				.expectRequest("EMPLOYEES"
					+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '11'),1)"
					+ "&$select=ID,Name&$filter=ID eq '12'&$top=1", {
					value : [
						{ID : "12", Name : "New2*"}
					]
				});
		};

		expectSideEffectsRequests();

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(2) side-effects refresh")
		]);

		const checkAllContexts = async (iStep) => {
			this.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$skip=3&$top=2", {
					value : [{
						DescendantCount : "1",
						DistanceFromRoot : "2",
						DrillState : "expanded",
						ID : "21",
						Name : "NewFromServer1*"
					}, {
						DescendantCount : "0",
						DistanceFromRoot : "3",
						DrillState : "leaf",
						ID : "22",
						Name : "NewFromServer2*"
					}]
				})
				.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$skip=6&$top=1", {
					value : [{
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						ID : "3",
						Name : "Gamma*"
					}]
				});

			await this.checkAllContexts(`(${iStep}) check all contexts`, assert, oBinding,
				["@$ui5.node.isExpanded", "@$ui5.node.level", "Name"], [
					[true, 1, "Alpha*"],
					[true, 2, "New1*"],
					[undefined, 3, "New2*"],
					[true, 3, "NewFromServer1*"],
					[undefined, 4, "NewFromServer2*"],
					[undefined, 2, "Beta*"],
					[undefined, 1, "Gamma*"]
				]);
		};

		await checkAllContexts(3);

		oAlpha.collapse();

		await this.waitForChanges(assert, "(4) collapse Alpha");

		checkTable("after (4)", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('3')"
		], [
			[false, 1, "Alpha*"],
			[undefined, 1, "Gamma*"]
		]);

		this.expectRequest(sUrlWithExpandLevelsCollapsed
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "2",
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "collapsed",
					ID : "1",
					Name : "Alpha*"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma*"
				}]
			})
			.expectRequest(sUrlWithExpandLevelsCollapsed
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,LimitedRank"
				+ "&$filter=ID eq '1' or ID eq '11' or ID eq '12'&$top=3", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "collapsed",
					ID : "1",
					LimitedRank : "0"
				}]
			})
			.expectRequest("EMPLOYEES"
				+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
				+ "&$select=ID,Name&$filter=ID eq '11'&$top=1", {
				value : [
					{ID : "11", Name : "New1*"}
				]
			})
			.expectRequest("EMPLOYEES"
				+ "?$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '11'),1)"
				+ "&$select=ID,Name&$filter=ID eq '12'&$top=1", {
				value : [
					{ID : "12", Name : "New2*"}
				]
			});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "(5) side-effects refresh")
		]);

		checkTable("after (5)", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('3')"
		], [
			[false, 1, "Alpha*"],
			[undefined, 1, "Gamma*"]
		]);

		expectSideEffectsRequests();

		// code under test
		oAlpha.expand();

		await this.waitForChanges(assert, "(6) expand Alpha");

		await checkAllContexts(7);
	});

	//*********************************************************************************************
	// Scenario: Expand all levels of a recursive hierarchy and move a node with descendants (not
	// yet fully loaded) to another parent. It is inserted between older siblings on the server and
	// is shown on the client "in place" (JIRA: CPOUI5ODATAV4-2466). Still, paging works!
	// Collapse the new parent and later its root to check that their "descendants" is correct.
	// Another root (Beth) is loaded with its child (Gimel) and moved to Aleph, but their
	// LimitedRank does not change. Then Gimel is moved to Aleph, thus Beth becomes a leaf again.
	// Gimel is moved to collapsed Alpha, thus expanding it again. Expand "the new parent" (Eta, see
	// above) again. Delete all moved nodes again in a single $batch.
	// JIRA: CPOUI5ODATAV4-2360
	//
	// Before deletion, Beta is maybe is maybe moved to make it a root (JIRA: CPOUI5ODATAV4-2400)
	// Old vs. new format of RecursiveHierarchy annotation (JIRA: CPOUI5ODATAV4-2401)
	// Request NodeID after creation (JIRA: CPOUI5ODATAV4-2381)
[false, true].forEach((bMakeRoot) => {
	["OldChart", "OrgChart"].forEach((sHierarchyQualifier) => {
		const sTitle = `Recursive Hierarchy: expand all and move for ${sHierarchyQualifier};
make root = ${bMakeRoot}`;
		const sLimitedRank = sHierarchyQualifier === "OldChart" ? "LimitedRank" : "Limited_Rank";

	QUnit.test(sTitle, async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sFriend = "/Artists(ArtistID='99',IsActiveEntity=false)/_Friend";
		const sBaseUrl = sFriend.slice(1) + "?$apply=orderby(ArtistID)"
			+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
			+ ",HierarchyQualifier='" + sHierarchyQualifier + "',NodeProperty='_/NodeID')";
		const sReadUrl = sBaseUrl + "&$select=ArtistID,IsActiveEntity,Name"
			+ ",_/DescendantCount,_/DistanceFromRoot,_/DrillState,_/NodeID";
		const sView = `
<t:Table id="table" rows="{path : '/Artists(ArtistID=\\'99\\',IsActiveEntity=false)/_Friend',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : '${sHierarchyQualifier}'
			},
			$orderby : 'ArtistID'
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ArtistID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 0 Alpha
		//   1 Beta (moved...)
		//     1.1 Gamma
		//       1.1.1 Delta (loaded later)
		//       1.1.2 Epsilon (loaded later)
		//   2 Zeta (loaded later)
		//   3 Eta (...to here)
		//     3.1 Theta
		//     3.2 Iota
		//     3.3 Kappa (loaded later)
		//   4 Lambda (loaded later)
		// 9 Aleph (loaded later)
		// 10 Beth (loaded later)
		//   10.1 Gimel (loaded later)
		this.expectRequest(sReadUrl + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "14",
				value : [{
					ArtistID : "0",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "10",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "0,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "1.1",
					IsActiveEntity : false,
					Name : "Gamma",
					_ : {
						DescendantCount : "2",
						DistanceFromRoot : "2",
						DrillState : "expanded",
						NodeID : "1.1,false"
					}
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			sFriend + "(ArtistID='0',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='1.1',IsActiveEntity=false)"
		], [
			[true, 1, "0", "Alpha"],
			[true, 2, "1", "Beta"],
			[true, 3, "1.1", "Gamma"]
		], 14);
		const oAlpha = oTable.getRows()[0].getBindingContext();
		let oBeta = oTable.getRows()[1].getBindingContext();
		const oListBinding = oAlpha.getBinding();
		assert.strictEqual(oBeta.getIndex(), 1);

		this.expectRequest(sReadUrl + "&$skip=6&$top=3", {
				value : [{
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Eta",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "3,false"
					}
				}, {
					ArtistID : "3.1",
					IsActiveEntity : false,
					Name : "Theta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "3.1,false"
					}
				}, {
					ArtistID : "3.2",
					IsActiveEntity : false,
					Name : "Iota",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "3.2,false"
					}
				}]
			});

		oTable.setFirstVisibleRow(6);

		await this.waitForChanges(assert, "scroll down to Eta");

		checkTable("after scroll down to Eta", assert, oTable, [
			sFriend + "(ArtistID='0',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='1.1',IsActiveEntity=false)",
			sFriend + "(ArtistID='3',IsActiveEntity=false)",
			sFriend + "(ArtistID='3.1',IsActiveEntity=false)",
			sFriend + "(ArtistID='3.2',IsActiveEntity=false)"
		], [
			[true, 2, "3", "Eta"],
			[undefined, 3, "3.1", "Theta"],
			[undefined, 3, "3.2", "Iota"]
		], 14);
		let oEta = oTable.getRows()[0].getBindingContext();

		// 0 Alpha
		//   2 Zeta (loaded later)
		//   3 Eta (...to here)
		//     3.1 Theta
		//     3.2 Iota
		//     1 Beta (moved...)
		//       1.1 Gamma <-- first visible row
		//         1.1.1 Delta (loaded soon)
		//         1.1.2 Epsilon (loaded soon)
		//     3.3 Kappa (loaded later)
		//   4 Lambda (loaded later)
		// 9 Aleph (loaded later)
		// 10 Beth (loaded later)
		//   10.1 Gimel (loaded later)
		this.expectRequest({
				batchNo : 3,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "Artists(ArtistID='1',IsActiveEntity=false)",
				payload : {
					"BestFriend@odata.bind" : "Artists(ArtistID='3',IsActiveEntity=false)"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : 3,
				url : sBaseUrl + "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
					+ "&$select=_/" + sLimitedRank
			}, {
				value : [{
					_ : {
						[sLimitedRank] : "5" // Edm.Int64
					}
				}]
			})
			.expectRequest({
				batchNo : 4,
				url : sReadUrl + "&$skip=7&$top=2"
			}, {
				value : [{
					ArtistID : "1.1.1",
					IsActiveEntity : false,
					Name : "Delta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "4",
						DrillState : "leaf",
						NodeID : "1.1.1,false"
					}
				}, {
					ArtistID : "1.1.2",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "4",
						DrillState : "leaf",
						NodeID : "1.1.2,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBeta.move({parent : oEta}),
			resolveLater(undefined, 5), // table update takes a moment
			this.waitForChanges(assert, "move Beta to Eta")
		]);

		checkTable("after move Beta to Eta", assert, oTable, [
			sFriend + "(ArtistID='0',IsActiveEntity=false)",
			sFriend + "(ArtistID='3',IsActiveEntity=false)",
			sFriend + "(ArtistID='3.1',IsActiveEntity=false)",
			sFriend + "(ArtistID='3.2',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='1.1',IsActiveEntity=false)",
			sFriend + "(ArtistID='1.1.1',IsActiveEntity=false)",
			sFriend + "(ArtistID='1.1.2',IsActiveEntity=false)"
		], [
			[true, 4, "1.1", "Gamma"],
			[undefined, 5, "1.1.1", "Delta"],
			[undefined, 5, "1.1.2", "Epsilon"]
		], 14);

		assert.strictEqual(oBeta.isTransient(), undefined, "unchanged");
		assert.strictEqual(oBeta.created(), undefined);
		assert.deepEqual(oBeta.getObject(), {
			// no "@$ui5.context.isTransient"!
			"@$ui5.node.isExpanded" : true,
			"@$ui5.node.level" : 3,
			ArtistID : "1",
			IsActiveEntity : false,
			Name : "Beta",
			_ : {
				NodeID : "1,false"
			}
		});
		// Note: #checkAllContexts below will check #getIndex for all nodes

		this.expectRequest(sReadUrl + "&$skip=1&$top=1", {
				value : [{
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Zeta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "2,false"
					}
				}]
			})
			.expectRequest(sReadUrl + "&$skip=9&$top=5", {
				value : [{
					ArtistID : "3.3",
					IsActiveEntity : false,
					Name : "Kappa",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "3.3,false"
					}
				}, {
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Lambda",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "4,false"
					}
				}, {
					ArtistID : "9",
					IsActiveEntity : false,
					Name : "Aleph",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "0",
						DrillState : "leaf",
						NodeID : "9,false"
					}
				}, {
					ArtistID : "10",
					IsActiveEntity : false,
					Name : "Beth",
					_ : {
						DescendantCount : "1",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "10,false"
					}
				}, {
					ArtistID : "10.1",
					IsActiveEntity : false,
					Name : "Gimel",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "10.1,false"
					}
				}]
			});

		await this.checkAllContexts("after move Beta to Eta: all", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[true, 1, "0", "Alpha"],
				[undefined, 2, "2", "Zeta"],
				[true, 2, "3", "Eta"],
				[undefined, 3, "3.1", "Theta"],
				[undefined, 3, "3.2", "Iota"],
				[true, 3, "1", "Beta"],
				[true, 4, "1.1", "Gamma"],
				[undefined, 5, "1.1.1", "Delta"],
				[undefined, 5, "1.1.2", "Epsilon"],
				[undefined, 3, "3.3", "Kappa"],
				[undefined, 2, "4", "Lambda"],
				[undefined, 1, "9", "Aleph"],
				[true, 1, "10", "Beth"],
				[undefined, 2, "10.1", "Gimel"]
			]);

		// code under test
		oEta.collapse(); // Note: this eventually destroys oBeta!
		oBeta = null;

		await this.checkAllContexts("after collapse Eta", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[true, 1, "0", "Alpha"],
				[undefined, 2, "2", "Zeta"],
				[false, 2, "3", "Eta"],
				[undefined, 2, "4", "Lambda"],
				[undefined, 1, "9", "Aleph"],
				[true, 1, "10", "Beth"],
				[undefined, 2, "10.1", "Gimel"]
			]);

		// code under test
		oAlpha.collapse(); // Note: this eventually destroys oEta!
		oEta = null;

		await this.checkAllContexts("after collapse Alpha", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[false, 1, "0", "Alpha"],
				[undefined, 1, "9", "Aleph"],
				[true, 1, "10", "Beth"],
				[undefined, 2, "10.1", "Gimel"]
			]);
		const [, oAleph, oBeth, oGimel] = oListBinding.getAllCurrentContexts();

		// 0 Alpha
		//   2 Zeta
		//   3 Eta
		//     3.1 Theta
		//     3.2 Iota
		//     1 Beta
		//       1.1 Gamma
		//         1.1.1 Delta
		//         1.1.2 Epsilon
		//     3.3 Kappa
		//   4 Lambda
		// 9 Aleph
		//   10 Beth (now moved beneath Aleph)
		//     10.1 Gimel
		this.expectRequest({
				batchNo : 6,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "Artists(ArtistID='10',IsActiveEntity=false)",
				payload : {
					"BestFriend@odata.bind" : "Artists(ArtistID='9',IsActiveEntity=false)"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : 6,
				url : sBaseUrl + "&$filter=ArtistID eq '10' and IsActiveEntity eq false"
					+ "&$select=_/" + sLimitedRank
			}, {
				value : [{
					_ : { // Note: rank has not changed due to move
						[sLimitedRank] : "12" // Edm.Int64
					}
				}]
			});

		await Promise.all([
			// code under test
			oBeth.move({parent : oAleph}),
			this.waitForChanges(assert, "move Beth to Aleph")
		]);

		// Note: #checkAllContexts will check #getIndex for all nodes
		await this.checkAllContexts("after move Beth to Aleph", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[false, 1, "0", "Alpha"],
				[true, 1, "9", "Aleph"],
				[true, 2, "10", "Beth"],
				[undefined, 3, "10.1", "Gimel"]
			]);

		this.expectRequest({
				batchNo : 7,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "Artists(ArtistID='10.1',IsActiveEntity=false)",
				payload : {
					"BestFriend@odata.bind" : "Artists(ArtistID='9',IsActiveEntity=false)"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : 7,
				url : sBaseUrl + "&$filter=ArtistID eq '10.1' and IsActiveEntity eq false"
					+ "&$select=_/" + sLimitedRank
			}, {
				value : [{
					_ : { // Note: rank has not changed due to move
						[sLimitedRank] : "13" // Edm.Int64
					}
				}]
			});

		await Promise.all([
			// code under test
			oGimel.move({parent : oAleph}),
			this.waitForChanges(assert, "move Gimel to Aleph")
		]);

		// Note: #checkAllContexts will check #getIndex for all nodes
		await this.checkAllContexts("after move Gimel to Aleph", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[false, 1, "0", "Alpha"],
				[true, 1, "9", "Aleph"],
				[undefined, 2, "10", "Beth"], // last child has gone
				[undefined, 2, "10.1", "Gimel"]
			]);

		// 0 Alpha
		//   2 Zeta
		//   3 Eta (still collapsed)
		//     3.1 Theta
		//     3.2 Iota
		//     1 Beta
		//       1.1 Gamma
		//         1.1.1 Delta
		//         1.1.2 Epsilon
		//     3.3 Kappa
		//   10.1 Gimel (moved to here)
		//   4 Lambda
		// 9 Aleph
		//   10 Beth
		this.expectRequest({
				batchNo : 8,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "Artists(ArtistID='10.1',IsActiveEntity=false)",
				payload : {
					"BestFriend@odata.bind" : "Artists(ArtistID='0',IsActiveEntity=false)"
				}
			}) // 204 No Content
			.expectRequest({
				batchNo : 8,
				url : sBaseUrl + "&$filter=ArtistID eq '10.1' and IsActiveEntity eq false"
					+ "&$select=_/" + sLimitedRank
			}, {
				value : [{
					_ : {
						[sLimitedRank] : "10" // Edm.Int64
					}
				}]
			});

		await Promise.all([
			// code under test
			oGimel.move({parent : oAlpha}),
			this.waitForChanges(assert, "move Gimel to collapsed Alpha")
		]);

		// Note: #checkAllContexts will check #getIndex for all nodes
		await this.checkAllContexts("after move Gimel to collapsed Alpha", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[true, 1, "0", "Alpha"], // auto-expanded
				[undefined, 2, "2", "Zeta"],
				[false, 2, "3", "Eta"], // still collapsed
				[undefined, 2, "10.1", "Gimel"],
				[undefined, 2, "4", "Lambda"],
				[true, 1, "9", "Aleph"],
				[undefined, 2, "10", "Beth"]
			]);

		oEta = oListBinding.getAllCurrentContexts()[2];
		assert.strictEqual(oEta.getProperty("Name"), "Eta", "double check that index was right");

		// code under test
		oEta.expand();

		await this.checkAllContexts("after expand all again", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[true, 1, "0", "Alpha"],
				[undefined, 2, "2", "Zeta"],
				[true, 2, "3", "Eta"],
				[undefined, 3, "3.1", "Theta"],
				[undefined, 3, "3.2", "Iota"],
				[true, 3, "1", "Beta"],
				[true, 4, "1.1", "Gamma"],
				[undefined, 5, "1.1.1", "Delta"],
				[undefined, 5, "1.1.2", "Epsilon"],
				[undefined, 3, "3.3", "Kappa"],
				[undefined, 2, "10.1", "Gimel"],
				[undefined, 2, "4", "Lambda"],
				[true, 1, "9", "Aleph"],
				[undefined, 2, "10", "Beth"]
			]);

		oBeta = oListBinding.getAllCurrentContexts()[5];
		assert.strictEqual(oBeta.getProperty("Name"), "Beta", "double check that index was right");

		if (bMakeRoot) {
			this.expectRequest({
					batchNo : 9,
					headers : {
						Prefer : "return=minimal"
					},
					method : "PATCH",
					url : "Artists(ArtistID='1',IsActiveEntity=false)",
					payload : {
						"BestFriend@odata.bind" : null
					}
				}) // 204 No Content
				.expectRequest({
					batchNo : 9,
					url : sBaseUrl + "&$filter=ArtistID eq '1' and IsActiveEntity eq false"
						+ "&$select=_/" + sLimitedRank
				}, {
					value : [{
						_ : { // Note: 0, 8, or 10
							[sLimitedRank] : "0" // Edm.Int64
						}
					}]
				});

			await Promise.all([
				// code under test
				oBeta.move({parent : null}),
				this.waitForChanges(assert, "move Beta to make it a root node")
			]);

			await this.checkAllContexts("after move Beta to make it a root node", assert,
				oListBinding,
				["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
					[true, 1, "1", "Beta"],
					[true, 2, "1.1", "Gamma"],
					[undefined, 3, "1.1.1", "Delta"],
					[undefined, 3, "1.1.2", "Epsilon"],
					[true, 1, "0", "Alpha"],
					[undefined, 2, "2", "Zeta"],
					[true, 2, "3", "Eta"],
					[undefined, 3, "3.1", "Theta"],
					[undefined, 3, "3.2", "Iota"],
					[undefined, 3, "3.3", "Kappa"],
					[undefined, 2, "10.1", "Gimel"],
					[undefined, 2, "4", "Lambda"],
					[true, 1, "9", "Aleph"],
					[undefined, 2, "10", "Beth"]
				]);
		}

		const iBatchNo = this.iBatchNo + 1; // don't care about exact no., but use thrice below
		this.expectRequest({
				batchNo : iBatchNo,
				method : "DELETE",
				url : "Artists(ArtistID='1',IsActiveEntity=false)"
			})
			.expectRequest({
				batchNo : iBatchNo,
				method : "DELETE",
				url : "Artists(ArtistID='10',IsActiveEntity=false)"
			})
			.expectRequest({
				batchNo : iBatchNo,
				method : "DELETE",
				url : "Artists(ArtistID='10.1',IsActiveEntity=false)"
			});

		await Promise.all([
			// code under test
			oBeta.delete(),
			// code under test
			oBeth.delete(),
			// code under test
			oGimel.delete(),
			this.waitForChanges(assert, "delete all moved")
		]);

		await this.checkAllContexts("after delete all moved", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "ArtistID", "Name"], [
				[true, 1, "0", "Alpha"],
				[undefined, 2, "2", "Zeta"],
				[true, 2, "3", "Eta"],
				[undefined, 3, "3.1", "Theta"],
				[undefined, 3, "3.2", "Iota"],
				[undefined, 3, "3.3", "Kappa"],
				[undefined, 2, "4", "Lambda"],
				[undefined, 1, "9", "Aleph"]
			]);
	});
	});
});

	//*********************************************************************************************
	// Scenario: Move Delta below a new parent Alpha and insert it before Gamma. Move Delta back to
	// root level explicitly to the last sibling position, where Delta is no longer visible but its
	// index is properly updated.
	// JIRA: CPOUI5ODATAV4-2228
	QUnit.test("Recursive Hierarchy: move to nextSibling", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sSelect = "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name";
		const sUrl = "EMPLOYEES"
			+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
			+ ",HierarchyQualifier='OrgChart',NodeProperty='ID',Levels=2)";
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 2,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="4">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		//   2 Beta
		//   3 Gamma
		// 4 Delta
		// 5 Epsilon
		this.expectRequest(sUrl + sSelect + "&$count=true&$skip=0&$top=4", {
				"@odata.count" : "5",
				value : [{
					DescendantCount : "2",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"],
			[undefined, 2, "Gamma"],
			[undefined, 1, "Delta"]
		], 5);
		const oListBinding = oTable.getBinding("rows");
		const [oAlpha,, oGamma, oDelta] = oListBinding.getCurrentContexts();

		// code under test: no move happens
		oAlpha.move();

		this.expectRequest({
				batchNo : 2,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')"
				},
				url : "EMPLOYEES('4')"
			}) // 204 No Content
			.expectRequest({
				batchNo : 2,
				headers : {
					Prefer : "return=minimal"
				},
				method : "POST",
				payload : {
					NextSibling : {ID : "3"}
				},
				url : "EMPLOYEES('4')" + sNextSiblingAction
			}) // 204 No Content
			.expectRequest({
				batchNo : 2,
				url : sUrl + "&$filter=ID eq '4'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "2"
				}]
			})
			// 1 Alpha
			//   2 Beta
			//   4 Delta
			//   3 Gamma
			// 5 Epsilon
			.expectRequest({
				batchNo : 2,
				url : sUrl + sSelect + "&$count=true&$skip=0&$top=4"
			}, {
				"@odata.count" : "5",
				value : [{
					DescendantCount : "3",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}]
			});

		await Promise.all([
			// code under test
			oDelta.move({nextSibling : oGamma, parent : oAlpha}),
			this.waitForChanges(assert, "move Delta before Gamma (below Alpha)")
		]);

		checkTable("after move Delta before Gamma (below Alpha)", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('4')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"],
			[undefined, 2, "Delta"],
			[undefined, 2, "Gamma"]
		], 5);

		this.expectRequest({
				batchNo : 3,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : null
				},
				url : "EMPLOYEES('4')"
			}) // 204 No Content
			.expectRequest({
				batchNo : 3,
				headers : {
					Prefer : "return=minimal"
				},
				method : "POST",
				payload : {
					NextSibling : null
				},
				url : "EMPLOYEES('4')" + sNextSiblingAction
			}) // 204 No Content
			.expectRequest({
				batchNo : 3,
				url : sUrl + "&$filter=ID eq '4'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "4"
				}]
			})
			// 1 Alpha
			//   2 Beta
			//   3 Gamma
			// 5 Epsilon
			// 4 Delta
			.expectRequest({
				batchNo : 3,
				url : sUrl + sSelect + "&$count=true&$skip=0&$top=4"
			}, {
				"@odata.count" : "5",
				value : [{
					DescendantCount : "2",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "5",
					Name : "Epsilon"
				}]
			});

		await Promise.all([
			// code under test
			oDelta.move({nextSibling : null, parent : null}),
			this.waitForChanges(assert, "move Delta to last position of root level")
		]);

		checkTable("after move Delta to last position of root level", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"],
			[undefined, 2, "Gamma"],
			[undefined, 1, "Epsilon"]
		], 5);
		assert.strictEqual(oDelta.getIndex(), 4);

		this.expectRequest(sUrl + sSelect + "&$skip=4&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}]
			});

		// "The index of the first visible row is too high. The value has been set to 1."
		oTable.setFirstVisibleRow(/*4*/ 1);

		await this.waitForChanges(assert, "scroll to Delta");

		checkTable("after scroll to Delta", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('4')"
		], [
			[undefined, 2, "Beta"],
			[undefined, 2, "Gamma"],
			[undefined, 1, "Epsilon"],
			[undefined, 1, "Delta"]
		]);
	});

	//*********************************************************************************************
	// Scenario: Expand Alpha and then move a child which was part of the group level cache to the
	// last sibling position of the root level, where it is no longer visible but its index is
	// properly updated. The requested rank for determining the new index uses the updated
	// ExpandLevels.
	// The binding uses filter, search, sorter, and custom query options to verify that the URL for
	// requesting the rank uses all relevant query options.
	// JIRA: CPOUI5ODATAV4-2572
	QUnit.test("Recursive Hierarchy: move nextSibling (from level cache)", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sFilterSearch = "ancestors($root/EMPLOYEES,OrgChart,ID,filter(Is_Manager)"
			+ "/search(covfefe),keep start)";
		const sSelect = "&$select=DrillState,ID,Name";
		const sUrl = "EMPLOYEES?custom=foo&$apply=" + sFilterSearch + "/orderby(ENTRYDATE)"
			+ "/com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
			+ ",HierarchyQualifier='OrgChart',NodeProperty='ID',Levels=1)";
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart',
				search : 'covfefe'
			},
			$filter : 'Is_Manager',
			$orderby : 'ENTRYDATE',
			custom : 'foo'
		}}" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		//   2 Beta
		//   3 Gamma
		// 4 Delta
		this.expectRequest(sUrl + sSelect + "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "2",
				value : [{
					DrillState : "collapsed",
					ID : "1",
					Name : "Alpha"
				}, {
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('4')"
		], [
			[false, 1, "Alpha"],
			[undefined, 1, "Delta"]
		]);
		const oListBinding = oTable.getBinding("rows");
		const [oAlpha] = oListBinding.getCurrentContexts();

		this.expectRequest("EMPLOYEES?custom=foo&$apply=" + sFilterSearch
				+ "/descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
				+ "/orderby(ENTRYDATE)" + sSelect + "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "2",
				value : [{
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}, {
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}]
			});

		oAlpha.expand();

		await this.waitForChanges(assert, "expand Alpha");

		checkTable("after expand Alpha", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"]
		]);
		const oBeta = oListBinding.getCurrentContexts()[1];

		this.expectRequest({
				batchNo : 3,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : null
				},
				url : "EMPLOYEES('2')"
			}) // 204 No Content
			.expectRequest({
				batchNo : 3,
				headers : {
					Prefer : "return=minimal"
				},
				method : "POST",
				payload : {
					NextSibling : null
				},
				url : "EMPLOYEES('2')" + sNextSiblingAction
			}) // 204 No Content
			.expectRequest({
				batchNo : 3,
				url : sUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "1", Levels : 1}])
					+ ")" + "&$filter=ID eq '2'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "3"
				}]
			})
			// 1 Alpha
			//   3 Gamma
			// 4 Delta
			// 2 Beta
			.expectRequest({
				batchNo : 3,
				url : sUrl.slice(0, -1) + ",ExpandLevels="
					+ JSON.stringify([{NodeID : "1", Levels : 1}])
					+ ")&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$count=true&$skip=0&$top=2"
			}, {
				"@odata.count" : "4",
				value : [{
					DescendantCount : "1",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}]
			});

		await Promise.all([
			// code under test
			oBeta.move({nextSibling : null, parent : null}),
			this.waitForChanges(assert, "move Beta to last root position")
		]);

		assert.strictEqual(oBeta.getIndex(), 3);

		this.expectRequest(sUrl.slice(0, -1) + ",ExpandLevels="
				+ JSON.stringify([{NodeID : "1", Levels : 1}])
				+ ")&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$skip=2&$top=2", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}]
			});

		await this.checkAllContexts("after move Beta to last root position", assert, oListBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "Name"], [
				[true, 1, "Alpha"],
				[undefined, 2, "Gamma"],
				[undefined, 1, "Delta"],
				[undefined, 1, "Beta"]
			]);
	});

	//*********************************************************************************************
	// Scenario: Show some nodes, create a new root node which is shown out of place. Move one child
	// to the last sibling position where it is no longer visible, but its index is properly
	// updated, taking the out-of-place node into account. Move the child to another parent w/o a
	// side-effects refresh - still the out-of-place node must be taken into account for its index.
	// JIRA: CPOUI5ODATAV4-2573
	QUnit.test("Recursive Hierarchy: move (to nextSibling) & OOP node", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sSelect = "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name";
		const sUrl = "EMPLOYEES"
			+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
			+ ",HierarchyQualifier='OrgChart',NodeProperty='ID')";
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {
				expandTo : 1E16,
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		//   2 Beta (moved as last sibling)
		//   3 Gamma
		//   4 Delta (loaded later)
		// 5 Epsilon (created)
		this.expectRequest(sUrl + sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "4",
				value : [{
					DescendantCount : "3",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"],
			[undefined, 2, "Gamma"]
		], 4);

		this.expectRequest({
				batchNo : 2,
				method : "POST",
				payload : {
					Name : "Epsilon"
				},
				url : "EMPLOYEES"
			}, {
				ID : "5",
				Name : "Epsilon"
			})
			.expectRequest({
				batchNo : 3,
				url : sUrl + "&$filter=ID eq '5'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "4"
				}]
			});

		const oListBinding = oTable.getBinding("rows");
		const oEpsilon = oListBinding.create({Name : "Epsilon"}, /*bSkipRefresh*/true);
		const oEpsilonCreated = oEpsilon.created();

		await Promise.all([
			oEpsilonCreated,
			this.waitForChanges(assert, "create new root")
		]);

		checkTable("after create new root", assert, oTable, [
			"/EMPLOYEES('5')", // out of place
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[undefined, 1, "Epsilon"],
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"]
		], 5);
		const [, oAlpha, oBeta] = oListBinding.getCurrentContexts();

		this.expectRequest({
				batchNo : 4,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')"
				},
				url : "EMPLOYEES('2')"
			}) // 204 No Content
			.expectRequest({
				batchNo : 4,
				headers : {
					Prefer : "return=minimal"
				},
				method : "POST",
				payload : {
					NextSibling : null
				},
				url : "EMPLOYEES('2')" + sNextSiblingAction
			}) // 204 No Content
			.expectRequest({
				batchNo : 4,
				url : sUrl + "&$filter=ID eq '2'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "3"
				}]
			})
			// 1 Alpha
			//   3 Gamma
			//   4 Delta (loaded now)
			//   2 Beta (moved here)
			// 5 Epsilon (created)
			.expectRequest({
				batchNo : 4,
				url : sUrl + sSelect + "&$count=true&$skip=0&$top=3"
			}, {
				"@odata.count" : "5",
				value : [{
					DescendantCount : "3",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "1",
					Name : "Alpha"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}]
			})
			.expectRequest({
				batchNo : 4,
				url : sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,LimitedRank"
					+ "&$filter=ID eq '5'&$top=1"
			}, {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "5",
					LimitedRank : "4"
				}]
			})
			.expectRequest({
				batchNo : 4,
				url : sUrl.slice(0, -1) + ",Levels=1)&$select=ID,Name&$filter=ID eq '5'&$top=1"
			}, {
				value : [{
					ID : "5",
					Name : "Epsilon"
				}]
			});

		await Promise.all([
			// code under test
			oBeta.move({nextSibling : null, parent : oAlpha}),
			this.waitForChanges(assert, "move Beta to last position of Alpha")
		]);

		assert.strictEqual(oBeta.getIndex(), 4, "out-of-place nodes taken into account");
		assert.strictEqual(oBeta.getModel(), undefined, "already destroyed");

		// 1 Alpha
		//   3 Gamma
		//   4 Delta
		//   2 Beta
		// 5 Epsilon
		this.expectRequest(sUrl + sSelect + "&$skip=3&$top=1", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Beta"
				}]
			});

		await this.checkAllContexts("after move Beta to last position of Alpha", assert,
			oListBinding, ["@$ui5.node.isExpanded", "@$ui5.node.level", "Name"], [
			[undefined, 1, "Epsilon"], // out of place
			[true, 1, "Alpha"],
			[undefined, 2, "Gamma"],
			[undefined, 2, "Delta"],
			[undefined, 2, "Beta"]
		]);

		//TODO checkCreatedPersisted(assert, oEpsilon, oEpsilonCreated);
		const oGamma = oListBinding.getAllCurrentContexts()[2];
		assert.strictEqual(oGamma.getProperty("Name"), "Gamma",
			"double check that index was right");
		const oBeta0 = oListBinding.getAllCurrentContexts()[4];
		assert.strictEqual(oBeta0.getProperty("Name"), "Beta",
			"double check that index was right");

		// 1 Alpha
		//   3 Gamma
		//     2 Beta (moved here)
		//   4 Delta
		// 5 Epsilon
		this.expectRequest({
				batchNo : 6,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('3')"
				},
				url : "EMPLOYEES('2')"
			}) // 204 No Content
			.expectRequest({
				batchNo : 6,
				url : sUrl + "&$filter=ID eq '2'&$select=LimitedRank"
			}, {
				value : [{
					LimitedRank : "2"
				}]
			});

		await Promise.all([
			// code under test
			oBeta0.move({parent : oGamma}),
			this.waitForChanges(assert, "move Beta below Gamma")
		]);

		assert.strictEqual(oBeta0.getIndex(), 3, "out-of-place nodes taken into account");

		await this.checkAllContexts("after move Beta below Gamma", assert,
			oListBinding, ["@$ui5.node.isExpanded", "@$ui5.node.level", "Name"], [
			[undefined, 1, "Epsilon"], // out of place
			[true, 1, "Alpha"],
			[true, 2, "Gamma"],
			[undefined, 3, "Beta"],
			[undefined, 2, "Delta"]
		]);
	});

	//*********************************************************************************************
	// Scenario: Move a root node to the first position. The POST for moving the position requires
	// a non-canonical URL. The NextSibling's complex type requires multiple keys.
	// JIRA: CPOUI5ODATAV4-2228
	QUnit.test("Recursive Hierarchy: nextSibling (non-canonical path)", async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sFriend = "/Artists(ArtistID='99',IsActiveEntity=false)/_Friend";
		const sUrl = sFriend.slice(1)
			+ "?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root" + sFriend
			+ ",HierarchyQualifier='OrgChart',NodeProperty='_/NodeID',Levels=1)";
		const sSelect = "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID";
		const sView = `
<t:Table id="table" rows="{path : '/Artists(ArtistID=\\'99\\',IsActiveEntity=false)/_Friend',
		parameters : {
			$$aggregation : {hierarchyQualifier : 'OrgChart'}
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		// 2 Beta
		this.expectRequest(sUrl + sSelect + "&$count=true&$skip=0&$top=3", {
				"@odata.count" : "2",
				value : [{
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DrillState : "leaf",
						NodeID : "1,false"
					}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DrillState : "leaf",
						NodeID : "2,false"
					}
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			sFriend + "(ArtistID='1',IsActiveEntity=false)",
			sFriend + "(ArtistID='2',IsActiveEntity=false)"
		], [
			[undefined, 1, "Alpha"],
			[undefined, 1, "Beta"]
		]);
		const oListBinding = oTable.getBinding("rows");
		const [oAlpha, oBeta] = oListBinding.getCurrentContexts();

		this.expectRequest({
				batchNo : 2,
				headers : {
					Prefer : "return=minimal"
				},
				method : "PATCH",
				payload : {
					"BestFriend@odata.bind" : null
				},
				url : "Artists(ArtistID='2',IsActiveEntity=false)"
			}) // 204 No Content
			.expectRequest({
				batchNo : 2,
				headers : {
					Prefer : "return=minimal"
				},
				method : "POST",
				payload : {
					// Note: add a non-key property for demonstrating the multi key scenario
					NextSibling : {ArtistID : "1", Name : "Alpha"}
				},
				url : sFriend.slice(1)
					+ "(ArtistID='2',IsActiveEntity=false)/special.cases.ChangeNextSibling"
			}) // 204 No Content
			.expectRequest({
				batchNo : 2,
				url : sUrl
					+ "&$filter=ArtistID eq '2' and IsActiveEntity eq false&$select=_/Limited_Rank"
			}, {
				value : [{
					_ : {Limited_Rank : "0"}
				}]
			})
			.expectRequest({
				batchNo : 2,
				url : sUrl + sSelect + "&$count=true&$skip=0&$top=3"
			}, {
				"@odata.count" : "2",
				value : [{
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DrillState : "leaf",
						NodeID : "2,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DrillState : "leaf",
						NodeID : "1,false"
					}
				}]
			});

		await Promise.all([
			// code under test
			oBeta.move({nextSibling : oAlpha, parent : null}),
			this.waitForChanges(assert, "move Beta to the front")
		]);

		checkTable("after move Beta to the front", assert, oTable, [
			sFriend + "(ArtistID='2',IsActiveEntity=false)",
			sFriend + "(ArtistID='1',IsActiveEntity=false)"
		], [
			[undefined, 1, "Beta"],
			[undefined, 1, "Alpha"]
		]);
		assert.strictEqual(oBeta.getIndex(), 0);
	});

	//*********************************************************************************************
	// Scenario: Show the first level of a recursive hierarchy ("Alpha", "Omega"), expand "Alpha".
	// Scroll to "Delta". Request side effects for the list binding. The parent node will not
	// anymore have a context in the list binding.
	// Determine the parent node of "Delta" with #getParent. It is not available at the moment.
	// Try to request the parent node of "Alpha" and "Delta".
	// JIRA: CPOUI5ODATAV4-2342
	QUnit.test("Recursive Hierarchy: getParent/requestParent after requestSideEffects",
			async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {hierarchyQualifier : 'OrgChart'}
		}}" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text id="id" text="{ID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 0 Alpha
		//   1 Beta
		//   2 Gamma
		//   3 Delta
		//   4 Epsilon
		// 9 Omega
		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
				+ "&$select=DrillState,ID,Name&$count=true&$skip=0&$top=2", {
				"@odata.count" : "2",
				value : [{
					DrillState : "collapsed",
					ID : "0",
					Name : "Alpha"
				}, {
					DrillState : "leaf",
					ID : "9",
					Name : "Omega"
				}]
			})
			.expectChange("id", ["0", "9"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('9')"
		], [
			[false, 1, "0", "Alpha"],
			[undefined, 1, "9", "Omega"]
		]);
		const oAlpha = oTable.getRows()[0].getBindingContext();

		this.expectRequest("EMPLOYEES?$apply=descendants($root/EMPLOYEES,OrgChart,ID"
					+ ",filter(ID eq '0'),1)"
				+ "&$select=DrillState,ID,Name&$count=true&$skip=0&$top=2", {
				"@odata.count" : "4",
				value : [{
					DrillState : "leaf",
					ID : "1",
					Name : "Beta"
				}, {
					DrillState : "leaf",
					ID : "2",
					Name : "Gamma"
				}]
			})
			.expectChange("id", [, "1"]);

		oAlpha.expand();

		await this.waitForChanges(assert, "expand 0 (Alpha)");

		checkTable("after expand 0 (Alpha)", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('9')"
		], [
			[true, 1, "0", "Alpha"],
			[undefined, 2, "1", "Beta"]
		], 6);

		this.expectRequest("EMPLOYEES?$apply=descendants($root/EMPLOYEES,OrgChart,ID"
					+ ",filter(ID eq '0'),1)"
				+ "&$select=DrillState,ID,Name&$skip=2&$top=2", {
				value : [{
					DrillState : "leaf",
					ID : "3",
					Name : "Delta"
				}, {
					DrillState : "leaf",
					ID : "4",
					Name : "Epsilon"
				}]
			})
			.expectChange("id", [,,, "3", "4"]);

		oTable.setFirstVisibleRow(3); // scroll to "Delta"

		await this.waitForChanges(assert, "setFirstVisibleRow to 3 (Delta)");

		checkTable("after setFirstVisibleRow", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')",
			"/EMPLOYEES('9')"
		], [
			[undefined, 2, "3", "Delta"],
			[undefined, 2, "4", "Epsilon"]
		]);
		const oDelta = oTable.getRows()[0].getBindingContext();

		this.expectRequest("EMPLOYEES?$select=ID,Name&$filter=ID eq '3' or ID eq '4'"
				+ "&$top=2", {
				value : [{
					DrillState : "leaf",
					ID : "3",
					Name : "Delta"
				}, {
					DrillState : "leaf",
					ID : "4",
					Name : "Epsilon"
				}]
			});

		// code under test
		assert.strictEqual(oAlpha.getParent(), null);
		assert.strictEqual(await oAlpha.requestParent(), null);

		await Promise.all([
			oDelta.getBinding().getHeaderContext().requestSideEffects(["Name"]),
			this.waitForChanges(assert, "request side effects for name")
		]);

		checkTable("after requestSideEffects", assert, oTable, [
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')"
		], [
			[undefined, 2, "3", "Delta"],
			[undefined, 2, "4", "Epsilon"]
		], 6);

		// code under test
		assert.strictEqual(oDelta.getParent(), undefined, "JIRA: CPOUI5ODATAV4-2323");

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
				+ "&$select=DrillState,ID,Name&$skip=0&$top=1", {
				value : [{
					DrillState : "collapsed",
					ID : "0",
					Name : "Alpha"
				}]
			})
			.expectChange("id", ["0", "9"]);

		// code under test
		const oResult = await oDelta.requestParent();

		assert.strictEqual(oAlpha.getModel(), undefined, "Alpha is destroyed");
		assert.notStrictEqual(oResult, oAlpha);
		assert.strictEqual(oResult.getPath(), oAlpha.getPath());
		assert.strictEqual(oResult.iIndex, oAlpha.iIndex);
		assert.strictEqual(oDelta.getParent(), oResult,
			"#getParent and #requestParent must deliver the same context");

		checkTable("after requestParent", assert, oTable, [
			"/EMPLOYEES('0')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('4')"
		], [
			[undefined, 2, "3", "Delta"],
			[undefined, 2, "4", "Epsilon"]
		], 6);
	});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 2. First visible
	// row starts at 2 (Gamma). Scroll to "Zeta". Determine the parent node of "Delta" and "Eta"
	// with #requestParent. A side effect for a structural property does not lead to trouble, same
	// for a side-effects refresh.
	// JIRA: CPOUI5ODATAV4-2467
	QUnit.test("Recursive Hierarchy: #requestParent for non-adjacent children",
			async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sUrl = "EMPLOYEES?custom=foo&$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
			+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
			+ ",NodeProperty='ID',Levels=2)";
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {expandTo : 2, hierarchyQualifier : 'OrgChart'},
			custom : 'foo'
		}}" firstVisibleRow="2" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text id="id" text="{ID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 0 Alpha // not loaded
		//   1 Beta // not loaded
		//   2 Gamma
		//   3 Delta
		//   4 Epsilon // not loaded
		//   5 Zeta
		//   6 Eta
		this.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$count=true&$skip=2&$top=2", {
				"@odata.count" : "7",
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Delta"
				}]
			})
			.expectChange("id", [,, "2", "3"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[undefined, 2, "2", "Gamma"],
			[undefined, 2, "3", "Delta"]
		], 7);
		const oDelta = oTable.getRows()[1].getBindingContext();

		this.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$skip=5&$top=2", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "5",
					Name : "Zeta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "6",
					Name : "Eta"
				}]
			})
			.expectChange("id", [,,,,, "5", "6"]);

		oTable.setFirstVisibleRow(5);

		await this.waitForChanges(assert, "scroll to 5 (Zeta)");

		checkTable("after scroll to 5 (Zeta)", assert, oTable, [
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[undefined, 2, "5", "Zeta"],
			[undefined, 2, "6", "Eta"]
		], 7);
		const oZeta = oTable.getRows()[0].getBindingContext();
		const oEta = oTable.getRows()[1].getBindingContext();

		this.expectRequest({
				batchNo : 3,
				url : "EMPLOYEES?custom=foo"
					+ "&$apply=ancestors($root/EMPLOYEES,OrgChart,ID,filter(ID eq '2'),1)"
					+ "&$select=ID,Name"
			}, {
				value : [{
					ID : "0",
					Name : "Alpha"
				}]
			})
			.expectRequest({
				batchNo : 3,
				url : "EMPLOYEES?custom=foo"
					+ "&$apply=ancestors($root/EMPLOYEES,OrgChart,ID,filter(ID eq '5'),1)"
					+ "&$select=ID,Name"
			}, {
				value : [{
					ID : "0",
					Name : "Alpha"
				}]
			})
			.expectRequest({
				batchNo : 4,
				url : sUrl + "&$filter=ID eq '0'"
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,LimitedRank"
			}, {
				value : [{
					DescendantCount : "6",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					LimitedRank : "0"
				}]
			});

		// code under test
		const [oAlpha, oAlpha0] = await Promise.all([
			oDelta.requestParent(),
			oEta.requestParent(),
			this.waitForChanges(assert, "request parent of 3 (Delta) and 6 (Eta)")
		]);

		assert.strictEqual(oAlpha, oAlpha0, "same context");
		assert.strictEqual(oAlpha.getPath(), "/EMPLOYEES('0')");
		assert.strictEqual(oAlpha.iIndex, 0);
		assert.deepEqual(oAlpha.getObject(), {
			"@$ui5.node.isExpanded" : true,
			"@$ui5.node.level" : 1,
			ID : "0",
			Name : "Alpha"
		});

		assert.strictEqual(oZeta.getParent(), oAlpha);
		assert.strictEqual(oEta.getParent(), oAlpha);
		assert.strictEqual(oDelta.getParent(), oAlpha);

		this.expectRequest("EMPLOYEES?custom=foo&$select=ID,Name&$filter=ID eq '5' or ID eq '6'"
				+ "&$top=2", {
				value : [{
					DrillState : "leaf",
					ID : "5",
					Name : "Zeta"
				}, {
					DrillState : "leaf",
					ID : "6",
					Name : "Eta"
				}]
			});

		await Promise.all([
			oEta.getBinding().getHeaderContext().requestSideEffects(["Name"]),
			this.waitForChanges(assert, "request side effects for name")
		]);

		checkTable("after requestSideEffects", assert, oTable, [
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')"
		], [
			[undefined, 2, "5", "Zeta"],
			[undefined, 2, "6", "Eta"]
		], 7);

		// code under test
		assert.strictEqual(oEta.getParent(), undefined);

		this.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$skip=0&$top=1", {
				value : [{
					DescendantCount : "6",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					ID : "0",
					Name : "Alpha"
				}]
			});

		// code under test
		const [oResult] = await Promise.all([
			oEta.requestParent(),
			this.waitForChanges(assert, "request parent of 6 (Eta)")
		]);

		assert.notStrictEqual(oResult, oAlpha, "Alpha was destroyed by side effect");
		assert.strictEqual(oResult.getPath(), "/EMPLOYEES('0')");
		assert.strictEqual(oResult.iIndex, 0);

		this.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$count=true&$skip=5&$top=2", {
				"@odata.count" : "7",
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "5",
					Name : "Zeta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "6",
					Name : "Eta"
				}]
			});

		await Promise.all([
			oEta.getBinding().getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "request side effects refresh")
		]);

		this.expectRequest({
				url : "EMPLOYEES?custom=foo"
					+ "&$apply=ancestors($root/EMPLOYEES,OrgChart,ID,filter(ID eq '5'),1)"
					+ "&$select=ID,Name"
			}, {
				value : [{
					ID : "1",
					Name : "Beta"
				}]
			})
			.expectRequest({
				url : sUrl + "&$filter=ID eq '1'"
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,LimitedRank"
			}, {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					LimitedRank : "1"
				}]
			});

		// code under test
		const [oBeta] = await Promise.all([
			oEta.requestParent(),
			this.waitForChanges(assert, "request parent of 6 (Eta)")
		]);

		assert.strictEqual(oBeta.getPath(), "/EMPLOYEES('1')");
		assert.strictEqual(oBeta.iIndex, 1);
		assert.deepEqual(oBeta.getObject(), {
			"@$ui5.node.level" : 2,
			ID : "1",
			Name : "Beta"
		});
	});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 2. First visible
	// row starts at 2 (Gamma). Request "Beta" as a keep alive context. Scroll to "Zeta". Determine
	// the parent node of "Delta" and "Eta" in an interleaved fashion and see that it is "Beta".
	// JIRA: CPOUI5ODATAV4-2467
	QUnit.test("Recursive Hierarchy: #requestParent interleaved", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sUrl = "EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
			+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
			+ ",NodeProperty='ID',Levels=2)";
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			$$aggregation : {expandTo : 2, hierarchyQualifier : 'OrgChart'}
		}}" firstVisibleRow="2" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text id="id" text="{ID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 0 Alpha // not loaded
		// 1 Beta // not loaded
		//   2 Gamma
		//   3 Delta
		//   4 Epsilon // not loaded
		//   5 Zeta
		//   6 Eta
		this.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$count=true&$skip=2&$top=2", {
				"@odata.count" : "7",
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "2",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Delta"
				}]
			})
			.expectChange("id", [,, "2", "3"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')"
		], [
			[undefined, 2, "2", "Gamma"],
			[undefined, 2, "3", "Delta"]
		], 7);
		const oDelta = oTable.getRows()[1].getBindingContext();

		this.expectRequest("EMPLOYEES('1')?$select=ID", {ID : "1"});

		const oBeta = oDelta.getBinding().getKeepAliveContext("/EMPLOYEES('1')");

		await this.waitForChanges(assert, "keep alive 1 (Beta)");

		this.expectRequest(sUrl + "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
				+ "&$skip=5&$top=2", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "5",
					Name : "Zeta"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "6",
					Name : "Eta"
				}]
			})
			.expectChange("id", [,,,,, "5", "6"]);

		oTable.setFirstVisibleRow(5);

		await this.waitForChanges(assert, "scroll to 5 (Zeta)");

		checkTable("after scroll to 5 (Zeta)", assert, oTable, [
			"/EMPLOYEES('2')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('5')",
			"/EMPLOYEES('6')",
			"/EMPLOYEES('1')"
		], [
			[undefined, 2, "5", "Zeta"],
			[undefined, 2, "6", "Eta"]
		], 7);
		const oEta = oTable.getRows()[1].getBindingContext();
		assert.strictEqual(oBeta.iIndex, undefined, "still unknown");

		let fnResolve;
		this.expectRequest({
				url : "EMPLOYEES?$apply=ancestors($root/EMPLOYEES,OrgChart,ID,filter(ID eq '2'),1)"
					+ "&$select=ID,Name"
			}, new Promise(function (resolve) {
				fnResolve = resolve.bind(null, {
					value : [{
						ID : "1",
						Name : "Beta"
					}]
				});
			}));

		// code under test
		const oBetaPromise = oDelta.requestParent();

		await this.waitForChanges(assert, "request parent of 3 (Delta)");

		this.expectRequest({
				url : "EMPLOYEES?$apply=ancestors($root/EMPLOYEES,OrgChart,ID,filter(ID eq '5'),1)"
					+ "&$select=ID,Name"
			}, {
				value : [{
					ID : "1",
					Name : "Beta"
				}]
			})
			.expectRequest({
				url : sUrl + "&$filter=ID eq '1'"
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,LimitedRank"
			}, {
				value : [{
					DescendantCount : "5",
					DistanceFromRoot : "0",
					DrillState : "expanded",
					LimitedRank : "1"
				}]
			});

		const [oBeta0] = await Promise.all([
			// code under test
			oEta.requestParent(),
			this.waitForChanges(assert, "request parent of 6 (Eta)")
		]);

		assert.strictEqual(oBeta0, oBeta, "keep alive context reused");
		assert.strictEqual(oBeta.getPath(), "/EMPLOYEES('1')");
		assert.strictEqual(oBeta.iIndex, 1);
		assert.deepEqual(oBeta.getObject(), {
			"@$ui5.node.isExpanded" : true,
			"@$ui5.node.level" : 1,
			ID : "1",
			Name : "Beta"
		});

		fnResolve();

		assert.strictEqual(await oBetaPromise, oBeta, "same context");

		assert.strictEqual(oDelta.getParent(), oBeta);
		assert.strictEqual(oEta.getParent(), oBeta);
	});

	//*********************************************************************************************
	// Scenario: Show the top pyramid of a recursive hierarchy, expanded to level 3. Create a new
	// child ("Iota") inserted below "Beta"; create a new child node ("Rho") inserted below "Alpha"
	// on the UI, but the rank is the last position in the hierarchy. Scroll to "Delta" and expand
	// the node "Delta".
	// Determine the parent of a node ("Delta") where a preceding sibling is not yet loaded, but the
	// parent is found.
	// Scroll to "Kappa" and collapse "Kappa". Scroll to "Omicron". Determine the parent of a
	// node ("Omicron") where the parent ("Xi") is not yet loaded and request this parent.
	// Scroll to "Xi" and see that it is inserted on the right position.
	// JIRA: CPOUI5ODATAV4-2378
	//
	// Second #requestParent on the same node returns the same context (JIRA: CPOUI5ODATAV4-2467).
	// #requestParent on adjacent children returns the same context (JIRA: CPOUI5ODATAV4-2467).
	QUnit.test("Recursive Hierarchy: getParent/requestParent with expandTo > 1",
			async function (assert) {
		const sUrl = "Artists?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
				+ "HierarchyNodes=$root/Artists,HierarchyQualifier='OrgChart'"
				+ ",NodeProperty='_/NodeID',Levels=3)";
		const sSelect = "&$select=ArtistID,IsActiveEntity,Name,_/DescendantCount,"
				+ "_/DistanceFromRoot,_/DrillState,_/NodeID";
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/Artists',
		parameters : {
			$$aggregation : {
				expandTo : 3,
				hierarchyQualifier : 'OrgChart'}
		}}" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{ArtistID}"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 0 Alpha
		//  1 Beta
		//    1.1 Gamma // not loaded
		//    1.2 Delta // expanded later
		//      1.2.1 Epsilon
		//      1.2.2 Zeta
		//      1.2.3 Eta // not loaded
		//    1.3 Theta
		//    1.4 Iota // created
		//  2 Kappa // collapsed later
		//    2.1 Lambda
		//    2.2 Mu
		//  3 Nu
		//  4 Xi // not loaded parent
		//    4.1 Omicron
		//    4.2 Pi
		//  5 Rho // created

		this.expectRequest(sUrl + sSelect + "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "12",
				value : [{
					ArtistID : "0",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						DescendantCount : "11",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						NodeID : "0,false"
					}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "Beta",
					_ : {
						DescendantCount : "3",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "1,false"
					}
				}]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		checkTable("initial page", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)"
		], [
			[true, 1, "0", "Alpha"],
			[true, 2, "1", "Beta"]
		], 12);
		const oAlpha = oTable.getRows()[0].getBindingContext();
		const oBeta = oTable.getRows()[1].getBindingContext();

		this.expectRequest({
				method : "POST",
				url : "Artists",
				payload : {
					"BestFriend@odata.bind" : "Artists(ArtistID='1',IsActiveEntity=false)",
					Name : "Iota"
				}
			}, {
				ArtistID : "1.4",
				IsActiveEntity : false,
				Name : "Iota",
				_ : null // not available w/ RAP for a non-hierarchical request
			})
			.expectRequest(sUrl + "&$filter=ArtistID eq '1.4' and IsActiveEntity eq false"
				+ "&$select=_/Limited_Rank,_/NodeID", {
				value : [{
					_ : {
						Limited_Rank : "5",
						NodeID : "1.4,false"
					}
				}]
			});

		// code under test
		const oIota = oAlpha.getBinding().create({
			"@$ui5.node.parent" : oBeta,
			Name : "Iota"
		}, /*bSkipRefresh*/true);

		await Promise.all([
			oIota.created(),
			this.waitForChanges(assert, "create node 1.4 (Iota)")
		]);

		checkTable("after create 1.4 (Iota)", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.4',IsActiveEntity=false)"
		], [
			[true, 1, "0", "Alpha"],
			[true, 2, "1", "Beta"]
		], 13);

		this.expectRequest({
				method : "POST",
				url : "Artists",
				payload : {
					"BestFriend@odata.bind" : "Artists(ArtistID='0',IsActiveEntity=false)",
					Name : "Rho"
				}
			}, {
				ArtistID : "5",
				IsActiveEntity : false,
				Name : "Rho",
				_ : null // not available w/ RAP for a non-hierarchical request
			})
			.expectRequest(sUrl + "&$filter=ArtistID eq '5' and IsActiveEntity eq false"
				+ "&$select=_/Limited_Rank,_/NodeID", {
				value : [{
					_ : {
						Limited_Rank : "13",
						NodeID : "5,false"
					}
				}]
			});

		// code under test
		const oRho = oAlpha.getBinding().create({
			"@$ui5.node.parent" : oAlpha,
			Name : "Rho"
		}, /*bSkipRefresh*/true);

		await Promise.all([
			oRho.created(),
			this.waitForChanges(assert, "create node 5 (Rho)")
		]);

		checkTable("after create 5 (Rho)", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='5',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.4',IsActiveEntity=false)"
		], [
			[true, 1, "0", "Alpha"],
			[undefined, 2, "5", "Rho"]
		], 14);

		this.expectRequest(sUrl + sSelect + "&$skip=3&$top=2", {
				value : [{
					ArtistID : "1.2",
					IsActiveEntity : false,
					Name : "Delta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "collapsed",
						NodeID : "1.2,false"
					}
				}, {
					ArtistID : "1.3",
					IsActiveEntity : false,
					Name : "Theta",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "1.3,false"
					}
				}]
			});

		oTable.setFirstVisibleRow(5);

		await this.waitForChanges(assert, "scroll to 1.2 (Delta)");

		checkTable("after scroll to 1.2 (Delta)", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='5',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.4',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.3',IsActiveEntity=false)"
		], [
			[false, 3, "1.2", "Delta"],
			[undefined, 3, "1.3", "Theta"]
		], 14);
		const oDelta = oTable.getRows()[0].getBindingContext();

		this.expectRequest("Artists?$apply=descendants("
					+ "$root/Artists,OrgChart,_/NodeID,"
					+ "filter(ArtistID eq '1.2' and IsActiveEntity eq false),1)"
				+ "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID"
				+ "&$count=true&$skip=0&$top=2", {
				"@odata.count" : "3",
				value : [{
					ArtistID : "1.2.1",
					IsActiveEntity : false,
					Name : "Epsilon",
					_ : {
						// ensures that collapsed nodes in group level caches are considered
						DrillState : "collapsed",
						NodeID : "1.2.1,false"
					}
				}, {
					ArtistID : "1.2.2",
					IsActiveEntity : false,
					Name : "Zeta",
					_ : {
						DrillState : "leaf",
						NodeID : "1.2.2,false"
					}
				}]
			});

		// code under test
		oDelta.expand();

		await this.waitForChanges(assert, "expand 1.2 (Delta)");

		checkTable("after expand 1.2 (Delta)", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='5',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.4',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.3',IsActiveEntity=false)"
		], [
			[true, 3, "1.2", "Delta"],
			[false, 4, "1.2.1", "Epsilon"]
		], 17);

		// code under test
		assert.strictEqual(oDelta.getParent(), oBeta, "Delta's parent is Beta");

		this.expectRequest(sUrl + sSelect + "&$skip=6&$top=2", {
				value : [{
					ArtistID : "2",
					IsActiveEntity : false,
					Name : "Kappa",
					_ : {
						DescendantCount : "2",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						NodeID : "2,false"
					}
				}, {
					ArtistID : "2.1",
					IsActiveEntity : false,
					Name : "Lambda",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "2.1,false"
					}
				}]
			});

		oTable.setFirstVisibleRow(10);

		await this.waitForChanges(assert, "scroll to 2 (Kappa)");

		checkTable("after scroll to 2 (Eta)", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='5',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.4',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.3',IsActiveEntity=false)",
			"/Artists(ArtistID='2',IsActiveEntity=false)",
			"/Artists(ArtistID='2.1',IsActiveEntity=false)"
		], [
			[true, 2, "2", "Kappa"],
			[undefined, 3, "2.1", "Lambda"]
		], 17);
		const oKappa = oTable.getRows()[0].getBindingContext();

		this.expectRequest(sUrl + sSelect + "&$skip=9&$top=1", {
				value : [{
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "Nu",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						NodeID : "3,false"
					}
				}]
			});
		oKappa.collapse();

		await this.waitForChanges(assert, "collapse 2 (Kappa)");

		checkTable("after collapse 2 (oKappa)", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='5',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.4',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.3',IsActiveEntity=false)",
			"/Artists(ArtistID='2',IsActiveEntity=false)",
			"/Artists(ArtistID='3',IsActiveEntity=false)"
		], [
			[false, 2, "2", "Kappa"],
			[undefined, 2, "3", "Nu"]
		], 15);

		this.expectRequest(sUrl + sSelect + "&$skip=11&$top=2", {
				value : [{
					ArtistID : "4.1",
					IsActiveEntity : false,
					Name : "Omicron",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "4.1,false"
					}
				}, {
					ArtistID : "4.2",
					IsActiveEntity : false,
					Name : "Pi",
					_ : {
						DescendantCount : "0",
						DistanceFromRoot : "2",
						DrillState : "leaf",
						NodeID : "4.2,false"
					}
				}]
			});

		oTable.setFirstVisibleRow(13);

		await this.waitForChanges(assert, "scroll to 4.1 (Omicron)");

		checkTable("after scroll to 4.1 (Omicron)", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='5',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.4',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.3',IsActiveEntity=false)",
			"/Artists(ArtistID='2',IsActiveEntity=false)",
			"/Artists(ArtistID='3',IsActiveEntity=false)",
			"/Artists(ArtistID='4.1',IsActiveEntity=false)",
			"/Artists(ArtistID='4.2',IsActiveEntity=false)"
		], [
			[undefined, 3, "4.1", "Omicron"],
			[undefined, 3, "4.2", "Pi"]
		], 15);
		const oOmicron = oTable.getRows()[0].getBindingContext();
		const oPi = oTable.getRows()[1].getBindingContext();

		// code under test
		assert.strictEqual(oOmicron.getParent(), undefined);
		assert.strictEqual(oPi.getParent(), undefined);

		this.expectRequest({
				batchNo : 11,
				url : "Artists?$apply=ancestors("
						+ "$root/Artists,OrgChart,_/NodeID,"
						+ "filter(ArtistID eq '4.1' and IsActiveEntity eq false),1)"
					+ "&$select=ArtistID,IsActiveEntity,Name"
			}, {
				value : [{
					ArtistID : "4",
					IsActiveEntity : false,
					Name : "Xi"
				}]
			})
			.expectRequest({
				batchNo : 12,
				url : sUrl + "&$filter=ArtistID eq '4' and IsActiveEntity eq false"
					+ "&$select=_/DescendantCount,_/DistanceFromRoot,_/DrillState,"
						+ "_/Limited_Rank,_/NodeID"
			}, {
				value : [{
					_ : {
						DescendantCount : "2",
						DistanceFromRoot : "1",
						DrillState : "expanded",
						Limited_Rank : "10", // Edm.Int64
						NodeID : "4,false"
					}
				}]
			});

		// code under test
		const [oXi, oXi0, oXi1] = await Promise.all([
			oPi.requestParent(),
			oOmicron.requestParent(),
			oOmicron.requestParent(),
			this.waitForChanges(assert, "request parent of 4.1 (Omicron) and 4.2 (Pi)")
		]);

		assert.strictEqual(oXi0, oXi,
			"CPOUI5ODATAV4-2467: request parent of 4.2 (Pi) returns the same context");
		assert.strictEqual(oXi0, oXi1,
			"CPOUI5ODATAV4-2467: second request returns the same context");
		assert.strictEqual(oXi.getIndex(), 12);
		assert.strictEqual(oXi.getPath(), "/Artists(ArtistID='4',IsActiveEntity=false)");
		assert.deepEqual(oXi.getObject(), {
			ArtistID : "4",
			IsActiveEntity : false,
			Name : "Xi",
			"@$ui5.node.isExpanded" : true,
			"@$ui5.node.level" : 2,
			_ : {
				NodeID : "4,false"
			}
		});

		assert.strictEqual(oOmicron.getParent(), oXi);
		// Pi has the same parent as Omicron, no additional request is needed
		assert.strictEqual(oTable.getRows()[1].getBindingContext().getParent(), oXi);

		oTable.setFirstVisibleRow(12);

		await resolveLater(); // table update takes a moment

		checkTable("after scroll to 4 (Xi)", assert, oTable, [
			"/Artists(ArtistID='0',IsActiveEntity=false)",
			"/Artists(ArtistID='5',IsActiveEntity=false)",
			"/Artists(ArtistID='1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.4',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.1',IsActiveEntity=false)",
			"/Artists(ArtistID='1.2.2',IsActiveEntity=false)",
			"/Artists(ArtistID='1.3',IsActiveEntity=false)",
			"/Artists(ArtistID='2',IsActiveEntity=false)",
			"/Artists(ArtistID='3',IsActiveEntity=false)",
			"/Artists(ArtistID='4',IsActiveEntity=false)",
			"/Artists(ArtistID='4.1',IsActiveEntity=false)",
			"/Artists(ArtistID='4.2',IsActiveEntity=false)"
		], [
			[true, 2, "4", "Xi"],
			[undefined, 3, "4.1", "Omicron"]
		], 15);

		assert.strictEqual(oXi, oTable.getRows()[0].getBindingContext());
	});

	//*********************************************************************************************
	// Scenario: Show the single root node of a recursive hierarchy and expand it. Not all children
	// are loaded, but some placeholders remain. Create two new child nodes underneath the root.
	// Scroll down to load the other children.
	// JIRA: CPOUI5ODATAV4-2260
	//
	// Create new child and cancel immediately (JIRA: CPOUI5ODATAV4-2272)
	// Also delete instead of cancelling (JIRA: CPOUI5ODATAV4-2274)
	// Delete a created persisted child (JIRA: CPOUI5ODATAV4-2224)
[false, true].forEach(function (bDelete) {
	const sTitle = `Recursive Hierarchy: create new children & placeholders, delete=${bDelete}`;

	QUnit.test(sTitle, function (assert) {
		var oListBinding, oRoot, oTable;

		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/Artists',
		parameters : {
			$$aggregation : {
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="3">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text id="id" text="{ArtistID}"/>\
	<Text id="name" text="{Name}"/>
</t:Table>`;
		const that = this;

		this.expectRequest({
				batchNo : 1,
				url : "Artists?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/Artists,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='_/NodeID',Levels=1)"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID"
					+ "&$count=true&$skip=0&$top=3"
			}, {
				"@odata.count" : "1",
				value : [{
					ArtistID : "0",
					IsActiveEntity : false,
					Name : "Alpha",
					_ : {
						// DescendantCount : "0", // not needed w/o expandTo
						// DistanceFromRoot : "0", // not needed w/o expandTo
						DrillState : "collapsed",
						NodeID : "0,false"
					}
				}]
			})
			.expectChange("id", ["0"])
			.expectChange("name", ["Alpha"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oRoot = oTable.getRows()[0].getBindingContext();
			oListBinding = oRoot.getBinding();

			checkTable("root is leaf", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=false)"
			], [
				[false, 1, "0", "Alpha"]
			]);

			that.expectRequest("Artists?$apply=descendants($root/Artists,OrgChart,_/NodeID"
						+ ",filter(ArtistID eq '0' and IsActiveEntity eq false),1)"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID"
					+ "&$count=true&$skip=0&$top=3", {
					"@odata.count" : "5",
					value : [{
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "Beta",
						_ : {
							DrillState : "leaf",
							NodeID : "1,false"
						}
					}, {
						ArtistID : "2",
						IsActiveEntity : false,
						Name : "Gamma",
						_ : {
							DrillState : "leaf",
							NodeID : "2,false"
						}
					}, {
						ArtistID : "3",
						IsActiveEntity : false,
						Name : "Delta",
						_ : {
							DrillState : "leaf",
							NodeID : "3,false"
						}
					}]
				})
				.expectChange("id", [, "1", "2"])
				.expectChange("name", [, "Beta", "Gamma"]);

			// code under test
			oRoot.expand();

			return that.waitForChanges(assert, "expand");
		}).then(function () {
			checkTable("after expand", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=false)",
				"/Artists(ArtistID='1',IsActiveEntity=false)",
				"/Artists(ArtistID='2',IsActiveEntity=false)",
				"/Artists(ArtistID='3',IsActiveEntity=false)"
			], [
				[true, 1, "0", "Alpha"],
				[undefined, 2, "1", "Beta"],
				[undefined, 2, "2", "Gamma"]
			], 6);

			// code under test (JIRA: CPOUI5ODATAV4-2272, JIRA: CPOUI5ODATAV4-2274)
			const oLostChild = oListBinding.create({
				"@$ui5.node.parent" : oRoot,
				Name : "n/a"
			}, /*bSkipRefresh*/true);
			if (bDelete) {
				oLostChild.delete();
			} else {
				oModel.resetChanges();
			}

			that.expectChange("id", [, "", "1"])
				.expectChange("name", [, "1st new child", "Beta"])
				.expectRequest({
					method : "POST",
					url : "Artists",
					payload : {
						"BestFriend@odata.bind" : "Artists(ArtistID='0',IsActiveEntity=false)",
						Name : "1st new child"
					}
				}, {
					ArtistID : "11",
					IsActiveEntity : false,
					Name : "First new child", // side effect
					_ : null // not available w/ RAP for a non-hierarchical request
				})
				.expectChange("id", [, "11"])
				.expectChange("name", [, "First new child"])
				.expectRequest("Artists?$apply=descendants($root/Artists,OrgChart,_/NodeID"
					+ ",filter(ArtistID eq '0' and IsActiveEntity eq false),1)"
					+ "&$filter=ArtistID eq '11' and IsActiveEntity eq false&$select=_/NodeID", {
					value : [{
						_ : {
							NodeID : "11,true"
						}
					}]
				});

			// code under test
			const oChild = oListBinding.create({
				"@$ui5.node.parent" : oRoot,
				Name : "1st new child"
			}, /*bSkipRefresh*/true);

			return Promise.all([
				checkCanceled(assert, oLostChild.created()),
				oChild.created(),
				that.waitForChanges(assert, "create 1st child")
			]);
		}).then(function () {
			that.expectChange("id", [, "", "11"])
				.expectChange("name", [, "2nd new child", "First new child"])
				.expectRequest({
					method : "POST",
					url : "Artists",
					payload : {
						"BestFriend@odata.bind" : "Artists(ArtistID='0',IsActiveEntity=false)",
						Name : "2nd new child"
					}
				}, {
					"@odata.etag" : "etag2.0",
					ArtistID : "12",
					IsActiveEntity : false,
					Name : "Second new child", // side effect
					_ : null // not available w/ RAP for a non-hierarchical request
				})
				.expectChange("id", [, "12"])
				.expectChange("name", [, "Second new child"])
				.expectRequest("Artists?$apply=descendants($root/Artists,OrgChart,_/NodeID"
					+ ",filter(ArtistID eq '0' and IsActiveEntity eq false),1)"
					+ "&$filter=ArtistID eq '12' and IsActiveEntity eq false&$select=_/NodeID", {
					value : [{
						"@odata.etag" : "etag2.0",
						_ : {
							NodeID : "12,true"
						}
					}]
				});

			// code under test
			const oChild = oListBinding.create({
				"@$ui5.node.parent" : oRoot,
				Name : "2nd new child"
			}, /*bSkipRefresh*/true);

			return Promise.all([
				oChild.created(),
				that.waitForChanges(assert, "create 2nd child")
			]);
		}).then(function () {
			checkTable("after creation", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=false)",
				"/Artists(ArtistID='12',IsActiveEntity=false)",
				"/Artists(ArtistID='11',IsActiveEntity=false)",
				"/Artists(ArtistID='1',IsActiveEntity=false)",
				"/Artists(ArtistID='2',IsActiveEntity=false)",
				"/Artists(ArtistID='3',IsActiveEntity=false)"
			], [
				[true, 1, "0", "Alpha"],
				[undefined, 2, "12", "Second new child"],
				[undefined, 2, "11", "First new child"]
			], 8);

			that.expectChange("id", [,,, "1", "2", "3"])
				.expectChange("name", [,,, "Beta", "Gamma", "Delta"]);

			// code under test
			oTable.setFirstVisibleRow(3);

			return that.waitForChanges(assert, "scroll down");
		}).then(function () {
			checkTable("after scroll down", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=false)",
				"/Artists(ArtistID='12',IsActiveEntity=false)",
				"/Artists(ArtistID='11',IsActiveEntity=false)",
				"/Artists(ArtistID='1',IsActiveEntity=false)",
				"/Artists(ArtistID='2',IsActiveEntity=false)",
				"/Artists(ArtistID='3',IsActiveEntity=false)"
			], [
				[undefined, 2, "1", "Beta"],
				[undefined, 2, "2", "Gamma"],
				[undefined, 2, "3", "Delta"]
			], 8);

			that.expectRequest("Artists?$apply=descendants($root/Artists,OrgChart,_/NodeID"
						+ ",filter(ArtistID eq '0' and IsActiveEntity eq false),1)"
					+ "&$select=ArtistID,IsActiveEntity,Name,_/DrillState,_/NodeID"
					+ "&$filter=not (ArtistID eq '11' and IsActiveEntity eq false"
						+ " or ArtistID eq '12' and IsActiveEntity eq false)"
					+ "&$skip=3&$top=2", {
					value : [{
						ArtistID : "4",
						IsActiveEntity : false,
						Name : "Epsilon",
						_ : {
							DrillState : "leaf",
							NodeID : "4,false"
						}
					}, {
						ArtistID : "5",
						IsActiveEntity : false,
						Name : "Zeta",
						_ : {
							DrillState : "leaf",
							NodeID : "5,false"
						}
					}]
				})
				.expectChange("id", [,,,,, "3", "4", "5"])
				.expectChange("name", [,,,,, "Delta", "Epsilon", "Zeta"]);

			// code under test
			oTable.setFirstVisibleRow(5);

			return that.waitForChanges(assert, "scroll to bottom");
		}).then(function () {
			checkTable("after scroll to bottom", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=false)",
				"/Artists(ArtistID='12',IsActiveEntity=false)",
				"/Artists(ArtistID='11',IsActiveEntity=false)",
				"/Artists(ArtistID='1',IsActiveEntity=false)",
				"/Artists(ArtistID='2',IsActiveEntity=false)",
				"/Artists(ArtistID='3',IsActiveEntity=false)",
				"/Artists(ArtistID='4',IsActiveEntity=false)",
				"/Artists(ArtistID='5',IsActiveEntity=false)"
			], [
				[undefined, 2, "3", "Delta"],
				[undefined, 2, "4", "Epsilon"],
				[undefined, 2, "5", "Zeta"]
			]);
		}).then(function () {
			that.expectChange("id", ["0", "12", "11"])
				.expectChange("name", ["Alpha", "Second new child", "First new child"]);

			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert, "scroll to top");
		}).then(function () {
			const oCreatedPersisted = oTable.getRows()[1].getBindingContext();
			checkCreatedPersisted(assert, oCreatedPersisted);

			that.expectChange("id", [, "11", "1"])
				.expectChange("name", [, "First new child", "Beta"])
				.expectRequest({
					method : "DELETE",
					headers : {
						"If-Match" : "etag2.0"
					},
					url : "Artists(ArtistID='12',IsActiveEntity=false)"
				});

			return Promise.all([
				// code under test (JIRA: CPOUI5ODATAV4-2224)
				oCreatedPersisted.delete(),
				that.waitForChanges(assert, "delete created persisted child")
			]);
		}).then(function () {
			checkTable("after deletion of created persisted", assert, oTable, [
				"/Artists(ArtistID='0',IsActiveEntity=false)",
				"/Artists(ArtistID='11',IsActiveEntity=false)",
				"/Artists(ArtistID='1',IsActiveEntity=false)",
				"/Artists(ArtistID='2',IsActiveEntity=false)",
				"/Artists(ArtistID='3',IsActiveEntity=false)",
				"/Artists(ArtistID='4',IsActiveEntity=false)",
				"/Artists(ArtistID='5',IsActiveEntity=false)"
			], [
				[true, 1, "0", "Alpha"],
				[undefined, 2, "11", "First new child"],
				[undefined, 2, "1", "Beta"]
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Sorting or filtering a recursive hierarchy keeps the expand state, but not the
	// out-of-place nodes. "methods" ending with "#1" cause a full refresh and lose the expand
	// state, in all other cases it will be a side-effects refresh keeping it.
	// (1) Expand Alpha
	// (2) Create Gamma (out of place)
	// (3) Call the method (hierarchy unchanged, Alpha still expanded, Gamma no longer out of place)
	// (4) Check all contexts
	// JIRA: CPOUI5ODATAV4-2025
[
	"changeParameters#0", "changeParameters#1", "filter", "resume#0", "resume#1", "sort"
].forEach(function (sMethod) {
	QUnit.test(`Recursive Hierarchy: ${sMethod} & ExpandLevels`, async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		let sOptions = "";
		const sUrl = "EMPLOYEES?foo=bar"
			+ "&$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/EMPLOYEES"
			+ ",HierarchyQualifier='OrgChart',NodeProperty='ID',Levels=1)";
		const sUrlWithExpandLevels = sUrl.slice(0, -1)
			+ ",ExpandLevels=" + JSON.stringify([{NodeID : "1", Levels : 1}]) + ")";
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
		parameters : {
			foo : 'bar',
			$$aggregation : {
				hierarchyQualifier : 'OrgChart'
			}
		}}" threshold="0" visibleRowCount="2">
	<Text text="{= %{@$ui5.node.isExpanded} }"/>
	<Text text="{= %{@$ui5.node.level} }"/>
	<Text text="{Name}"/>
</t:Table>`;

		// 1 Alpha
		//   2 Beta
		//   3 Gamma (created)
		// 4 Delta
		const expectInitial = (sRequestUrl) => {
			this.expectRequest(sRequestUrl
					+ "&$select=DrillState,ID,Name&$count=true&$skip=0&$top=2", {
					"@odata.count" : "2",
					value : [
						{DrillState : "collapsed", ID : "1", Name : "Alpha"},
						{DrillState : "leaf", ID : "4", Name : "Delta"}
					]
				});
		};
		expectInitial(sUrl);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oBinding = oTable.getBinding("rows");
		const oAlpha = oBinding.getCurrentContexts()[0];

		this.expectRequest("EMPLOYEES?foo=bar"
				+ "&$apply=descendants($root/EMPLOYEES,OrgChart,ID,filter(ID eq '1'),1)"
				+ "&$select=DrillState,ID,Name&$count=true&$skip=0&$top=2", {
				"@odata.count" : "1",
				value : [
					{DrillState : "leaf", ID : "2", Name : "Beta"}
				]
			});

		oAlpha.expand();

		await this.waitForChanges(assert, "(1) expand Alpha");

		checkTable("after (1)", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('4')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"]
		]);

		this.expectRequest({
				method : "POST",
				url : "EMPLOYEES?foo=bar",
				payload : {
					"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('1')",
					Name : "Gamma"
				}
			}, {
				ID : "3",
				Name : "Gamma"
			});

		const oGamma = oBinding.create({
			"@$ui5.node.parent" : oAlpha,
			Name : "Gamma"
		}, /*bSkipRefresh*/true);

		await Promise.all([
			oGamma.created(),
			this.waitForChanges(assert, "(2) create Gamma")
		]);

		checkTable("after (2)", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('3')",
			"/EMPLOYEES('2')",
			"/EMPLOYEES('4')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Gamma"]
		]);

		const expectSideEffectsRefresh = () => {
			this.expectRequest(sUrlWithExpandLevels.replace("$apply=", `$apply=${sOptions}/`)
					+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name"
					+ "&$count=true&$skip=0&$top=2", {
					"@odata.count" : "4",
					value : [{
						DescendantCount : "2",
						DistanceFromRoot : "0",
						DrillState : "expanded",
						ID : "1",
						Name : "Alpha"
					}, {
						DescendantCount : "0",
						DistanceFromRoot : "1",
						DrillState : "leaf",
						ID : "2",
						Name : "Beta"
					}]
				});
		};

		switch (sMethod) {
			case "changeParameters#0":
				sOptions = "ancestors($root/EMPLOYEES,OrgChart,ID,filter(AGE gt 0),keep start)"
					+ "/orderby(AGE)";
				expectSideEffectsRefresh();

				// code under test
				oBinding.changeParameters({
					$filter : "AGE gt 0",
					$orderby : "AGE"
				});
				break;

			case "changeParameters#1":
				expectInitial(
					sUrl.replace("bar", "baz").replace("$apply=", "$apply=orderby(AGE)/"));

				// code under test
				oBinding.changeParameters({
					foo : "baz",
					$orderby : "AGE"
				});
				break;

			case "filter":
				sOptions = "ancestors($root/EMPLOYEES,OrgChart,ID,filter(AGE gt 0),keep start)";
				expectSideEffectsRefresh();

				// code under test
				oBinding.filter(new Filter("AGE", FilterOperator.GT, 0));
				break;

			case "resume#0":
				sOptions = "ancestors($root/EMPLOYEES,OrgChart,ID,filter(AGE gt 0),keep start)"
					+ "/orderby(AGE,Name)";
				expectSideEffectsRefresh();

				// code under test
				oBinding.suspend();
				oBinding.sort(new Sorter("AGE"));
				oBinding.filter(new Filter("AGE", FilterOperator.GT, 0));
				oBinding.changeParameters({$orderby : "Name"});
				oBinding.resume();
				break;

			case "resume#1":
				expectInitial(
					sUrl.replace("bar", "baz").replace("$apply=", "$apply=orderby(AGE)/"));

				// code under test
				oBinding.suspend();
				oBinding.changeParameters({foo : "baz"}); // no side-effects refresh possible
				oBinding.sort(new Sorter("AGE")); // must not activate it anymore!
				oBinding.resume();
				break;

			case "sort":
				sOptions = "orderby(AGE)";
				expectSideEffectsRefresh();

				// code under test
				oBinding.sort(new Sorter("AGE"));
				break;

			// no default
		}

		await this.waitForChanges(assert, `(3) ${sMethod}`);

		if (sMethod.endsWith("#1")) {
			return await this.checkAllContexts("(4) check all contexts", assert, oBinding,
				["@$ui5.node.isExpanded", "@$ui5.node.level", "Name"], [
					[false, 1, "Alpha"],
					[undefined, 1, "Delta"]
				]);
		}

		this.expectRequest(sUrlWithExpandLevels.replace("$apply=", `$apply=${sOptions}/`)
				+ "&$select=DescendantCount,DistanceFromRoot,DrillState,ID,Name&$skip=2&$top=2", {
				value : [{
					DescendantCount : "0",
					DistanceFromRoot : "1",
					DrillState : "leaf",
					ID : "3",
					Name : "Gamma"
				}, {
					DescendantCount : "0",
					DistanceFromRoot : "0",
					DrillState : "leaf",
					ID : "4",
					Name : "Delta"
				}]
			});

		await this.checkAllContexts("(4) check all contexts", assert, oBinding,
			["@$ui5.node.isExpanded", "@$ui5.node.level", "Name"], [
				[true, 1, "Alpha"],
				[undefined, 2, "Beta"],
				[undefined, 2, "Gamma"],
				[undefined, 1, "Delta"]
			]);

		if (sMethod !== "changeParameters#0") {
			return;
		}

		// eslint-disable-next-line require-atomic-updates
		sOptions = "ancestors($root/EMPLOYEES,OrgChart,ID,filter(AGE gt 0),keep start)";
		expectSideEffectsRefresh();

		// code under test
		oBinding.changeParameters({
			$orderby : undefined
		});

		await this.waitForChanges(assert, "(5) changeParameters removing $orderby");

		checkTable("after (5)", assert, oTable, [
			"/EMPLOYEES('1')",
			"/EMPLOYEES('2')"
		], [
			[true, 1, "Alpha"],
			[undefined, 2, "Beta"]
		], 4);
	});
});

	//*********************************************************************************************
	// Scenario: Create a node in a hierarchical list. Bind a sublist to the created node. See that
	// a deep create is not possible. When the node has been persisted, see that the data for the
	// sublist is fetched and creating an entity is possible.
	// SNOW: DINC0005276
	QUnit.test("Recursive Hierarchy: DINC0005276", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"});
		const sView = `
<Table id="employees" items="{path : '/EMPLOYEES',
		parameters : {$$aggregation : {hierarchyQualifier : 'OrgChart'}}}">
	<Text id="name" text="{Name}"/>
</Table>
<Table id="equipments" items="{EMPLOYEE_2_EQUIPMENTS}">
    <Text id="category" text="{Category}"/>
</Table>`;

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
				+ "&$select=DrillState,ID,Name&$count=true&$skip=0&$top=100", {
				"@odata.count" : "0",
				value : []
			})
			.expectChange("name", [])
			.expectChange("category", []);

		await this.createView(assert, sView, oModel);

		this.expectChange("name", ["foo"]);

		// code under test
		const oEmployeeContext = this.oView.byId("employees").getBinding("items")
			.create({Name : "foo"}, true);

		const oEquipmentsTable = this.oView.byId("equipments");
		const oEquipmentsBinding = oEquipmentsTable.getBinding("items");

		// code under test
		oEquipmentsTable.setBindingContext(oEmployeeContext);

		await this.waitForChanges(assert, "create Employee");

		assert.throws(function () {
			// code under test
			oEquipmentsBinding.create();
		}, new Error("Deep create is not supported with data aggregation"));

		this.expectRequest({
				method : "POST",
				url : "EMPLOYEES",
				payload : {Name : "foo"}
			}, {ID : "42", Name : "foo"})
			.expectRequest("EMPLOYEES('42')/EMPLOYEE_2_EQUIPMENTS?$select=Category,ID"
				+ "&$skip=0&$top=100",
				{value : [{Category : "C", ID : 23}]})
			.expectChange("category", ["C"]);

		await Promise.all([
			oModel.submitBatch("update"),
			oEmployeeContext.created(),
			this.waitForChanges(assert, "submit")
		]);

		this.expectChange("category", ["D", "C"])
			.expectRequest({
				method : "POST",
				url : "EMPLOYEES('42')/EMPLOYEE_2_EQUIPMENTS",
				payload : {Category : "D"}
			}, {Category : "D", ID : 24});

		// code under test
		const oEquipmentContext = oEquipmentsBinding.create({Category : "D"}, true);

		await Promise.all([
			oModel.submitBatch("update"),
			oEquipmentContext.created(),
			this.waitForChanges(assert, "create Equipment and submit")
		]);
	});

	//*********************************************************************************************
	// Scenario: Paging with prefetch (threshold is 5, intentionally odd). Set first visible row to
	// 30. Then consecutively increase resp. decrease it by one and see that requests only occur
	// after threshold/2 has been surmounted.
	// JIRA: CPOUI5ODATAV4-2432
[false, true].forEach(function (bAggregation) {
	const sTitle = "CPOUI5ODATAV4-2432: " + (bAggregation ? "Recursive Hierarchy: " : "")
		+ "Paging w/ Prefetch";
	QUnit.test(sTitle, async function (assert) {
		var oTable;

		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sParameters = bAggregation
			? "{$$aggregation : {hierarchyQualifier : 'OrgChart'}}"
			: "{$count : true}";
		const sBaseQuery = bAggregation
			? "$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels"
				+ "(HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
				+ ",NodeProperty='ID',Levels=1)&$select=DrillState,ID"
			: "$count=true&$select=ID";
		const sView = `
<t:Table firstVisibleRow="30" id="table" rows="{path : '/EMPLOYEES', parameters : ${sParameters}}"
		threshold="5" visibleRowCount="3">
	<Text id="id" text="{ID}"/>
</t:Table>`;
		let bCount = bAggregation;

		/**
		 * Expects request (if iSkip and iTop are given) and change events.
		 *
		 * @param {number} iRow - The first visible row
		 * @param {number} [iSkip] - $skip for the request; no request if undefined
		 * @param {number} [iTop] - $top for the request
		 * @param {boolean} [bNoChangeEvents] - Whether no change events are to be expected
		 */
		const expect = (iRow, iSkip, iTop, bNoChangeEvents) => {
			if (iSkip !== undefined) {
				const aElements = [];
				for (let i = 0; i < iTop; i += 1) {
					aElements.push({DrillState : "leaf", ID : `E${iSkip + i}`});
				}

				const sQuery = sBaseQuery + (bCount ? "&$count=true" : "");
				bCount = false;
				this.expectRequest(`EMPLOYEES?${sQuery}&$skip=${iSkip}&$top=${iTop}`,
						resolveLater({
							"@odata.count" : "100",
							value : aElements
						})
					);
			}
			if (!bNoChangeEvents) {
				for (let i = 0; i < 3; i += 1) {
					this.expectChange("id", `E${iRow + i}`, iRow + i);
				}
			}
		};

		/**
		 * Scrolls the table to the given row, expects request and change events and waits for them.
		 *
		 * @param {number} iRow - The new first visible row
		 * @param {number} [iSkip] - $skip for the request; no request if undefined
		 * @param {number} [iTop] - $top for the request
		 * @param {boolean} [bNoWait] - Whether to wait for request and changes
		 */
		const scroll = async (iRow, iSkip, iTop, bNoWait) => {
			expect(iRow, iSkip, iTop, bNoWait);
			oTable.setFirstVisibleRow(iRow);

			if (!bNoWait) {
				await this.waitForChanges(assert, `scroll to ${iRow}`);
			}
		};

		expect(30, 25, 13); // 5 before, 3 visible, 5 after

		await this.createView(assert, sView, oModel);

		oTable = this.oView.byId("table");

		// forward
		await scroll(31);
		await scroll(32);
		await scroll(33, 38, 3); // 3 after (> threshold/2)
		await scroll(34);
		await scroll(35);
		scroll(36, 41, 3, true); // 3 after
		await Promise.resolve();
		// this scroll happens before the response arrived, because we did not wait for the changes
		await scroll(37);
		// backward
		await scroll(29);
		await scroll(28);
		await scroll(27, 22, 3); // 3 before
		await scroll(26);
		await scroll(25);
		await scroll(24, 19, 3); // 3 before
	});
});

	//*********************************************************************************************
	// Scenario: Recursive Hierarchy, prefetch and nodes w/o "rank"
	// (1) Initially the table only contains root nodes Alpha, Delta, Epsilon...
	// (2) Create two children Beta, Gamma of Alpha
	// (3) Collapse Alpha
	// (4) Request side effects
	// (5) Scroll to 5
	// (6) Expand Alpha again; Beta and Gamma are now invisible placeholders w/o rank
	// (7) Quickly scroll to 4 and 3; Gamma must not be requested twice
	// JIRA: CPOUI5ODATAV4-2432
	QUnit.test("CPOUI5ODATAV4-2432: Recursive Hierarchy, prefetch, rank", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<t:Table id="table" rows="{path : '/EMPLOYEES',
 			parameters : {$$aggregation : {hierarchyQualifier : 'OrgChart'}}}"
		threshold="4" visibleRowCount="2">
	<Text id="name" text="{Name}"/>
</t:Table>`;

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
					+ "&$select=DrillState,ID,Name&$count=true&$skip=0&$top=6", {
				"@odata.count" : "20",
				value : [
					{DrillState : "leaf", ID : "0", Name : "Alpha"},
					{DrillState : "leaf", ID : "1", Name : "Delta"},
					{DrillState : "leaf", ID : "2", Name : "Epsilon"},
					{DrillState : "leaf", ID : "3", Name : "Zeta"},
					{DrillState : "leaf", ID : "4", Name : "Eta"},
					{DrillState : "leaf", ID : "5", Name : "Theta"}
				]
			})
			.expectChange("name", ["Alpha", "Delta"]);

		await this.createView(assert, sView, oModel);

		this.expectChange("name", [, "Beta"])
			.expectRequest({
				method : "POST",
				url : "EMPLOYEES",
				payload : {"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('0')", Name : "Gamma"}
			}, {DrillState : "leaf", ID : "0.1", Name : "Gamma"})
			.expectRequest({
				method : "POST",
				url : "EMPLOYEES",
				payload : {"EMPLOYEE_2_MANAGER@odata.bind" : "EMPLOYEES('0')", Name : "Beta"}
			}, {DrillState : "leaf", ID : "0.0", Name : "Beta"});

		const oTable = this.oView.byId("table");
		const oBinding = oTable.getBinding("rows");
		const oAlpha = oBinding.getCurrentContexts()[0];
		const oGamma = oBinding.create({
			"@$ui5.node.parent" : oAlpha,
			Name : "Gamma"
		}, true);
		const oBeta = oBinding.create({
			"@$ui5.node.parent" : oAlpha,
			Name : "Beta"
		}, true);

		await Promise.all([
			oBeta.created(),
			oGamma.created(),
			this.waitForChanges(assert, "(2) create Beta & Gamma")
		]);

		this.expectChange("name", [, "Delta"]);

		oAlpha.collapse();

		await this.waitForChanges(assert, "(3) collapse Alpha");

		this.expectRequest("EMPLOYEES?$select=ID,Name&$filter=ID eq '0' or ID eq '1'&$top=2", {
				value : [
					{ID : "0", Name : "Alpha*"},
					{ID : "1", Name : "Delta*"}
				]
			})
			.expectChange("name", ["Alpha*", "Delta*"]);

		await Promise.all([
			oBinding.getHeaderContext().requestSideEffects(["Name"]),
			this.waitForChanges(assert, "(4) side effects")
		]);

		this.expectRequest("EMPLOYEES?$apply=com.sap.vocabularies.Hierarchy.v1.TopLevels("
					+ "HierarchyNodes=$root/EMPLOYEES,HierarchyQualifier='OrgChart'"
					+ ",NodeProperty='ID',Levels=1)"
					+ "&$select=DrillState,ID,Name&$skip=2&$top=9", {
				value : [
					{DrillState : "leaf", ID : "2", Name : "Epsilon*"},
					{DrillState : "leaf", ID : "3", Name : "Zeta*"},
					{DrillState : "leaf", ID : "4", Name : "Eta*"},
					{DrillState : "leaf", ID : "5", Name : "Theta*"},
					{DrillState : "leaf", ID : "6", Name : "Iota*"},
					{DrillState : "leaf", ID : "7", Name : "Kappa*"},
					{DrillState : "leaf", ID : "8", Name : "Lambda*"},
					{DrillState : "leaf", ID : "9", Name : "Mu*"},
					{DrillState : "leaf", ID : "10", Name : "Nu*"}
				]
			})
			.expectChange("name", [,,,,, "Theta*", "Iota*"]);

		oTable.setFirstVisibleRow(5);

		await this.waitForChanges(assert, "(5) scroll to 5");

		this.expectChange("name", [,,,,, "Zeta*", "Eta*"]);

		oAlpha.expand();

		await this.waitForChanges(assert, "(6) expand Alpha");

		this.expectRequest("EMPLOYEES('0.0')?$select=DrillState,ID,Name",
				{DrillState : "leaf", ID : "0.0", Name : "Beta*"})
			.expectRequest("EMPLOYEES('0.1')?$select=DrillState,ID,Name",
				{DrillState : "leaf", ID : "0.1", Name : "Gamma*"})
			.expectChange("name", [,,, "Delta*", "Epsilon*"]);

		oTable.setFirstVisibleRow(4);
		await Promise.resolve();
		oTable.setFirstVisibleRow(3);

		await this.waitForChanges(assert, "(7) quickly scroll to 4 and 3");
	});

	//*********************************************************************************************
	// Scenario: Application tries to overwrite client-side instance annotations.
	// JIRA: CPOUI5UISERVICESV3-1220
	QUnit.test("@$ui5.* is write-protected", function (assert) {
		var oModel = this.createTeaBusiModel(),
			sView = '\
<FlexBox binding="{/MANAGERS(\'1\')}" id="form">\
	<Input id="foo" value="{= %{@$ui5.foo} }"/>\
	<Text id="id" text="{ID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("MANAGERS('1')", {
				"@$ui5.foo" : 42,
				ID : "1"
			})
			.expectChange("foo", 42)
			.expectChange("id", "1");

		return this.createView(assert, sView, oModel).then(function () {
			var oMatcher = sinon.match("/MANAGERS('1')/@$ui5.foo: "
				+ "Read-only path must not be updated"),
				oPropertyBinding = that.oView.byId("foo").getBinding("value");

			assert.strictEqual(oPropertyBinding.getValue(), 42);
			that.oLogMock.expects("error")
				.withExactArgs("Read-only path must not be updated", oMatcher,
					"sap.ui.model.odata.v4.ODataMetaModel");
			that.oLogMock.expects("error")
				.withExactArgs("Failed to update path /MANAGERS('1')/@$ui5.foo", oMatcher, sODPrB);

			that.expectMessages([{
					message : "/MANAGERS('1')/@$ui5.foo: Read-only path must not be updated",
					persistent : true,
					technical : true,
					technicalDetails : {}, // we do NOT expect technicalDetails for JS Errors
					type : "Error"
				}]);

			// code under test
			oPropertyBinding.setValue(0);

			return that.waitForChanges(assert);
		}).then(function () {
			var oContext = that.oView.byId("form").getBindingContext();

			// code under test
			oContext.getObject()["@$ui5.foo"] = 1; // just changing a clone

			assert.strictEqual(oContext.getProperty("@$ui5.foo"), 42);
		});
	});

	//*********************************************************************************************
	// Scenario: Application tries to create client-side instance annotations via ODLB#create.
	// JIRA: CPOUI5UISERVICESV3-1237
	//
	// Also test that no client annotation (starting with "@$ui5") is sent to the server (incl.
	// nested structural properties)
	// JIRA: CPOUI5ODATAV4-360
	QUnit.test("@$ui5.* is write-protected for ODLB#create", function (assert) {
		var oContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
	<Text id="salary" text="{SALARY/MONTHLY_BASIC_SALARY_AMOUNT}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID,Name,SALARY/MONTHLY_BASIC_SALARY_AMOUNT"
			+ "&$skip=0&$top=100", {
				value : [{
					ID : "2",
					Name : "John Doe",
					SALARY : {
						MONTHLY_BASIC_SALARY_AMOUNT : "888"
					}
				}]
			})
			.expectChange("name", ["John Doe"])
			.expectChange("salary", ["888"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oListBinding = that.oView.byId("table").getBinding("items"),
				oInitialData = {
					Name : "New Employee",
					"@$ui5.foo" : "foo0",
					SALARY : {
						MONTHLY_BASIC_SALARY_AMOUNT : "999",
						"@$ui5.foo" : "foo1"
					},
					Titles : [
						{short : "Dr", long : "Doctor"},
						{short : "Prof", long : "Professor", "@$ui5.foo" : "foo2"}
					]
				};

			that.expectChange("name", ["New Employee", "John Doe"]);
			that.expectChange("salary", ["999", "888"]);

			// code under test
			oContext = oListBinding.create(oInitialData, true);

			assert.strictEqual(oContext.getProperty("@$ui5.foo"), undefined);
			assert.strictEqual(oContext.getProperty("SALARY/@$ui5.foo"), undefined);
			assert.strictEqual(oContext.getObject("Titles")[0]["@$ui5.foo"], undefined);
			assert.strictEqual(oContext.getObject("Titles")[1]["@$ui5.foo"], undefined);

			return that.waitForChanges(assert, "no private annotation in transient entity");
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "EMPLOYEES",
					payload : {
						Name : "New Employee",
						SALARY : {
							MONTHLY_BASIC_SALARY_AMOUNT : "999"
						},
						Titles : [
							{short : "Dr", long : "Doctor"},
							{short : "Prof", long : "Professor"}
						]
					}
				}, {
					ID : "42",
					Name : "New Employee",
					SALARY : {
						MONTHLY_BASIC_SALARY_AMOUNT : "997"
					}
					// Titles do no matter here
				})
				.expectChange("salary", ["997"]);

			return Promise.all([
				that.oModel.submitBatch("update"),
				oContext.created(),
				that.waitForChanges(assert, "no private annotation in request")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Application tries to read private client-side instance annotations.
	//
	// Note: Private annotations of navigation properties are also read protected.
	// BCP: 2080181343
	QUnit.test("@$ui5._ is read-protected", function (assert) {
		var oModel = this.createTeaBusiModel(),
			sView = '\
<FlexBox binding="{path : \'/MANAGERS(\\\'1\\\')\', \
		parameters : {$expand : {Manager_to_Team : true}}}" id="form">\
	<Text id="predicate" text="{= %{@$ui5._/predicate} }"/>\
	<Text id="id" text="{ID}"/>\
	<FlexBox binding="{Manager_to_Team}">\
		<Text id="teamPredicate" text="{= %{@$ui5._/predicate} }"/>\
		<Text id="teamId" text="{Team_Id}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		function expectFailedToDrillDown(sPrefix) {
			if (sPrefix !== "") {
				that.oLogMock.expects("error").withExactArgs("Failed to enhance query options for "
					+ "auto-$expand/$select as the path '/MANAGERS('1')/" + sPrefix
					+ "@$ui5._/predicate' does not point to a property",
					sinon.match.string, "sap.ui.model.odata.v4.ODataParentBinding"
				); // fetchIfChildCanUseCache
				that.oLogMock.expects("error").withExactArgs("Not a valid property path: "
					+ sPrefix + "@$ui5._/predicate", undefined, sContext);
			}
			that.oLogMock.expects("error")
				.withExactArgs("Failed to drill-down into " + sPrefix
						+ "@$ui5._/predicate, invalid segment: @$ui5._",
					sTeaBusi + "MANAGERS('1')?$expand=Manager_to_Team",
					"sap.ui.model.odata.v4.lib._Cache")
				.exactly(sPrefix !== "" ? 2 : 3); // binding, getProperty, requestObject
		}

		this.expectRequest("MANAGERS('1')?$expand=Manager_to_Team", {
				ID : "1",
				Manager_to_Team : {
					Team_Id : "42"
				}
			})
			.expectChange("predicate", undefined) // binding itself is "code under test"
			.expectChange("id", "1")
			.expectChange("teamPredicate", undefined)
			.expectChange("teamId", "42");

		expectFailedToDrillDown("");
		expectFailedToDrillDown("Manager_to_Team/");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("form").getBindingContext(),
				oManager = oContext.getObject();

			// code under test
			assert.notOk("@$ui5._" in oManager);
			assert.notOk("@$ui5._" in oManager.Manager_to_Team);

			// code under test
			assert.strictEqual(oContext.getProperty("@$ui5._/predicate"), undefined);
			assert.strictEqual(
				oContext.getProperty("Manager_to_Team/@$ui5._/predicate"),
				undefined
			);

			// code under test
			return Promise.all([
					oContext.requestProperty("@$ui5._/predicate"),
					oContext.requestProperty("Manager_to_Team/@$ui5._/predicate")
				]).then(function (aResult) {
					assert.strictEqual(aResult[0], undefined);
					assert.strictEqual(aResult[1], undefined);

					// code under test
					return oContext.requestObject().then(function (oParent) {
						assert.notOk("@$ui5._" in oParent);
						assert.notOk("@$ui5._" in oParent.Manager_to_Team);
					});
				});
		});
	});

	//*********************************************************************************************
	[
		// Scenario: flat list with aggregated data via $apply, can be combined with $count,
		// $filter, $orderby and system query options are still used (also for $skip, $top)
		"Flat list with aggregated data",
		// Scenario: same as before, but via ODLB#updateAnalyticalInfo; in other words:
		// a hypothetical chart w/ paging, but w/o min/max; initial $skip > 0!
		"ODLB#updateAnalyticalInfo without min/max"
	].forEach(function (sTitle, i) {
		QUnit.test(sTitle, function (assert) {
			var aAggregation = [{ // dimension
					grouped : false,
					inResult : true,
					name : "LifecycleStatus"
				}, { // measure
					name : "GrossAmount",
					total : false
				}],
				sBasicPath = "SalesOrderList?$count=true&$filter=GrossAmount lt 42"
					+ "&$orderby=LifecycleStatus desc"
					+ "&$apply=groupby((LifecycleStatus),aggregate(GrossAmount))",
				oTable,
				sView = '\
<Text id="count" text="{$count}"/>\
<t:Table firstVisibleRow="1" id="table" rows="{path : \'/SalesOrderList\',\
		parameters : {\
			$count : true,\
			$filter : \'GrossAmount lt 42\',\
			$orderby : \'LifecycleStatus desc\'\
' + (i === 0 ? ",$apply : 'groupby((LifecycleStatus),aggregate(GrossAmount))'" : "") + '\
		}}" threshold="0" visibleRowCount="4">\
	<Text id="lifecycleStatus" text="{LifecycleStatus}"/>\
	<Text id="grossAmount" text="{GrossAmount}"/>\
</t:Table>',
				that = this;

			if (i > 0) {
				// for simulating Chart, call #updateAnalyticalInfo _before_ #getContexts
				this.mock(ODataListBinding.prototype)
					.expects("getContexts")
					.withExactArgs(1, 4, 0, undefined)
					.callsFake(function () {
						this.updateAnalyticalInfo(aAggregation);
						ODataListBinding.prototype.getContexts.restore();

						return this.getContexts.apply(this, arguments);
					});
			}
			this.expectRequest(sBasicPath + "&$skip=1&$top=4", {
					"@odata.count" : "26",
					value : [
						{GrossAmount : "2", LifecycleStatus : "Y"},
						{GrossAmount : "3", LifecycleStatus : "X"},
						{GrossAmount : "4", LifecycleStatus : "W"},
						{GrossAmount : "5", LifecycleStatus : "V"}
					]
				})
				.expectChange("count")
				.expectChange("grossAmount", [, "2.00", "3.00", "4.00", "5.00"])
				.expectChange("lifecycleStatus", [, "Y", "X", "W", "V"]);

			return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
				oTable = that.oView.byId("table");

				that.expectChange("count", "26");

				that.oView.byId("count").setBindingContext(
					oTable.getBinding("rows").getHeaderContext());

				return that.waitForChanges(assert);
			}).then(function () {
				if (i > 0) {
					// no additional request for same aggregation data
					oTable.getBinding("rows").updateAnalyticalInfo(aAggregation);
				}

				return that.waitForChanges(assert);
			}).then(function () {
				that.expectRequest(sBasicPath + "&$skip=0&$top=1", {
						"@odata.count" : "26",
						value : [{
							GrossAmount : "1",
							LifecycleStatus : "Z"
						}]
					});
				that.expectChange("grossAmount", ["1.00", "2.00", "3.00", "4.00"])
					.expectChange("lifecycleStatus", ["Z", "Y", "X", "W"]);

				oTable.setFirstVisibleRow(0);

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Simulate a chart that requests minimum and maximum values for a measure via
	// #updateAnalyticalInfo; initial $skip > 0!
	// JIRA: CPOUI5UISERVICESV3-1151
	//
	//TODO this should work the same for an initially suspended binding where #updateAnalyticalInfo
	// is called before #resume, see CPOUI5UISERVICESV3-1754 (PS2 of the change contains that test);
	// currently sap.ui.table.Table interferes with suspend/resume, see skipped test
	// "ODLB: resume/refresh/filter w/ submitBatch on a t:Table"
	QUnit.test("ODLB#updateAnalyticalInfo with min/max", function (assert) {
		var aAggregation = [{ // dimension
				grouped : false,
				inResult : true,
				name : "Name"
			}, { // measure
				max : true,
				min : true,
				name : "AGE",
				total : false
			}],
			oMeasureRangePromise,
			oTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<t:Table firstVisibleRow="1" id="table" rows="{\
			path : \'/EMPLOYEES\',\
			parameters : {$count : true},\
			filters : {path : \'AGE\', operator : \'GE\', value1 : 30},\
			sorter : {path : \'AGE\'}\
		}" threshold="0" visibleRowCount="3">\
	<Text id="text" text="{Name}"/>\
	<Text id="age" text="{AGE}"/>\
</t:Table>',
			that = this;

		// for simulating Chart, call #updateAnalyticalInfo _before_ #getContexts
		this.mock(ODataListBinding.prototype)
			.expects("getContexts")
			.withExactArgs(1, 3, 0, undefined)
			.callsFake(function () {
				that.expectCanceledError("Cache discarded as a new cache has been created");
				oMeasureRangePromise = this.updateAnalyticalInfo(aAggregation)
					.measureRangePromise.then(function (mMeasureRange) {
						assert.deepEqual(mMeasureRange, {
							AGE : {
								max : 77,
								min : 42
							}
						});
					});
				ODataListBinding.prototype.getContexts.restore();

				return this.getContexts.apply(this, arguments);
			});
		this.expectRequest("EMPLOYEES?$apply=groupby((Name),aggregate(AGE))"
				+ "/filter(AGE ge 30)/orderby(AGE)"
				+ "/concat(aggregate(AGE with min as UI5min__AGE,"
				+ "AGE with max as UI5max__AGE,$count as UI5__count)"
				+ ",skip(1)/top(3))", {
				value : [{
					// the server response may contain additional data for example @odata.id or
					// type information "UI5min__AGE@odata.type" : "#Int16"
					"@odata.id" : null,
					"UI5min__AGE@odata.type" : "#Int16",
					UI5min__AGE : 42,
					UI5max__AGE : 77,
					UI5__count : "4",
					"UI5__count@odata.type" : "#Decimal"
				},
				{ID : "1", Name : "Jonathan Smith", AGE : 50},
				{ID : "0", Name : "Frederic Fall", AGE : 70},
				{ID : "2", Name : "Peter Burke", AGE : 77}]
			})
			.expectChange("count")
			.expectChange("text", [, "Jonathan Smith", "Frederic Fall", "Peter Burke"])
			.expectChange("age", [, "50", "70", "77"]);

		return this.createView(assert, sView).then(function () {
			oTable = that.oView.byId("table");

			that.expectChange("count", "4");

			that.oView.byId("count").setBindingContext(
				oTable.getBinding("rows").getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			// no additional request for same aggregation data
			oTable.getBinding("rows").updateAnalyticalInfo(aAggregation);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("EMPLOYEES?$apply=groupby((Name),aggregate(AGE))"
					// Note: for consistency, we prefer filter() over $filter here
					// (same for orderby() vs. $orderby and skip/top)
					+ "/filter(AGE ge 30)/orderby(AGE)/top(1)", {
					value : [{
						ID : "3",
						Name : "John Field",
						AGE : 42
					}]
				})
				.expectChange("text", ["John Field", "Jonathan Smith", "Frederic Fall"])
				.expectChange("age", ["42", "50", "70"]);

			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert);
		}).then(function () {
			return oMeasureRangePromise; // no child left behind :-)
		});
	});

	//*********************************************************************************************
	// Scenario: Simulate a chart that requests minimum and maximum values for a measure via
	// #updateAnalyticalInfo on a suspended binding
	// JIRA: CPOUI5UISERVICESV3-1754
	//
	// Add searching before aggregating.
	// JIRA: CPOUI5ODATAV4-1030
	QUnit.test("ODLB#updateAnalyticalInfo with min/max while suspended", function (assert) {
		var aAggregation = [{ // dimension
				grouped : false,
				inResult : true,
				name : "Name"
			}, { // measure
				max : true,
				min : true,
				name : "AGE",
				total : false
			}],
			oListBinding,
			sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\', suspended : true}">\
	<Text id="text" text="{Name}"/>\
	<Text id="age" text="{AGE}"/>\
</Table>',
			that = this;

		this.expectChange("text", [])
			.expectChange("age", []);

		return this.createView(assert, sView).then(function () {
			var oMeasureRangePromise;

			oListBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("EMPLOYEES?$apply=search(covfefe)/groupby((Name),aggregate(AGE))"
					+ "/concat(aggregate(AGE with min as UI5min__AGE,AGE with max as UI5max__AGE)"
					+ ",top(100))", {
					value : [{
						// the server response may contain additional data for example
						// @odata.id or type information "UI5min__AGE@odata.type" : "#Int16"
						"@odata.id" : null,
						"UI5min__AGE@odata.type" : "#Int16",
						UI5min__AGE : 42,
						UI5max__AGE : 77
					},
					{ID : "1", Name : "Jonathan Smith", AGE : 50},
					{ID : "0", Name : "Frederic Fall", AGE : 70},
					{ID : "2", Name : "Peter Burke", AGE : 77}]
				})
				.expectChange("text", ["Jonathan Smith", "Frederic Fall", "Peter Burke"])
				.expectChange("age", ["50", "70", "77"]);

			// code under test
			oListBinding.setAggregation({search : "covfefe"});

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {},
				group : {},
				groupLevels : [],
				search : "covfefe"
			}, "JIRA: CPOUI5ODATAV4-1825");

			// code under test
			oMeasureRangePromise
				= oListBinding.updateAnalyticalInfo(aAggregation).measureRangePromise;

			// code under test
			oListBinding.resume();

			return Promise.all([oMeasureRangePromise, that.waitForChanges(assert)]);
		}).then(function (aResults) {
			var mMeasureRange = aResults[0];

			assert.deepEqual(mMeasureRange, {
				AGE : {
					max : 77,
					min : 42
				}
			});

			// code under test
			assert.deepEqual(oListBinding.getAggregation(), {
				aggregate : {
					AGE : {
						max : true,
						min : true
					}
				},
				group : {
					Name : {}
				},
				groupLevels : [],
				search : "covfefe"
			}, "JIRA: CPOUI5ODATAV4-1825");
		});
	});

	//*********************************************************************************************
	// Scenario: bindElement is called twice for the items aggregation of a sap.m.Table.
	// ManagedObject#bindObject (which is the same as #bindElement) first unbinds and then binds
	// the element again if an element binding exists. The second bindElement on "unbind" calls
	// ODLB#getContexts which must reset the previous data needed for ECD so that the diff is
	// properly computed.
	// BCP 1870081505
	QUnit.test("bindElement called twice on table", function (assert) {
		var fnRespond,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			// Note: table must be "growing" otherwise it does not use ECD
			sView = '\
<Table id="table" items="{TEAM_2_EMPLOYEES}" growing="true">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectChange("name", []);

		return this.createView(assert, sView, oModel).then(function () {
			// Here it is essential that createView renders the table, as
			// GrowingEnablement#updateItems only performs ECD if the associated control's method
			// getItemsContainerDomRef returns a truthy value
			oTable = that.oView.byId("table");
			that.expectRequest("TEAMS('TEAM_01')?$select=Team_Id"
					+ "&$expand=TEAM_2_EMPLOYEES($select=ID,Name)", {
					Team_Id : "TEAM_01",
					TEAM_2_EMPLOYEES : [{
						ID : "3",
						Name : "Jonathan Smith"
					}]
				})
				.expectChange("name", ["Jonathan Smith"]);

			// code under test
			oTable.bindElement("/TEAMS('TEAM_01')");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("TEAMS('TEAM_01')?$select=Team_Id"
					+ "&$expand=TEAM_2_EMPLOYEES($select=ID,Name)", new Promise(function (resolve) {
					fnRespond = resolve.bind(null, {
						Team_Id : "TEAM_01",
						TEAM_2_EMPLOYEES : [{
							ID : "3",
							Name : "Jonathan Smith"
						}]
					});
				}));

			// code under test
			oTable.bindElement("/TEAMS('TEAM_01')");

			return that.waitForChanges(assert, "request");
		}).then(function () {
			assert.strictEqual(oTable.getItems().length, 0, "All gone");

			that.expectChange("name", ["Jonathan Smith"]);

			fnRespond();

			return that.waitForChanges(assert, "response");
		}).then(function () {
			assert.strictEqual(oTable.getItems().length, 1, "The one entry is displayed again");
		});
	});

	//*********************************************************************************************
	// Scenario: ManagedObject#setParent is called on a table to remove and add a parent. This
	// causes the list binding to be recreated. No diff must be used in order to avoid duplicate
	// data.
	// BCP: 2380130744
	QUnit.test("BCP: 2380130744", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		// Note: table must be "growing" otherwise it does not use ECD
		const sView = `
<FlexBox id="form">
	<Table id="table" items="{/EMPLOYEES}" growing="true">
		<Text id="name" text="{Name}"/>
	</Table>
</FlexBox>`;

		this.expectRequest("EMPLOYEES?$select=ID,Name&$skip=0&$top=20", {
				value : [{
					ID : "3",
					Name : "Jonathan Smith"
				}]
			})
			.expectChange("name", ["Jonathan Smith"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");

		// code under test
		oTable.setParent(null);

		await this.waitForChanges(assert, "remove parent");

		assert.strictEqual(oTable.getBinding("items"), undefined);
		assert.strictEqual(oTable.getItems().length, 1);
		assert.strictEqual(oTable.getItems()[0].getCells()[0].getText(), "Jonathan Smith",
			"still there!");

		this.expectRequest("EMPLOYEES?$select=ID,Name&$skip=0&$top=20", {
				value : [{
					ID : "2",
					Name : "Frederic Fall"
				}]
			})
			.expectChange("name", ["Frederic Fall"]);

		// code under test
		oTable.setParent(this.oView.byId("form"));

		await this.waitForChanges(assert, "restore parent");

		checkTable("after restore parent", assert, oTable, ["/EMPLOYEES('2')"], [
			["Frederic Fall"]
		]);
	});

	//*********************************************************************************************
	// Scenario: Update a property via a control and check that the control contains the value
	// afterwards. Reason: ManagedObject#updateModelProperty fetches the updated model value and
	// sets it in the control after setting it in the model. ODataPropertyBinding#setValue must not
	// become asynchronous in this case; otherwise the control gets the old value.
	//
	// We need two text fields: The one used to observe change events cannot be used for setText
	// because our test framework attaches a formatter.
	QUnit.test("Update model property via control", function (assert) {
		var oModel = this.createTeaBusiModel(),
			sView = '\
<FlexBox binding="{/TEAMS(\'1\')}" id="form">\
	<Text id="Team_Id" text="{Team_Id}"/>\
	<Text id="Name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('1')", {
				Team_Id : "1",
				Name : "Old Name"
			})
			.expectChange("Team_Id", "1");

		return this.createView(assert, sView, oModel).then(function () {
			var oText = that.oView.byId("Name");

			that.expectRequest({
					method : "PATCH",
					url : "TEAMS('1')",
					payload : {Name : "New Name"}
				}, {
					Team_Id : "1",
					Name : "New Name"
				});

			oText.setText("New Name");
			assert.strictEqual(oText.getText(), "New Name");
		});
	});

	//*********************************************************************************************
	// Scenario: Object page bound to active entity: Call the "Edit" bound action on an active
	// entity which responds with the inactive entity. The invoke for the "Edit" operation binding
	// resolves with the context for the inactive entity. Data for the inactive entity is displayed
	// when setting this context on the object page. It can be edited and side effects can be
	// requested. The controls on the object page bound to the return value context are cleared when
	// the return value context is destroyed by e.g. resetting the context of the operation binding.
	// The second test uses a bound function instead of an action to check that the different
	// access to the cache also works.
	// JIRA: CPOUI5UISERVICESV3-1193
	[{
		operation : "EditAction",
		method : "POST"
	}, {
		operation : "GetDraft",
		method : "GET"
	}].forEach(function (oFixture, i) {
		QUnit.test("bound operation: invoke resolves with V4 context, " + i, function (assert) {
			var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
				oOperation,
				sRequestPath = "Artists(ArtistID='42',IsActiveEntity=true)/special.cases."
					+ oFixture.operation + (oFixture.method === "GET" ? "()" : ""),
				sView = '\
<FlexBox id="objectPage">\
	<Text id="city" text="{Address/City}"/>\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActive" text="{IsActiveEntity}"/>\
	<Input id="name" value="{Name}"/>\
</FlexBox>',
				that = this;

			this.expectChange("city")
				.expectChange("id")
				.expectChange("isActive")
				.expectChange("name");

			return this.createView(assert, sView, oModel).then(function () {
				that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
						+ "?$select=Address/City,ArtistID,IsActiveEntity,Name", {
						Address : {City : "Liverpool"},
						ArtistID : "42",
						IsActiveEntity : true,
						Name : "Hour Frustrated"
					})
					.expectChange("city", "Liverpool")
					.expectChange("id", "42")
					.expectChange("isActive", "Yes")
					.expectChange("name", "Hour Frustrated");

				that.oView.setBindingContext(
					oModel.bindContext("/Artists(ArtistID='42',IsActiveEntity=true)")
						.getBoundContext());

				return that.waitForChanges(assert);
			}).then(function () {
				oOperation = that.oModel.bindContext("special.cases." + oFixture.operation
					+ "(...)", that.oView.getBindingContext(), {
						$select : "Address/City,ArtistID,IsActiveEntity,Name,Messages"
					});

				that.expectRequest({
					method : oFixture.method,
					url : sRequestPath
						+ "?$select=Address/City,ArtistID,IsActiveEntity,Messages,Name",
					payload : oFixture.method === "GET" ? undefined : {}
				}, {
					Address : {City : "Liverpool"},
					ArtistID : "42",
					IsActiveEntity : false,
					Name : "Hour Frustrated",
					Messages : [{
						code : "23",
						message : "Just A Message",
						numericSeverity : 1,
						target : "Name",
						transition : true
					}]
				})
				.expectMessages([{
					code : "23",
					message : "Just A Message",
					persistent : true,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
					type : "Success"
				}]);

				// code under test
				return Promise.all([
					oOperation.invoke(),
					that.waitForChanges(assert)
				]);
			}).then(function (aPromiseResults) {
				var oInactiveArtistContext = aPromiseResults[0];

				that.expectChange("isActive", "No");

				that.oView.byId("objectPage").setBindingContext(oInactiveArtistContext);

				return that.waitForChanges(assert);
			}).then(function () {
				return that.checkValueState(assert, "name", "Success", "Just A Message");
			}).then(function () {
				that.expectRequest({
						method : "PATCH",
						url : "Artists(ArtistID='42',IsActiveEntity=false)",
						payload : {Name : "foo"}
					}, {Name : "foo"})
					.expectChange("name", "foo");

				// code under test: editing values is possible on the returned entity
				that.oView.byId("name").getBinding("value").setValue("foo");

				return that.waitForChanges(assert);
			}).then(function () {
				var oInactiveArtistContext = that.oView.byId("objectPage").getBindingContext();

				that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)"
						+ "?$select=Address/City,Name", {
						Address : {City : "London"},
						Name : "bar" // unrealistic side effect
					})
					.expectChange("city", "London")
					.expectChange("name", "bar");

				return Promise.all([
					// code under test
					oInactiveArtistContext.requestSideEffects(["Address/City", "Name"]),
					that.waitForChanges(assert)
				]);
			}).then(function () {
				that.expectChange("city", null)
					.expectChange("id", null)
					.expectChange("isActive", null)
					.expectChange("name", null);

				// code under test: destroy return value context
				oOperation.setContext(undefined);

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Object page bound to active entity: Call the "Edit" bound action on an active
	// entity which responds with the inactive entity. The invoke for the "Edit" operation binding
	// resolves with the context for the inactive entity. Data for the inactive entity is displayed
	// when setting this context on the object page. Then call the "Activate" bound action to switch
	// back to the active entity. The actions are part of the form.
	// The object page has two starting points: Either it is started for a row of a list page and
	// gets the row context, or it is started with a 'deep link' and gets the canonical path of an
	// entity as string. Both variants are shown in the test, the list scenario with key '42' and
	// the 'deep link' scenario with key '23'.
	// CPOUI5UISERVICESV3-1712
	// When creating an operation context for the Edit or Activation action, we always use
	// oObjectPage.getBindingContext() for the binding parameter and use
	// oObjectPage.setBindingContext(oReturnValueContext) to set the object page to the action's
	// result. By this we achieve that a subsequent action always gets the return value context of
	// the preceding action as binding parameter. This avoids that setting the RVC at the object
	// page creates a circular dependency which would result in its destruction.
	// There are three variants:
	// 1. The one originally recommended to FE. The object page has a fixed hidden binding with
	//    empty path performing the requests. It either gets the list's row context or a context
	//    created via oModel.createBindingContext() for the 'deep link' scenario as parent.
	// 2. Avoid this hidden binding when starting with the list. The list data is then also used for
	//    the object page, enriched by a late property request. For the 'deep link' a hidden,
	//    absolute binding is created as a starting point.
	// 3. Flexible Column Layout: Keep the row context alive and always update it via
	//    Context#replaceWith. For the 'deep link' this also uses the absolute, hidden binding.
	// CPOUI5ODATAV4-764
[
	{hiddenBinding : true, title : "relative hidden binding"},
	{title : "use row context directly; absolute hidden binding for 'deep links'"},
	{keepAlive : true, title : "use kept-alive context and replace in list"}
].forEach(function (oFixture) {
	var sTitle = "bound operation: switching between active and inactive entity, " + oFixture.title;

	QUnit.test(sTitle, function (assert) {
		var oHiddenBinding, // to be kept in the controller
			oPublications,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			mNames = {
				"23" : "The Rolling Stones",
				"42" : "The Beatles"
			},
			mPrices = {
				"23" : "12.99",
				"42" : "9.99"
			},
			oObjectPage,
			oRowContext,
			sView = '\
<Table id="table" items="{path : \'/Artists\', \
		parameters : {$filter : \'IsActiveEntity\', $$patchWithoutSideEffects : true}}">\
	<Text id="listId" text="{ArtistID}"/>\
	<Text id="listIsActive" text="{IsActiveEntity}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActive" text="{IsActiveEntity}"/>\
	<Input id="name" value="{Name}"/>\
	<Table id="publication" items="{path : \'_Publication\', parameters : {$$ownRequest : true}}">\
		<Input id="price" value="{Price}"/>\
	</Table>\
</FlexBox>',
			that = this;

		function expectArtistRequest(sId, bIsActive) {
			that.expectRequest("Artists(ArtistID='" + sId + "',IsActiveEntity=" + bIsActive
					+ ")?$select=ArtistID,IsActiveEntity,Name", {
					ArtistID : sId,
					IsActiveEntity : bIsActive,
					Name : mNames[sId]
				})
				.expectChange("id", sId)
				.expectChange("isActive", bIsActive ? "Yes" : "No")
				.expectChange("name", mNames[sId]);
		}

		function expectPublicationRequest(sId, bIsActive, bAlreadyCached) {
			if (!bAlreadyCached) {
				that.expectRequest("Artists(ArtistID='" + sId + "',IsActiveEntity=" + bIsActive
						+ ")/_Publication?$select=Price,PublicationID&$skip=0&$top=100", {
						value : [{
							Price : mPrices[sId],
							PublicationID : "42-0"
						}]
					});
			}
			that.expectChange("price", [mPrices[sId]]);
		}

		/*
		 * Fires the given action on the given entity, set the object page to its return value
		 * context and wait for the expected changes.
		 *
		 * @param {string} sAction - The name of the action
		 * @param {string} sId - The artist ID
		 * @param {string} [sName] - The resulting artist's name if it differs from the default
		 * @returns {Promise} - A promise that waits for the expected changes
		 */
		function action(sAction, sId, sName) {
			var bIsActive = sAction === "ActivationAction", // The resulting artist's bIsActive
				// TODO The object page's parent context may be the return value context of the
				//   previous operation. By using it as parent for the new operation we build a long
				//   chain of bindings that we never release as long as we switch between draft and
				//   active entity. -> CPOUI5UISERVICESV3-1746
				oEntityContext = oObjectPage.getBindingContext(),
				oAction = that.oModel.bindContext("special.cases." + sAction + "(...)",
					oEntityContext, {$$inheritExpandSelect : true}),
				bReplaceWithRVC = sId === "42" && oFixture.keepAlive;

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='" + sId + "',IsActiveEntity=" + !bIsActive
						+ ")/special.cases." + sAction + "?$select=ArtistID,IsActiveEntity,Name",
					payload : {}
				}, {
					ArtistID : sId,
					IsActiveEntity : bIsActive,
					Name : sName || mNames[sId]
				});
			if (bReplaceWithRVC) {
				that.expectChange("listIsActive", [bIsActive ? "Yes" : "No"]);
			}

			// code under test
			return Promise.all([
				oAction.invoke(undefined, undefined, undefined, bReplaceWithRVC),
				that.waitForChanges(assert)
			]).then(function (aPromiseResults) {
				var oContext = aPromiseResults[0]; // the return value context

				that.expectChange("isActive", bIsActive ? "Yes" : "No");
				expectPublicationRequest(sId, bIsActive);

				return bindObjectPage(oContext, false);
			});
		}

		/*
		 * Binds the object page. A return value context directly becomes the binding context of the
		 * object page. Everything else becomes the parent context of the hidden binding, which
		 * itself becomes the parent binding of the object page.
		 *
		 * @param {string|sap.ui.model.odata.v4.Context} vSource
		 *   The source, either a path or a list context or a return value context
		 * @param {boolean} bUseHiddenBinding
		 *   Whether to use the hidden binding as intermediate binding
		 * @returns {Promise}
		 *   A promise that waits for the expected changes
		 */
		function bindObjectPage(vSource, bUseHiddenBinding) {
			var oBinding,
				oContext = vSource;

			if (typeof vSource === "string") {
				if (oFixture.hiddenBinding) {
					oHiddenBinding.setContext(that.oModel.createBindingContext(vSource));
					oBinding = oHiddenBinding;
				} else {
					// create an absolute binding for that path
					oBinding = that.oModel.bindContext(vSource, undefined,
						{$$patchWithoutSideEffects : true});
				}
				oContext = oBinding.getBoundContext();
			} else if (bUseHiddenBinding) {
				oHiddenBinding.setContext(oContext);
				oContext = oHiddenBinding.getBoundContext();
			}
			oObjectPage.setBindingContext(oContext);

			if (vSource) {
				assert.ok(oObjectPage.getBindingContext().getBinding().isPatchWithoutSideEffects(),
					"Object page has $$patchWithoutSideEffects");
			}
			return that.waitForChanges(assert, "bind object page to " + oContext);
		}

		// start here :-)
		this.expectRequest("Artists?$filter=IsActiveEntity&$select=ArtistID,IsActiveEntity"
				+ "&$skip=0&$top=100", {
				value : [{ArtistID : "42", IsActiveEntity : true}]
			})
			.expectChange("listId", ["42"])
			.expectChange("listIsActive", ["Yes"])
			.expectChange("id")
			.expectChange("isActive")
			.expectChange("name")
			.expectChange("price", []);

		return this.createView(assert, sView, oModel).then(function () {
			oObjectPage = that.oView.byId("objectPage"); // just to keep the test shorter
			oPublications = that.oView.byId("publication").getBinding("items");
			if (oFixture.hiddenBinding) {
				// create the hidden binding when creating the controller
				oHiddenBinding = that.oModel.bindContext("", undefined,
					{$$patchWithoutSideEffects : true});
				expectArtistRequest("42", true);
			} else {
				that.expectChange("id", "42")
					.expectChange("isActive", "Yes")
					// late property request for the name
					.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=Name",
						{Name : "The Beatles"})
					.expectChange("name", "The Beatles");
			}
			expectPublicationRequest("42", true);

			// first start with the list
			oRowContext = that.oView.byId("table").getItems()[0].getBindingContext();
			oRowContext.setKeepAlive(oFixture.keepAlive);
			return bindObjectPage(oRowContext, oFixture.hiddenBinding);
		}).then(function () {
			return action("EditAction", "42");
		}).then(function () {
			// BCP 2170181227: Check that dependent bindings of an operation are also resumed if the
			// root binding is resumed.
			var oRootBinding = oHiddenBinding
					? oHiddenBinding.getRootBinding()
					: that.oView.byId("table").getBinding("items");

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)/_Publication"
				+ "?$select=Price,PublicationID&$filter=Price gt 8&$skip=0&$top=100", {
					value : [{
						Price : "8.88",
						PublicationID : "42-0"
					}]
				})
				.expectChange("price", ["8.88"]);

			// code under test
			oRootBinding.suspend();
			oPublications.filter(new Filter("Price", FilterOperator.GT, "8"));
			oRootBinding.resume();

			return that.waitForChanges(assert, "BCP: 2170181227");
		}).then(function () {
			expectPublicationRequest("42", false);

			// reset filter in order to continue with the next .then(...)
			oPublications.filter();

			return that.waitForChanges(assert, "BCP: 2170181227, reset filter");
		}).then(function () {
			that.expectChange("name", "The Beatles (modified)")
				.expectRequest({
					headers : {Prefer : "return=minimal"},
					method : "PATCH",
					url : "Artists(ArtistID='42',IsActiveEntity=false)",
					payload : {Name : "The Beatles (modified)"}
				}); // 204 No Content

			that.oView.byId("name").getBinding("value").setValue("The Beatles (modified)");
			return that.waitForChanges(assert, "PATCH");
		}).then(function () {
			return action("ActivationAction", "42", "The Beatles (modified)");
		}).then(function () {
			expectArtistRequest("23", false);
			expectPublicationRequest("23", false);

			// now start directly with the entity
			return bindObjectPage("/Artists(ArtistID='23',IsActiveEntity=false)");
		}).then(function () {
			return action("ActivationAction", "23");
		}).then(function () {
			return action("EditAction", "23");
		}).then(function () {
			var oRowContext;

			that.expectChange("id", "42")
				.expectChange("isActive", "Yes")
				.expectChange("name",
						oFixture.keepAlive ? "The Beatles (modified)" : "The Beatles");
			expectPublicationRequest("42", true, true);

			// Now return to the artist from the list.
			// There is no request; the caches are reused.
			oRowContext = that.oView.byId("table").getItems()[0].getBindingContext();
			return bindObjectPage(oRowContext, oFixture.hiddenBinding);
		}).then(function () {
			// clear the object page
			that.expectChange("id", null)
				.expectChange("isActive", null)
				.expectChange("name", null);

			return bindObjectPage(null, false);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Fiori Elements Safeguard - Test 1 (Edit/Activate)
	// Test the following scenario twice with:
	// a) a row context (sap.ui.model.odata.v4.Context) of an OData V4 list binding and
	// b) a base context (sap.ui.model.Context):
	// 1. Show the active version of an entity by using the given context
	// 2. Within the binding hierarchy of the object page use a hidden binding with its own binding
	//   parameters $$patchWithoutSideEffects=true and $select=Messages to request messages.
	//   The hidden binding is a binding that is independent of the object page. Before calling
	//   the edit action, its cache stores the Artist data and the $select query option is
	//   determined for this binding. The first call of the edit action is relative to the hidden
	//   binding's bound context. Hence the operation can request the necessary selection of the
	//   Artist data using $$inheritExpandSelect. This data is then available within the return
	//   value context which serves as a binding context of the object page and as the parent
	//   context for the following activate action.
	// 3. Create an edit action with $$inheritExpandSelect=true to select all properties used in
	//   the object page. Call the action and bind the object page to the return value context.
	// 4a. Patch the inactive entity to see that $$patchWithoutSideEffects works.
	//   4b. Patch a property reachable via a navigation property (BCP: 2070137560)
	//   4c. Try to patch a property via the wrong context (not the return value context)
	//      (BCP: 2070137560)
	// 5. Show the creation row of a creation row binding (a binding that does not request data,
	//   must not be refreshed) which is relative to the return value context of the inactive
	//   version.
	// 6. Request side effects for the return value context of the inactive version to see that the
	//   creation row is untouched.
	// 7. Switch back to the active version.
	// CPOUI5ODATAV4-189
[function () {
	return this.oView.byId("table").getItems()[0].getBindingContext();
}, function () {
	return this.oModel.createBindingContext("/Artists(ArtistID='42',IsActiveEntity=true)");
}].forEach(function (fnGetParentContext, i) {
	var sTitle = "Fiori Elements Safeguard: Test 1 (Edit/Activate) " + (i ? "base" : "row")
		+ " context";

	QUnit.test(sTitle, function (assert) {
		var oCreationRow,
			oCreationRowContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oObjectPage,
			oReturnValueContext,
			sTable = '\
<Table id="table" items="{/Artists}">\
	<Text id="listId" text="{ArtistID}"/>\
</Table>',
			sView = '\
<FlexBox id="objectPage">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActive" text="{IsActiveEntity}"/>\
	<Input id="name" value="{Name}"/>\
	<Input id="bestFriend" value="{BestFriend/Name}"/>\
	<FlexBox id="creationRow">\
		<Text id="price" text="{Price}"/>\
		<Text id="artistName" text="{_Artist/Name}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		/*
		 * Invokes the given action (ActivationAction or EditAction) on Artist ID 42.
		 * Sets the object page to its return value context and waits for the expected changes.
		 *
		 * @param {string} sAction - The name of the action
		 * @returns {Promise} - A promise that waits for the expected changes
		 */
		function action(sAction) {
			var bIsActive = sAction === "ActivationAction", // The resulting artist's bIsActive
				oEntityContext = oObjectPage.getBindingContext(),
				oAction = that.oModel.bindContext("special.cases." + sAction + "(...)",
					oEntityContext, {$$inheritExpandSelect : true});

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='42',IsActiveEntity=" + !bIsActive
						+ ")/special.cases." + sAction
						+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
						+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)",
					payload : {}
				}, {
					ArtistID : "42",
					BestFriend : {
						ArtistID : "23",
						IsActiveEntity : true,
						Name : bIsActive ? "Sgt. Pepper (modified)" : "Sgt. Pepper"
					},
					IsActiveEntity : bIsActive,
					Name : "The Beatles"
				});

			return Promise.all([
				// code under test
				oAction.invoke(),
				that.waitForChanges(assert)
			]).then(function (aPromiseResults) {
				oReturnValueContext = aPromiseResults[0];
				that.expectChange("isActive", bIsActive ? "Yes" : "No");

				// code under test
				oObjectPage.setBindingContext(oReturnValueContext);

				return that.waitForChanges(assert);
			});
		}

		// Note: table is only needed for the first test with the row context
		if (!i) {
			sView = sTable + sView;
			this.expectRequest("Artists?$select=ArtistID,IsActiveEntity"
					+ "&$skip=0&$top=100", {
					value : [{ArtistID : "42", IsActiveEntity : true}]
				})
				.expectChange("listId", ["42"]);
		}

		this.expectChange("id")
			.expectChange("isActive")
			.expectChange("name")
			.expectChange("bestFriend")
			.expectChange("artistName")
			.expectChange("price");

		return this.createView(assert, sView, oModel).then(function () {
			var oHiddenBinding;
			// 1. Start with the given context and show it within the object page

			// 2. Within the controller code create the hidden binding
			oHiddenBinding = that.oModel.bindContext("", fnGetParentContext.call(that),
					{$$patchWithoutSideEffects : true, $select : "Messages"});

			oObjectPage = that.oView.byId("objectPage");
			oCreationRow = that.oView.byId("creationRow");

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)", {
					ArtistID : "42",
					BestFriend : {
						ArtistID : "23",
						IsActiveEntity : true,
						Name : "Sgt. Pepper"
					},
					IsActiveEntity : true,
					Name : "The Beatles"
				})
				.expectChange("id", "42")
				.expectChange("isActive", "Yes")
				.expectChange("name", "The Beatles")
				.expectChange("bestFriend", "Sgt. Pepper");

			// set binding context for creationRow to "null" to skip inheriting the binding context
			oCreationRow.setBindingContext(null);

			oObjectPage.setBindingContext(oHiddenBinding.getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			// 3. switch to the edit mode and show the inactive version
			return action("EditAction");
		}).then(function () {
			// 4a. Patch the inactive entity to see that $$patchWithoutSideEffects works.

			that.expectChange("name", "The Beatles (modified)")
				.expectRequest({
					headers : {Prefer : "return=minimal"},
					method : "PATCH",
					url : "Artists(ArtistID='42',IsActiveEntity=false)",
					payload : {Name : "The Beatles (modified)"}
				}, {
					ArtistID : "42",
					IsActiveEntity : false,
					Name : "$$patchWithoutSideEffects ignores this"
				});

			that.oView.byId("name").getBinding("value").setValue("The Beatles (modified)");

			return that.waitForChanges(assert);
		}).then(function () {
			// 4b. Patch a property reachable via a navigation property

			that.expectChange("bestFriend", "Sgt. Pepper (modified)")
				.expectRequest({
					headers : {Prefer : "return=minimal"},
					method : "PATCH",
					url : "Artists(ArtistID='23',IsActiveEntity=true)",
					payload : {Name : "Sgt. Pepper (modified)"}
				}); // 204 No Content

			that.oView.byId("bestFriend").getBinding("value").setValue("Sgt. Pepper (modified)");

			return that.waitForChanges(assert);
		}).then(function () {
			// 4c. Patching a property via the wrong context must not succeed
			// We're not interested in the exact errors, only in some failure
			that.oLogMock.expects("error").twice();

			return oReturnValueContext.getBinding().getBoundContext()
				.setProperty("BestFriend/Name", "n/a")
				.then(mustFail(assert), function () {
					// expect one message and remove it again
					assert.strictEqual(Messaging.getMessageModel().getObject("/").length, 1);
					Messaging.removeAllMessages();

					assert.strictEqual(oReturnValueContext.getProperty("BestFriend/Name"),
						"Sgt. Pepper (modified)");
				});
		}).then(function () {
			// 5. Show the creation row of a creation row binding [...]

			oCreationRowContext = that.oModel.bindList("_Publication", oReturnValueContext,
				undefined, undefined, {$$updateGroupId : "doNotSubmit"}).create();
			oCreationRowContext.setProperty("Price", "47"); // BCP: 2270087626

			that.expectChange("price", "47")
				.expectChange("artistName", "The Beatles (modified)");

			oCreationRow.setBindingContext(oCreationRowContext);

			return that.waitForChanges(assert);
		}).then(function () {
			// 6. Request side effects for the return value context of the inactive version to see
			// that the creation row is untouched.

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Messages,Name", {
					ArtistID : "42",
					IsActiveEntity : false,
					Name : "The Beatles"
				})
				.expectChange("name", "The Beatles")
				.expectChange("artistName", "The Beatles");

			return Promise.all([
				oReturnValueContext.requestSideEffects(["*", "_Publication"]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// Delete creation row context before switching back to the active version

			that.expectChange("price", null)
				.expectChange("artistName", null);

			return Promise.all([
				// handle cancellation caused by .delete()
				checkCanceled(assert, oCreationRowContext.created()),
				oCreationRowContext.delete(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// 7. Switch back to active version
			return action("ActivationAction");
		});
	});
});

	//*********************************************************************************************
	// Scenario: Fiori Elements Safeguard - Test 2 (Create)
	// 1. Call create action bound to collection with $select for Messages,
	//    $$patchWithoutSideEffects but w/o $$inheritExpandSelect because nothing can be
	//    inherited.
	// 2. Bind object page to the return value context of the create action and see that structural
	//    properties and properties via navigation properties are fetched as late properties.
	// 3. Show the creation row of a creation row binding (a binding that does not request data,
	//    is not be refreshed) which is relative to the return value context of the inactive
	//    version.
	// 4. Request side effects for the return value context of the inactive version to see that the
	//    creation row is untouched.
	// 5. Switch back to active version. (CPOUI5ODATAV4-711)
	// 6. Refresh active version. (CPOUI5ODATAV4-711)
	//
	// JIRA: CPOUI5ODATAV4-189
	QUnit.test("Fiori Elements Safeguard: Test 2 (Create)", function (assert) {
		var oCreationRowContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oReturnValueContext,
			sView = '\
<FlexBox id="objectPage">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActive" text="{IsActiveEntity}"/>\
	<Text id="name" text="{Name}"/>\
	<FlexBox id="bestFriend" binding="{BestFriend}">\
		<Text id="bestFriendName" text="{Name}"/>\
	</FlexBox>\
	<FlexBox id="creationRow">\
		<Text id="price" text="{Price}"/>\
		<Text id="artistName" text="{_Artist/Name}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectChange("id")
			.expectChange("isActive")
			.expectChange("name")
			.expectChange("bestFriendName")
			.expectChange("price")
			.expectChange("artistName");

		return this.createView(assert, sView, oModel).then(function () {
			// 1. Call create action bound to collection
			var oOperationBinding = oModel.bindContext("special.cases.Create(...)",
					oModel.bindList("/Artists").getHeaderContext(),
					{$$patchWithoutSideEffects : true, $select : "Messages"});

			that.expectRequest({
					method : "POST",
					payload : {},
					url : "Artists/special.cases.Create?$select=Messages"
				}, {
					ArtistID : "23",
					IsActiveEntity : false,
					Messages : []
				});

			return oOperationBinding.invoke();
		}).then(function (oReturnValueContext0) {
			// 2. Bind object page to the return value context of the create action
			oReturnValueContext = oReturnValueContext0;

			// two late property requests (one had only a $expand, so BestFriend is selected too)
			that.expectRequest("Artists(ArtistID='23',IsActiveEntity=false)"
					+ "?$select=Name&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)", {
					Name : "DJ Bobo",
					BestFriend : {
						ArtistID : "32",
						IsActiveEntity : true,
						Name : "Robin Schulz"
					}
				})
				.expectChange("id", "23")
				.expectChange("isActive", "No")
				.expectChange("name", "DJ Bobo")
				.expectChange("bestFriendName", "Robin Schulz");

			// set binding context for creationRow to "null" to skip inheriting the binding context
			that.oView.byId("creationRow").setBindingContext(null);
			that.oView.byId("objectPage").setBindingContext(oReturnValueContext);

			return that.waitForChanges(assert);
		}).then(function () {
			// 2a. Refresh the RVC, expect one request
			that.expectRequest("Artists(ArtistID='23',IsActiveEntity=false)"
				+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)", {
				ArtistID : "23",
				IsActiveEntity : false,
				Messages : [],
				Name : "DJ Bobo",
				BestFriend : {
					ArtistID : "32",
					IsActiveEntity : true,
					Name : "Robin Schulz"
				}
			});

			return Promise.all([
				// code under test
				oReturnValueContext.requestRefresh(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// 3. Show the creation row of a creation row binding
			oCreationRowContext = that.oModel.bindList("_Publication", oReturnValueContext,
				undefined, undefined, {$$updateGroupId : "doNotSubmit"}).create({Price : "47"});

			that.expectChange("price", "47");
			that.expectChange("artistName", "DJ Bobo");

			that.oView.byId("creationRow").setBindingContext(oCreationRowContext);

			return that.waitForChanges(assert);
		}).then(function () {
			// 4. Request side effects for the return value context of the inactive version to see
			// that the creation row is untouched
			that.expectRequest("Artists(ArtistID='23',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)", {
					ArtistID : "23",
					IsActiveEntity : false,
					Messages : [],
					Name : "DJ Bobo",
					BestFriend : {
						ArtistID : "32",
						IsActiveEntity : true,
						Name : "Robin Schulz"
					}
				});

			return Promise.all([
				oReturnValueContext.requestSideEffects(["*", "BestFriend", "_Publication"]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// 5. Switch back to active version.
			var oAction = that.oModel.bindContext("special.cases.ActivationAction(...)",
					oReturnValueContext, {$$inheritExpandSelect : true});

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='23',IsActiveEntity=false)"
						+ "/special.cases.ActivationAction"
						+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
						+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)",
					payload : {}
				}, {
					ArtistID : "23",
					IsActiveEntity : true,
					Messages : [],
					Name : "DJ Bobo",
					BestFriend : {
						ArtistID : "32",
						IsActiveEntity : true,
						Name : "Robin Schulz"
					}
				});

			return Promise.all([
				// code under test
				oAction.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aPromiseResults) {
			oReturnValueContext = aPromiseResults[0];

			// no late properties request because the late properties were inherited
			that.expectChange("isActive", "Yes");

			// code under test
			that.oView.byId("objectPage").setBindingContext(oReturnValueContext);

			return that.waitForChanges(assert);
		}).then(function () {
			// 6. Refresh active version.
			that.expectRequest("Artists(ArtistID='23',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)", {
					ArtistID : "23",
					IsActiveEntity : true,
					Messages : [],
					Name : "DJ Bobo",
					BestFriend : {
						ArtistID : "32",
						IsActiveEntity : true,
						Name : "Robin Schulz"
					}
				});

			return Promise.all([
				// code under test
				oReturnValueContext.requestRefresh(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: An object page is rebound to the same entity. In the page there is a list of
	// dependent items containing a back link to the entity via partner attributes. It must be
	// ensured that this path is re-added to the parent's $select, even though the corresponding
	// property bindings are not recreated and do not get a different context. If the list is empty,
	// there even is no such property binding.
	// JIRA: CPOUI5ODATAV4-848
	// BCP: 2180125559
	// Add a sub-object page with a late property. Ensure that the property is still known and late
	// after the rebind.
	// JIRA: CPOUI5ODATAV4-936
	QUnit.test("BCP: 2180125559", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oObjectPage,
			sView = '\
<FlexBox id="objectPage">\
	<Text id="name" text="{Name}"/>\
	<Table id="table" growing="true" growingThreshold="5" items="{\
				path : \'_Publication\',\
				parameters : {$$ownRequest : true}\
			}">\
		<Text id="price" text="{Price}"/>\
		<Text id="channel" text="{_Artist/defaultChannel}"/>\
	</Table>\
</FlexBox>\
<FlexBox id="subObjectPage">\
	<Text id="currency" text="{CurrencyCode}"/>\
</FlexBox>',
			that = this;

		this.expectChange("name")
			.expectChange("price", [])
			.expectChange("channel", [])
			.expectChange("currency");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Name,defaultChannel", {
					ArtistID : "42",
					IsActiveEntity : true,
					Name : "Hour Frustrated",
					defaultChannel : "Channel 1"
				})
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=5", {
					value : []
				})
				.expectChange("name", "Hour Frustrated");

			oObjectPage = that.oView.byId("objectPage");
			oObjectPage.setBindingContext(
				oModel.bindContext("/Artists(ArtistID='42',IsActiveEntity=true)")
					.getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Name,defaultChannel", {
					ArtistID : "42",
					IsActiveEntity : true,
					Name : "Hour Frustrated again",
					defaultChannel : "Channel 2"
				})
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=5", {
					value : [{
						Price : "9.99",
						PublicationID : "42-0"
					}]
				})
				.expectChange("name", "Hour Frustrated again")
				.expectChange("price", ["9.99"])
				.expectChange("channel", ["Channel 2"]);

			oObjectPage.setBindingContext(
				oModel.bindContext("/Artists(ArtistID='42',IsActiveEntity=true)")
					.getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			var oContext = that.oView.byId("table").getItems()[0].getBindingContext();

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication('42-0')"
					+ "?$select=CurrencyCode", {CurrencyCode : "EUR"})
				.expectChange("currency", "EUR");

			that.oView.byId("subObjectPage").setBindingContext(oContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Name,defaultChannel", {
					ArtistID : "42",
					IsActiveEntity : true,
					Name : "Hour Frustrated again and again",
					defaultChannel : "Channel 3"
				})
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=5", {
					value : [{
						Price : "10.99",
						PublicationID : "42-0"
					}]
				})
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication('42-0')"
					+ "?$select=CurrencyCode", {CurrencyCode : "USD"})
				.expectChange("name", "Hour Frustrated again and again")
				.expectChange("price", ["10.99"])
				.expectChange("channel", ["Channel 3"])
				.expectChange("currency", "USD");

			oObjectPage.setBindingContext(
				oModel.bindContext("/Artists(ArtistID='42',IsActiveEntity=true)")
					.getBoundContext());

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Object page bound to an active entity and its navigation property is $expand'ed via
	// an own request. Invoke "Edit" bound action to start editing using a return value context and
	// modify a property in the entity referenced by the navigation property. Activate the inactive
	// entity via a bound action using another return value context.
	// The elements referenced via the navigation property must not be taken from the cache.
	// See CPOUI5UISERVICESV3-1686.
	//
	// Request an absolute side effect for the table below the R.V.C. (BCP: 2380046603)
["_Publication", "/special.cases.Container/Artists/_Publication"].forEach(function (sPath) {
	var sTitle = "return value contexts: don't reuse caches if context changed; side effect path: "
			+ sPath;

	QUnit.test(sTitle, function (assert) {
		var oActiveArtistContext,
			oInactiveArtistContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oNewActiveArtistContext,
			sView = '\
<FlexBox id="objectPage">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActive" text="{IsActiveEntity}"/>\
	<Input id="name" value="{Name}"/>\
	<Table id="table" items="{\
				path : \'_Publication\',\
				parameters : {$$ownRequest : true}\
			}">\
		<Input id="price" value="{Price}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("id")
			.expectChange("isActive")
			.expectChange("name")
			.expectChange("price", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [{
						Price : "9.99",
						PublicationID : "42-0"
					}]
				})
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Name", {
					ArtistID : "42",
					IsActiveEntity : true,
					Name : "Hour Frustrated"
				})
				.expectChange("id", "42")
				.expectChange("isActive", "Yes")
				.expectChange("name", "Hour Frustrated")
				.expectChange("price", ["9.99"]);

			oActiveArtistContext = oModel.bindContext("/Artists(ArtistID='42',IsActiveEntity=true)")
				.getBoundContext();
			that.oView.setBindingContext(oActiveArtistContext);

			return that.waitForChanges(assert);
		}).then(function () {
			var oOperation = that.oModel.bindContext("special.cases.EditAction(...)",
					oActiveArtistContext, {$$inheritExpandSelect : true});

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='42',IsActiveEntity=true)/special.cases.EditAction"
						+ "?$select=ArtistID,IsActiveEntity,Name",
					payload : {}
				}, {
					ArtistID : "42",
					IsActiveEntity : false,
					Name : "Hour Frustrated"
				});

			return Promise.all([
				// code under test
				oOperation.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aPromiseResults) {
			oInactiveArtistContext = aPromiseResults[0];

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [{
						Price : "9.99",
						PublicationID : "42-0"
					}]
				})
				.expectChange("isActive", "No")
				.expectChange("price", ["9.99"]);

			that.oView.setBindingContext(oInactiveArtistContext);

			return that.waitForChanges(assert);
		}).then(function () {
			var oBinding = that.oView.byId("table").getItems()[0].getCells()[0].getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "Artists(ArtistID='42',IsActiveEntity=false)/_Publication('42-0')",
					payload : {Price : "8.88"}
				}, {
					Price : "8.88"
				})
				.expectChange("price", ["8.88"]);

			oBinding.setValue("8.88");

			return that.waitForChanges(assert);
		}).then(function () {
			// switching back to active context takes values from cache
			that.expectChange("isActive", "Yes")
				.expectChange("price", ["9.99"]);

			that.oView.setBindingContext(oActiveArtistContext);

			return that.waitForChanges(assert);
		}).then(function () {
			// switching back to inactive context takes values also from cache
			that.expectChange("isActive", "No")
				.expectChange("price", ["8.88"]);

			that.oView.setBindingContext(oInactiveArtistContext);

			return that.waitForChanges(assert);
		}).then(function () {
			var oOperation = that.oModel.bindContext("special.cases.ActivationAction(...)",
					oInactiveArtistContext, {$$inheritExpandSelect : true});

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='42',IsActiveEntity=false)"
						+ "/special.cases.ActivationAction?$select=ArtistID,IsActiveEntity,Name",
					payload : {}
				}, {
					ArtistID : "42",
					IsActiveEntity : true,
					Name : "Hour Frustrated"
				});

			return Promise.all([
				// code under test
				oOperation.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aPromiseResults) {
			oNewActiveArtistContext = aPromiseResults[0];

			// new active artist context causes dependent binding to reload data
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [{
						Price : "8.88",
						PublicationID : "42-0"
					}]
				})
				.expectChange("isActive", "Yes")
				.expectChange("price", ["8.88"]);

			that.oView.setBindingContext(oNewActiveArtistContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [{
						Price : "8.89", // side effect
						PublicationID : "42-0"
					}]
				})
				.expectChange("price", ["8.89"]);

			return Promise.all([
				oNewActiveArtistContext.requestSideEffects([sPath]),
				that.waitForChanges(assert, "side effect at R.V.C.")
			]);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [{
						Price : "8.99", // side effect
						PublicationID : "42-0"
					}]
				})
				.expectChange("price", ["8.99"]);

			return Promise.all([
				oActiveArtistContext.requestSideEffects([sPath]),
				that.waitForChanges(assert, "side effect above operation binding")
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: List and details containing a dependent table with an own request. Use
	// cached values in dependent table if user switches between entries in the list.
	// See CPOUI5UISERVICESV3-1686.
	QUnit.test("Reuse caches in dependent tables w/ own request while switching list entry",
			function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			oTableBinding,
			sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
</Table>\
<FlexBox id="form" binding="{path : \'\', parameters : {$$ownRequest : true}}">\
	<Text id="managerId" text="{EMPLOYEE_2_MANAGER/ID}"/>\
	<Table items="{path : \'EMPLOYEE_2_EQUIPMENTS\', parameters : {$$ownRequest : true}}">\
		<Text id="equipmentId" text="{ID}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID,Name&$skip=0&$top=100", {
				value : [
					{ID : "42", Name : "Jonathan Smith"},
					{ID : "43", Name : "Frederic Fall"}
				]
			})
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"])
			.expectChange("managerId")
			.expectChange("equipmentId", []);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oTableBinding = oTable.getBinding("items");

			that.expectRequest("EMPLOYEES('42')?$select=ID&$expand=EMPLOYEE_2_MANAGER($select=ID)",
				{
					ID : "42",
					EMPLOYEE_2_MANAGER : {ID : "1"}
				})
				.expectRequest("EMPLOYEES('42')/EMPLOYEE_2_EQUIPMENTS?$select=Category,ID"
					+ "&$skip=0&$top=100", {
					value : [
						{Category : "Electronics", ID : 99},
						{Category : "Electronics", ID : 98}
					]
				})
				.expectChange("managerId", "1")
				.expectChange("equipmentId", ["99", "98"]);

			// code under test
			that.oView.byId("form").setBindingContext(oTableBinding.getCurrentContexts()[0]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("EMPLOYEES('43')/EMPLOYEE_2_EQUIPMENTS?$select=Category,ID"
					+ "&$skip=0&$top=100", {
					value : [
						{Category : "Electronics", ID : 97},
						{Category : "Electronics", ID : 96}
					]
				})
				.expectRequest("EMPLOYEES('43')?$select=ID&$expand=EMPLOYEE_2_MANAGER($select=ID)",
				{
					ID : "43",
					EMPLOYEE_2_MANAGER : {ID : "2"}
				})
				.expectChange("managerId", "2")
				.expectChange("equipmentId", ["97", "96"]);

			// code under test
			that.oView.byId("form").setBindingContext(oTableBinding.getCurrentContexts()[1]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("managerId", "1")
				.expectChange("equipmentId", ["99", "98"]);

			// code under test - no request!
			that.oView.byId("form").setBindingContext(oTableBinding.getCurrentContexts()[0]);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Object page bound to active entity with a navigation property $expand'ed via
	// auto-$expand/$select. The "Edit" bound action on the active entity has the binding parameter
	// $$inheritExpandSelect set so that it invokes the POST request with the same $expand and
	// $select parameters used for loading the active entity. This way, all fields in the object
	// page can be populated from the bound action response.
	// Read side effects which include navigation properties while there are pending changes.
	// JIRA: CPOUI5UISERVICESV3-1193
	QUnit.test("bound operation: $$inheritExpandSelect", function (assert) {
		var fnDataReceived = this.spy(),
			fnDataRequested = this.spy(),
			oJustAMessage = {
				code : "23",
				message : "Just A Message",
				persistent : true,
				target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
				type : "Success"
			},
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="objectPage">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActive" text="{IsActiveEntity}"/>\
	<Input id="name" value="{Name}"/>\
	<Text id="inProcessByUser" text="{DraftAdministrativeData/InProcessByUser}"/>\
</FlexBox>',
			that = this;

		this.expectChange("id")
			.expectChange("isActive")
			.expectChange("name")
			.expectChange("inProcessByUser");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?custom=foo"
					+ "&$select=ArtistID,IsActiveEntity,Messages,Name"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)", {
					ArtistID : "42",
					DraftAdministrativeData : null,
					IsActiveEntity : true,
					Messages : [],
					Name : "Hour Frustrated"
				})
				.expectChange("id", "42")
				.expectChange("isActive", "Yes")
				.expectChange("name", "Hour Frustrated")
				.expectChange("inProcessByUser", ""); // initialization due to #setContext

			that.oView.setBindingContext(
				oModel.bindContext("/Artists(ArtistID='42',IsActiveEntity=true)", null,
						{custom : "foo", $select : "Messages"})
					.getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			var oOperation = that.oModel.bindContext("special.cases.EditAction(...)",
					that.oView.getBindingContext(), {$$inheritExpandSelect : true});

			oOperation.attachDataReceived(fnDataReceived);
			oOperation.attachDataRequested(fnDataRequested);
			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='42',IsActiveEntity=true)/special.cases.EditAction"
						+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
						+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)",
					payload : {}
				}, {
					"@odata.etag" : "ETag0",
					ArtistID : "42",
					DraftAdministrativeData : {
						DraftID : "1",
						InProcessByUser : "JOHNDOE"
					},
					IsActiveEntity : false,
					Messages : [{
						code : "23",
						message : "Just A Message",
						numericSeverity : 1,
						target : "Name",
						transition : true
					}],
					Name : "Hour Frustrated"
				})
				.expectMessages([oJustAMessage]);

			return Promise.all([
				// code under test
				oOperation.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aPromiseResults) {
			var oInactiveArtistContext = aPromiseResults[0];

			that.expectChange("isActive", "No")
				.expectChange("inProcessByUser", "JOHNDOE");

			that.oView.setBindingContext(oInactiveArtistContext);

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, "name", "Success", "Just A Message");
		}).then(function () {
			var oInactiveArtistContext = that.oView.getBindingContext();

			that.expectChange("name", "TAFKAP")
				.expectRequest({
					method : "PATCH",
					url : "Artists(ArtistID='42',IsActiveEntity=false)",
					headers : {"If-Match" : "ETag0"},
					payload : {Name : "TAFKAP"}
				}, {/* response does not matter here */});

			that.oView.byId("name").getBinding("value").setValue("TAFKAP");

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)"
					+ "?$select=DraftAdministrativeData"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)", {
					DraftAdministrativeData : {
						DraftID : "1",
						InProcessByUser : "bar"
					}
				})
				.expectChange("inProcessByUser", "bar");
				// no change in messages

			return Promise.all([
				// code under test
				oInactiveArtistContext.requestSideEffects([{
					$PropertyPath : "DraftAdministrativeData/InProcessByUser"
				}]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(fnDataReceived.callCount, 0, "no dataReceived");
			assert.strictEqual(fnDataRequested.callCount, 0, "no dataRequested");

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)", {
					ArtistID : "42",
					DraftAdministrativeData : {
						DraftID : "1",
						InProcessByUser : "JOHNDOE"
					},
					IsActiveEntity : false,
					Messages : [],
					Name : "Changed"
				})
				.expectChange("name", "Changed")
				.expectChange("inProcessByUser", "JOHNDOE");
				// no change in messages

			// code under test
			that.oView.getBindingContext().refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			var oOperation = that.oModel.bindContext("special.cases.ActivationAction(...)",
					that.oView.getBindingContext(), {$$inheritExpandSelect : true});

			assert.strictEqual(fnDataReceived.callCount, 1, "dataReceived");
			assert.strictEqual(fnDataRequested.callCount, 1, "dataRequested");
			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='42',IsActiveEntity=false)"
						+ "/special.cases.ActivationAction"
						+ "?$select=ArtistID,IsActiveEntity,Messages,Name"
						+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)",
					payload : {}
				}, {
					ArtistID : "42",
					DraftAdministrativeData : {
						DraftID : "1",
						InProcessByUser : ""
					},
					IsActiveEntity : true,
					Messages : [],
					Name : "Hour Frustrated"
				});
				// no change in messages

			return Promise.all([
				oOperation.invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: An Edm.Stream property is requested as a "late" property and then inherited by an
	// "Edit" action which replaces the active version by a draft inside the (hidden) ODLB. The
	// property itself is missing from the response, but is not again requested.
	// BCP: 2380058514
	QUnit.test("BCP: 2380058514", function (assert) {
		var oContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox>\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActive" text="{IsActiveEntity}"/>\
	<Text id="url" text="{Picture}"/>\
</FlexBox>',
			that = this;

		this.expectChange("id")
			.expectChange("isActive")
			.expectChange("url");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Picture", {
					ArtistID : "42",
					IsActiveEntity : true
					// Picture property not seen here -> "Picture@$ui5.noData" : true
					// "Picture@odata.mediaContentType" etc. intentionally left out here
				})
				.expectChange("id", "42")
				.expectChange("isActive", "Yes")
				.expectChange("url",
					"/special/cases/Artists(ArtistID='42',IsActiveEntity=true)/Picture");

			oContext = oModel.getKeepAliveContext("/Artists(ArtistID='42',IsActiveEntity=true)");
			that.oView.setBindingContext(oContext);

			return that.waitForChanges(assert);
		}).then(function () {
			var oOperation = that.oModel.bindContext("special.cases.EditAction(...)", oContext,
					{$$inheritExpandSelect : true});

			assert.deepEqual(oContext.getObject(), {
				ArtistID : "42",
				IsActiveEntity : true,
				"Picture@$ui5.noData" : true
			});

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='42',IsActiveEntity=true)/special.cases.EditAction"
						+ "?$select=ArtistID,IsActiveEntity,Picture",
					payload : {}
				}, {
					ArtistID : "42",
					IsActiveEntity : false
					// Picture property not seen here -> "Picture@$ui5.noData" : true
					// "Picture@odata.mediaContentType" etc. intentionally left out here
				});

			return Promise.all([
				// code under test
				oOperation.invoke(undefined, false, null, /*bReplaceWithRVC*/true),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			assert.deepEqual(aResults[0].getObject(), {
				ArtistID : "42",
				IsActiveEntity : false,
				"Picture@$ui5.noData" : true
			});

			that.expectChange("isActive", "No")
				.expectChange("url",
					"/special/cases/Artists(ArtistID='42',IsActiveEntity=false)/Picture");

			that.oView.setBindingContext(aResults[0]);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Call an action which returns the binding parameter as return value. Expect that
	// the result is copied back to the binding parameter.
	// JIRA: CPOUI5UISERVICESV3-523
	QUnit.test("bound operation: copy result into context", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/SalesOrderList(\'42\')}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="LifecycleStatusDesc" text="{LifecycleStatusDesc}"/>\
	<Text id="CompanyName" text="{SO_2_BP/CompanyName}"/>\
	<FlexBox id="action"\
		binding="{path : \'com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm(...)\'\
			, parameters : {$$inheritExpandSelect : true}}">\
		<layoutData><FlexItemData/></layoutData>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=LifecycleStatusDesc,SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
				SalesOrderID : "42",
				LifecycleStatusDesc : "New",
				SO_2_BP : {
					BusinessPartnerID : "1",
					CompanyName : "Kunde"
				}
			})
			.expectChange("id", "42")
			.expectChange("LifecycleStatusDesc", "New")
			.expectChange("CompanyName", "Kunde");

		return this.createView(assert, sView, oModel).then(function () {
			var oOperation = that.oView.byId("action").getObjectBinding();

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('42')/"
						+ "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm"
						+ "?$select=LifecycleStatusDesc,SalesOrderID"
						+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)",
					payload : {}
				}, {
					SalesOrderID : "42",
					LifecycleStatusDesc : "Confirmed",
					SO_2_BP : {
						BusinessPartnerID : "1",
						CompanyName : "Kunde (glcklich)"
					}
				})
				.expectChange("LifecycleStatusDesc", "Confirmed")
				.expectChange("CompanyName", "Kunde (glcklich)");

			return Promise.all([
				// code under test
				oOperation.invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete return value context obtained from bound action invoke.
	// JIRA: CPOUI5UISERVICESV3-1193
	QUnit.test("bound operation: delete return value context", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="objectPage">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActive" text="{IsActiveEntity}"/>\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("id")
			.expectChange("isActive")
			.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Name", {
					ArtistID : "42",
					IsActiveEntity : true,
					Name : "Hour Frustrated"
				})
				.expectChange("id", "42")
				.expectChange("isActive", "Yes")
				.expectChange("name", "Hour Frustrated");

			that.oView.setBindingContext(
				oModel.bindContext("/Artists(ArtistID='42',IsActiveEntity=true)")
					.getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='42',IsActiveEntity=true)/special.cases.EditAction",
					payload : {}
				}, {
					ArtistID : "42",
					IsActiveEntity : false,
					Name : "Hour Frustrated"
				});

			return Promise.all([
				that.oModel
					.bindContext("special.cases.EditAction(...)", that.oView.getBindingContext())
					.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aPromiseResults) {
			var oInactiveArtistContext = aPromiseResults[0];

			that.expectChange("isActive", "No");

			that.oView.byId("objectPage").setBindingContext(oInactiveArtistContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("DELETE Artists(ArtistID='42',IsActiveEntity=false)")
				.expectChange("id", null)
				.expectChange("isActive", null)
				.expectChange("name", null);

			return Promise.all([
				// code under test
				that.oView.byId("objectPage").getBindingContext().delete(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Invoke bound action with context for which no data has been read yet.
	// CPOUI5ODATAV4-1580: show usage of ODataModel#request+getKeyPredicate
	QUnit.test("bound operation: invoke bound action on context w/o read", function (assert) {
		var oEntity = {IsActiveEntity : true, ArtistID : "4/2"}, // reverse key odering
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oParentContext,
			that = this;

		 // code under test (CPOUI5ODATAV4-1580)
		return oModel.requestKeyPredicate("/Artists", oEntity).then(function (sKeyPredicate) {
			oParentContext = oModel.bindContext("/Artists" + sKeyPredicate).getBoundContext();

			return that.createView(assert, "", oModel);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='4%2F2',IsActiveEntity=true)/special.cases.EditAction",
					payload : {}
				}, {
					ArtistID : "4/2",
					IsActiveEntity : false
				});

			return Promise.all([
				// code under test
				oModel.bindContext("special.cases.EditAction(...)", oParentContext).invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aPromiseResults) {
			var oInactiveArtistContext = aPromiseResults[0];

			assert.strictEqual(oInactiveArtistContext.getProperty("IsActiveEntity"), false);
			assert.strictEqual(
				// code under test (CPOUI5ODATAV4-1580)
				oModel.getKeyPredicate("/Artists",
					oInactiveArtistContext.getObject()), // use back-end key odering
				"(ArtistID='4%2F2',IsActiveEntity=false)"
			);
		});
	});

	//*********************************************************************************************
	// Scenario: List report shows active version which is kept alive and shows messages. Object
	// page shows an "items" table sending own requests.
	// "EditAction" or "GetDraft" function returns draft version which replaces the active one.
	//
	// - PATCH and "ActivationAction" are sent in the same $batch (change set does not matter here).
	// Refresh destroys both the draft and the active version (unrealistic) and calls
	// <code>fnOnBeforeDestroy</code>.
	// JIRA: CPOUI5ODATAV4-347
	// The "items" table is refreshed after activation (JIRA: CPOUI5ODATAV4-1355)
	// oInactiveArtistContext.delete(null); can be used to remove messages for the draft that
	// has been activated w/o sending a DELETE request (JIRA: CPOUI5ODATAV4-1342)
	//
	// - An invalid value is entered. Editing is canceled via v4.Context#replaceWith with a known
	// active version. The draft is DELETEd afterwards.
	// JIRA: CPOUI5ODATAV4-1271
	//
	// - An invalid value is entered. Editing is canceled, but the active version is unknown and
	// first needs to be retrieved via invocation of "SiblingEntity(...)" navigation propery. The
	// draft is DELETEd afterwards.
	// JIRA: CPOUI5ODATAV4-1272
["EditAction", "GetDraft"].forEach(function (sDraftOperation) {
	[false, true].forEach(function (bCancel) {
		[false, true].forEach(function (bWithActive) {
			[false, true].forEach(function (bRefresh) {
				var sTitle = "CPOUI5ODATAV4-347: draft operation = " + sDraftOperation
						+ ", cancel = " + bCancel
						+ ", known active version = " + bWithActive
						+ ", refresh after activation = " + bRefresh;

				if (!bCancel && !bWithActive || bCancel && !bRefresh) {
					return;
				}

	QUnit.test(sTitle, function (assert) {
		var oActiveArtistContext,
			oDraftOperation,
			oInactiveArtistContext,
			oInput,
			oListBinding,
			sMessage1 = "It sure feels fine to see one's name in print",
			sMessage2 = "A book's a book, though there's naught in 't",
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			fnOnBeforeDestroy = sinon.spy(),
			oTable,
			sView = '\
<Table id="list" items="{path : \'/Artists\', parameters : {$$patchWithoutSideEffects : true}}">\
	<Text id="artistID" text="{ArtistID}"/>\
	<Text id="isActiveEntity" text="{IsActiveEntity}"/>\
	<Input id="name" value="{Name}"/>\
</Table>\
<Table id="items" items="{path : \'_Publication\', parameters : {$$ownRequest : true}}">\
	<Text id="price" text="{Price}"/>\
</Table>',
			that = this;

		this.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name&$skip=0&$top=100", {
				value : [{
					"@odata.etag" : "activETag",
					ArtistID : "42",
					IsActiveEntity : true,
					Name : "Missy Eliot"
				}]
			})
			.expectChange("artistID", ["42"])
			.expectChange("isActiveEntity", ["Yes"]);
		if (!bCancel) {
			this.expectChange("name", ["Missy Eliot"]);
		}
		this.expectChange("price", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=Messages", {
					"@odata.etag" : "activETag",
					Messages : [{
						message : sMessage1,
						numericSeverity : 1,
						target : "Name"
					}]
				})
				.expectMessages([{
					message : sMessage1,
					target : "/Artists(ArtistID='42',IsActiveEntity=true)/Name",
					type : "Success"
				}]);

			oTable = that.oView.byId("list");
			oListBinding = oTable.getBinding("items");
			oActiveArtistContext = oListBinding.getCurrentContexts()[0];
			oActiveArtistContext
				.setKeepAlive(true, fnOnBeforeDestroy.bind(that), /*bRequestMessages*/true);

			return that.waitForChanges(assert, "setKeepAlive, bRequestMessages");
		}).then(function () {
			return that.checkValueState(assert, oTable.getItems()[0].getCells()[2], "Success",
					sMessage1);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [{
						Price : "9.99",
						PublicationID : "42-0"
					}]
				})
				.expectChange("price", ["9.99"]);

			that.oView.byId("items").setBindingContext(oActiveArtistContext);

			return that.waitForChanges(assert, "items for active");
		}).then(function () {
			var bAction = sDraftOperation === "EditAction";

			oDraftOperation = that.oModel.bindContext("special.cases." + sDraftOperation + "(...)",
				oActiveArtistContext, {$$inheritExpandSelect : true});

			that.expectRequest({
					headers : bAction ? {"If-Match" : "activETag"} : {},
					method : bAction ? "POST" : "GET",
					url : "Artists(ArtistID='42',IsActiveEntity=true)/special.cases."
						+ sDraftOperation + (bAction ? "" : "()")
						+ "?$select=ArtistID,IsActiveEntity,Messages,Name",
					payload : bAction ? {} : undefined
				}, {
					"@odata.etag" : "inactivETag",
					ArtistID : "42",
					IsActiveEntity : false,
					Messages : [{
						message : sMessage2,
						numericSeverity : 1,
						target : "Name"
					}],
					Name : "Missy Eliot"
				})
				.expectChange("isActiveEntity", ["No"])
				.expectMessages([{
					message : sMessage1,
					target : "/Artists(ArtistID='42',IsActiveEntity=true)/Name",
					type : "Success"
				}, {
					message : sMessage2,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
					type : "Success"
				}]);

			return Promise.all([
				// code under test
				oDraftOperation.invoke(/*sGroupId*/undefined, /*bIgnoreETag*/false,
					/*fnOnStrictHandlingFailed*/null, /*bReplaceWithRVC*/true),
				that.waitForChanges(assert, sDraftOperation)
			]);
		}).then(function (aResults) {
			oInactiveArtistContext = aResults[0];

			assert.ok(oActiveArtistContext.isKeepAlive(), true);
			assert.strictEqual(oActiveArtistContext.getBinding(), oListBinding);
			assert.strictEqual(oActiveArtistContext.getIndex(), undefined);

			assert.ok(oInactiveArtistContext.isKeepAlive(), true);
			assert.strictEqual(oInactiveArtistContext.getBinding(), oListBinding);
			assert.strictEqual(oInactiveArtistContext.getIndex(), 0);

			assert.strictEqual(oDraftOperation.getBoundContext().getProperty("IsActiveEntity"),
				undefined, "draft data available via ODLB only");

			return that.checkValueState(assert, oTable.getItems()[0].getCells()[2], "Success",
					sMessage2);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [{
						Price : "10.99",
						PublicationID : "42-0"
					}]
				})
				.expectChange("price", ["10.99"]);

			that.oView.byId("items").setBindingContext(oInactiveArtistContext);

			return that.waitForChanges(assert, "items for draft");
		}).then(function () {
			var oActivationAction,
				sMessage = "EnterTextMaxLength 255",
				sValue = "*".repeat(256);

			if (!bCancel) {
				oActivationAction = that.oModel.bindContext("special.cases.ActivationAction(...)",
					oInactiveArtistContext, {$$inheritExpandSelect : true});

				that.expectChange("name", ["Mrs Eliot"])
					.expectRequest({
						batchNo : 6,
						headers : {
							"If-Match" : "inactivETag",
							Prefer : "return=minimal"
						},
						method : "PATCH",
						payload : {Name : "Mrs Eliot"},
						url : "Artists(ArtistID='42',IsActiveEntity=false)"
					}, null, {ETag : "inactivETag*"}) // 204 No Content
					.expectRequest({
						batchNo : 6,
						headers : {
							"If-Match" : "inactivETag"
						},
						method : "POST",
						url : "Artists(ArtistID='42',IsActiveEntity=false)"
							+ "/special.cases.ActivationAction"
							+ "?$select=ArtistID,IsActiveEntity,Messages,Name",
						payload : {}
					}, {
						"@odata.etag" : "activETag*",
						ArtistID : "42",
						IsActiveEntity : true,
						Messages : [],
						Name : "Mrs. Eliot" // "auto correction"
					})
					.expectChange("isActiveEntity", ["Yes"])
					.expectChange("name", ["Mrs. Eliot"])
					.expectMessages([{
						message : sMessage2,
						target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
						type : "Success"
					}]);

				return Promise.all([
					// code under test
					oInactiveArtistContext.setProperty("Name", "Mrs Eliot"),
					// code under test
					oActivationAction.invoke(/*sGroupId*/undefined, /*bIgnoreETag*/false,
						/*fnOnStrictHandlingFailed*/null, /*bReplaceWithRVC*/true),
					that.waitForChanges(assert, "PATCH Name & POST ActivationAction")
				]).then(function (aResults) {
					assert.ok(aResults[1] === oActiveArtistContext, "active context preserved");
					assert.strictEqual(oActiveArtistContext.getIndex(), 0);

					that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
							+ "?$select=Price,PublicationID&$skip=0&$top=100", {
							value : [{
								Price : "11.99",
								PublicationID : "42-0"
							}]
						})
						.expectChange("price", ["11.99"]);

					that.oView.byId("items").setBindingContext(oActiveArtistContext);

					return that.waitForChanges(assert, "items for new active");
				}).then(function () {
					if (!bRefresh) {
						that.expectMessages([]);

						return Promise.all([
							// code under test (get rid of message for draft)
							oInactiveArtistContext.delete(null),
							that.waitForChanges(assert, "DELETE draft after activation")
						]).then(function () {
							assert.strictEqual(oInactiveArtistContext.getBinding(), undefined);
							assert.strictEqual(oInactiveArtistContext.getModel(), undefined);
						});
					}

					// Note: oInactiveArtistContext.setKeepAlive(false); would be realistic, but we
					// prefer to check fnOnBeforeDestroy in this test
					assert.strictEqual(oInactiveArtistContext.getProperty("@odata.etag"),
						"inactivETag*");

					// Note: draft operation is relative to ODLB and function is refreshed, too
					oDraftOperation.setContext(null);

					that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Messages,Name"
							+ "&$filter=ArtistID eq '42' and IsActiveEntity eq false"
							+ " or ArtistID eq '42' and IsActiveEntity eq true&$top=2", {
							value : []
						})
						.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name&$skip=0"
							+ "&$top=100", {
							value : []
						})
						.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
							+ "?$select=Price,PublicationID&$skip=0&$top=100", {
							value : [{
								Price : "12.99",
								PublicationID : "42-0"
							}]
						})
						.expectChange("artistID", [])
						.expectChange("isActiveEntity", [])
						.expectChange("name", [])
						.expectChange("price", ["12.99"])
						.expectMessages([]);

					return Promise.all([
						// code under test
						oListBinding.requestRefresh(),
						that.waitForChanges(assert, "refresh")
					]).then(function () {
						assert.strictEqual(fnOnBeforeDestroy.callCount, 2);
						assert.ok(fnOnBeforeDestroy.alwaysCalledOn(that),
							"Function#bind still works");
						assert.ok(fnOnBeforeDestroy.calledWithExactly(), "still no args here");
						assert.ok(
							fnOnBeforeDestroy.calledWithExactly(
								sinon.match.same(oInactiveArtistContext)),
							"for the 'clone', we need the context to distinguish");
					});
				});
			}
			// cancel
			oInput = oTable.getItems()[0].getCells()[2];

			that.expectMessages([{
					message : sMessage1,
					target : "/Artists(ArtistID='42',IsActiveEntity=true)/Name",
					type : "Success"
				}, {
					message : sMessage2,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
					type : "Success"
				}, {
					message : sMessage,
					persistent : false,
					target : oInput.getId() + "/value",
					technical : false,
					type : "Error"
				}]);

			TestUtils.withNormalizedMessages(function () {
				// Note: Because the invalid value has to be set via control, changes for that
				// control cannot be observed via expectChange
				oInput.setValue(sValue);
			});

			assert.strictEqual(oInput.getValue(), sValue);
			assert.strictEqual(oInput.getBinding("value").getValue(), "Missy Eliot");

			return Promise.all([
				that.checkValueState(assert, oInput, "Error", sMessage),
				that.waitForChanges(assert)
			]).then(function () {
				var oSiblingEntity;

				that.expectMessages([{
						message : sMessage1,
						target : "/Artists(ArtistID='42',IsActiveEntity=true)/Name",
						type : "Success"
					}, {
						message : sMessage2,
						target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
						type : "Success"
					}]);

				if (bWithActive) {
					that.expectChange("isActiveEntity", ["Yes"]);

					// code under test
					oInactiveArtistContext.replaceWith(oActiveArtistContext);

					return that.waitForChanges(assert, "replaceWith");
				}

				oSiblingEntity = that.oModel.bindContext("SiblingEntity(...)",
					oInactiveArtistContext, {$$inheritExpandSelect : true});

				that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)"
						+ "/SiblingEntity?$select=ArtistID,IsActiveEntity,Messages,Name", {
						"@odata.etag" : "activETag*",
						ArtistID : "42",
						IsActiveEntity : true,
						Messages : [{
							message : sMessage1,
							numericSeverity : 1,
							target : "Name"
						}],
						Name : "Missy Eliot"
					})
					.expectChange("isActiveEntity", ["Yes"]);

				return Promise.all([
					// code under test
					oSiblingEntity.invoke("$auto", /*bIgnoreETag*/false,
						/*fnOnStrictHandlingFailed*/null, /*bReplaceWithRVC*/true),
					that.waitForChanges(assert, "SiblingEntity")
				]);
			}).then(function (aResults) {
				if (!bWithActive) {
					that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
							+ "?$select=Price,PublicationID&$skip=0&$top=100", {
							value : [{
								Price : "13.99",
								PublicationID : "42-0"
							}]
						});
				}
				that.expectChange("price", [bWithActive ? "9.99" : "13.99"]);

				that.oView.byId("items").setBindingContext(
					bWithActive ? oActiveArtistContext : aResults[0]);

				return that.waitForChanges(assert, "items for old active");
			}).then(function () {
				assert.strictEqual(oInput.getValue(), "Missy Eliot");

				return Promise.all([
					that.checkValueState(assert, oInput, "Success", sMessage1),
					that.waitForChanges(assert)
				]);
			}).then(function () {
				that.expectRequest({
						headers : {
							"If-Match" : "inactivETag"
						},
						method : "DELETE",
						url : "Artists(ArtistID='42',IsActiveEntity=false)"
					}) // 204 No Content
					.expectMessages([{
						message : sMessage1,
						target : "/Artists(ArtistID='42',IsActiveEntity=true)/Name",
						type : "Success"
					}]);

				return Promise.all([
					// code under test
					oInactiveArtistContext.delete("$auto", /*bDoNotRequestCount*/true),
					that.waitForChanges(assert, "DELETE")
				]);
			});
		});
	});
			});
		});
	});
});

	//*********************************************************************************************
	// Scenario: Invoke bound action; the parent binding has an empty path, but does not have a
	// cache, so that $$inheritExpandSelect must search the query options in the parent's parent.
	// JIRA: CPOUI5ODATAV4-189
	QUnit.test("bound operation: $$inheritExpandSelect and parent w/o cache #1", function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/SalesOrderList\', parameters : {$select : \'Messages\'}}">\
	<Text id="listId" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="objectPage" binding="{}">\
	<Text id="objectId" text="{SalesOrderID}"/>\
	<FlexBox id="action" binding="{path : \'' + sAction + '(...)\', \
		parameters : {$$inheritExpandSelect : true}}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Messages,SalesOrderID&$skip=0&$top=100",
				{value : [{SalesOrderID : "1"}]})
			.expectChange("listId", ["1"])
			.expectChange("objectId");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("objectId", "1");

			that.oView.byId("objectPage").setBindingContext(
				that.oView.byId("table").getItems()[0].getBindingContext()
			);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('1')/" + sAction + "?$select=Messages,SalesOrderID",
					payload : {}
				}, {
					SalesOrderID : "1"
				});

			return Promise.all([
				that.oView.byId("action").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0].getPath(), "/SalesOrderList('1')");
		});
	});

	//*********************************************************************************************
	// Scenario: Invoke bound action; the parent binding has a non-empty path, but does not have a
	// cache, so that $$inheritExpandSelect must search the query options in the parent's parent.
	// JIRA: CPOUI5ODATAV4-189
	QUnit.test("bound operation: $$inheritExpandSelect and parent w/o cache #2", function (assert) {
		var sAction = "special.cases.EditAction",
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/Artists\',\
		parameters : {$select : \'BestFriend/Messages\'}}">\
	<Text id="artists" text="{ArtistID}"/>\
	<Text id="bestFriends" text="{BestFriend/ArtistID}"/>\
</Table>\
<FlexBox id="objectPage" binding="{BestFriend}">\
	<Text id="bestFriend" text="{ArtistID}"/>\
	<FlexBox id="action" binding="{path : \'' + sAction + '(...)\', \
		parameters : {$$inheritExpandSelect : true}}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists?$select=ArtistID,IsActiveEntity"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Messages)"
				+ "&$skip=0&$top=100", {
				value : [{
					ArtistID : "1",
					IsActiveEntity : true,
					BestFriend : {
						ArtistID : "2",
						IsActiveEntity : true
					}
				}]
			})
			.expectChange("artists", ["1"])
			.expectChange("bestFriends", ["2"])
			.expectChange("bestFriend");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("bestFriend", "2");

			that.oView.byId("objectPage").setBindingContext(
				that.oView.byId("table").getItems()[0].getBindingContext()
			);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='1',IsActiveEntity=true)/BestFriend/" + sAction
						+ "?$select=ArtistID,IsActiveEntity,Messages",
					payload : {}
				}, {
					ArtistID : "2",
					IsActiveEntity : false,
					Messages : [{
						message : "Some Message",
						numericSeverity : 3,
						target : "ArtistID",
						transition : false
					}]
				})
				.expectMessages([{
					message : "Some Message",
					targets : [
						"/Artists(ArtistID='1',IsActiveEntity=true)/BestFriend/" + sAction
							+ "(...)/ArtistID"
					],
					type : "Warning"
				}]);

			return Promise.all([
				that.oView.byId("action").getObjectBinding().invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function ([oReturnValueContext]) {
			// TODO return value context not supported here
			// assert.strictEqual(aResults[0].getPath(),
			//     "Artists(ArtistID='2',IsActiveEntity=false)");
			assert.strictEqual(oReturnValueContext, undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: Create entity for an absolute ListBinding, save the new entity and call a bound
	// action for the new non-transient entity
	// JIRA: CPOUI5UISERVICESV3-1233
	QUnit.test("Create absolute, save and call action", function (assert) {
		var oCreatedContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			that = this,
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Text id="Team_Id" text="{Team_Id}"/>\
</Table>';

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=100", {
				value : [{Team_Id : "42"}]
			})
			.expectChange("Team_Id", ["42"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {Team_Id : "new"}
				}, {Team_Id : "newer"})
				.expectChange("Team_Id", ["new"])
				.expectChange("Team_Id", ["newer", "42"])
				.expectRequest("TEAMS('newer')?$select=Team_Id", {Team_Id : "newer"});

			oCreatedContext = that.oView.byId("table").getBinding("items").create({
				Team_Id : "new"
			});

			return Promise.all([oCreatedContext.created(), that.waitForChanges(assert)]);
		}).then(function () {
			var oAction = oModel.bindContext("com.sap.gateway.default.iwbep.tea_busi.v0001."
					+ "AcChangeManagerOfTeam(...)", oCreatedContext);

			assert.strictEqual(oCreatedContext.getPath(), "/TEAMS('newer')");

			that.expectRequest({
					method : "POST",
					url : "TEAMS('newer')/com.sap.gateway.default.iwbep.tea_busi.v0001."
						+ "AcChangeManagerOfTeam",
					payload : {ManagerID : "01"}
			});
			oAction.setParameter("ManagerID", "01");

			return Promise.all([
				// code under test
				oAction.invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create entity for a relative ListBinding, save the new entity and call a bound
	// action for the new non-transient entity
	// JIRA: CPOUI5UISERVICESV3-1233
	//
	// Ensure that a Return Value Context is created and the structure of the path is same like the
	// binding parameter
	// JIRA: CPOUI5ODATAV4-2096
	QUnit.test("Create relative, save and call action", function (assert) {
		var oCreatedContext,
			oModel = this.createTeaBusiModel(),
			oTeam2EmployeesBinding,
			that = this,
			sView = '\
<FlexBox id="form" binding="{path : \'/TEAMS(\\\'42\\\')\',\
	parameters : {$expand : {TEAM_2_EMPLOYEES : {$select : \'ID\'}}}}">\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Text id="id" text="{ID}"/>\
	</Table>\
</FlexBox>';

		this.expectRequest("TEAMS('42')?$expand=TEAM_2_EMPLOYEES($select=ID)", {
				TEAM_2_EMPLOYEES : [{ID : "2"}]
			})
			.expectChange("id", ["2"]);

		return this.createView(assert, sView, oModel).then(function () {
			// create new relative entity
			that.expectRequest({
					method : "POST",
					url : "TEAMS('42')/TEAM_2_EMPLOYEES",
					payload : {ID : null}
				}, {ID : "7"})
				.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES('7')?$select=ID", {ID : "7"})
				.expectChange("id", [""]) // from setValue(null)
				.expectChange("id", ["7", "2"]);
			oTeam2EmployeesBinding = that.oView.byId("table").getBinding("items");
			oCreatedContext = oTeam2EmployeesBinding.create({ID : null});

			return Promise.all([oCreatedContext.created(), that.waitForChanges(assert)]);
		}).then(function () {
			var oAction = that.oModel.bindContext(
					"com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee(...)",
					oCreatedContext);

			assert.strictEqual(oCreatedContext.getPath(), "/TEAMS('42')/TEAM_2_EMPLOYEES('7')");

			that.expectRequest({
					method : "POST",
					url : "TEAMS('42')/TEAM_2_EMPLOYEES('7')/"
						+ "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee"
						+ "?$expand=EMPLOYEE_2_TEAM($select=Team_Id)",
					payload : {TeamID : "02"}
				}, {
					EMPLOYEE_2_TEAM : {
						Team_Id : "02"
					},
					ID : "7"
				});
			oAction.setParameter("TeamID", "02");

			return Promise.all([
				// code under test
				oAction.invoke().then(function (oReturnValueContext) {
					assert.strictEqual(
						oReturnValueContext.getPath(),
						"/TEAMS('02')/TEAM_2_EMPLOYEES('7')");
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create a new entity on an absolute ListBinding, save the new entity and call bound
	// action for the new non-transient entity
	// Afterwards create a new entity on a containment relative to the just saved absolute entity,
	// save the containment and call a bound function on the new non-transient contained entity
	// JIRA: CPOUI5UISERVICESV3-1233
	QUnit.test("Create absolute and contained entity, save and call bound action/function",
			function (assert) {
		var oCreatedItemContext,
			oCreatedSOContext,
			oItemBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			that = this,
			sView = '\
<Table id="SalesOrders" items="{/SalesOrderList}">\
	<Text id="SalesOrderID" text="{SalesOrderID}"/>\
</Table>\
<Table id="LineItems" items="{SO_2_SOITEM}">\
	<Text id="ItemSalesOrderID" text="{SalesOrderID}"/>\
	<Text id="ItemPosition" text="{ItemPosition}"/>\
</Table>';

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [{SalesOrderID : "42"}]
			})
			.expectChange("SalesOrderID", ["42"])
			.expectChange("ItemPosition", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {SalesOrderID : "newID"}
				}, {SalesOrderID : "43"})
				.expectChange("SalesOrderID", ["newID"]) // from create()
				.expectChange("SalesOrderID", ["43", "42"])
				.expectRequest("SalesOrderList('43')?$select=SalesOrderID", {SalesOrderID : "43"});

			oCreatedSOContext = that.oView.byId("SalesOrders").getBinding("items").create({
				SalesOrderID : "newID"
			});

			return Promise.all([oCreatedSOContext.created(), that.waitForChanges(assert)]);
		}).then(function () {
			// set context for line items after sales order is created
			that.expectRequest("SalesOrderList('43')/SO_2_SOITEM?$select=ItemPosition,"
					+ "SalesOrderID&$skip=0&$top=100", {value : []});
			oItemBinding = that.oView.byId("LineItems").getBinding("items");
			oItemBinding.setContext(oCreatedSOContext);

			return that.waitForChanges(assert);
		}).then(function () {
			// create a sales order line item
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('43')/SO_2_SOITEM",
					payload : {
						SalesOrderID : "43",
						ItemPosition : "newPos"
					}
				}, {
					SalesOrderID : "43",
					ItemPosition : "10"
				})
				.expectRequest("SalesOrderList('43')"
					+ "/SO_2_SOITEM(SalesOrderID='43',ItemPosition='10')"
					+ "?$select=ItemPosition,SalesOrderID", {
					SalesOrderID : "43",
					ItemPosition : "10"
				})
				.expectChange("ItemPosition", ["newPos"])
				.expectChange("ItemPosition", ["10"]);

			oCreatedItemContext = oItemBinding.create({
				SalesOrderID : "43",
				ItemPosition : "newPos"
			});

			return Promise.all([oCreatedItemContext.created(), that.waitForChanges(assert)]);
		}).then(function () {
			// confirm created sales order (call action on created context)
			var oAction = oModel.bindContext("com.sap.gateway.default.zui5_epm_sample"
					+ ".v0002.SalesOrder_Confirm(...)", oCreatedSOContext);

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('43')/com.sap.gateway.default.zui5_epm_sample"
						+ ".v0002.SalesOrder_Confirm",
					payload : {}
				}, {SalesOrderID : "43"});

			return Promise.all([
				// code under test
				oAction.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// check availability (call function on created containment)
			var oFunction = oModel.bindContext("com.sap.gateway.default.zui5_epm_"
					+ "sample.v0002.SalesOrderLineItem_CheckAvailability(...)",
					oCreatedItemContext);

			that.expectRequest("SalesOrderList('43')/SO_2_SOITEM(SalesOrderID='43'"
					+ ",ItemPosition='10')/com.sap.gateway.default.zui5_epm_"
					+ "sample.v0002.SalesOrderLineItem_CheckAvailability()", {value : "5.0"});

			return Promise.all([
				// code under test
				oFunction.invoke(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// JIRA: CPOUI5UISERVICESV3-1153
	// JIRA: CPOUI5ODATAV4-1082
	["$direct", "$auto"].forEach(function (sGroupId) {
		QUnit.test("Header messages in response: " + sGroupId, function (assert) {
			var aMessages = [{
					code : "foo-42",
					longtextUrl : "../Messages(1)/LongText/$value",
					message : "text0",
					numericSeverity : 3
				}, {
					code : "foo-77",
					message : "text1",
					numericSeverity : 2,
					target : null // JIRA: CPOUI5ODATAV4-1086
				}, {
					code : "foo-22",
					message : "text2",
					numericSeverity : 1,
					target : "" // JIRA: CPOUI5ODATAV4-1082
				}, {
					code : "foo-13",
					message : "text3",
					numericSeverity : 1,
					target : "Name" // JIRA: CPOUI5ODATAV4-1082
				}],
				oModel = this.createTeaBusiModel({groupId : sGroupId}),
				sView = '\
<FlexBox binding="{path : \'/TEAMS(\\\'42\\\')/TEAM_2_MANAGER\',\
	parameters : {custom : \'foo\'}}">\
	<Text id="id" text="{ID}"/>\
</FlexBox>';

			function withTransition(oObject) {
				return Object.assign({}, {transition : true}, oObject);
			}

			this.expectRequest("TEAMS('42')/TEAM_2_MANAGER?custom=foo", {ID : "23"}, {
					"sap-messages" : JSON.stringify(aMessages)
				})
				.expectMessages([{
					code : "foo-42",
					descriptionUrl : sTeaBusi + "Messages(1)/LongText/$value",
					message : "text0",
					persistent : true,
					technicalDetails : {
						originalMessage : withTransition(aMessages[0])
					},
					type : "Warning"
				}, {
					code : "foo-77",
					message : "text1",
					persistent : true,
					technicalDetails : {
						originalMessage : withTransition(aMessages[1])
					},
					type : "Information"
				}, {
					code : "foo-22",
					message : "text2",
					persistent : true,
					target : "/TEAMS('42')/TEAM_2_MANAGER",
					technicalDetails : {
						originalMessage : withTransition(aMessages[2])
					},
					type : "Success"
				}, {
					code : "foo-13",
					message : "text3",
					persistent : true,
					target : "/TEAMS('42')/TEAM_2_MANAGER/Name",
					technicalDetails : {
						originalMessage : withTransition(aMessages[3])
					},
					type : "Success"
				}])
				.expectChange("id", "23");

			return this.createView(assert, sView, oModel);
		});
	});

	//*********************************************************************************************
	// Scenario: List/detail. Select the first row in the list table, the detail list returns
	// an item with a message. Select the second row in the list table, the message remains
	// although the item is no longer displayed. Now sort the detail table (which refreshes it) and
	// the message is gone.
	// JIRA: CPOUI5UISERVICESV3-135
	QUnit.test("List/Detail & messages", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Text id="text" text="{Name}"/>\
</Table>\
<Table id="detailTable" items="{\
			path : \'TEAM_2_EMPLOYEES\',\
			parameters : {\
				$select : \'__CT__FAKE__Message/__FAKE__Messages\'\
			}\
		}">\
	<Input id="Name" value="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100", {
				value : [
					{Team_Id : "Team_01", Name : "Team 01"},
					{Team_Id : "Team_02", Name : "Team 02"}
				]
			})
			.expectChange("text", ["Team 01", "Team 02"])
			.expectChange("Name", []);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectRequest("TEAMS('Team_01')/TEAM_2_EMPLOYEES"
					+ "?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages&$skip=0&$top=100", {
					value : [{
						ID : "1",
						Name : "Peter Burke",
						__CT__FAKE__Message : {
							__FAKE__Messages : [{
								code : "1",
								message : "Text",
								numericSeverity : 3,
								target : "Name",
								transition : false
							}]
						}
					}]
				})
				.expectChange("Name", ["Peter Burke"])
				.expectMessages([{
					code : "1",
					message : "Text",
					target : "/TEAMS('Team_01')/TEAM_2_EMPLOYEES('1')/Name",
					type : "Warning"
				}]);

			that.oView.byId("detailTable").setBindingContext(
				oTable.getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("detailTable").getItems()[0].getCells()[0],
				"Warning", "Text");
		}).then(function () {
			that.expectRequest("TEAMS('Team_02')/TEAM_2_EMPLOYEES"
					+ "?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages&$skip=0&$top=100", {
					value : []
				})
				.expectChange("Name", []);
				// no change in messages

			that.oView.byId("detailTable").setBindingContext(
				oTable.getItems()[1].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("TEAMS('Team_02')/TEAM_2_EMPLOYEES"
					+ "?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages"
					+ "&$orderby=Name&$skip=0&$top=100", {
					value : []
				})
				.expectMessages([]); // message is gone

			that.oView.byId("detailTable").getBinding("items").sort(new Sorter("Name"));

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario:
	// Two List/Detail binding hierarchies for sales orders and sales order line items. When
	// refreshing a single sales order, line items requests are invoked and messages are updated
	// only for this single sales order and its dependent sales order line items. For other sales
	// orders and their dependent sales order line items cached data is not discarded and messages
	// are kept untouched. If there are unresolved bindings, their cached data which depends on the
	// refreshed sales order is discarded and the corresponding messages are removed. Resolved
	// bindings for other binding hierarchies are not affected. (CPOUI5UISERVICESV3-1575)
	QUnit.test("sap.ui.model.odata.v4.Context#refresh: caches and messages", function (assert) {
		var sView = '\
<Table id="tableSalesOrder" items="{/SalesOrderList}">\
	<Text id="salesOrder" text="{SalesOrderID}"/>\
</Table>\
<Table id="tableSOItems" items="{\
			path : \'SO_2_SOITEM\',\
			parameters : {\
				$$ownRequest : true,\
				$select : \'Messages\'\
			}}">\
	<Input id="note" value="{Note}"/>\
</Table>\
<!-- same paths in different control hierarchies -->\
<Table id="tableSalesOrder2" items="{/SalesOrderList}">\
	<Text id="salesOrder2" text="{SalesOrderID}"/>\
</Table>\
<!-- to determine which request is fired the second table requests only 5 entries -->\
<Table id="tableSOItems2" growing="true" growingThreshold="5" items="{SO_2_SOITEM}">\
	<Input id="note2" value="{Note}"/>\
</Table>',
			oExpectedMessage0 = {
				code : "1",
				message : "Message0",
				target : "/SalesOrderList('0500000347')"
					+ "/SO_2_SOITEM(SalesOrderID='0500000347',ItemPosition='0')/Note",
				type : "Warning"
			},
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
					value : [
						{SalesOrderID : "0500000347"},
						{SalesOrderID : "0500000348"}
					]
				})
			.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
					value : [
						{SalesOrderID : "0500000347"},
						{SalesOrderID : "0500000348"}
					]
				})
			.expectChange("salesOrder", ["0500000347", "0500000348"])
			.expectChange("note", [])
			.expectChange("salesOrder2", ["0500000347", "0500000348"])
			.expectChange("note2", []);

		return this.createView(assert, sView, oModel).then(function () {
			// Select the first sales order in both hierarchies to get their items and messages
			that.expectRequest("SalesOrderList('0500000347')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=5", {
					value : [
						{ItemPosition : "0", Note : "Test1", SalesOrderID : "0500000347"},
						{ItemPosition : "1", Note : "Test2", SalesOrderID : "0500000347"}
					]
				})
				.expectRequest("SalesOrderList('0500000347')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Messages,Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : "0",
						Messages : [{
							code : "1",
							message : "Message0",
							numericSeverity : 3,
							target : "Note",
							transition : false
						}],
						Note : "Test1",
						SalesOrderID : "0500000347"
					}, {
						ItemPosition : "1",
						Messages : [],
						Note : "Test2",
						SalesOrderID : "0500000347"
					}]
				})
				.expectChange("note", ["Test1", "Test2"])
				.expectChange("note2", ["Test1", "Test2"])
				.expectMessages([oExpectedMessage0]);

			that.oView.byId("tableSOItems").setBindingContext(
				that.oView.byId("tableSalesOrder").getItems()[0].getBindingContext());
			that.oView.byId("tableSOItems2").setBindingContext(
				that.oView.byId("tableSalesOrder2").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			// Note: the message target addresses both fields!
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems2").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			// Select the second sales order to get its items and messages
			that.expectRequest("SalesOrderList('0500000348')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Messages,Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : "0",
						Messsages : [],
						Note : "Test3",
						SalesOrderID : "0500000348"
					}, {
						ItemPosition : "1",
						Messages : [{
							code : "1",
							message : "Message1",
							numericSeverity : 3,
							target : "Note",
							transition : false
						}],
						Note : "Test4",
						SalesOrderID : "0500000348"
					}]
				})
				.expectChange("note", ["Test3", "Test4"])
				.expectMessages([oExpectedMessage0, {
					code : "1",
					message : "Message1",
					target : "/SalesOrderList('0500000348')"
						+ "/SO_2_SOITEM(SalesOrderID='0500000348',ItemPosition='1')/Note",
					type : "Warning"
				}]);

			// code under test
			that.oView.byId("tableSOItems").setBindingContext(
				that.oView.byId("tableSalesOrder").getItems()[1].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems").getItems()[1].getCells()[0],
				"Warning", "Message1");
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems2").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			// refresh the second sales order; the message for the first sales order is kept
			that.expectRequest("SalesOrderList('0500000348')?$select=SalesOrderID",
					{SalesOrderID : "0500000348"})
				.expectRequest("SalesOrderList('0500000348')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Messages,Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : "0",
						Messages : [],
						Note : "Test3a",
						SalesOrderID : "0500000348"
					}, {
						ItemPosition : "1",
						Messages : [],
						Note : "Test4a",
						SalesOrderID : "0500000348"
					}]
				})
				.expectChange("note", ["Test3a", "Test4a"])
				.expectMessages([oExpectedMessage0]);

			// code under test
			that.oView.byId("tableSalesOrder").getItems()[1].getBindingContext().refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems").getItems()[1].getCells()[0],
				"None", "");
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems2").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			// select the first sales order again; no requests, the cache for the items is still
			// alive
			that.expectChange("note", ["Test1", "Test2"]);
				// no change in messages

			// code under test
			that.oView.byId("tableSOItems").setBindingContext(
				that.oView.byId("tableSalesOrder").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems2").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			// remove the binding context for the sales order items to get an unresolved binding
			// with caches
			that.expectChange("note", []);
				// no change in messages

			that.oView.byId("tableSOItems").setBindingContext(null);

			return that.waitForChanges(assert);
		}).then(function () {
			// refresh the first sales order, caches and messages of unresolved bindings for this
			// sales order are discarded
			that.expectRequest("SalesOrderList('0500000347')?$select=SalesOrderID",
					{SalesOrderID : "0500000347"})
				.expectMessages([]);

			that.oView.byId("tableSalesOrder").getItems()[0].getBindingContext().refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			// Note: "tableSOItems" currently unresolved
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems2").getItems()[0].getCells()[0],
				"None", "");
		}).then(function () {
			// select the first sales order to get its items and messages, request is
			// invoked because the cache for the sales order line items is discarded
			that.expectRequest("SalesOrderList('0500000347')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Messages,Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : "0",
						Messages : [{
							code : "1",
							message : "Message0",
							numericSeverity : 3,
							target : "Note",
							transition : false
						}],
						Note : "Test1",
						SalesOrderID : "0500000347"
					}, {
						ItemPosition : "1",
						Messages : [],
						Note : "Test2",
						SalesOrderID : "0500000347"
					}]
				})
				.expectChange("note", ["Test1", "Test2"])
				.expectMessages([oExpectedMessage0]);

			// code under test
			that.oView.byId("tableSOItems").setBindingContext(
				that.oView.byId("tableSalesOrder").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			// select the second sales order again; no requests, cache is still alive
			that.expectChange("note", ["Test3a", "Test4a"]);
				// no change in messages

			// code under test
			that.oView.byId("tableSOItems").setBindingContext(
				that.oView.byId("tableSalesOrder").getItems()[1].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems").getItems()[0].getCells()[0],
				"None", "");
		}).then(function () {
			// remove the binding context for the items of the second binding hierarchy
			that.expectChange("note2", []);
				// no change in messages

			that.oView.byId("tableSOItems2").setBindingContext(null);

			return that.waitForChanges(assert);
		}).then(function () {
			// select the same sales order again in the second binding hierarchy; no requests, cache
			// is still alive; cache was not affected by refreshing sales order "0500000347" in the
			// first binding hierarchy
			that.expectChange("note2", ["Test1", "Test2"]);
				// no change in messages

			that.oView.byId("tableSOItems2").setBindingContext(
				that.oView.byId("tableSalesOrder2").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems2").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			// remove the binding context for the items of the binding hierarchy
			that.expectChange("note", []);
				// no change in messages

			that.oView.byId("tableSOItems").setBindingContext(null);

			return that.waitForChanges(assert);
		}).then(function () {
			// Refresh the whole binding
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
					value : [
						{SalesOrderID : "0500000347"},
						{SalesOrderID : "0500000348"}
					]
				})
				.expectMessages([oExpectedMessage0]);

			that.oView.byId("tableSalesOrder").getBinding("items").refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("tableSOItems2").getItems()[0].getCells()[0],
				"Warning", "Message0");
		}).then(function () {
			// select the same sales order again in the binding hierarchy, new request is sent;
			//TODO if Binding.refresh considers unbound bindings this request is expected.
			// Will be fixed with CPOUI5UISERVICESV3-1701
			/* eslint-disable no-tabs */
			// that.expectRequest("SalesOrderList('0500000347')/SO_2_SOITEM"
			// 		+ "?$select=ItemPosition,Messages,Note,SalesOrderID&$skip=0&$top=100", {
			// 		value : [
			// 			{ItemPosition : "0", Note : "Test1", SalesOrderID : "0500000347"},
			// 			{ItemPosition : "1", Note : "Test2", SalesOrderID : "0500000347"}
			// 		]
			// 	})
			/* eslint-enable no-tabs */
			that.expectChange("note", ["Test1", "Test2"]);

			that.oView.byId("tableSOItems").setBindingContext(
				that.oView.byId("tableSalesOrder").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Change a property in a dependent binding with an own cache below a list binding.
	// Unset the binding context for the dependent binding and expect that there are still pending
	// changes for the formerly set context. Set the binding context to the second entry of the
	// equipments table and refresh the context of the second entry and expect that refresh is
	// possible. (CPOUI5UISERVICESV3-1575)
	QUnit.test("Context: Pending change in a hidden cache", function (assert) {
		var oContext0,
			oContext1,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="equipments" items="{/Equipments}">\
	<Text id="id" text="{ID}"/>\
</Table>\
<FlexBox id="employeeDetails"\
		binding="{path : \'EQUIPMENT_2_EMPLOYEE\', parameters : {$$updateGroupId : \'foo\'\}}">\
	<Input id="employeeName" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Equipments?$select=Category,ID&$skip=0&$top=100", {
				value : [
					{Category : "Electronics", ID : 23},
					{Category : "Vehicle", ID : 42}
				]
			})
			.expectChange("id", ["23", "42"])
			.expectChange("employeeName");

		return this.createView(assert, sView, oModel).then(function () {
			oContext0 = that.oView.byId("equipments").getItems()[0].getBindingContext();

			that.expectRequest("Equipments(Category='Electronics',ID=23)/EQUIPMENT_2_EMPLOYEE"
					+ "?$select=ID,Name", {
					ID : "1",
					Name : "John Smith"
				})
				.expectChange("employeeName", "John Smith");

			// select the first row in the equipments table
			that.oView.byId("employeeDetails").setBindingContext(oContext0);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("employeeName", "Peter Burke");

			// change the name of the employee
			that.oView.byId("employeeName").getBinding("value").setValue("Peter Burke");

			assert.ok(oContext0.hasPendingChanges());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("employeeName", null);

			that.oView.byId("employeeDetails").setBindingContext(null);

			// code under test (BCP: 2070187260)
			assert.notOk(that.oView.byId("employeeDetails").getObjectBinding().hasPendingChanges());

			assert.ok(oContext0.hasPendingChanges());
			assert.throws(function () {
				oContext0.refresh();
			}, /Cannot refresh entity due to pending changes:/);

			//TODO: hasPendingChanges on binding will be fixed with CPOUI5UISERVICESV3-1701
			// assert.ok(that.oView.byId("equipments").getBinding("items").hasPendingChanges());

			return that.waitForChanges(assert);
		}).then(function () {
			oContext1 = that.oView.byId("equipments").getItems()[1].getBindingContext();

			that.expectRequest("Equipments(Category='Vehicle',ID=42)/EQUIPMENT_2_EMPLOYEE"
					+ "?$select=ID,Name", {
					ID : "2",
					Name : "Frederic Fall"
				})
				.expectChange("employeeName", "Frederic Fall");

			// select the second row in the equipments table
			that.oView.byId("employeeDetails").setBindingContext(oContext1);

			// code under test
			assert.ok(that.oView.byId("equipments").getBinding("items").hasPendingChanges());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Equipments(Category='Vehicle',ID=42)?$select=Category,ID", {
					Category : "Vehicle",
					ID : 42
				})
				.expectRequest("Equipments(Category='Vehicle',ID=42)/EQUIPMENT_2_EMPLOYEE"
					+ "?$select=ID,Name", {
					ID : "2",
					Name : "Frederic Fall"
				});

			// refresh the second row in the equipments table
			oContext1.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("employeeName", "Peter Burke");

			// select the first row in the equipments table
			that.oView.byId("employeeDetails").setBindingContext(oContext0);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity with a state message and a transition message from an
	// ODataListBinding. Both messages are removed when the context is deleted.
	// JIRA: CPOUI5UISERVICESV3-1361
	QUnit.test("Delete an entity with messages from an ODataListBinding", function (assert) {
		var oDeleteMessage = {
				code : "occupied",
				message : "Cannot delete occupied worker",
				persistent : true,
				target : "/EMPLOYEES('1')/STATUS",
				technical : true,
				type : "Error"
			},
			oModel = this.createTeaBusiModel({autoExpandSelect : true, groupId : "$direct"}),
			oReadMessage = {
				code : "1",
				message : "Text",
				target : "/EMPLOYEES('1')/Name",
				type : "Warning"
			},
			oTable,
			sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\', \
		parameters : {$select : \'__CT__FAKE__Message/__FAKE__Messages\'}}">\
	<Input id="name" value="{Name}"/>\
	<Input id="status" value="{STATUS}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID,Name,STATUS,__CT__FAKE__Message/__FAKE__Messages"
				+ "&$skip=0&$top=100", {
				value : [{
					ID : "1",
					Name : "Jonathan Smith",
					STATUS : "Occupied",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Text",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				}, {
					ID : "2",
					Name : "Frederic Fall",
					STATUS : "Available",
					__CT__FAKE__Message : {__FAKE__Messages : []}
				}]
			})
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"])
			.expectChange("status", ["Occupied", "Available"])
			.expectMessages([oReadMessage]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			return that.checkValueState(assert,
				oTable.getItems()[0].getCells()[0],
				"Warning", "Text");
		}).then(function () {
			var oContext = oTable.getItems()[0].getBindingContext(),
				oError = createError({
					code : "occupied",
					message : "Cannot delete occupied worker",
					target : "STATUS"
				});

			that.oLogMock.expects("error")
				.withExactArgs("Failed to delete /EMPLOYEES('1')", sinon.match(oError.message),
					sContext);
			that.expectChange("name", ["Frederic Fall"])
				.expectChange("status", ["Available"])
				.expectRequest("DELETE EMPLOYEES('1')", oError)
				.expectChange("name", ["Jonathan Smith", "Frederic Fall"])
				.expectChange("status", ["Occupied", "Available"])
				.expectMessages([oReadMessage, oDeleteMessage]);

			return Promise.all([
				// code under test
				oContext.delete().then(mustFail(assert), function (oError0) {
					assert.strictEqual(oError0, oError);
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert,
				oTable.getItems()[0].getCells()[1],
				"Error", "Cannot delete occupied worker");
		}).then(function () {
			var oContext = oTable.getItems()[0].getBindingContext();

			that.expectChange("name", ["Frederic Fall"])
				.expectChange("status", ["Available"])
				.expectRequest("DELETE EMPLOYEES('1')")
				.expectMessages([]);

			return Promise.all([
				// code under test
				oContext.delete(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity with messages from an ODataContextBinding
	// JIRA: CPOUI5UISERVICESV3-1361
	QUnit.test("Delete an entity with messages from an ODataContextBinding", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{path : \'/EMPLOYEES(\\\'2\\\')\', \
	parameters : {$select : \'__CT__FAKE__Message/__FAKE__Messages\'}}">\
	<Input id="text" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages", {
				ID : "1",
				Name : "Jonathan Smith",
				__CT__FAKE__Message : {
					__FAKE__Messages : [{
						code : "1",
						message : "Text",
						numericSeverity : 3,
						target : "Name",
						transition : false
					}]
				}
			})
			.expectChange("text", "Jonathan Smith")
			.expectMessages([{
				code : "1",
				message : "Text",
				target : "/EMPLOYEES('2')/Name",
				type : "Warning"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			return that.checkValueState(assert, "text", "Warning", "Text");
		}).then(function () {
			var oContext = that.oView.byId("form").getBindingContext();

			that.expectRequest("DELETE EMPLOYEES('2')")
				.expectChange("text", null)
				.expectMessages([]);

			return Promise.all([
				// code under test
				oContext.delete(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity with messages from an relative ODLB w/o cache
	// JIRA: CPOUI5UISERVICESV3-1361
	QUnit.test("Delete an entity with messages from an relative ODLB w/o cache", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<FlexBox id="detail" binding="{/TEAMS(\'TEAM_01\')}">\
	<Text id="Team_Id" text="{Team_Id}"/>\
	<Table id="table" items="{path : \'TEAM_2_EMPLOYEES\', \
			parameters : {$select : \'__CT__FAKE__Message/__FAKE__Messages\'}}">\
		<Input id="name" value="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('TEAM_01')?$select=Team_Id"
				+ "&$expand=TEAM_2_EMPLOYEES($select=ID,Name,"
				+ "__CT__FAKE__Message/__FAKE__Messages)", {
				Team_Id : "TEAM_01",
				TEAM_2_EMPLOYEES : [{
					ID : "1",
					Name : "Jonathan Smith",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Text",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				}, {
					ID : "2",
					Name : "Frederic Fall",
					__CT__FAKE__Message : {__FAKE__Messages : []}
				}]
			})
			.expectChange("Team_Id", "TEAM_01")
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"])
			.expectMessages([{
				code : "1",
				message : "Text",
				target : "/TEAMS('TEAM_01')/TEAM_2_EMPLOYEES('1')/Name",
				type : "Warning"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			return that.checkValueState(assert, oTable.getItems()[0].getCells()[0], "Warning",
				"Text");
		}).then(function () {
			var oContext = oTable.getItems()[0].getBindingContext();

			that.expectRequest("DELETE EMPLOYEES('1')")
				.expectChange("name", ["Frederic Fall"])
				.expectMessages([]);

			return Promise.all([
				// code under test
				oContext.delete(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity from a relative ODLB with pending changes (POST) in siblings
	// CPOUI5UISERVICESV3-1799
	QUnit.test("Delete entity from rel. ODLB with pending changes in siblings", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			oTable,
			sView = '\
<FlexBox id="detail" binding="{/TEAMS(\'TEAM_01\')}">\
	<Text id="Team_Id" text="{Team_Id}"/>\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Text id="name" text="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('TEAM_01')?$select=Team_Id"
				+ "&$expand=TEAM_2_EMPLOYEES($select=ID,Name)", {
				Team_Id : "TEAM_01",
				TEAM_2_EMPLOYEES : [{
					ID : "1",
					Name : "Jonathan Smith"
				}, {
					ID : "2",
					Name : "Frederic Fall"
				}]
			})
			.expectChange("Team_Id", "TEAM_01")
			.expectChange("name", ["Jonathan Smith", "Frederic Fall"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectChange("name", ["John Doe", "Jonathan Smith", "Frederic Fall"]);

			oTable.getBinding("items").create({Name : "John Doe"});

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("DELETE EMPLOYEES('1')")
				.expectChange("name", [, "Frederic Fall"]);

			return Promise.all([
				// code under test
				oTable.getItems()[1].getBindingContext().delete("$auto"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Navigate to a detail page (e.g. by passing an entity key via URL parameter),
	// delete the root element and navigate back to the list page. When navigating again to the
	// detail page with the same entity key (e.g. via browser forward/back) no obsolete caches must
	// be used and all bindings shall fail while trying to read the data.
	// BCP: 1970282109
	QUnit.test("Delete removes dependent caches", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true, groupId : "$direct"}),
			sView = '\
<FlexBox id="detail" binding="">\
	<Text id="Team_Id" text="{Team_Id}"/>\
	<Table id="table" items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$$ownRequest : true}}">\
		<Text id="name" text="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("Team_Id")
			.expectChange("name", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("TEAMS('TEAM_01')?$select=Team_Id", {
					Team_Id : "TEAM_01"
				})
				.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name"
					+ "&$skip=0&$top=100", {
					value : [{
						ID : "1",
						Name : "Jonathan Smith"
					}, {
						ID : "2",
						Name : "Frederic Fall"
					}]
				})
				.expectChange("Team_Id", "TEAM_01")
				.expectChange("name", ["Jonathan Smith", "Frederic Fall"]);

			// simulate navigation to a detail page if only a key property is given
			that.oView.byId("detail").setBindingContext(
				that.oModel.bindContext("/TEAMS('TEAM_01')").getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("DELETE TEAMS('TEAM_01')")
				.expectChange("Team_Id", null);

			return Promise.all([
				// code under test
				that.oView.byId("detail").getBindingContext().delete("$auto"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// simulate failing read of data that has been deleted before
			var oError1 = new Error("404 Not Found"),
				oError2 = new Error("404 Not Found");

			that.oLogMock.expects("error")
				.withExactArgs("Failed to read path /TEAMS('TEAM_01')/Team_Id",
					sinon.match.string, sODPrB);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to read path /TEAMS('TEAM_01')", sinon.match.string, sODCB);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to get contexts for " + sTeaBusi
						+ "TEAMS('TEAM_01')/TEAM_2_EMPLOYEES with start index 0 and length 100",
					sinon.match.string, sODLB);
			that.expectRequest("TEAMS('TEAM_01')?$select=Team_Id", oError1)
				.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name"
					+ "&$skip=0&$top=100", oError2)
				.expectMessages([{
					message : "404 Not Found",
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					message : "404 Not Found",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			// simulate navigation to a detail page if only a key property is given which belongs
			// to a deleted entity; all bindings have to read data again and fail because entity is
			// deleted
			that.oView.byId("detail").setBindingContext(
				that.oModel.bindContext("/TEAMS('TEAM_01')").getBoundContext());

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity with messages from a relative ODataContextBinding w/o cache
	QUnit.test("Delete an entity with messages from a relative ODCB w/o cache", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Equipments(Category=\'foo\',ID=815)}">\
	<FlexBox id="form" binding="{path : \'EQUIPMENT_2_EMPLOYEE\', \
		parameters : {$select : \'__CT__FAKE__Message/__FAKE__Messages\'}}">\
		<layoutData><FlexItemData/></layoutData>\
		<Input id="text" value="{Name}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("Equipments(Category='foo',ID=815)?$select=Category,ID"
				+ "&$expand=EQUIPMENT_2_EMPLOYEE($select=ID,Name,"
				+ "__CT__FAKE__Message/__FAKE__Messages)", {
				Category : "foo",
				ID : 815, // Edm.Int32
				EQUIPMENT_2_EMPLOYEE : {
					ID : "1",
					Name : "Jonathan Smith",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Text",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				}
			})
			.expectChange("text", "Jonathan Smith")
			.expectMessages([{
				code : "1",
				message : "Text",
				target : "/Equipments(Category='foo',ID=815)/EQUIPMENT_2_EMPLOYEE/Name",
				type : "Warning"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			return that.checkValueState(assert, "text", "Warning", "Text");
		}).then(function () {
			var oContext = that.oView.byId("form").getBindingContext();

			that.expectRequest("DELETE EMPLOYEES('1')")
				.expectChange("text", null)
				.expectMessages([]);

			// code under test
			return oContext.delete().then(function () {
				// Wait for the delete first, because it immediately clears the field and then the
				// messages are checked before the response can remove.
				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Update property within an absolute binding and get bound messages in response
	QUnit.test("Update property (in absolute binding), getting bound messages", function (assert) {
		var oBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{path : \'/EMPLOYEES(\\\'1\\\')\', \
		parameters : {\
			$select : \'__CT__FAKE__Message/__FAKE__Messages\',\
			$$updateGroupId : \'foo\'\
		}}" id="form">\
	<Text id="id" text="{ID}"/>\
	<Input id="name" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages", {
				ID : "1",
				Name : "Jonathan Smith",
				__CT__FAKE__Message : {__FAKE__Messages : []}
			})
			.expectChange("id", "1")
			.expectChange("name", "Jonathan Smith");

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("name").getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('1')",
					payload : {Name : ""}
				}, {
					ID : "1",
					Name : "",
					// unrealistic scenario for OData V4.0 because a PATCH request does not contain
					// selects and Gateway will not return message properties; OData 4.01 feature;
					// if other server implementations send messages, process them anyway
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Enter a name",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				})
				.expectChange("name", "") // invoked by setValue
				.expectMessages([{
					code : "1",
					message : "Enter a name",
					target : "/EMPLOYEES('1')/Name",
					type : "Warning"
				}]);

			// code under test
			oBinding.setValue("");

			return Promise.all([
				oModel.submitBatch("foo"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "name", "Warning", "Enter a name");
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('1')",
					payload : {Name : "Hugo"}
				}, {
					ID : "1",
					Name : "Hugo",
					__CT__FAKE__Message : {__FAKE__Messages : []}
				})
				.expectChange("name", "Hugo") // invoked by setValue
				.expectMessages([]);

			// code under test
			oBinding.setValue("Hugo");

			return Promise.all([
				oModel.submitBatch("foo"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "name", "None", "");
		});
	});

	//*********************************************************************************************
	// Scenario: Update property within a relative binding and get bound messages in response
	QUnit.test("Update property (in relative binding), getting bound messages", function (assert) {
		var oBinding,
			oContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sPathToMessages = "TEAM_2_EMPLOYEES('1')/__CT__FAKE__Message/__FAKE__Messages",
			sView = '\
<FlexBox binding="{path : \'/TEAMS(\\\'TEAM_01\\\')\', \
		parameters : {\
			$expand : {\
				\'TEAM_2_EMPLOYEES\' : {\
					$select : \'__CT__FAKE__Message/__FAKE__Messages\'\
				}\
			},\
			$$updateGroupId : \'foo\'\
		}}" id="form">\
	<Text id="teamId" text="{Team_Id}"/>\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Input id="name" value="{Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('TEAM_01')"
				+ "?$expand=TEAM_2_EMPLOYEES($select=ID,Name,__CT__FAKE__Message/__FAKE__Messages)"
				+ "&$select=Team_Id", {
				Team_Id : "TEAM_01",
				TEAM_2_EMPLOYEES : [{
					ID : "1",
					Name : "Jonathan Smith",
					__CT__FAKE__Message : {__FAKE__Messages : []}
				}]
			})
			.expectChange("teamId", "TEAM_01")
			.expectChange("name", ["Jonathan Smith"])
			.expectMessages([]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getItems()[0].getCells()[0].getBinding("value");
			oContext = that.oView.byId("form").getBindingContext();

			that.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('1')",
					payload : {Name : ""}
				}, {
					ID : "1",
					Name : "",
					// unrealistic scenario for OData V4.0 because a PATCH request does not contain
					// selects and Gateway will not return message properties; OData 4.01 feature;
					// if other server implementations send messages, process them anyway
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Enter a name",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				})
				.expectChange("name", [""]) // invoked by setValue
				.expectMessages([{
					code : "1",
					message : "Enter a name",
					target : "/TEAMS('TEAM_01')/TEAM_2_EMPLOYEES('1')/Name",
					type : "Warning"
				}]);

			// there are no messages for employee 1
			assert.strictEqual(oContext.getObject(sPathToMessages).length, 0);
			assert.strictEqual(oContext.getObject(sPathToMessages + "/$count"), 0);

			// code under test
			oBinding.setValue("");

			return Promise.all([
				oModel.submitBatch("foo"),
				that.waitForChanges(assert)
			]).then(function () {
				// after the patch there is one message for employee 1
				assert.strictEqual(oContext.getObject(sPathToMessages).length, 1);
				assert.strictEqual(oContext.getObject(sPathToMessages)[0].message, "Enter a name");
				assert.strictEqual(oContext.getObject(sPathToMessages + "/$count"), 1);

				return that.checkValueState(assert,
					that.oView.byId("table").getItems()[0].getCells()[0],
					"Warning", "Enter a name");
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Update property within an entity in a collection and get bound messages in response
	QUnit.test("Update property (in collection), getting bound messages", function (assert) {
		var oBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\', \
		parameters : {\
			$select : \'__CT__FAKE__Message/__FAKE__Messages\',\
			$$updateGroupId : \'foo\'\
		}}">\
	<Input id="name" value="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages"
				+ "&$skip=0&$top=100", {
				value : [{
					ID : "1",
					Name : "Jonathan Smith",
					__CT__FAKE__Message : {__FAKE__Messages : []}
				}]
			})
			.expectChange("name", ["Jonathan Smith"])
			.expectMessages([]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getItems()[0].getCells()[0].getBinding("value");

			that.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('1')",
					payload : {Name : ""}
				}, {
					ID : "1",
					Name : "",
					// unrealistic scenario for OData V4.0 because a PATCH request does not contain
					// selects and Gateway will not return message properties; OData 4.01 feature;
					// if other server implementations send messages, process them anyway
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Enter a name",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				})
				.expectChange("name", [""]) // invoked by setValue
				.expectMessages([{
					code : "1",
					message : "Enter a name",
					target : "/EMPLOYEES('1')/Name",
					type : "Warning"
				}]);

			// code under test
			oBinding.setValue("");

			return Promise.all([
				oModel.submitBatch("foo"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert,
				that.oView.byId("table").getItems()[0].getCells()[0],
				"Warning", "Enter a name");
		});
	});

	//*********************************************************************************************
	// Scenario: Modify a property without side effects, i.e. the PATCH request's response is
	// ignored; read the side effects later on via API Context#requestSideEffects and check that the
	// corresponding fields on the UI change. This must work the same way if a first PATCH/GET
	// $batch fails.
	QUnit.test("$$patchWithoutSideEffects, then requestSideEffects", function (assert) {
		var oModel = this.createSalesOrdersModel123({
				autoExpandSelect : true,
				groupId : "$direct", // GET should not count for batchNo
				updateGroupId : "update"
			}),
			sView = '\
<FlexBox binding="{\
			path : \'/SalesOrderList(\\\'42\\\')\',\
			parameters : {$$patchWithoutSideEffects : true}\
		}"\
		id="form">\
	<Input id="netAmount" value="{NetAmount}"/>\
	<Text id="grossAmount" text="{GrossAmount}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?sap-client=123"
				+ "&$select=GrossAmount,NetAmount,SalesOrderID", {
				"@odata.etag" : "ETag0",
				GrossAmount : "119.00",
				NetAmount : "100.00",
				SalesOrderID : "42"
			})
			.expectChange("netAmount", "100.00")
			.expectChange("grossAmount", "119.00");

		return this.createView(assert, sView, oModel).then(function () {
			var oPromise;

			that.oLogMock.expects("error")
				.withArgs("Failed to update path /SalesOrderList('42')/NetAmount");
			that.oLogMock.expects("error")
				.withArgs("Failed to request side effects");

			that.expectChange("netAmount", "-1.00")
				.expectRequest({
					batchNo : 2,
					method : "PATCH",
					url : "SalesOrderList('42')?sap-client=123",
					headers : {"If-Match" : "ETag0", Prefer : "return=minimal"},
					payload : {NetAmount : "-1"}
				}, createErrorInsideBatch({message : "Value -1 not allowed"}))
				.expectRequest({
					batchNo : 2,
					url : "SalesOrderList('42')?sap-client=123&$select=GrossAmount"
				}) // no response required since the PATCH fails
				.expectMessages([{
					code : "CODE",
					message : "Value -1 not allowed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			that.oView.byId("netAmount").getBinding("value").setValue("-1");

			// code under test
			oPromise = that.oView.byId("form").getBindingContext().requestSideEffects([{
				$PropertyPath : "GrossAmount"
			}]).then(mustFail(assert), function (oError0) {
				assert.strictEqual(oError0.message, sPreviousFailed);
			});

			return Promise.all([
					oPromise,
					oModel.submitBatch("update"),
					that.waitForChanges(assert)
				]);
		}).then(function () {
			// remove persistent, technical messages from above
			Messaging.removeAllMessages();

			that.expectMessages([]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("netAmount", "200.00")
				.expectRequest({
					batchNo : 3,
					method : "PATCH",
					url : "SalesOrderList('42')?sap-client=123",
					headers : {"If-Match" : "ETag0", Prefer : "return=minimal"},
					payload : {NetAmount : "200"}
				}, null, {ETag : "ETag1"}); // 204 No Content

			that.oView.byId("netAmount").getBinding("value").setValue("200");

			return Promise.all([
					oModel.submitBatch("update"),
					that.waitForChanges(assert)
				]);
		}).then(function () {
			var oPromise;

			that.expectChange("netAmount", "0.00"); // external value: 200.00 -> 0.00

			that.oView.byId("netAmount").getBinding("value").setValue("0");

			// code under test
			oPromise = that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "NetAmount" // order MUST not matter
				}, {
					$PropertyPath : "GrossAmount"
				}, {
					$PropertyPath : "TaxAmount" // must be ignored due to intersection
				}]).then(function (vResult) {
					assert.strictEqual(vResult, undefined);
				});

			that.expectRequest({
					batchNo : 4,
					method : "PATCH",
					url : "SalesOrderList('42')?sap-client=123",
					headers : {
						"If-Match" : "ETag1", // new ETag is used!
						Prefer : "return=minimal"
					},
					payload : {NetAmount : "0"}
				}, {
					// "@odata.etag" : "ETag2", // not ignored, but unused by the rest of this test
					NetAmount : "$$patchWithoutSideEffects ignores this",
					Messages : [{
						code : "n/a",
						message : "$$patchWithoutSideEffects ignores this",
						numericSeverity : 3,
						target : "NetAmount"
					}],
					SalesOrderID : "42"
				})
				.expectRequest({
					batchNo : 4,
					url : "SalesOrderList('42')?sap-client=123&$select=GrossAmount,NetAmount"
				}, {
					// "@odata.etag" : "ETag2",
					GrossAmount : "0.00", // side effect
					NetAmount : "0.00", // "side effect": decimal places added
					Messages : [{ // side effect: reported, even if not selected
						code : "23",
						message : "Enter a minimum amount of 1",
						numericSeverity : 3,
						target : "NetAmount"
					}]
				})
				.expectChange("grossAmount", "0.00")
				.expectChange("netAmount", "0.00") // internal value has changed: 0 -> 0.00
				.expectMessages([{
					code : "23",
					message : "Enter a minimum amount of 1",
					target : "/SalesOrderList('42')/NetAmount",
					type : "Warning"
				}]);

			return Promise.all([
				oModel.submitBatch("update"),
				oPromise,
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "TaxAmount" // must be ignored due to intersection
				}]), // no GET request, no issue with locks!
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "netAmount",
				"Warning", "Enter a minimum amount of 1");
		});
	});

	//*********************************************************************************************
	// Scenario: Modify a property within a list binding with $$patchWithoutSideEffects, then modify
	// in a context binding that inherits the parameter
	// CPOUI5UISERVICESV3-1684
	//
	// Refresh of a relative context binding w/ $$ownRequest (JIRA: CPOUI5ODATAV4-2500)
	QUnit.test("$$patchWithoutSideEffects in list binding and inherited", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" items="{path : \'/SalesOrderList\',\
		parameters : {$$patchWithoutSideEffects : true}}">\
	<Input id="listNote" value="{Note}"/>\
</Table>\
<FlexBox id="form" binding="{path : \'\', parameters : {$$ownRequest : true}}">\
	<Input id="formNote" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
				value : [{
					"@odata.etag" : "ETag0",
					Note : "Note",
					SalesOrderID : "42"
				}]
			})
			.expectChange("listNote", ["Note"])
			.expectChange("formNote");

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectChange("listNote", ["Note (entered)"])
				.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag0", Prefer : "return=minimal"},
					payload : {Note : "Note (entered)"}
				}); // 204 No Content

			oTable.getItems()[0].getCells()[0].getBinding("value").setValue("Note (entered)");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID", {
					"@odata.etag" : "ETag1",
					Note : "Note (from server)",
					SalesOrderID : "42"
				})
				.expectChange("formNote", "Note (from server)");

			that.oView.byId("form").setBindingContext(
				oTable.getBinding("items").getCurrentContexts()[0]
			);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("formNote", "Note (entered)")
				.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('42')",
					headers : {"If-Match" : "ETag1", Prefer : "return=minimal"},
					payload : {Note : "Note (entered)"}
				}); // 204 No Content

			that.oView.byId("formNote").getBinding("value").setValue("Note (entered)");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID", {
					"@odata.etag" : "ETag2",
					Note : "Note (refreshed)",
					SalesOrderID : "42"
				})
				.expectChange("formNote", "Note (refreshed)");

			return Promise.all([
				// code under test
				that.oView.byId("form").getObjectBinding().requestRefresh(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Read side effects which include navigation properties while there are pending
	// changes.
	QUnit.test("requestSideEffects with navigation properties", function (assert) {
		var oModel = this.createSpecialCasesModel({
				autoExpandSelect : true,
				groupId : "$direct", // GET should not count for batchNo
				updateGroupId : "update"
			}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Input id="name" value="{Name}"/>\
	<Text id="inProcessByUser" text="{DraftAdministrativeData/InProcessByUser}"/>\
	<Text binding="{DraftAdministrativeData}" id="inProcessByUser2" text="{InProcessByUser}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity,Name"
				+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)", {
				"@odata.etag" : "ETag0",
				ArtistID : "42",
				DraftAdministrativeData : {
					DraftID : "23",
					InProcessByUser : "foo"
				},
				IsActiveEntity : true,
				Name : "Prince"
			})
			.expectChange("name", "Prince")
			.expectChange("inProcessByUser", "foo")
			.expectChange("inProcessByUser2", "foo");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("name", "TAFKAP");

			that.oView.byId("name").getBinding("value").setValue("TAFKAP");

			that.expectRequest({
					batchNo : 2,
					method : "PATCH",
					url : "Artists(ArtistID='42',IsActiveEntity=true)",
					headers : {"If-Match" : "ETag0"},
					payload : {Name : "TAFKAP"}
				}, {/* response does not matter here */})
				.expectRequest({
					batchNo : 2,
					url : "Artists(ArtistID='42',IsActiveEntity=true)"
						+ "?$select=DraftAdministrativeData"
						+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)"
				}, {
					DraftAdministrativeData : {
						DraftID : "23",
						InProcessByUser : "bar"
					}
				})
				.expectChange("inProcessByUser", "bar")
				.expectChange("inProcessByUser2", "bar");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "DraftAdministrativeData/InProcessByUser"
				}]),
				oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Read side effects via $NavigationPropertyPath. The dependent binding must be
	// refreshed.
	QUnit.test("requestSideEffects with $NavigationPropertyPath", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{}" id="section">\
		<Text binding="{path : \'DraftAdministrativeData\', parameters : {$$ownRequest : true}}"\
			id="inProcessByUser" text="{InProcessByUser}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/DraftAdministrativeData"
				+ "?$select=DraftID,InProcessByUser", {
				DraftID : "23",
				InProcessByUser : "foo"
			})
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity", {
				ArtistID : "42",
				IsActiveEntity : true
			})
			.expectChange("id", "42")
			.expectChange("inProcessByUser", "foo");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity", {
					ArtistID : "42",
					IsActiveEntity : true
				})
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/DraftAdministrativeData"
					+ "?$select=DraftID,InProcessByUser", {
					DraftID : "23",
					InProcessByUser : "bar"
				})
				.expectChange("inProcessByUser", "bar");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$NavigationPropertyPath : ""
				}, { // Note: this makes no difference, "" wins
					$NavigationPropertyPath : "DraftAdministrativeData"
				}]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/DraftAdministrativeData"
					+ "?$select=DraftID,InProcessByUser", {
					DraftID : "23*", // key property has changed
					InProcessByUser : "foo"
				})
				.expectChange("inProcessByUser", "foo");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$NavigationPropertyPath : "DraftAdministrativeData"
				}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: requestSideEffects for an expanded list with a $filter which needs encoding.
	// BCP: 2180064047
	QUnit.test("requestSideEffects with $filter in $expand", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{path : \'/SalesOrderList(\\\'1\\\')\',\
		parameters : {$expand : {SO_2_SOITEM : {$filter : \'Note.contains(\\\' \\\'\'}}}}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Table items="{SO_2_SOITEM}">\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')"
				+ "?$expand=SO_2_SOITEM($filter=Note.contains('%20%E2%82%AC')", {
				SalesOrderID : "1",
				SO_2_SOITEM : [
					{ItemPosition : "0010", Note : "Note ", SalesOrderID : "1"}
				]
			})
			.expectChange("id", "1")
			.expectChange("note", ["Note "]);

		return this.createView(assert, sView, this.createSalesOrdersModel()).then(function () {
			that.expectRequest("SalesOrderList('1')"
					+ "?$expand=SO_2_SOITEM($filter=Note.contains('%20%E2%82%AC')"
					+ "&$select=SO_2_SOITEM", {
					SO_2_SOITEM : [
						{ItemPosition : "0010", Note : "Note *", SalesOrderID : "1"}
					]
				})
				.expectChange("note", ["Note *"]);

			return Promise.all([
				that.oView.byId("form").getBindingContext().requestSideEffects(["SO_2_SOITEM"]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: requestSideEffects delivers a new entity. See that it can be patched later on.
	// JIRA: CPOUI5UISERVICESV3-1992
	QUnit.test("requestSideEffects delivers a new entity", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}" id="form">\
	<Input id="company" value="{SO_2_BP/CompanyName}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
				SalesOrderID : "1",
				SO_2_BP : null
			})
			.expectChange("company", "");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=SO_2_BP"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
					SO_2_BP : {
						"@odata.etag" : "ETag",
						BusinessPartnerID : "42",
						CompanyName : "Company"
					}
				})
				.expectChange("company", "Company");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects(["SO_2_BP"]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("company", "changed")
				.expectRequest({
					headers : {"If-Match" : "ETag"},
					method : "PATCH",
					payload : {CompanyName : "changed"},
					url : "BusinessPartnerList('42')"
				});

			that.oView.byId("company").getBinding("value").setValue("changed");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=SO_2_BP"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
					SO_2_BP : null
				})
			.expectChange("company", "");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects(["SO_2_BP"]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: requestSideEffects deletes an entity when only changes in its properties where
	// expected.
	// JIRA: CPOUI5ODATAV4-225
	QUnit.skip("requestSideEffects unexpectedly deletes an entity", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}" id="form">\
	<Input id="company" value="{SO_2_BP/CompanyName}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
				SalesOrderID : "1",
				SO_2_BP : {
					BusinessPartnerID : "42",
					CompanyName : "Company"
				}
			})
			.expectChange("company", "Company");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=SO_2_BP"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
					SO_2_BP : null
				});

			return Promise.all([
				// code under test
				// TODO this should fail because SO_2_BP becomes null
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "SO_2_BP/CompanyName"
				}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: read side effects which affect dependent bindings.
	QUnit.test("requestSideEffects: dependent bindings #1", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{}" id="section">\
		<Text binding="{\
				path : \'DraftAdministrativeData\',\
				parameters : {$$ownRequest : true}\
			}" id="inProcessByUser" text="{InProcessByUser}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/DraftAdministrativeData"
				+ "?$select=DraftID,InProcessByUser", {
				DraftID : "23",
				InProcessByUser : "foo"
			})
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity", {
				ArtistID : "42",
				IsActiveEntity : true
			})
			.expectChange("id", "42")
			.expectChange("inProcessByUser", "foo");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/DraftAdministrativeData"
					+ "?$select=DraftID,InProcessByUser", {
					DraftID : "23",
					InProcessByUser : "bar"
				})
				.expectChange("inProcessByUser", "bar");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "DraftAdministrativeData/InProcessByUser"
				}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Modifying a property of a kept-alive element in a list with
	// $$patchWithoutSideEffects, invokes a side-effects refresh. The PATCH request does change the
	// ETag of the kept-alive element. The list refresh request does only add unknown properties
	// to the kept-alive element, but does not take over changed properties. The refresh for the
	// kept-alive element must do this.
	// SNOW: DINC0072978
	QUnit.test("requestSideEffects with modified keep alive element", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<Table id="table" items="{path : '/TEAMS', parameters : {$$patchWithoutSideEffects : true}}">
	<Input id="name" value="{Name}"/>
	<Text id="budget" text="{Budget}"/>
</Table>`;

		this.expectRequest("TEAMS?$select=Budget,Name,Team_Id&$skip=0&$top=100", {
				value : [{
					"@odata.etag" : "etag1.0",
					Team_Id : "TEAM_01",
					Name : "Team 01",
					Budget : "0"
				}]
			})
			.expectChange("name", ["Team 01"])
			.expectChange("budget", ["0"]);

		await this.createView(assert, sView, oModel);

		const oBinding = this.oView.byId("table").getBinding("items");
		const oKeptContext = oBinding.getCurrentContexts()[0];
		oKeptContext.setKeepAlive(true);

		this.expectChange("name", ["New Team"])
			.expectRequest({
				batchNo : 2,
				headers : {
					"If-Match" : "etag1.0",
					Prefer : "return=minimal"
				},
				method : "PATCH",
				url : "TEAMS('TEAM_01')",
				payload : {Name : "New Team"}
			}, null, {ETag : "etag1.1"}) // no response required
			.expectRequest({
				batchNo : 2,
				url : "TEAMS?$select=Budget,Name,Team_Id&$filter=Team_Id eq 'TEAM_01'"
			}, {
				value : [{
					"@odata.etag" : "etag1.1",
					Budget : "42",
					Name : "New Team",
					Team_Id : "TEAM_01"
				}]
			})
			.expectRequest({
				batchNo : 2,
				url : "TEAMS?$select=Budget,Name,Team_Id&$skip=0&$top=100"
			}, {
				value : [{
					"@odata.etag" : "etag1.1",
					Budget : "n/a",
					Name : "n/a",
					Team_Id : "TEAM_01"
				}]
			})
			.expectChange("budget", ["42"]); // "side effect"

		const aTableRows = this.oView.byId("table").getItems();
		aTableRows[0].getCells()[0].getBinding("value").setValue("New Team");

		return Promise.all([
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert)
		]);
	});

	//*********************************************************************************************
	// Scenario: read side effects which affect dependent bindings; add some unnecessary context
	// bindings
	QUnit.test("requestSideEffects: dependent bindings #2", function (assert) {
		var sDraftAdministrativeData = "Artists(ArtistID='42',IsActiveEntity=true)"
				+ "/BestFriend/BestFriend/DraftAdministrativeData",
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{BestFriend}" id="section">\
		<FlexBox binding="{BestFriend}" id="section2">\
			<Text binding="{\
					path : \'DraftAdministrativeData\',\
					parameters : {$$ownRequest : true}\
				}" id="inProcessByUser" text="{InProcessByUser}"/>\
		</FlexBox>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest(sDraftAdministrativeData + "?$select=DraftID,InProcessByUser", {
				DraftID : "23",
				InProcessByUser : "foo"
			})
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity"
				//TODO CPOUI5UISERVICESV3-1677: Avoid unnecessary $expand
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
					+ ";$expand=BestFriend($select=ArtistID,IsActiveEntity))", {
				ArtistID : "42",
				IsActiveEntity : true
			})
			.expectChange("id", "42")
			.expectChange("inProcessByUser", "foo");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest(sDraftAdministrativeData + "?$select=DraftID,InProcessByUser", {
					DraftID : "23",
					InProcessByUser : "bar"
				})
				.expectChange("inProcessByUser", "bar");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "BestFriend/BestFriend/DraftAdministrativeData/InProcessByUser"
				}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: read side effects which affect dependent bindings; add some unnecessary context
	// bindings
	//TODO Enable autoExpandSelect once CPOUI5UISERVICESV3-1677 has been solved!
	QUnit.test("requestSideEffects: dependent bindings #3", function (assert) {
		var sDraftAdministrativeData = "Artists(ArtistID='42',IsActiveEntity=true)"
				+ "/BestFriend/_Friend(ArtistID='42',IsActiveEntity=true)/DraftAdministrativeData",
			oModel = this.createSpecialCasesModel({autoExpandSelect : false}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{BestFriend}" id="section">\
		<FlexBox binding="{_Friend(ArtistID=\'42\',IsActiveEntity=true)}" id="section2">\
			<Text binding="{\
					path : \'DraftAdministrativeData\',\
					parameters : {$$ownRequest : true}\
				}" id="inProcessByUser" text="{InProcessByUser}"/>\
		</FlexBox>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				/*+ "?$select=ArtistID,IsActiveEntity"*/, {
				ArtistID : "42",
				IsActiveEntity : true
			})
			.expectRequest(sDraftAdministrativeData/* + "?$select=DraftID,InProcessByUser"*/, {
				DraftID : "23",
				InProcessByUser : "foo"
			})
			.expectChange("id", "42")
			.expectChange("inProcessByUser", "foo");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest(sDraftAdministrativeData + "?$select=DraftID,InProcessByUser", {
					DraftID : "23",
					InProcessByUser : "bar"
				})
				.expectChange("inProcessByUser", "bar");

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "BestFriend/_Friend/DraftAdministrativeData/InProcessByUser"
				}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Read side effects via collection-valued $NavigationPropertyPath.
	// There is a child binding w/o own cache for the collection-valued navigation property affected
	// by the side effect; the whole collection is refreshed using $expand; eventing is OK to update
	// the UI.
	// Note: This works the same with a grid table, except for CPOUI5UISERVICESV3-1685.
	[false, true].forEach(function (bGrowing) {
		var sTitle = "requestSideEffects with collection-valued navigation; growing = " + bGrowing;

		QUnit.test(sTitle, function (assert) {
			var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
				sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{BestFriend}" id="section">\
		<Table growing="' + bGrowing + '" id="table" items="{_Publication}">\
			<Text id="price" text="{Price}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>',
				that = this;

			this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
						+ ";$expand=_Publication($select=Price,PublicationID))", {
					ArtistID : "42",
					BestFriend : {
						ArtistID : "23",
						IsActiveEntity : true,
						_Publication : [{
							Price : "9.99",
							PublicationID : "42-0"
						}]
					},
					IsActiveEntity : true
				})
				.expectChange("id", "42")
				.expectChange("price", ["9.99"]);

			return this.createView(assert, sView, oModel).then(function () {
				that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
						+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
						+ ";$expand=_Publication($select=Price,PublicationID))", {
						BestFriend : {
							ArtistID : "23",
							IsActiveEntity : true,
							_Publication : [{
								Price : "7.77",
								PublicationID : "42-0"
							}]
						}
					})
					.expectChange("price", ["7.77"]);

				return Promise.all([
					// code under test
					that.oView.byId("form").getBindingContext().requestSideEffects([{
						$NavigationPropertyPath : "BestFriend/_Publication"
					}]),
					that.waitForChanges(assert)
				]);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Read side effects for a collection-valued navigation property where only a single
	// property is affected. There is a child binding with own cache for the collection affected
	// by the side effect; instead of refreshing the whole collection, an efficient request is sent.
	// JIRA: CPOUI5UISERVICESV3-1690
	QUnit.test("requestSideEffects for a single property of a collection", function (assert) {
		var oModel,
			oTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{BestFriend}" id="section">\
		<t:Table firstVisibleRow="1" id="table"\
				rows="{path : \'_Publication\', parameters : {$count : true,\
					$filter : \'CurrencyCode eq \\\'EUR\\\'\', $orderby : \'PublicationID\',\
					$$ownRequest : true}}"\
				threshold="0" visibleRowCount="2">\
			<Input id="price" value="{Price}"/>\
			<Text id="currency" text="{CurrencyCode}"/>\
			<Text id="inProcessByUser" text="{DraftAdministrativeData/InProcessByUser}"/>\
		</t:Table>\
	</FlexBox>\
</FlexBox>',
			that = this;

		oModel = this.createModel("/special/cases/?sap-client=123", {autoExpandSelect : true}, {
			"/special/cases/$metadata?sap-client=123"
				: {source : "odata/v4/data/metadata_special_cases.xml"}
		});

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?sap-client=123&$select=ArtistID,IsActiveEntity"
				//TODO CPOUI5UISERVICESV3-1677: Avoid unnecessary $expand
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity)", {
				ArtistID : "42",
				IsActiveEntity : true
			})
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
				+ "?sap-client=123&$count=true&$filter=CurrencyCode eq 'EUR'"
				+ "&$orderby=PublicationID&$select=CurrencyCode,Price,PublicationID"
				+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)"
				+ "&$skip=1&$top=2", {
				"@odata.count" : "10",
				value : [{
					CurrencyCode : "EUR",
					DraftAdministrativeData : {
						DraftID : "42-1-A",
						InProcessByUser : "Charlie Brown"
					},
					Price : "9.11", // Note: 9.ii for old value at index i, 7.ii for new value
					PublicationID : "42-1"
				}, {
					CurrencyCode : "EUR",
					DraftAdministrativeData : {
						DraftID : "42-2-A",
						InProcessByUser : "Schroeder"
					},
					Price : "9.22",
					PublicationID : "42-2"
				}]
			})
			.expectChange("count")
			.expectChange("id", "42")
			.expectChange("price", [, "9.11", "9.22"])
			.expectChange("currency", [, "EUR", "EUR"])
			.expectChange("inProcessByUser", [, "Charlie Brown", "Schroeder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectChange("count", "10"); // must not be affected by side effects below!

			that.oView.byId("count").setBindingContext(
				oTable.getBinding("rows").getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
					+ "?sap-client=123"
					+ "&$filter=PublicationID eq '42-1' or PublicationID eq '42-2'"
					+ "&$select=Price,PublicationID"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)&$top=2", {
					value : [{
						DraftAdministrativeData : {
							DraftID : "42-1-A",
							InProcessByUser : "Jane Doe"
						},
						Price : "7.11", // side effect
						PublicationID : "42-1"
					}, {
						DraftAdministrativeData : {
							DraftID : "42-2-A", // side effect
							InProcessByUser : "John Doe"
						},
						Messages : [{ // side effect: reported, even if not selected
							code : "23",
							message : "This looks pretty cheap now",
							numericSeverity : 2,
							target : "Price"
						}],
						Price : "7.22", // side effect
						PublicationID : "42-2"
					}]
				})
				.expectChange("price", [, "7.11", "7.22"])
				.expectChange("inProcessByUser", [, "Jane Doe", "John Doe"])
				.expectMessages([{
					code : "23",
					message : "This looks pretty cheap now",
					target : "/Artists(ArtistID='42',IsActiveEntity=true)/BestFriend"
						+ "/_Publication('42-2')/Price",
					type : "Information"
				}]);

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "BestFriend/_Publication/Price"
				}, {
					$PropertyPath :
						"BestFriend/_Publication/DraftAdministrativeData/InProcessByUser"
				}]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, oTable.getRows()[1].getCells()[0], "Information",
				"This looks pretty cheap now");
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
					+ "?sap-client=123&$count=true&$filter=CurrencyCode eq 'EUR'"
					+ "&$orderby=PublicationID&$select=CurrencyCode,Price,PublicationID"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)"
					+ "&$skip=7&$top=2", {
					"@odata.count" : "10",
					value : [{
						CurrencyCode : "EUR",
						DraftAdministrativeData : null,
						Price : "7.77",
						PublicationID : "42-7"
					}, {
						CurrencyCode : "EUR",
						DraftAdministrativeData : null,
						Price : "7.88",
						PublicationID : "42-8"
					}]
				})
				.expectChange("price", [,,,,,,, "7.77", "7.88"])
				.expectChange("currency", [,,,,,,, "EUR", "EUR"])
				.expectChange("inProcessByUser", [,,,,,,, "", ""]);

			oTable.setFirstVisibleRow(7);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
					+ "?sap-client=123"
					+ "&$filter=PublicationID eq '42-7' or PublicationID eq '42-8'"
					+ "&$select=Price,PublicationID&$top=2", {
					value : [{ // Note: different order than before!
						Price : "5.88", // side effect
						PublicationID : "42-8"
					}, {
						Price : "5.77", // side effect
						PublicationID : "42-7"
					}]
				})
				.expectChange("price", [,,,,,,, "5.77", "5.88"]);

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "BestFriend/_Publication/Price"
				}]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
					+ "?sap-client=123&$count=true&$filter=CurrencyCode eq 'EUR'"
					+ "&$orderby=PublicationID&$select=CurrencyCode,Price,PublicationID"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)"
					+ "&$skip=1&$top=2", {
					"@odata.count" : "10",
					value : [{
						CurrencyCode : "EUR",
						DraftAdministrativeData : {
							DraftID : "42-1-A",
							InProcessByUser : "Charlie Brown"
						},
						Price : "5.11",
						PublicationID : "42-1"
					}, {
						CurrencyCode : "EUR",
						DraftAdministrativeData : {
							DraftID : "42-2-A",
							InProcessByUser : "Schroeder"
						},
						Price : "5.22",
						PublicationID : "42-2"
					}]
				})
				.expectChange("price", [, "5.11", "5.22"])
				.expectChange("currency", [, "EUR", "EUR"])
				.expectChange("inProcessByUser", [, "Charlie Brown", "Schroeder"]);

			// Note: invisible, cached data was not updated and thus must be read again
			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Read side effects for a collection-valued navigation property where only a single
	// property is affected. There is a child binding with own cache for the collection affected
	// by the side effect; instead of refreshing the whole collection, an efficient request is sent.
	// Additionally, there are detail "views" (form and table) which send their own requests and are
	// affected by the side effect.
	// Finally, read a side effect that affects a single row, refreshing it completely.
	// JIRA: CPOUI5UISERVICESV3-1867
	QUnit.test("requestSideEffects: collection & list/detail", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oTable,
			oTableBinding,
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{BestFriend}" id="section">\
		<Table id="table" items="{path : \'_Publication\', parameters : {$$ownRequest : true}}">\
			<Text id="price" text="{Price}"/>\
			<Text id="currency" text="{CurrencyCode}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>\
<FlexBox binding="{path : \'\', parameters : {$$ownRequest : true}}" id="detail">\
	<Text id="priceDetail" text="{Price}"/>\
	<Text id="currencyDetail" text="{CurrencyCode}"/>\
	<Text id="inProcessByUser" text="{DraftAdministrativeData/InProcessByUser}"/>\
</FlexBox>\
<Table id="detailTable" items="{_Artist/_Friend}">\
	<Text id="idDetail" text="{ArtistID}"/>\
	<Text id="nameDetail" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
				+ "?$select=CurrencyCode,Price,PublicationID&$skip=0&$top=100", {
				value : [{
					CurrencyCode : "EUR",
					Price : "9.00", // Note: 9.ii for old value at index i, 7.ii for new value
					PublicationID : "42-0"
				}, {
					CurrencyCode : "EUR",
					Price : "9.11",
					PublicationID : "42-1"
				}]
			})
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity"
				//TODO CPOUI5UISERVICESV3-1677: Avoid unnecessary $expand
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity)", {
				ArtistID : "42",
				IsActiveEntity : true
			})
			.expectChange("id", "42")
			.expectChange("price", ["9", "9.11"])
			.expectChange("currency", ["EUR", "EUR"])
			.expectChange("priceDetail")
			.expectChange("currencyDetail")
			.expectChange("inProcessByUser")
			.expectChange("idDetail", [])
			.expectChange("nameDetail", []);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oTableBinding = oTable.getBinding("items");

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend"
					+ "/_Publication('42-0')?$select=CurrencyCode,Price,PublicationID"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)", {
					CurrencyCode : "EUR",
					DraftAdministrativeData : {
						DraftID : "1",
						InProcessByUser : "JOHNDOE"
					},
					Price : "9.00",
					PublicationID : "42-0"
				})
				.expectChange("priceDetail", "9")
				.expectChange("currencyDetail", "EUR")
				.expectChange("inProcessByUser", "JOHNDOE");

			that.oView.byId("detail").setBindingContext(oTableBinding.getCurrentContexts()[0]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
					+ "?$select=Price,PublicationID"
					+ "&$filter=PublicationID eq '42-0' or PublicationID eq '42-1'&$top=2", {
					value : [{
						Price : "7.11", // side effect
						PublicationID : "42-1"
					}, {
						Price : "7.00", // side effect
						PublicationID : "42-0"
					}]
				})
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend"
					+ "/_Publication('42-0')?$select=Price"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)", {
					DraftAdministrativeData : {
						DraftID : "1",
						InProcessByUser : "Jane Doe"
					},
					Price : "7.00"
				})
				.expectChange("priceDetail", "7")
				.expectChange("inProcessByUser", "Jane Doe")
				.expectChange("price", ["7", "7.11"]);

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([
					"BestFriend/_Publication/Price",
					"BestFriend/_Publication/DraftAdministrativeData/InProcessByUser"
				]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend"
					+ "/_Publication('42-1')/_Artist/_Friend?$select=ArtistID,IsActiveEntity,Name"
					+ "&$skip=0&$top=100", {
					value : [{
						ArtistID : "0",
						IsActiveEntity : true,
						Name : "TAFKAP"
					}, {
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "John & Jane"
					}]
				})
				.expectChange("idDetail", ["0", "1"])
				.expectChange("nameDetail", ["TAFKAP", "John & Jane"]);

			that.oView.byId("detailTable").setBindingContext(oTableBinding.getCurrentContexts()[1]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend"
					+ "/_Publication('42-1')/_Artist/_Friend?$select=ArtistID,IsActiveEntity,Name"
					+ "&$filter=ArtistID eq '0' and IsActiveEntity eq true"
					+ " or ArtistID eq '1' and IsActiveEntity eq false&$top=2", {
					value : [{
						ArtistID : "0",
						IsActiveEntity : true,
						Name : "TAFKAP (1)"
					}, {
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "John | Jane"
					}]
				})
				.expectChange("nameDetail", ["TAFKAP (1)", "John | Jane"]);

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$PropertyPath : "BestFriend/_Publication/_Artist/_Friend/Name"
				}]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var o2ndRowContext = oTableBinding.getCurrentContexts()[1];

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend"
					+ "/_Publication('42-1')?$select=CurrencyCode,Messages,Price,PublicationID", {
					CurrencyCode : "JPY",
					Messages : [],
					Price : "123", // side effect
					PublicationID : "42-1"
				})
				.expectChange("price", [, "123"])
				.expectChange("currency", [, "JPY"]);

			//TODO @see CPOUI5UISERVICESV3-1832: open issue with autoExpandSelect, detailTable
			// would not send own request anymore because list table's oCachePromise becomes
			// pending again (see PS1 of POC #4122940); workaround by removing binding context
			that.oView.byId("detailTable").setBindingContext(null);

			return Promise.all([
				// code under test
				o2ndRowContext.requestSideEffects([{$NavigationPropertyPath : ""}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Read side effects on a single row of a table with a row context. We expect that
	// this
	//  (a) only loads side effects for the corresponding single context, not all current contexts
	//  (b) does not invalidate the other contexts, esp. the contexts belonging to currently not
	//     visible rows
	//  (c) can be called on both a non-transient, created entity and an entity loaded from the
	//     server
	// Load side effects for the complete table using the header context.
	// CPOUI5UISERVICESV3-1765
	QUnit.test("requestSideEffects on context of a list binding", function (assert) {
		var oCreatedContext0,
			oModel = this.createSpecialCasesModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<t:Table id="table" rows="{/Artists(\'42\')/_Publication}" threshold="0" visibleRowCount="2">\
	<Text id="id" text="{PublicationID}"/>\
	<Text id="price" text="{Price}"/>\
</t:Table>',
			that = this;

		this.expectRequest("Artists('42')/_Publication?$select=Price,PublicationID"
				+ "&$skip=0&$top=2", {
				value : [{
					Price : "1.11",
					PublicationID : "42-1"
				}, {
					Price : "2.22",
					PublicationID : "42-2"
				}]
			})
			.expectChange("id", ["42-1", "42-2"])
			.expectChange("price", ["1.11", "2.22"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectChange("id", ["New 1", "42-1"])
				.expectChange("price", [null, "1.11"]);

			oCreatedContext0 = oTable.getBinding("rows").create({PublicationID : "New 1"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "Artists('42')/_Publication",
					payload : {PublicationID : "New 1"}
				}, {
					Price : "3.33",
					PublicationID : "New 1"
				})
				.expectChange("price", ["3.33"]);

			return Promise.all([
				oCreatedContext0.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("Artists('42')/_Publication"
					+ "?$select=Price,PublicationID"
					+ "&$filter=PublicationID eq '42-1'", {
					value : [{
						Price : "1.12",
						PublicationID : "42-1"
					}]
				})
				.expectChange("price", [, "1.12"]);

			return Promise.all([
				// code under test: request side effects on "not-created" entity from server
				oTable.getRows()[1].getBindingContext().requestSideEffects(["Price"]),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("Artists('42')/_Publication('New 1')"
					+ "?$select=Messages,Price,PublicationID", {
					Messages : [],
					Price : "3.34",
					PublicationID : "New 1"
				})
				.expectChange("price", ["3.34"]);

			return Promise.all([
				// code under test: request side effects on non-transient created entity
				oTable.getRows()[0].getBindingContext().requestSideEffects([""]),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// Note: no data invalidation by requestSideEffects => no request expected
			that.expectChange("id", [, "42-1", "42-2"])
				.expectChange("price", [, "1.12", "2.22"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists('42')/_Publication"
					+ "?$select=Price,PublicationID"
					+ "&$filter=PublicationID eq 'New 1' or "
					+ "PublicationID eq '42-1' or PublicationID eq '42-2'&$top=3", {
						value : [{
							Price : "3.35",
							PublicationID : "New 1"
						}, {
							Price : "1.13",
							PublicationID : "42-1"
						}, {
							Price : "2.23",
							PublicationID : "42-2"
						}]
				})
				.expectChange("price", [, "1.13", "2.23"]);

			return Promise.all([
				// code under test: call on header context loads side effects for the whole binding
				oTable.getBinding("rows").getHeaderContext().requestSideEffects(["Price"]),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Request side effects on a context binding without an own cache, relative to a
	// context binding with a cache.
	// CPOUI5UISERVICESV3-1707
	QUnit.test("requestSideEffects: relative to a context binding", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<FlexBox binding="{BestFriend}" id="bestFriend">\
		<Text id="name" text="{Name}"/>\
		<FlexBox binding="{BestPublication}" id="bestPublication">\
			<Text id="bestPublication::currency" text="{CurrencyCode}"/>\
		</FlexBox>\
		<Table id="publication" \
				items="{path : \'_Publication\', parameters : {$$ownRequest : true}}">\
			<Text id="currency" text="{CurrencyCode}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name;"
					+ "$expand=BestPublication($select=CurrencyCode,PublicationID))", {
				ArtistID : "42",
				IsActiveEntity : true,
				BestFriend : {
					ArtistID : "23",
					BestPublication : {
						CurrencyCode : "JPY",
						PublicationID : "13"
					},
					IsActiveEntity : true,
					Name : "Best Friend"
				}
			})
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
				+ "?$select=CurrencyCode,PublicationID&$skip=0&$top=100", {
				value : [{
					CurrencyCode : "EUR",
					PublicationID : "1"
				}, {
					CurrencyCode : "USD",
					PublicationID : "2"
				}]
			})
			.expectChange("currency", ["EUR", "USD"])
			.expectChange("bestPublication::currency", "JPY")
			.expectChange("name", "Best Friend");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name;"
						+ "$expand=BestPublication($select=CurrencyCode,PublicationID))", {
					BestFriend : {
						ArtistID : "23",
						BestPublication : {
							CurrencyCode : "JPY2",
							PublicationID : "13"
						},
						IsActiveEntity : true,
						Name : "Best Friend2"
					}
				})
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/BestFriend/_Publication"
					+ "?$select=CurrencyCode,PublicationID&$skip=0&$top=100", {
					value : [{
						CurrencyCode : "EUR2",
						PublicationID : "1*" // key property has changed
					}, {
						CurrencyCode : "USD2",
						PublicationID : "2*" // key property has changed
					}]
				})
				.expectChange("currency", ["EUR2", "USD2"])
				.expectChange("bestPublication::currency", "JPY2")
				.expectChange("name", "Best Friend2");

			return Promise.all([
				// code under test
				that.oView.byId("bestFriend").getBindingContext().requestSideEffects([{
					$PropertyPath : "BestPublication/CurrencyCode"
				}, {
					$PropertyPath : "Name"
				}, {
					$NavigationPropertyPath : "_Publication"
				}]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity;"
						+ "$expand=BestPublication($select=CurrencyCode,PublicationID))", {
					BestFriend : {
						ArtistID : "23",
						BestPublication : {
							CurrencyCode : "USD",
							PublicationID : "13"
						},
						IsActiveEntity : true
					}
				})
				.expectChange("bestPublication::currency", "USD");

			return Promise.all([
				// code under test
				that.oView.byId("bestPublication").getBindingContext().requestSideEffects([{
					$PropertyPath : "CurrencyCode"
				}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario 1: Request side effects on a context binding without an own cache, relative to a
	// list binding with a cache.
	// CPOUI5UISERVICESV3-1707
	//
	// Scenario 2: Two GET requests for side effects are merged. One is expecting changes for
	// structural properties only ("*") and fails if a key predicate changes. The other allows that
	// a complete navigation property changes; it does not fail if a key predicate changes. Make
	// sure that the check for unexpected changes of key predicates does not fail due to this
	// merging.
	// BCP: 2170263464
	QUnit.test("requestSideEffects: relative to a list binding", function (assert) {
		var oBestFriendBox,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/Artists}">\
	<FlexBox binding="{BestFriend}"> \
		<Text id="name" text="{Name}"/>\
		<FlexBox binding="{BestPublication}" id="bestPublication">\
			<Text id="currency" text="{CurrencyCode}"/>\
		</FlexBox>\
	</FlexBox>\
</Table>',
			that = this;

		this.expectRequest("Artists"
				+ "?$select=ArtistID,IsActiveEntity"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name;"
					+ "$expand=BestPublication($select=CurrencyCode,PublicationID))"
				+ "&$skip=0&$top=100", {
				value : [{
					ArtistID : "23",
					BestFriend : {
						ArtistID : "43",
						BestPublication : {
							CurrencyCode : "GBP",
							PublicationID : "43-0"
						},
						IsActiveEntity : true,
						Name : "Best Friend of 23"
					},
					IsActiveEntity : true
				}, {
					ArtistID : "24",
					BestFriend : {
						ArtistID : "44",
						BestPublication : {
							CurrencyCode : "JPY",
							PublicationID : "44-0"
						},
						IsActiveEntity : true,
						Name : "Best Friend of 24"
					},
					IsActiveEntity : true
				}]
			})
			.expectChange("currency", ["GBP", "JPY"])
			.expectChange("name", ["Best Friend of 23", "Best Friend of 24"]);

		return this.createView(assert, sView, oModel).then(function () {
			oBestFriendBox = that.oView.byId("table").getItems()[1].getCells()[0];

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name;"
						+ "$expand=BestPublication($select=CurrencyCode,PublicationID))"
					+ "&$filter=ArtistID eq '24' and IsActiveEntity eq true", {
					value : [{
						ArtistID : "24",
						BestFriend : {
							ArtistID : "44",
							BestPublication : {
								CurrencyCode : "JPY2",
								PublicationID : "44-0"
							},
							IsActiveEntity : true,
							Name : "New Best Friend of 24"
						},
						IsActiveEntity : true
					}]
				})
				.expectChange("currency", [, "JPY2"])
				.expectChange("name", [, "New Best Friend of 24"]);

			return Promise.all([
				// code under test
				oBestFriendBox.getBindingContext().requestSideEffects([{
					$PropertyPath : "BestPublication/CurrencyCode"
				}, {
					$PropertyPath : "Name"
				}]),
				that.waitForChanges(assert, "Scenario 1")
			]);
		}).then(function () {
			var oBestPublicationBox = oBestFriendBox.getItems()[1];

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity;"
						+ "$expand=BestPublication($select=CurrencyCode,PublicationID))"
					+ "&$filter=ArtistID eq '24' and IsActiveEntity eq true", {
					value : [{
						ArtistID : "24",
						BestFriend : {
							ArtistID : "44",
							BestPublication : {
								CurrencyCode : "JPY3",
								PublicationID : "44-0"
							},
							IsActiveEntity : true
						},
						IsActiveEntity : true
					}]
				})
				.expectChange("currency", [, "JPY3"]);

			return Promise.all([
				// code under test
				oBestPublicationBox.getBindingContext().requestSideEffects(["CurrencyCode"]),
				that.waitForChanges(assert, "Scenario 1")
			]);
		}).then(function () {
			var oHeaderContext = that.oView.byId("table").getBinding("items").getHeaderContext();

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name"
						+ ";$expand=BestPublication($select=CurrencyCode,PublicationID))"
					+ "&$filter=ArtistID eq '23' and IsActiveEntity eq true"
						+ " or ArtistID eq '24' and IsActiveEntity eq true"
					+ "&$top=2", {
					value : [{
						ArtistID : "23",
						BestFriend : {
							ArtistID : "63", // this change must not result in an error
							BestPublication : {
								CurrencyCode : "GBP4",
								PublicationID : "44-0"
							},
							IsActiveEntity : true,
							Name : "New best Friend of 23"
						},
						IsActiveEntity : true
					}, {
						ArtistID : "24",
						BestFriend : {
							ArtistID : "64", // this change must not result in an error
							BestPublication : {
								CurrencyCode : "JPY4",
								PublicationID : "43-0"
							},
							IsActiveEntity : true,
							Name : "New best Friend of 24"
						},
						IsActiveEntity : true
					}]
				})
				.expectChange("currency", ["GBP4", "JPY4"])
				.expectChange("name", ["New best Friend of 23", "New best Friend of 24"]);

			return Promise.all([
				// code under test (BCP: 2170263464)
				oHeaderContext.requestSideEffects(["BestFriend/BestPublication/*"]),
				oHeaderContext.requestSideEffects(["BestFriend"]),
				that.waitForChanges(assert, "Scenario 2")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Request side effects on a context binding with an empty path and cache, relative to
	// a context binding with a cache. Side effects are requested on the parent binding.
	// CPOUI5UISERVICESV3-1984
	QUnit.test("requestSideEffects: skip empty path", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true, groupId : "$direct"}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="outer">\
	<Text id="outerName" text="{Name}"/>\
	<FlexBox id="inner" binding="{path : \'\', parameters : {$$ownRequest : true}}"> \
		<Text id="innerName" text="{Name}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity,Name", {
				ArtistID : "42",
				IsActiveEntity : true,
				Name : "Cher"
			})
			.expectChange("outerName", "Cher")
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity,Name", {
				ArtistID : "42",
				IsActiveEntity : true,
				Name : "Cher"
			})
			.expectChange("innerName", "Cher");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=Name", {
					Name : "Cherilyn"
				})
				.expectChange("innerName", "Cherilyn")
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=Name", {
					Name : "Cherilyn"
				})
				.expectChange("outerName", "Cherilyn");

			return Promise.all([
				// code under test
				that.oView.byId("innerName").getBindingContext().requestSideEffects(["Name"]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Check that the failure to refresh a complete table using requestSideEffects leads
	// to a rejected promise, but no changes in data.
	// JIRA: CPOUI5UISERVICESV3-1828
	//
	// Check that a kept-alive context does not interfere with this.
	// JIRA: CPOUI5ODATAV4-1104
	QUnit.test("ODLB: refresh within requestSideEffects fails", function (assert) {
		var oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			oTableBinding,
			sView = '\
<Table id="list" items="{/SalesOrderList}">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [{SalesOrderID : "42"}]
			})
			.expectChange("salesOrderID", ["42"])
			.expectChange("note", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.oLogMock.expects("error").withArgs("Failed to refresh kept-alive elements");
			that.oLogMock.expects("error")
				.withArgs(sinon.match.string, sinon.match(sPreviousFailed));
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$filter=SalesOrderID eq '42'",
					createErrorInsideBatch())
				// no response required
				.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100")
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			oTable = that.oView.byId("list");
			oTableBinding = oTable.getBinding("items");

			// code under test (JIRA: CPOUI5ODATAV4-1104)
			oTableBinding.getCurrentContexts()[0].setKeepAlive(true);

			return Promise.all([
				oTableBinding.getHeaderContext().requestSideEffects([""])
					.then(mustFail(assert), function () {
						assert.ok(true, "requestSideEffects failed as expected");
					}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oTableBinding.getCurrentContexts()[0].getPath(),
				"/SalesOrderList('42')");
		});
	});

	//*********************************************************************************************
	// Scenario: Check that the failure to refresh a complete table using requestSideEffects leads
	// to a rejected promise, but no changes in data.
	// JIRA: CPOUI5UISERVICESV3-1828
	QUnit.test("ODLB+ODCB: refresh within requestSideEffects fails", function (assert) {
		var oContext,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			oTableBinding,
			sView = '\
<Table id="list" items="{/SalesOrderList}">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="detail" binding="{path : \'\', parameters : {$$ownRequest : true}}">\
	<Text id="note" text="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [{SalesOrderID : "42"}]
			})
			.expectChange("salesOrderID", ["42"])
			.expectChange("note");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID", {
					SalesOrderID : "42",
					Note : "Note 42"
				})
				.expectChange("note", "Note 42");

			oTable = that.oView.byId("list");
			oTableBinding = oTable.getBinding("items");
			oContext = oTable.getItems()[0].getBindingContext();

			that.oView.byId("detail").setBindingContext(oContext);
			return that.waitForChanges(assert);
		}).then(function () {
			that.oLogMock.expects("error").withArgs("Failed to get contexts for"
				+ " /sap/opu/odata4/sap/zui5_testv4/default/sap/zui5_epm_sample/0002/SalesOrderList"
				+ " with start index 0 and length 100");
			that.oLogMock.expects("error")
				.withArgs(sinon.match.string, sinon.match(sPreviousFailed));
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100",
					createErrorInsideBatch())
				.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID") // no reponse req.
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				oTableBinding.getHeaderContext().requestSideEffects([""])
					.then(mustFail(assert), function () {
						assert.ok(true, "requestSideEffects failed as expected");
					}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oDetailContext = that.oView.byId("detail").getElementBinding().getBoundContext();

			assert.strictEqual(oTableBinding.getCurrentContexts()[0].getPath(),
				"/SalesOrderList('42')");
			assert.strictEqual(oDetailContext.getPath(), "/SalesOrderList('42')");
		});
	});

	//*********************************************************************************************
	// Scenario: Check that the failure to refresh a complete form using requestSideEffects leads
	// to a rejected promise, but no changes in data.
	// JIRA: CPOUI5UISERVICESV3-1828
	QUnit.test("ODCB+ODLB: refresh within requestSideEffects fails", function (assert) {
		var oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'42\')}">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="position" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=SalesOrderID", {SalesOrderID : "42"})
			.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$select=ItemPosition,SalesOrderID"
				+ "&$skip=0&$top=100", {
				value : [{
					SalesOrderID : "42",
					ItemPosition : "0010"
				}]
			})
			.expectChange("salesOrderID", "42")
			.expectChange("position", ["0010"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.oLogMock.expects("error").withArgs("Failed to read path /SalesOrderList('42')");
			that.oLogMock.expects("error")
				.withArgs(sinon.match.string, sinon.match(sPreviousFailed));
			that.oLogMock.expects("error")
				.withArgs("Failed to get contexts for /sap/opu/odata4/sap/zui5_testv4/default/sap"
					+ "/zui5_epm_sample/0002/SalesOrderList('42')/SO_2_SOITEM"
					+ " with start index 0 and length 100");
			that.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$select=ItemPosition,SalesOrderID"
					+ "&$skip=0&$top=100",
					createErrorInsideBatch({
						code : "CODE1",
						message : "Request 1 intentionally failed"
					}))
				.expectRequest("SalesOrderList('42')?$select=SalesOrderID",
					createErrorInsideBatch({
						code : "CODE2",
						message : "Request 2 intentionally failed"
					}))
				.expectMessages([{
					code : "CODE1",
					message : "Request 1 intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				that.oView.byId("form").getElementBinding().getBoundContext()
					.requestSideEffects([{$NavigationPropertyPath : ""}])
						.then(mustFail(assert), function (oError) {
							assert.strictEqual(oError.message, "HTTP request was not processed"
								+ " because the previous request failed");
							assert.strictEqual(oError.cause.error.message,
								"Request 1 intentionally failed");
						}),
				oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oFormContext = that.oView.byId("form").getElementBinding().getBoundContext(),
				oRowContext = that.oView.byId("table").getBinding("items").getCurrentContexts()[0];

			assert.strictEqual(oFormContext.getPath(), "/SalesOrderList('42')");
			assert.strictEqual(oRowContext.getPath(),
				"/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0010')");
		});
	});

	//*********************************************************************************************
	// Scenario: Check that the failure to refresh a complete form using requestSideEffects leads
	// to a rejected promise, but no changes in data, even in case of a return value context.
	// BCP: 2280001179
	QUnit.test("R.V.C.: refresh within requestSideEffects fails", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oParentContext,
			oReturnValueContext,
			sView = '\
<FlexBox id="form">\
	<Text id="note" text="{Note}"/>\
	<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="itemPosition" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("note")
			.expectChange("itemPosition", []);

		return this.createView(assert, sView, oModel).then(function () {
			var oContextBinding = oModel.bindContext("/SalesOrderList('1')");

			that.expectRequest("SalesOrderList('1')?$select=Note,SalesOrderID", {
					Note : "Hello, world!",
					SalesOrderID : "1"
				})
				.expectChange("note", "Hello, world!")
				.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : "0010",
						SalesOrderID : "1"
					}]
				})
				.expectChange("itemPosition", ["0010"]);

			oParentContext = oContextBinding.getBoundContext();
			that.oView.byId("form").setBindingContext(oParentContext);

			return that.waitForChanges(assert, "setBindingContext");
		}).then(function () {
			var sOperation = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
				oOperationBinding
					= oModel.bindContext(sOperation + "(...)", oParentContext,
						{$$inheritExpandSelect : true, $select : ["Messages"]});

			that.expectRequest({
					method : "POST",
					payload : {},
					url : "SalesOrderList('1')/" + sOperation
						+ "?$select=Messages,Note,SalesOrderID"
				}, {
					Messages : [{
						message : "Just A Message",
						numericSeverity : 1,
						target : "Note"
					}],
					Note : "Good-bye",
					SalesOrderID : "1"
				})
				.expectChange("note", "Good-bye") // sync into binding parameter
				.expectMessages([{
					message : "Just A Message",
					target : "/SalesOrderList('1')/Note",
					type : "Success"
				}]);

			return Promise.all([
				oOperationBinding.invoke(),
				that.waitForChanges(assert, "invoke")
			]);
		}).then(function (aResults) {
			oReturnValueContext = aResults[0];

			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : "0010",
						SalesOrderID : "1"
					}]
				})
				.expectChange("itemPosition", ["0010"]);

			that.oView.byId("form").setBindingContext(oReturnValueContext);

			return that.waitForChanges(assert, "setBindingContext: R.V.C.");
		}).then(function () {
			that.oLogMock.expects("error").withArgs("Failed to get contexts for"
				+ " /sap/opu/odata4/sap/zui5_testv4/default/sap/zui5_epm_sample/0002"
				+ "/SalesOrderList('1')/SO_2_SOITEM with start index 0 and length 100");
			that.oLogMock.expects("error").withArgs("Failed to read path /SalesOrderList('1')"
				+ "/com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm(...)");
			that.oLogMock.expects("error")
				.withArgs("Failed to read path /SalesOrderList('1')/Note");
			that.expectRequest("SalesOrderList('1')?$select=Messages,Note,SalesOrderID",
					createErrorInsideBatch())
				.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100") // no response required
				.expectChange("note", null) // temporary data loss due to failed request
				.expectChange("note", "Good-bye") // "keep cache on error"
				// Note: there is proof that "Just A Message" would be gone on success
				.expectMessages([{
					message : "Just A Message",
					target : "/SalesOrderList('1')/Note",
					type : "Success"
				}, {
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				oReturnValueContext.requestSideEffects([""]).then(mustFail(assert), function () {
					assert.ok(true, "requestSideEffects failed as expected");
				}),
				that.waitForChanges(assert, "requestSideEffects")
			]);
		}).then(function () {
			var oListBinding = that.oView.byId("items").getBinding("items");

			assert.strictEqual(oReturnValueContext.getProperty("Note"), "Good-bye");
			assert.deepEqual(oListBinding.getCurrentContexts().map(getPath), [
				"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')"
			]);
			assert.strictEqual(oListBinding.getCurrentContexts()[0].getProperty("ItemPosition"),
				"0010");
		});
	});

	//*********************************************************************************************
	// Scenario: Check that the failure to refresh a complete form using requestSideEffects leads
	// to a rejected promise.
	// JIRA: CPOUI5UISERVICESV3-1828
	QUnit.test("ODCB: failed requestSideEffects & changeParameters", function (assert) {
		var oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'42\')}">\
	<Text id="note" text="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID", {
				SalesOrderID : "42",
				Note : "Note"
			})
			.expectChange("note", "Note");

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("form").getElementBinding(),
				oPromise;

			that.expectCanceledError("Cache discarded as a new cache has been created")
				.expectCanceledError("Failed to read path /SalesOrderList('42')/Note",
					"Cache discarded as a new cache has been created")
				.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID&foo=bar", {
					SalesOrderID : "42",
					Note : "Note updated"
				})
				.expectChange("note", "Note updated");

			oPromise = oBinding.getBoundContext().requestSideEffects([""]);
			oBinding.changeParameters({foo : "bar"});

			return Promise.all([
				oPromise,
				oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Request side effects in a different batch group, and show the danger of pending
	// changes.
	// JIRA: CPOUI5UISERVICESV3-1921
	QUnit.test("Request side effects in a different batch group", function (assert) {
		var oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oPromise,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'42\')}">\
	<Input id="note" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=Note,SalesOrderID", {
				"@odata.etag" : "ETag",
				Note : "Note",
				SalesOrderID : "42"
			})
			.expectChange("note", "Note");

		return this.createView(assert, sView, oModel).then(function () {
			var oInput = that.oView.byId("note");

			that.expectChange("note", "User input");

			oInput.getBinding("value").setValue("User input");

			oPromise = oInput.getBindingContext().requestSideEffects([{
					$PropertyPath : "Note"
				}], "differentBatchGroup");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('42')?$select=Note", {
					"@odata.etag" : "ETag2",
					Note : "Side effect"
				})
				.expectChange("note", "Side effect"); // side effect wins over user input!

			return Promise.all([
				oPromise,
				oModel.submitBatch("differentBatchGroup"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest({
					headers : {"If-Match" : "ETag2"}, // uses ETag from side effect!
					method : "PATCH",
					payload : {Note : "User input"},
					url : "SalesOrderList('42')"
				}, {
					Note : "Server response",
					SalesOrderID : "42"
				})
				.expectChange("note", "Server response");

			return Promise.all([
				oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A requestSideEffects and a bound action are invoked concurrently and end up in
	// the same $batch. The requestSideEffects is already running when the action starts.
	// Nevertheless it must be possible to get the action's binding parameter from the cache being
	// updated.
	// BCP: 2080268833
	QUnit.test("BCP: 2080268833: requestSideEffects before bound action", function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Text id="note" text="{Note}"/>\
	<Table items="{SO_2_SOITEM}">\
		<Text id="pos" text="{ItemPosition}"/>\
	</Table>\
	<FlexBox id="action" binding="{' + sAction + '(...)}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=Note,SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)", {
				"@odata.etag" : "ETag",
				Note : "Note 1",
				SalesOrderID : "1",
				SO_2_SOITEM : [{ItemPosition : "0010", SalesOrderID : "1"}]
			})
			.expectChange("note", "Note 1")
			.expectChange("pos", ["0010"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList('1')/" + sAction,
					headers : {"If-Match" : "ETag"},
					payload : {}
				})
				.expectRequest({
					batchNo : 2,
					url : "SalesOrderList('1')?$select=SO_2_SOITEM"
						+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)"
				}, {
					"@odata.etag" : "ETag",
					SO_2_SOITEM : [{ItemPosition : "0010*", SalesOrderID : "1"}]
				})
				.expectChange("pos", ["0010*"]);

			return Promise.all([
				that.oView.byId("form").getBindingContext().requestSideEffects(["SO_2_SOITEM"]),
				Promise.resolve().then(function () {
					// code under test - invoke while requestSideEffects is already being processed
					return that.oView.byId("action").getObjectBinding().invoke()
						.then(function (oReturnValueContext) {
							assert.strictEqual(oReturnValueContext, undefined,
								"no R.V.C. w/o key predicate");
						});
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Automatic retry of failed PATCHes, along the lines of
	// MIT.SalesOrderCreateRelative.html, but with $auto group
	// JIRA: CPOUI5UISERVICESV3-1450
	[function () { // Context#setProperty restarts only PATCHes for the same entity (other field)
		var oStatusBinding = this.oView.byId("status0").getBinding("value");

		this.expectChange("status0", "Busy")
			.expectRequest({
				method : "PATCH",
				url : "EMPLOYEES('3')",
				headers : {"If-Match" : "ETag3"},
				payload : {
					ROOM_ID : "31", // <-- retry
					STATUS : "Busy"
				}
			}, {/* don't care */});

		oStatusBinding.setValue("Busy");
	}, function () { // Context#setProperty restarts only PATCHes for the same entity (same field)
		var oRoomIdBinding = this.oView.byId("roomId0").getBinding("value");

		this.expectChange("roomId0", "32")
			.expectRequest({
				method : "PATCH",
				url : "EMPLOYEES('3')",
				headers : {"If-Match" : "ETag3"},
				payload : {
					ROOM_ID : "32" // <-- new change wins over retry
				}
			}, {/* don't care */});

		oRoomIdBinding.setValue("32");
	}, function (assert) { // ODCB#invoke restarts only PATCHes for the same entity
		var sAction = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
			oRoomIdBinding = this.oView.byId("roomId0").getBinding("value");

		this.expectRequest({
				method : "PATCH",
				url : "EMPLOYEES('3')",
				headers : {"If-Match" : "ETag3"},
				payload : {
					ROOM_ID : "31" // <-- retry
				}
			}, {/* don't care */})
			.expectRequest({
				method : "POST",
				headers : {"If-Match" : "ETag3"},
				url : "EMPLOYEES('3')/" + sAction,
				payload : {TeamID : "23"}
			}, {/* don't care */});

		// bound action also invokes retry
		return this.oModel.bindContext(sAction + "(...)", oRoomIdBinding.getContext())
			.setParameter("TeamID", "23")
			.invoke("$auto")
			.then(function (oReturnValueContext) {
				assert.strictEqual(oReturnValueContext, undefined,
					"no R.V.C. w/o key predicate");
			});
	}, function () { // CPOUI5ODATAV4-1932: Context#delete restarts only PATCHes for the same entity
		var oRoomIdBinding = this.oView.byId("roomId0").getBinding("value");

		this.expectChange("roomId0", null)
			.expectChange("status0", null)
			.expectRequest({
				method : "PATCH",
				url : "EMPLOYEES('3')",
				headers : {"If-Match" : "ETag3"},
				payload : {
					ROOM_ID : "31" // <-- retry
				}
			}, {/* don't care */})
			.expectRequest({
				method : "DELETE",
				url : "EMPLOYEES('3')",
				headers : {"If-Match" : "*"}
			});

		return oRoomIdBinding.getContext().delete();
	}, function () { // ODataModel#submitBatch restarts all PATCHes
		this.expectRequest({
				$ContentID : "0.0",
				batchNo : 4,
				changeSetNo : 1,
				groupId : "$auto",
				headers : {"If-Match" : "ETag4"},
				method : "PATCH",
				payload : {
					ROOM_ID : "41" // <-- retry
				},
				url : "EMPLOYEES('4')"
			}, {/* don't care */})
			.expectRequest({
				$ContentID : "1.0",
				batchNo : 4,
				changeSetNo : 1,
				groupId : "$auto",
				headers : {"If-Match" : "ETag3"},
				method : "PATCH",
				payload : {
					ROOM_ID : "31" // <-- retry
				},
				url : "EMPLOYEES('3')"
			}, {/* don't care */})
			.expectRequest({
				$ContentID : undefined,
				batchNo : 4,
				changeSetNo : 2, // new changeset via submitBatch("$auto")
				groupId : "$auto",
				method : "POST",
				payload : {
					Budget : "1234.1234",
					TeamID : "TEAM_01"
				},
				url : "ChangeTeamBudgetByID"
			}, {/* don't care */});

		return Promise.all([
			this.oModel.submitBatch("$auto"),
			// code under test (JIRA: CPOUI5ODATAV4-2134)
			this.oModel.bindContext("/ChangeTeamBudgetByID(...)")
				.setParameter("Budget", "1234.1234")
				.setParameter("TeamID", "TEAM_01")
				.invoke("$auto")
		]).then(function () {
			return /*bAll*/true;
		});
	}, function (assert, oForm0Binding, oForm1Binding) {
		// ODataModel#resetChanges removes all PATCHes
		this.expectChange("roomId0", "30")
			.expectChange("roomId1", "40")
			.expectCanceledError("Failed to update path /EMPLOYEES('3')/ROOM_ID",
				"Request canceled: PATCH EMPLOYEES('3'); group: $parked.$auto")
			.expectCanceledError("Failed to update path /EMPLOYEES('4')/ROOM_ID",
				"Request canceled: PATCH EMPLOYEES('4'); group: $parked.$auto");

		// code under test
		this.oModel.resetChanges("$auto");

		assert.strictEqual(this.oModel.hasPendingChanges(), false);
		assert.strictEqual(oForm0Binding.hasPendingChanges(), false);
		assert.strictEqual(oForm1Binding.hasPendingChanges(), false);

		return this.oModel.submitBatch("$auto").then(function () {
			return /*bAll*/true;
		});
	}, function (_assert, oForm0Binding) {
		// Context#requestSideEffects restarts all PATCHes within the same $batch as the side effect
		this.expectRequest({
				batchNo : 4,
				headers : {"If-Match" : "ETag3"},
				method : "PATCH",
				payload : {
					ROOM_ID : "31" // <-- retry
				},
				url : "EMPLOYEES('3')"
			}, {/* don't care */})
			.expectRequest({
				batchNo : 4,
				headers : {"If-Match" : "ETag4"},
				method : "PATCH",
				payload : {
					ROOM_ID : "41" // <-- retry
				},
				url : "EMPLOYEES('4')"
			}, {/* don't care */})
			.expectRequest({
				batchNo : 4,
				url : "EMPLOYEES('3')?$select=STATUS"
			}, {
				STATUS : "Busy"
			})
			.expectChange("status0", "Busy");

		return oForm0Binding.getBoundContext().requestSideEffects([{$PropertyPath : "STATUS"}])
			.then(function () {
				return /*bAll*/true;
			});
	}].forEach(function (fnCodeUnderTest, i) {
		QUnit.test("Later retry failed PATCHes for $auto, " + i, function (assert) {
			var oForm0Binding,
				oForm1Binding,
				oModel = this.createTeaBusiModel({groupId : "$direct", updateGroupId : "$auto"}),
				sView = '\
<FlexBox binding="{/EMPLOYEES(\'3\')}" id="form0">\
	<Input id="roomId0" value="{ROOM_ID}"/>\
	<Input id="status0" value="{STATUS}"/>\
</FlexBox>\
<FlexBox binding="{/EMPLOYEES(\'4\')}" id="form1">\
	<Input id="roomId1" value="{ROOM_ID}"/>\
</FlexBox>',
				that = this;

			this.expectRequest("EMPLOYEES('3')", {
					"@odata.etag" : "ETag3",
					ID : "3",
					ROOM_ID : "30",
					STATUS : "Occupied"
				})
				.expectRequest("EMPLOYEES('4')", {
					"@odata.etag" : "ETag4",
					ID : "4",
					ROOM_ID : "40"
				})
				.expectChange("roomId0", "30")
				.expectChange("roomId1", "40")
				.expectChange("status0", "Occupied");

			return this.createView(assert, sView, oModel).then(function () {
				var oRoomIdBinding0 = that.oView.byId("roomId0").getBinding("value"),
					oRoomIdBinding1 = that.oView.byId("roomId1").getBinding("value");

				oForm0Binding = that.oView.byId("form0").getObjectBinding();
				oForm1Binding = that.oView.byId("form1").getObjectBinding();

				that.expectChange("roomId0", "31")
					.expectChange("roomId1", "41")
					.expectRequest({
						method : "PATCH",
						url : "EMPLOYEES('3')",
						headers : {"If-Match" : "ETag3"},
						payload : {ROOM_ID : "31"}
					}, createErrorInsideBatch())
					.expectRequest({
						method : "PATCH",
						url : "EMPLOYEES('4')",
						headers : {"If-Match" : "ETag4"},
						payload : {ROOM_ID : "41"}
					}) // no response required
					.expectMessages([{
						code : "CODE",
						message : "Request intentionally failed",
						persistent : true,
						technical : true,
						type : "Error"
					}]);
				that.oLogMock.expects("error")
					.withArgs("Failed to update path /EMPLOYEES('3')/ROOM_ID");
				that.oLogMock.expects("error")
					.withArgs("Failed to update path /EMPLOYEES('4')/ROOM_ID");

				oRoomIdBinding0.setValue("31");
				oRoomIdBinding1.setValue("41");

				assert.ok(oModel.hasPendingChanges());
				assert.ok(oForm0Binding.hasPendingChanges());
				assert.ok(oForm1Binding.hasPendingChanges());

				return that.waitForChanges(assert);
			}).then(function () {
				return Promise.all([
					fnCodeUnderTest.call(that, assert, oForm0Binding, oForm1Binding),
					that.waitForChanges(assert)
				]);
			}).then(function (aResults) {
				var bAll = aResults[0];

				assert.strictEqual(oModel.hasPendingChanges(), !bAll);
				assert.strictEqual(oForm0Binding.hasPendingChanges(), false);
				assert.strictEqual(oForm1Binding.hasPendingChanges(), !bAll);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Immediate retry of failed PATCHes; make sure that order is preserved
	// JIRA: CPOUI5UISERVICESV3-1450
	//
	// Additionally, observe the "propertyChange" event (JIRA: CPOUI5ODATAV4-1919)
	["$auto", "group"].forEach(function (sUpdateGroupId) {
		QUnit.test("Immediately retry failed PATCHes for " + sUpdateGroupId, function (assert) {
			var oAgeBinding,
				iCount = 0,
				oModel = this.createTeaBusiModel({updateGroupId : sUpdateGroupId}),
				oPatchPromise1,
				oPatchPromise2,
				mParameters,
				fnReject,
				oRoomIdBinding,
				oSubmitPromise,
				sView = '\
<FlexBox binding="{/EMPLOYEES(\'3\')}">\
	<Input id="age" value="{AGE}"/>\
	<Input id="roomId" value="{ROOM_ID}"/>\
	<Input id="status" value="{STATUS}"/>\
</FlexBox>',
				that = this;

			// code under test
			oModel.attachPropertyChange(function (oEvent) {
				iCount += 1;
				mParameters = oEvent.getParameters();
				assert.strictEqual(oEvent.getSource(), oModel);
			});

			this.expectRequest("EMPLOYEES('3')", {
					"@odata.etag" : "ETag0",
					ID : "3",
					AGE : 66,
					ROOM_ID : "2",
					STATUS : "Occupied"
				})
				.expectChange("age", "66")
				.expectChange("roomId", "2")
				.expectChange("status", "Occupied");

			return this.createView(assert, sView, oModel).then(function () {
				oAgeBinding = that.oView.byId("age").getBinding("value");
				oRoomIdBinding = that.oView.byId("roomId").getBinding("value");

				that.expectChange("age", "67")
					.expectChange("roomId", "42")
					.expectRequest({
						method : "PATCH",
						url : "EMPLOYEES('3')",
						headers : {"If-Match" : "ETag0"},
						payload : {
							AGE : 67,
							ROOM_ID : "42"
						}
					}, new Promise(function (_resolve, reject) {
						fnReject = reject;
					}));

				oAgeBinding.setValue(67); // Happy Birthday!

				assert.strictEqual(iCount, 1, "propertyChange fired sync");
				assert.strictEqual(mParameters.resolvedPath, "/EMPLOYEES('3')/AGE");
				oPatchPromise1 = mParameters.promise;

				oRoomIdBinding.setValue("42");

				assert.strictEqual(iCount, 2, "propertyChange fired sync");
				assert.strictEqual(mParameters.resolvedPath, "/EMPLOYEES('3')/ROOM_ID");
				oPatchPromise2 = mParameters.promise;

				oSubmitPromise = oModel.submitBatch("group");

				return that.waitForChanges(assert);
			}).then(function () {
				that.expectChange("roomId", "23");

				oRoomIdBinding.setValue("23");

				assert.strictEqual(iCount, 3, "propertyChange fired sync");
				assert.strictEqual(mParameters.resolvedPath, "/EMPLOYEES('3')/ROOM_ID");

				that.expectRequest({
						method : "PATCH",
						url : "EMPLOYEES('3')",
						headers : {"If-Match" : "ETag0"},
						payload : {
							AGE : 67,
							ROOM_ID : "23"
						}
					}, {
						"@odata.etag" : "ETag1",
						AGE : 67,
						ROOM_ID : "23"
					})
					.expectMessages([{
						code : "CODE",
						message : "Request intentionally failed",
						persistent : true,
						technical : true,
						type : "Error"
					}]);
				that.oLogMock.expects("error")
					.withArgs("Failed to update path /EMPLOYEES('3')/AGE");
				that.oLogMock.expects("error")
					.withArgs("Failed to update path /EMPLOYEES('3')/ROOM_ID");

				fnReject(createErrorInsideBatch());

				return Promise.all([
					oSubmitPromise,
					oModel.submitBatch("group"),
					oPatchPromise1, // retry succeeds
					oPatchPromise2, // retry succeeds
					mParameters.promise,
					that.waitForChanges(assert)
				]);
			}).then(function () {
				var oStatusBinding = that.oView.byId("status").getBinding("value");

				that.expectChange("status", "Busy")
					.expectRequest({
						method : "PATCH",
						url : "EMPLOYEES('3')",
						headers : {"If-Match" : "ETag1"},
						payload : {STATUS : "Busy"}
					}, {/* don't care */});

				oStatusBinding.setValue("Busy"); // a different field is changed

				assert.strictEqual(iCount, 4, "propertyChange fired sync");
				assert.strictEqual(mParameters.resolvedPath, "/EMPLOYEES('3')/STATUS");

				return Promise.all([
					oModel.submitBatch("group"),
					mParameters.promise,
					that.waitForChanges(assert)
				]);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: ODCB#invoke waits until PATCHes are back and happens inside same $batch as retry
	// (CPOUI5UISERVICESV3-1451)
	QUnit.test("CPOUI5UISERVICESV3-1451: ODCB#invoke after all PATCHes", function (assert) {
		var oModel = this.createTeaBusiModel({groupId : "$direct", updateGroupId : "$auto"}),
			fnReject,
			oRoomIdBinding,
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'3\')}">\
	<Input id="age" value="{AGE}"/>\
	<Input id="roomId" value="{ROOM_ID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('3')", {
				"@odata.etag" : "ETag0",
				ID : "3",
				AGE : 66,
				ROOM_ID : "2"
			})
			.expectChange("age", "66")
			.expectChange("roomId", "2");

		return this.createView(assert, sView, oModel).then(function () {
			oRoomIdBinding = that.oView.byId("roomId").getBinding("value");

			that.expectChange("age", "67")
				.expectChange("roomId", "42")
				.expectRequest({
					method : "PATCH",
					url : "EMPLOYEES('3')",
					headers : {"If-Match" : "ETag0"},
					payload : {
						AGE : 67,
						ROOM_ID : "42"
					}
				}, new Promise(function (_resolve, reject) {
					fnReject = reject;
				}));

			that.oView.byId("age").getBinding("value").setValue(67); // Happy Birthday!
			oRoomIdBinding.setValue("42");

			return that.waitForChanges(assert);
		}).then(function () {
			var sAction = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
				oPromise;

			function reject() {
				that.expectMessages([{
						code : "CODE",
						message : "Request intentionally failed",
						persistent : true,
						technical : true,
						type : "Error"
					}]);
				that.oLogMock.expects("error")
					.withArgs("Failed to update path /EMPLOYEES('3')/AGE");
				that.oLogMock.expects("error")
					.withArgs("Failed to update path /EMPLOYEES('3')/ROOM_ID");

				fnReject(createErrorInsideBatch());
			}

			that.expectRequest({
					batchNo : 3,
					method : "PATCH",
					url : "EMPLOYEES('3')",
					headers : {"If-Match" : "ETag0"},
					payload : {
						AGE : 67,
						ROOM_ID : "42"
					}
				}, {/* don't care */})
				.expectRequest({
					batchNo : 3,
					method : "POST",
					headers : {"If-Match" : "ETag0"},
					url : "EMPLOYEES('3')/" + sAction,
					payload : {TeamID : "23"}
				}, {/* don't care */});

			// bound action waits for PATCHes and invokes retry
			oPromise = that.oModel.bindContext(sAction + "(...)", oRoomIdBinding.getContext())
				.setParameter("TeamID", "23")
				.invoke("$auto");

			return Promise.all([
				oPromise.then(function (oReturnValueContext) {
					assert.strictEqual(oReturnValueContext, undefined,
						"no R.V.C. w/o key predicate");
				}),
				resolveLater(reject),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create entity for a ListBinding relative to a newly created entity
	QUnit.test("Create relative, on newly created entity", function (assert) {
		var oEmployeeCreatedContext,
			oModel = this.createTeaBusiModel(),
			oTable,
			oTeamCreatedContext,
			sView = '\
<FlexBox binding="{path : \'\',\
		parameters : {\
			$expand : {\
				\'TEAM_2_EMPLOYEES\' : {\
					$select : \'__CT__FAKE__Message/__FAKE__Messages,ID\'\
				}\
			}\
		}}" id="form">\
	<Table id="table" items="{TEAM_2_EMPLOYEES}">\
		<Input id="id" value="{ID}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("id", []);

		return this.createView(assert, sView, oModel).then(function () {
			// create a new team
			that.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {}
				}, {Team_Id : "23"});

			oTeamCreatedContext = oModel.bindList("/TEAMS").create({}, true);

			return Promise.all([
				oTeamCreatedContext.created(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oTeamCreatedContext.getPath(), "/TEAMS('23')");

			that.expectRequest("TEAMS('23')?$expand=TEAM_2_EMPLOYEES("
					+ "$select=__CT__FAKE__Message/__FAKE__Messages,ID)", {
					Team_Id : "23",
					TEAM_2_EMPLOYEES : [{
						ID : "3",
						__CT__FAKE__Message : {__FAKE__Messages : []}
					}]
				})
				.expectChange("id", ["3"])
				.expectMessages([]);

			that.oView.byId("form").setBindingContext(oTeamCreatedContext);

			return that.waitForChanges(assert);
		}).then(function () {
			// create new relative entity
			that.expectRequest({
					method : "POST",
					url : "TEAMS('23')/TEAM_2_EMPLOYEES",
					payload : {ID : null}
				}, {
					ID : "7",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "Enter an ID",
							numericSeverity : 3,
							target : "ID",
							transition : false
						}]
					}
				})
				.expectChange("id", [""]) // from setValue(null)
				.expectChange("id", ["7", "3"])
				.expectMessages([{
					code : "1",
					message : "Enter an ID",
					target : "/TEAMS('23')/TEAM_2_EMPLOYEES('7')/ID",
					type : "Warning"
				}]);

			oTable = that.oView.byId("table");
			oEmployeeCreatedContext = oTable.getBinding("items").create({ID : null}, true);

			return Promise.all([
				oEmployeeCreatedContext.created(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// the new one is at the top
			var oInput = oTable.getItems()[0].getCells()[0];

			assert.strictEqual(oEmployeeCreatedContext.getPath(),
				 "/TEAMS('23')/TEAM_2_EMPLOYEES('7')");
			assert.strictEqual(oInput.getBindingContext().getPath(),
				oEmployeeCreatedContext.getPath(), "we got the right input control");

			return that.checkValueState(assert, oInput, "Warning", "Enter an ID");
		});
	});

	//*********************************************************************************************
	// Scenario: if a 1 to n navigation occurs we use the deep path for this case instead of the
	// canonical path; the app can opt-out of this behavior with a binding specific parameter
	// CPOUI5UISERVICESV3-1567
	// Delete and Patch still use the canonical path. Messages have to be reported with the deep
	// path.
	// CPOUI5UISERVICESV3-1813
	// No "sap-cancel-on-close" header in DELETE request (JIRA: CPOUI5ODATAV4-2506)
	[false, true].forEach(function (bUseCanonicalPath) {
		QUnit.test("read with deep path, $$canonicalPath: " + bUseCanonicalPath, function (assert) {
			var sEntityPath = bUseCanonicalPath
					? "BusinessPartnerList('23')"
					: "SalesOrderList('0500000000')/SO_2_BP",
				oModel = this.createSalesOrdersModel({
					autoExpandSelect : true,
					groupId : "$direct"
				}),
				sParameters = bUseCanonicalPath
					? "parameters : {$$canonicalPath : true}"
					: "parameters : {$$ownRequest : true}",
				oTable,
				sView = '\
<FlexBox binding="{/SalesOrderList(\'0500000000\')/SO_2_BP}">\
	<Text text="{BusinessPartnerID}"/>\
	<FlexBox binding="{path : \'\',\
		' + sParameters + '\
		}">\
		<layoutData><FlexItemData/></layoutData>\
		<Text id="street" text="{Address/Street}"/>\
	</FlexBox>\
	<Table id="table" items="{path : \'BP_2_PRODUCT\', ' + sParameters + '\ }">\
		<Text text="{ProductID}"/>\
		<Input value="{Name}"/>\
	</Table>\
</FlexBox>',
				that = this;

			this.expectRequest("SalesOrderList('0500000000')/SO_2_BP?$select=BusinessPartnerID", {
					BusinessPartnerID : "23"
				})
				.expectRequest(sEntityPath + "?$select=Address/Street,BusinessPartnerID", {
					Address : {Street : "Bakerstreet"},
					BusinessPartnerID : "23"
				})
				.expectRequest(sEntityPath + "/BP_2_PRODUCT?$select=Name,ProductID&$skip=0"
					+ "&$top=100", {
					value : [{
						"@odata.etag" : "ETag",
						ProductID : "1",
						Name : "NoName"
					}]
				});

			return this.createView(assert, sView, oModel).then(function () {
				var oError = createError({
						code : "top_patch",
						message : "Error occurred while processing the request",
						details : [{
							code : "bound_patch",
							message : "Must not change mock data",
							"@Common.longtextUrl" : "Messages(1)/LongText",
							"@Common.numericSeverity" : 4,
							target : "Name"
						}]
					});

				oTable = that.oView.byId("table");

				that.oLogMock.expects("error").twice() // Note: twice, w/ different class name :-(
					.withArgs("Failed to update path /SalesOrderList('0500000000')/SO_2_BP/"
						+ "BP_2_PRODUCT('1')/Name", sinon.match(oError.message));
				that.expectRequest({
						method : "PATCH",
						url : "ProductList('1')",
						headers : {"If-Match" : "ETag"},
						payload : {Name : "A product with no name"}
					}, oError)
					.expectMessages([{
						code : "top_patch",
						message : "Error occurred while processing the request",
						persistent : true,
						technical : true,
						type : "Error"
					}, {
						code : "bound_patch",
						descriptionUrl : sSalesOrderService + "Messages(1)/LongText",
						message : "Must not change mock data",
						persistent : true,
						target : "/SalesOrderList('0500000000')/SO_2_BP/BP_2_PRODUCT('1')/Name",
						type : "Error"
					}]);

				// code under test
				oTable.getItems("items")[0].getCells()[1].getBinding("value")
					.setValue("A product with no name");

				return that.waitForChanges(assert);
			}).then(function () {
				var oInput = oTable.getItems("items")[0].getCells()[1];

				return that.checkValueState(assert, oInput, "Error", "Must not change mock data");
			}).then(function () {
				var oError = createError({
						code : "top_delete",
						message : "Error occurred while processing the request",
						details : [{
							code : "bound_delete",
							message : "Must not delete mock data",
							"@Common.longtextUrl" : "./Messages(1)/LongText",
							"@Common.numericSeverity" : 4,
							target : ""
						}]
					});

				that.oLogMock.expects("error").withExactArgs("Failed to delete"
						+ " /SalesOrderList('0500000000')/SO_2_BP/BP_2_PRODUCT('1')",
						sinon.match(oError.message), sContext);
				that.expectRequest({
						method : "DELETE",
						url : "ProductList('1')",
						headers : {"If-Match" : "ETag"/*, NO "sap-cancel-on-close" */}
					}, oError)
					.expectMessages([{
						code : "top_delete",
						message : "Error occurred while processing the request",
						persistent : true,
						technical : true,
						type : "Error"
					}, {
						code : "bound_delete",
						descriptionUrl : sSalesOrderService + "Messages(1)/LongText",
						message : "Must not delete mock data",
						persistent : true,
						target : "/SalesOrderList('0500000000')/SO_2_BP/BP_2_PRODUCT('1')",
						type : "Error"
					}]);

				Messaging.removeAllMessages();

				return Promise.all([
					// code under test
					oTable.getBinding("items").getCurrentContexts()[0].delete()
						.then(mustFail(assert), function (oError0) {
							assert.strictEqual(oError0, oError);
						}),
					that.waitForChanges(assert)
				]);
			}).then(function () {
				that.expectRequest({
						method : "PATCH",
						url : "ProductList('1')",
						headers : {"If-Match" : "ETag"},
						payload : {Name : "A product name leads to PATCH success with a message"}
					}, {
						// "@odata.etag" : "ETag2",
						Name : "A product name (from server)",
						Messages : [{
							code : "23",
							message : "Enter a product name",
							numericSeverity : 3,
							target : "Name"
						}]
					})
					.expectMessages([{
						code : "23",
						message : "Enter a product name",
						target : "/SalesOrderList('0500000000')/SO_2_BP/BP_2_PRODUCT('1')/Name",
						type : "Warning"
					}]);

				Messaging.removeAllMessages();

				// code under test
				oTable.getItems("items")[0].getCells()[1].getBinding("value")
					.setValue("A product name leads to PATCH success with a message");

				return that.waitForChanges(assert);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Dependent binding uses $$canonicalPath; hasPendingChanges and refresh consider
	// caches of the dependent binding.
	// CPOUI5UISERVICESV3-1706
	QUnit.test("hasPendingChanges and refresh with $$canonicalPath", function (assert) {
		var oBusinessPartnerContext,
			oBusinessPartnerList,
			oForm,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			sView = '\
<Table id="businessPartnerList" items="{/BusinessPartnerList}">\
	<Text id="businessPartnerID" text="{BusinessPartnerID}"/>\
</Table>\
<FlexBox id="form" binding="{BP_2_SO(\'42\')}">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\', parameters : {$$canonicalPath : true}}">\
		<Text id="productID" text="{ProductID}"/>\
		<Input id="note" value="{Note}"/>\
	</Table>\
	<FlexBox binding="{path : \'SO_2_BP/BP_2_SO(\\\'23\\\')\',\
			parameters : {$$canonicalPath : true}}">\
		<Input id="billingStatus" value="{BillingStatus}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		function checkPendingChanges() {
			assert.strictEqual(oBusinessPartnerList.getBinding("items").hasPendingChanges(), true);
			assert.strictEqual(oBusinessPartnerContext.hasPendingChanges(), true);
		}

		function clearDetails() {
			that.expectChange("billingStatus", null)
				.expectChange("note", [])
				.expectChange("productID", [])
				.expectChange("salesOrderID", null);

			oForm.setBindingContext(null);
		}

		function expectDetailRequests() {
			// Note: this is requested anyway by autoExpandSelect, thus we might as well show it
			that.expectRequest("BusinessPartnerList('0500000000')/BP_2_SO('42')"
					+ "?$select=SalesOrderID", {
					SalesOrderID : "42"
				})
				.expectRequest("SalesOrderList('42')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Note,ProductID,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : "10",
						Note : "Notebook Basic 15",
						ProductID : "HT-1000",
						SalesOrderID : "42"
					}, {
						ItemPosition : "20",
						Messages : [{
							code : "23",
							message : "Just a test",
							numericSeverity : 3,
							target : "Note"
						}],
						Note : "ITelO Vault",
						ProductID : "HT-1007",
						SalesOrderID : "42"
					}]
				})
				.expectRequest("SalesOrderList('42')/SO_2_BP/BP_2_SO('23')"
					+ "?$select=BillingStatus,SalesOrderID", {
					BillingStatus : "UNKNOWN",
					Messages : [{
						code : "00",
						message : "Unknown billing status",
						numericSeverity : 3,
						target : "BillingStatus"
					}],
					SalesOrderID : "23"
				})
				.expectMessages([{
					code : "23",
					message : "Just a test",
					target : "/BusinessPartnerList('0500000000')/BP_2_SO('42')"
						+ "/SO_2_SOITEM(SalesOrderID='42',ItemPosition='20')/Note",
					type : "Warning"
				}, {
					code : "00",
					message : "Unknown billing status",
					target : "/BusinessPartnerList('0500000000')/BP_2_SO('42')"
						+ "/SO_2_BP/BP_2_SO('23')/BillingStatus",
					type : "Warning"
				}]);
		}

		function selectFirst() {
			that.expectChange("billingStatus", "UNKNOWN")
				.expectChange("note", ["Notebook Basic 15", "ITelO Vault"])
				.expectChange("productID", ["HT-1000", "HT-1007"])
				.expectChange("salesOrderID", "42");

			oForm.setBindingContext(oBusinessPartnerContext);
		}

		this.expectRequest("BusinessPartnerList?$select=BusinessPartnerID&$skip=0&$top=100", {
				value : [{BusinessPartnerID : "0500000000"}]
			})
			.expectChange("billingStatus")
			.expectChange("businessPartnerID", ["0500000000"])
			.expectChange("note", [])
			.expectChange("productID", [])
			.expectChange("salesOrderID");

		return this.createView(assert, sView, oModel).then(function () {
			oForm = that.oView.byId("form");
			oBusinessPartnerList = that.oView.byId("businessPartnerList");
			oBusinessPartnerContext = oBusinessPartnerList.getItems()[0].getBindingContext();

			expectDetailRequests();
			selectFirst();

			return that.waitForChanges(assert);
		}).then(function () {
			var oInput;

			oTable = that.oView.byId("table");
			oInput = oTable.getItems()[1].getCells()[1];

			return that.checkValueState(assert, oInput, "Warning", "Just a test");
		}).then(function () {
			return that.checkValueState(assert, "billingStatus", "Warning",
				"Unknown billing status");
		}).then(function () {
			clearDetails();

			return that.waitForChanges(assert);
		}).then(function () {
			// set context for details again - take values from cache
			selectFirst();

			return that.waitForChanges(assert);
		}).then(function () {
			clearDetails();

			return that.waitForChanges(assert);
		}).then(function () {
			// refresh business partner
			that.expectRequest("BusinessPartnerList('0500000000')?$select=BusinessPartnerID", {
					BusinessPartnerID : "0500000000"
				})
				.expectMessages([]);

			oBusinessPartnerContext.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			// set context for details again - don't use cached data
			expectDetailRequests();
			selectFirst();

			return that.waitForChanges(assert);
		}).then(function () {
			// change value in details
			that.expectChange("note", ["Foo"]);

			// Note: cannot call Input#setValue because of that.setFormatter
			oTable.getItems()[0].getCells()[1].getBinding("value").setValue("Foo");

			checkPendingChanges();

			return that.waitForChanges(assert);
		}).then(function () {
			// clear details and check pending changes
			clearDetails();
			checkPendingChanges();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: unnecessary context bindings to confuse auto-$expand/$select
	QUnit.skip("CPOUI5UISERVICESV3-1677: Avoid unnecessary $expand", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{BestFriend}">\
		<FlexBox binding="{_Friend(ArtistID=\'42\',IsActiveEntity=true)}">\
		</FlexBox>\
	</FlexBox>\
</FlexBox>';

		//TODO avoid the following $expand
		// + "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
		// + ";$expand=_Friend($select=ArtistID,IsActiveEntity))"
		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity", {
				ArtistID : "42",
				IsActiveEntity : true
			})
			.expectChange("id", "42");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: context binding for :N navigation property using key predicate
	QUnit.skip("CPOUI5UISERVICESV3-1679: nav.prop. using key predicate", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}">\
	<Text id="id" text="{ArtistID}"/>\
	<FlexBox binding="{_Friend(ArtistID=\'23\',IsActiveEntity=true)}">\
		<Text id="friend" text="{ArtistID}"/>\
	</FlexBox>\
</FlexBox>';

		//TODO Failed to drill-down into _Friend(ArtistID='23',IsActiveEntity=true)/ArtistID
		// --> "friend" binding would need to send its own request!
		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity"
				//TODO CPOUI5UISERVICESV3-1677: Avoid unnecessary $expand
				+ "&$expand=_Friend($select=ArtistID,IsActiveEntity)", {
				ArtistID : "42",
				IsActiveEntity : true
			})
			.expectChange("id", "42")
			.expectChange("id", "23");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: A grid table shows a collection which completely resides in the parent binding's
	// cache. Auto-$expand/$select does not properly handle this case: "Price" is not selected.
	QUnit.skip("CPOUI5UISERVICESV3-1685: autoExpandSelect with grid table", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}">\
	<Text id="id" text="{ArtistID}"/>\
	<t:Table rows="{_Publication}">\
		<Text id="price" text="{Price}"/>\
	</t:Table>\
</FlexBox>';

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity"
				+ "&$expand=_Publication($select=Price,PublicationID)", {
				ArtistID : "42",
				IsActiveEntity : true,
				_Publication : [{
					Price : "9.99",
					PublicationID : "42-0"
				}]
			})
			.expectChange("id", "42")
			.expectChange("price", ["9.99"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: property binding with "##"-path pointing to a meta model property.
	// CPOUI5UISERVICESV3-1676
	testViewStart("Property binding with metapath", '\
<FlexBox binding="{/Artists(\'42\')}">\
	<Text id="label0" text="{Name##@com.sap.vocabularies.Common.v1.Label}"/>\
	<Text id="name" text="{Name}"/>\
</FlexBox>\
<Text id="insertable"\
	text="{/Artists##@Org.OData.Capabilities.V1.InsertRestrictions/Insertable}"/>\
<Text id="label1" text="{/Artists##/@com.sap.vocabularies.Common.v1.Label}"/>',
		{"Artists('42')?$select=ArtistID,IsActiveEntity,Name" : {
			//ArtistID : ..., IsActiveEntity : ...
			Name : "Foo"
		}},
		{label0 : "Artist Name", name : "Foo", insertable : true, label1 : "Artist"},
		function () {
			return this.createSpecialCasesModel({autoExpandSelect : true});
		}
	);

	//*********************************************************************************************
	// Scenario: Metadata property binding with target type any represented as a part %{...}
	// in an expression binding where the property binding has an object value.
	// CPOUI5UISERVICESV3-1676
	testViewStart("Metadata property binding with object value", '\
<Text id="insertable"\
	text="{:= %{/Artists##@Org.OData.Capabilities.V1.InsertRestrictions}.Insertable }"/>',
		/* no data request*/ undefined,
		{insertable : true},
		function () {
			return this.createSpecialCasesModel({autoExpandSelect : true});
		}
	);

	//*********************************************************************************************
	// Scenario: Relative data property binding with target type any represented as a part %{...}
	// in an expression binding where the property binding refers to a navigation property and thus
	// has an object value.
	// CPOUI5UISERVICESV3-1676
	testViewStart("Relative data property binding with object value", '\
<FlexBox binding="{/Artists(\'42\')}">\
	<Text id="publicationCount" text="{:= %{_Publication}.length }"/>\
</FlexBox>',
		{"Artists('42')?$select=ArtistID,IsActiveEntity&$expand=_Publication($select=PublicationID)" : {
			//ArtistID : ..., IsActiveEntity : ...
			_Publication : [{/*PublicationID : ...*/}, {}, {}]
		}},
		{publicationCount : 3},
		function () {
			return this.createSpecialCasesModel({autoExpandSelect : true});
		}
	);

	//*********************************************************************************************
	// Scenario: list binding with auto-$expand/$select and filter (so that metadata is required to
	// build the query string), but the metadata could not be loaded (CPOUI5UISERVICESV3-1723)
	QUnit.test("Auto-$expand/$select with dynamic filter, but no metadata", function (assert) {
		var oModel, sView;

		oModel = this.createModel("/invalid/model/", {autoExpandSelect : true}, {
			"/invalid/model/$metadata" : {code : 500}
		});
		sView = '\
<Table items="{path : \'/Artists\', \
		filters : {path : \'IsActiveEntity\', operator : \'EQ\', value1 : \'true\'}}">\
	<Text id="id" text="{path : \'ID\', type : \'sap.ui.model.odata.type.String\'}"/>\
</Table>';

		this.oLogMock.restore();
		this.stub(Log, "error"); // the exact follow-up errors do not interest
		this.expectMessages([{
				message : "Could not load metadata: 500 Internal Server Error",
				persistent : true,
				technical : true,
				type : "Error"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			// check that the first error message complains about the metadata access
			sinon.assert.calledWithExactly(Log.error.firstCall, "GET /invalid/model/$metadata",
				"Could not load metadata: 500 Internal Server Error",
				"sap.ui.model.odata.v4.lib._MetadataRequestor");
		});
	});

	//*********************************************************************************************
	// Scenario: Display a measure with unit using the customizing loaded from the back end
	// based on the "com.sap.vocabularies.CodeList.v1.UnitsOfMeasure" on the service's entity
	// container.
	// CPOUI5UISERVICESV3-1711
	// Scenario 2: With the binding parameter <code>$$ignoreMessages</code> the application
	// developer can control whether model messages are displayed at the control. For
	// <code>sap.ui.model.odata.type.Currency</code> and <code>sap.ui.model.odata.type.Unit</code>
	// the parameter <code>$$ignoreMessages</code> is determined automatically based on the format
	// option <code>showMeasure</code>. Manual setting of <code>$$ignoreMessages</code> wins over
	// automatic determination.
	// No own test as unit value list is cached in a private cache
	// JIRA: CPOUI5MODELS-302
	// Transport sap-language (BCP: 2270119565)
	// Show that the amount scale is used instead of the unit decimal places. Change the type of the
	// binding part for the amount to see that this is also considered in the output format.
	// JIRA: CPOUI5MODELS-1606
	QUnit.test("OData Unit type considering unit customizing", function (assert) {
		var oControl,
			oModel = this.createModel(sSalesOrderService + "?sap-client=123", {
				autoExpandSelect : true,
				metadataUrlParams : {"sap-context-token" : "foo", "sap-language" : "EN"}
			}, {
				"/sap/opu/odata4/sap/zui5_testv4/default/sap/zui5_epm_sample/0002/$metadata?sap-client=123&sap-context-token=foo&sap-language=EN"
					: {source : "odata/v4/data/metadata_zui5_epm_sample.xml"},
				"/sap/opu/odata4/sap/zui5_testv4/default/iwbep/common/0001/$metadata?sap-language=EN"
					: {source : "odata/v4/data/metadata_codelist.xml"}
			}),
			sView = '\
<FlexBox binding="{/ProductList(\'HT-1000\')}">\
	<Input id="weight" value="{parts: [\'WeightMeasure\', \'WeightUnit\',\
					{path : \'/##@@requestUnitsOfMeasure\',\
						mode : \'OneTime\', targetType : \'any\'}],\
				mode : \'TwoWay\',\
				type : \'sap.ui.model.odata.type.Unit\'}"/>\
	<Text id="weightMeasure" text="{WeightMeasure}"/>\
	<!-- for CPOUI5MODELS-302 -->\
	<Input id="weight0" value="{\
		formatOptions : {showMeasure : false},\
		mode : \'TwoWay\',\
		parts: [\'WeightMeasure\', \'WeightUnit\',\
			{mode : \'OneTime\', path : \'/##@@requestUnitsOfMeasure\', targetType : \'any\'}],\
		type : \'sap.ui.model.odata.type.Unit\'}"/>\
	<Input id="weight1" value="{\
		formatOptions : {showMeasure : false},\
		mode : \'TwoWay\',\
		parts: [\
			\'WeightMeasure\',\
			{parameters : {$$ignoreMessages : false}, path : \'WeightUnit\'},\
			{mode : \'OneTime\', path : \'/##@@requestUnitsOfMeasure\', targetType : \'any\'}\
		],\
		type : \'sap.ui.model.odata.type.Unit\'}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("ProductList(\'HT-1000\')?sap-client=123"
			+ "&$select=ProductID,WeightMeasure,WeightUnit", {
				"@odata.etag" : "ETag",
				ProductID : "HT-1000",
				WeightMeasure : "12.34",
				WeightUnit : "KG"
			})
			.expectRequest("UnitsOfMeasure?sap-language=EN"
				+ "&$select=ExternalCode,DecimalPlaces,Text,ISOCode", {
				value : [{
					DecimalPlaces : 5,
					ExternalCode : "KG",
					ISOCode : "KGM",
					Text : "Kilogramm",
					UnitCode : "KG"
				}]
			})
			.expectChange("weightMeasure", "12.340") // Scale=3 in property metadata => 3 decimals
			.expectChange("weight", "12.340 KG")
			.expectChange("weight0", "12.340")
			.expectChange("weight1", "12.340");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectMessages([{
					code : "42",
					message : "Warning for WeightUnit",
					target : "/ProductList('HT-1000')/WeightUnit",
					type : "Warning"
				}]);

			// simulate messages for unit of measure as sales order model does not declare a message
			// property for products
			oModel.reportStateMessages("ProductList", {
				"" : [{
					code : "42",
					message : "Warning for WeightUnit",
					numericSeverity : 3,
					target : "('HT-1000')/WeightUnit",
					transition : false
				}]
			}, []);

			return that.waitForChanges(assert);
		}).then(function () {
			return Promise.all([
				that.checkValueState(assert, "weight", "Warning", "Warning for WeightUnit"),
				that.checkValueState(assert, "weight0", "None", ""),
				that.checkValueState(assert, "weight1", "Warning", "Warning for WeightUnit"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectMessages([]);
			// remove model messages again
			oModel.reportStateMessages("ProductList", {});
		}).then(function () {
			oControl = that.oView.byId("weight");

			that.expectChange("weight", "23.400 KG")
				.expectChange("weight0", "23.400")
				.expectChange("weight1", "23.400")
				.expectChange("weightMeasure", "23.400")
				.expectRequest({
					method : "PATCH",
					url : "ProductList('HT-1000')?sap-client=123",
					headers : {"If-Match" : "ETag"},
					payload : {WeightMeasure : "23.4", WeightUnit : "KG"}
				});

			oControl.getBinding("value").setRawValue(["23.4", "KG"]);

			return that.waitForChanges(assert);
		}).then(function () {
			// this change happens twice because PropertyBinding#setType fires change via
			// fnTypeChangedCallback and v4.ODataPropertyBinding#setType itself fires changes also.
			// This is ok because the usecase for changing a binding part's type of a composite
			// binding is very rare.
			that.expectChange("weight", "23.40 KG")
				.expectChange("weight", "23.40 KG");

			// code under test: change scale of amount part from 3 to 2
			oControl.getBinding("value").getBindings()[0].setType(
				new Decimal(undefined, {precision : 13, scale : 2}));

			return that.waitForChanges(assert, "JIRA: CPOUI5MODELS-1606");
		}).then(function () {
			that.expectChange("weight", "34.51 KG")
				.expectChange("weightMeasure", "34.510")
				.expectChange("weight0", "34.510")
				.expectChange("weight1", "34.510")
				.expectRequest({
					method : "PATCH",
					url : "ProductList('HT-1000')?sap-client=123",
					headers : {"If-Match" : "ETag"},
					payload : {WeightMeasure : "34.51", WeightUnit : "KG"}
				});

			// code under test: for amount change the event for "weight" happens only once
			oControl.getBinding("value").setRawValue(["34.51", "KG"]);

			return that.waitForChanges(assert, "JIRA: CPOUI5MODELS-1606");
		}).then(function () {
			that.expectChange("weightMeasure", "0.000")
				.expectChange("weight0", "0.000")
				.expectChange("weight1", "0.000")
				.expectRequest({
					method : "PATCH",
					url : "ProductList('HT-1000')?sap-client=123",
					headers : {"If-Match" : "ETag"},
					payload : {WeightMeasure : "0", WeightUnit : "KG"}
				});

			// remove the formatter so that we can call setValue at the control
			oControl.getBinding("value").setFormatter(null);

			// code under test
			oControl.setValue("");

			return that.waitForChanges(assert);
		}).then(function () {
			// Check that the previous setValue led to the correct result
			assert.strictEqual(oControl.getValue(), "0.00 KG");

			that.expectMessages([{
					message : "EnterNumberFraction 5",
					target : oControl.getId() + "/value",
					type : "Error"
				}]);

			TestUtils.withNormalizedMessages(function () {
				// code under test
				oControl.setValue("12.123456 KG");
			});

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, oControl, "Error", "EnterNumberFraction 5");
		});
	});

	//*********************************************************************************************
	// Scenario: Display an amount with currency using the customizing loaded from the back end
	// based on the "com.sap.vocabularies.CodeList.v1.CurrencyCodes" on the service's entity
	// container.
	// CPOUI5UISERVICESV3-1733
	// Scenario 2: With the binding parameter <code>$$ignoreMessages</code> the application
	// developer can control whether model messages are displayed at the control. For
	// <code>sap.ui.model.odata.type.Currency</code> and <code>sap.ui.model.odata.type.Unit</code>
	// the parameter <code>$$ignoreMessages</code> is determined automatically based on the format
	// option <code>showMeasure</code>. Manual setting of <code>$$ignoreMessages</code> wins over
	// automatic determination.
	// No own test as currency value list is cached in a private cache
	// JIRA: CPOUI5MODELS-302
	// Transport sap-language (BCP: 2270119565)
	QUnit.test("OData Currency type considering currency customizing", function (assert) {
		var oControl,
			oModel = this.createModel(sSalesOrderService + "?sap-client=123", {
				autoExpandSelect : true,
				metadataUrlParams : {"sap-context-token" : "foo", "sap-language" : "EN"}
			}, {
				"/sap/opu/odata4/sap/zui5_testv4/default/sap/zui5_epm_sample/0002/$metadata?sap-client=123&sap-context-token=foo&sap-language=EN"
					: {source : "odata/v4/data/metadata_zui5_epm_sample.xml"},
				"/sap/opu/odata4/sap/zui5_testv4/default/iwbep/common/0001/$metadata?sap-language=EN"
					: {source : "odata/v4/data/metadata_codelist.xml"}
			}),
			sView = '\
<FlexBox binding="{/ProductList(\'HT-1000\')}">\
	<Input id="price" value="{parts: [\'Price\', \'CurrencyCode\',\
					{path : \'/##@@requestCurrencyCodes\',\
						mode : \'OneTime\', targetType : \'any\'}],\
				mode : \'TwoWay\',\
				type : \'sap.ui.model.odata.type.Currency\'}"/>\
	<Text id="amount" text="{Price}"/>\
	<!-- for CPOUI5MODELS-302 -->\
	<Input id="price0" value="{\
		formatOptions : {showMeasure : false},\
		mode : \'TwoWay\',\
		parts: [\'Price\', \'CurrencyCode\',\
			{mode : \'OneTime\', path : \'/##@@requestCurrencyCodes\', targetType : \'any\'}],\
		type : \'sap.ui.model.odata.type.Currency\'}"/>\
	<Input id="price1" value="{\
		formatOptions : {showMeasure : false},\
		mode : \'TwoWay\',\
		parts: [\
			\'Price\',\
			{parameters : {$$ignoreMessages : false}, path : \'CurrencyCode\'},\
			{mode : \'OneTime\', path : \'/##@@requestCurrencyCodes\', targetType : \'any\'}],\
		type : \'sap.ui.model.odata.type.Currency\'}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("ProductList(\'HT-1000\')?sap-client=123"
			+ "&$select=CurrencyCode,Price,ProductID", {
				"@odata.etag" : "ETag",
				ProductID : "HT-1000",
				Price : "12.3",
				CurrencyCode : "EUR"
			})
			.expectRequest("Currencies?sap-language=EN"
				+ "&$select=CurrencyCode,DecimalPlaces,Text,ISOCode", {
				value : [{
					CurrencyCode : "EUR",
					DecimalPlaces : 2,
					ISOCode : "EUR",
					Text : "Euro"
				}, {
					CurrencyCode : "JPY",
					DecimalPlaces : 0,
					ISOCode : "JPY",
					Text : "Yen"
				}]
			})
			.expectChange("amount", "12.3")
			.expectChange("price", "12.30\u00a0EUR") // "\u00a0" is a non-breaking space
			.expectChange("price0", "12.30")
			.expectChange("price1", "12.30");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectMessages([{
					code : "43",
					message : "Info for CurrencyCode",
					target : "/ProductList('HT-1000')/CurrencyCode",
					type : "Information"
				}]);

			// simulate messages for currency code as sales order model does not declare a message
			// property for products
			oModel.reportStateMessages("ProductList", {
				"" : [{
					code : "43",
					message : "Info for CurrencyCode",
					numericSeverity : 2,
					target : "('HT-1000')/CurrencyCode",
					transition : false
				}]
			}, []);

			return that.waitForChanges(assert);
		}).then(function () {
			return Promise.all([
				that.checkValueState(assert, "price", "Information", "Info for CurrencyCode"),
				that.checkValueState(assert, "price0", "None", ""),
				that.checkValueState(assert, "price1", "Information", "Info for CurrencyCode"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectMessages([]);
			// remove model messages again
			oModel.reportStateMessages("ProductList", {});
		}).then(function () {
			//TODO get rid of first change event which is due to using setRawValue([...]) on the
			//  composite binding. Solution idea: change integration test framework to not use
			//  formatters but overwrite formatValue on the binding's type if ever possible. Without
			//  formatters, one can then set the value on the control.
			that.expectChange("price", "42.00\u00a0EUR")
				.expectChange("price", "42\u00a0JPY")
				.expectChange("price0", "42.00")
				.expectChange("price0", "42")
				.expectChange("price1", "42.00")
				.expectChange("price1", "42")
				.expectChange("amount", "42")
				.expectRequest({
					method : "PATCH",
					url : "ProductList('HT-1000')?sap-client=123",
					headers : {"If-Match" : "ETag"},
					payload : {Price : "42", CurrencyCode : "JPY"}
				});

			that.oView.byId("price").getBinding("value").setRawValue(["42", "JPY"]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("amount", "0")
				.expectChange("price0", "0")
				.expectChange("price1", "0")
				.expectRequest({
					method : "PATCH",
					url : "ProductList('HT-1000')?sap-client=123",
					headers : {"If-Match" : "ETag"},
					payload : {Price : "0", CurrencyCode : "JPY"}
				});

			oControl = that.oView.byId("price");
			// remove the formatter so that we can call setValue at the control
			oControl.getBinding("value").setFormatter(null);

			// code under test
			oControl.setValue("");

			return that.waitForChanges(assert);
		}).then(function () {
			// Check that the previous setValue led to the correct result
			assert.strictEqual(oControl.getValue(), "0\u00a0JPY");

			that.expectMessages([{
					message : "EnterInt",
					target : oControl.getId() + "/value",
					type : "Error"
				}]);

			TestUtils.withNormalizedMessages(function () {
				// code under test
				oControl.setValue("12.1");
			});

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, oControl, "Error", "EnterInt");
		});
	});
	//TODO With updateGroupId $direct, changing *both* parts of a composite binding (amount and
	//  currency) in one step invokes *two* PATCH requests:
	//  The first request contains the new amount and also the old currency as PATCHes for amounts
	//  are always sent with currency.
	//  The second request only contains the new currency.
	//  Solution idea: Only invoke $direct requests in prerendering task
	//  Is this critical? - Productive scenario runs with $batch. However: What if amount and
	//  currency are in two different fields in draft scenario (no save button)?

	//*********************************************************************************************
	// Scenario: Request value list information for an action's parameter.
	// BCP: 1970116818
	// JIRA: CPOUI5UISERVICESV3-1744
	QUnit.test("Value help at action parameter", function (assert) {
		var oModel = this.createSpecialCasesModel({}, {
				"/special/countryoforigin/$metadata"
					: {source : "odata/v4/data/metadata_countryoforigin.xml"}
			}),
			sPropertyPath = "/Artists/special.cases.Create/Countryoforigin";

		return oModel.getMetaModel().requestValueListType(sPropertyPath)
			.then(function (sValueListType) {
				assert.strictEqual(sValueListType, ValueListType.Fixed);

				return oModel.getMetaModel().requestValueListInfo(sPropertyPath);
			}).then(function (mQualifier2ValueList) {
				assert.strictEqual(mQualifier2ValueList[""].$model.toString(),
					"sap.ui.model.odata.v4.ODataModel: /special/countryoforigin/");
				delete mQualifier2ValueList[""].$model;
				assert.deepEqual(mQualifier2ValueList, {
					"" : {
						$qualifier : "",
						CollectionPath : "I_AIVS_CountryCode",
						Label : "Country Code Value Help",
						Parameters : [{
							$Type : "com.sap.vocabularies.Common.v1.ValueListParameterInOut",
							LocalDataProperty : {
								$PropertyPath : "Countryoforigin"
							},
							ValueListProperty : "CountryCode"
						}]
					}
				});
			});
	});

	//*********************************************************************************************
	// Scenario: Request value list information for a parameter of a bound action via annotations
	// with targets in 4.01 syntax and ValueListType.Fixed.
	// JIRA: CPOUI5ODATAV4-54
	QUnit.test("Value help at bound action parameter, 4.01 syntax, fixed", function (assert) {
		var oModel = this.createSpecialCasesModel({}, {
				"/special/CurrencyCode/$metadata"
					: {source : "odata/v4/data/metadata_CurrencyCode.xml"}
			}),
			oOperationBinding
				= oModel.bindContext("/Artists('42')/_Publication/special.cases.Create(...)"),
			oPropertyBinding
				= oModel.bindProperty("CurrencyCode", oOperationBinding.getParameterContext());

		return oModel.getMetaModel().requestData().then(function () {
			assert.strictEqual(oPropertyBinding.getValueListType(), ValueListType.Fixed);

			return oPropertyBinding.requestValueListInfo();
		}).then(function (mQualifier2ValueList) {
			assert.strictEqual(mQualifier2ValueList[""].$model.toString(),
				"sap.ui.model.odata.v4.ODataModel: /special/CurrencyCode/");
			delete mQualifier2ValueList[""].$model;
			assert.deepEqual(mQualifier2ValueList, {
				"" : {
					$qualifier : "",
					Label : "Publication's Currency"
				}
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Request value list information for a parameter of a bound action via annotations
	// with targets both in 4.0 and 4.01 syntax.
	// JIRA: CPOUI5ODATAV4-54
	QUnit.test("Value help at bound action parameter, 4.01 syntax, standard", function (assert) {
		var oModel = this.createSpecialCasesModel({}, {
				"/special/Price/$metadata"
					: {source : "odata/v4/data/metadata_Price.xml"}
			}),
			oOperationBinding
				= oModel.bindContext("/Artists('42')/_Publication/special.cases.Create(...)"),
			oPropertyBinding
				= oModel.bindProperty("Price", oOperationBinding.getParameterContext());

		return oModel.getMetaModel().requestData().then(function () {
			assert.strictEqual(oPropertyBinding.getValueListType(), ValueListType.Standard);

			return oPropertyBinding.requestValueListInfo();
		}).then(function (mQualifier2ValueList) {
			assert.strictEqual(mQualifier2ValueList[""].$model.toString(),
				"sap.ui.model.odata.v4.ODataModel: /special/Price/");
			delete mQualifier2ValueList[""].$model;
			assert.strictEqual(mQualifier2ValueList.A.$model.toString(),
				"sap.ui.model.odata.v4.ODataModel: /special/Price/");
			delete mQualifier2ValueList.A.$model;
			assert.strictEqual(mQualifier2ValueList.B.$model.toString(),
				"sap.ui.model.odata.v4.ODataModel: /special/Price/");
			delete mQualifier2ValueList.B.$model;
			assert.deepEqual(mQualifier2ValueList, {
				"" : {
					Label : "Price #"
				},
				A : {
					Label : "Price #A"
				},
				B : {
					Label : "Price #B"
				}
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Invoke a bound action on the target of a navigation property. That action returns
	// its binding parameter which is thus updated ("cache synchronization") and is the target of
	// messages.
	// CPOUI5UISERVICESV3-1587
	QUnit.test("bound action on navigation property updates binding parameter", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sResourcePath = "Artists(ArtistID='42',IsActiveEntity=true)/BestPublication",
			sView = '\
<FlexBox binding="{\
		path : \'/Artists(ArtistID=\\\'42\\\',IsActiveEntity=true)/BestPublication\',\
		parameters : {$select : \'Messages\'}\
	}" id="form">\
	<Input id="price" value="{Price}"/>\
</FlexBox>',
			that = this;

		this.expectRequest(sResourcePath + "?$select=Messages,Price,PublicationID", {
				PublicationID : "42-0",
				Price : "9.99"
			})
			.expectChange("price", "9.99");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("form").getObjectBinding().getBoundContext(),
				oOperation = that.oModel.bindContext("special.cases.PreparationAction(...)",
					oContext, {$$inheritExpandSelect : true});

			that.expectRequest({
				method : "POST",
				url : sResourcePath + "/special.cases.PreparationAction"
					+ "?$select=Messages,Price,PublicationID",
				payload : {}
			}, {
				Messages : [{
					code : "23",
					message : "Just A Message",
					numericSeverity : 1,
					target : "Price",
					transition : true
				}],
				PublicationID : "42-0",
				Price : "3.33"
			})
			.expectChange("price", "3.33")
			.expectMessages([{
				code : "23",
				message : "Just A Message",
				persistent : true,
				// Note: We cannot know whether PreparationAction changed the target of
				// BestPublication, but as long as the form still displays "42-0", we might as well
				// keep it up-to-date and show messages there...
				target : "/Artists(ArtistID='42',IsActiveEntity=true)/BestPublication/Price",
				type : "Success"
			}]);

			// code under test
			return Promise.all([
				oOperation.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "price", "Success", "Just A Message");
		});
	});

	//*********************************************************************************************
	// Scenario: Request side effects at a return value context leads to "duplicate" requests.
	// (Note: This is as expected, because two caches need to be updated!)
	// Avoid this by using the bound context of the binding with the empty path (a workaround by FE
	// for missing support of $expand at action POSTs). No fix required.
	// BCP: 1980108040
	QUnit.test("BCP: 1980108040", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oReturnValueContext,
			sView = '\
<FlexBox id="objectPage" binding="{path : \'\', parameters : {$$ownRequest : true}}">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("id")
			.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			var oListBinding = that.oModel.bindList("/Artists"),
				oHeaderContext = oListBinding.getHeaderContext(),
				oOperationBinding = that.oModel.bindContext("special.cases.Create(...)",
					oHeaderContext, {$$patchWithoutSideEffects : true});

			that.expectRequest({
				method : "POST",
				payload : {},
				url : "Artists/special.cases.Create"
			}, {
				ArtistID : "42",
				IsActiveEntity : false
			});

			return oOperationBinding.invoke();
		}).then(function (oReturnValueContext0) {
			oReturnValueContext = oReturnValueContext0;

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Name", {
					ArtistID : "42",
					IsActiveEntity : false,
					Name : ""
				})
				.expectChange("id", "42")
				.expectChange("name", "");

			that.oView.byId("objectPage").setBindingContext(oReturnValueContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)?$select=Name", {
					Name : "Hour Frustrated"
				})
				.expectChange("name", "Hour Frustrated");

			return Promise.all([
				// Note: do not use oReturnValueContext, it would invoke duplicate requests
				that.oView.byId("objectPage").getObjectBinding().getBoundContext()
					// code under test
					.requestSideEffects([{$PropertyPath : "Name"}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: List binding is destroyed while request is in flight. Gracefully ignore response.
	// Note: No such problem for context or property binding.
	// BCP: 1980173241
	QUnit.test("BCP: 1980173241", function (assert) {
		var fnRespond,
			sView = '\
<Table items="{/EMPLOYEES}">\
	<Text text="{ID}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$skip=0&$top=100", new Promise(function (resolve) {
				fnRespond = resolve.bind(null, {value : []});
			}));

		return this.createView(assert, sView).then(function () {
			that.expectCanceledError("Failed to get contexts for " + sTeaBusi
						+ "EMPLOYEES with start index 0 and length 100",
					sODLB + ": /EMPLOYEES is ignoring response from inactive cache: " + sTeaBusi
						+ "EMPLOYEES");

			that.oView.destroy();
			delete that.oView;

			fnRespond();

			return resolveLater(); // avoid timing issues ("Assertion occurred after test finished")
		});
	});

	//*********************************************************************************************
	// Scenario: POST is "in flight", GET request should wait for the POST's response because
	// exclusive $filter needs to be adjusted. Similarly, side effects should update the created
	// entity and thus must also wait.
	// JIRA: CPOUI5UISERVICESV3-1845
[function () {
	this.expectRequest("BusinessPartnerList?$select=BusinessPartnerID,CompanyName"
			+ "&$filter=not (BusinessPartnerID eq '4710')"
			+ "&$skip=2&$top=1", {
			value : [{
				BusinessPartnerID : "4713",
				CompanyName : "FooBar"
			}]
		})
		.expectChange("id", [,, "4712", "4713"])
		.expectChange("name", [,, "Bar", "FooBar"]);
	// show more items while POST is still pending
	this.oView.byId("table").requestItems();
}, function () {
	// Note: 4712 is discarded because it is currently not visible
	this.expectRequest("BusinessPartnerList?$select=BusinessPartnerID,CompanyName"
			+ "&$filter=BusinessPartnerID eq '4710' or BusinessPartnerID eq '4711'&$top=2", {
			value : [{
				BusinessPartnerID : "4710",
					CompanyName : "Baz*"
			}, {
				BusinessPartnerID : "4711",
					CompanyName : "Foo*"
			}]
		})
		.expectChange("name", ["Baz*", "Foo*"]);
	// request side effects while POST is still pending
	return Promise.all([
		this.oView.byId("table").getBinding("items").getHeaderContext()
			.requestSideEffects([{$PropertyPath : "CompanyName"}]),
		this.oModel.submitBatch("update")
	]);
}].forEach(function (fnCodeUnderTest, i) {
	QUnit.test("JIRA: CPOUI5UISERVICESV3-1845 - POST still pending, " + i, function (assert) {
		var oContext,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			fnRespond,
			oSubmitBatchPromise,
			sView = '\
<Table growing="true" growingThreshold="2" id="table" items="{/BusinessPartnerList}">\
	<Text id="id" text="{BusinessPartnerID}"/>\
	<Text id="name" text="{CompanyName}"/>\
</Table>',
			that = this;

		this.expectRequest("BusinessPartnerList?$select=BusinessPartnerID,CompanyName"
				+ "&$skip=0&$top=2", {
				value : [{
					BusinessPartnerID : "4711",
					CompanyName : "Foo"
				}, {
					BusinessPartnerID : "4712",
					CompanyName : "Bar"
				}]
			})
			.expectChange("id", ["4711", "4712"])
			.expectChange("name", ["Foo", "Bar"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "POST",
					payload : {},
					url : "BusinessPartnerList"
				}, new Promise(function (resolve) {
					fnRespond = resolve.bind(null, {
						BusinessPartnerID : "4710",
						CompanyName : "Baz"
					});
				}))
				.expectChange("id", [""])
				.expectChange("name", [""]);
			oContext = that.oView.byId("table").getBinding("items").create({}, true);
			oSubmitBatchPromise = that.oModel.submitBatch("update");

			return that.waitForChanges(assert);
		}).then(function () {
			var oPromise;

			that.expectChange("id", ["4710"])
				.expectChange("name", ["Baz"]);
			oPromise = fnCodeUnderTest.call(that);
			fnRespond();

			return Promise.all([
				oPromise,
				oSubmitBatchPromise,
				oContext.created(),
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: GET request is invoked before POST, but ends up inside same $batch and thus
	// could return the newly created entity.
	// JIRA: CPOUI5UISERVICESV3-1825
	//
	// Test ODLB#getCount
	// JIRA: CPOUI5ODATAV4-958
	QUnit.skip("JIRA: CPOUI5UISERVICESV3-1825 - GET & POST in same $batch", function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Text id="count" text="{$count}"/>\
<Table growing="true" growingThreshold="2" id="table"\
		items="{path : \'/BusinessPartnerList\', parameters : {$count : true}}">\
	<Text id="id" text="{BusinessPartnerID}"/>\
</Table>',
			that = this;

		this.expectRequest("BusinessPartnerList?$count=true&$select=BusinessPartnerID"
				+ "&$skip=0&$top=2", {
				"@odata.count" : "3",
				value : [{
					BusinessPartnerID : "4711"
				}, {
					BusinessPartnerID : "4712"
				}]
			})
			.expectChange("count")
			.expectChange("id", ["4711", "4712"]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");

			that.expectChange("count", "3");
			that.oView.byId("count").setBindingContext(oBinding.getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			var oContext;

			assert.strictEqual(oBinding.getCount(), 3, "count of elements");
			assert.strictEqual(oBinding.getLength(), 2, "length of the table");

			that.expectRequest({
					batchNo : 2,
					changeSetNo : 2,
					url : "BusinessPartnerList?$count=true&$select=BusinessPartnerID"
						+ "&$filter=not (BusinessPartnerID eq '4710')" //TODO this is missing!
						+ "&$skip=2&$top=1"
				}, {
					"@odata.count" : "3",
					value : [{BusinessPartnerID : "4713"}]
				});
			// show more items before POST is even invoked
			that.oView.byId("table").requestItems();

			that.expectChange("count", "4")
				.expectRequest({
					batchNo : 2,
					changeSetNo : 1, //TODO maybe this "reordering" is wrong (here)?
					method : "POST",
					payload : {},
					url : "BusinessPartnerList"
				}, {BusinessPartnerID : "4710"})
				.expectChange("id", ["4710",,, "4713"]);
			oContext = oBinding.create({}, true);

			return Promise.all([
				oContext.created(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Annotation target with parentheses to specify action overload
	// JIRA: CPOUI5UISERVICESV3-1844
	QUnit.test("Annotation target with parentheses to specify action overload", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true});

		return this.createView(assert, "", oModel).then(function () {
			return oModel.getMetaModel().requestData();
		}).then(function (oMetaData) {
			assert.deepEqual(
				oMetaData.$Annotations
					["special.cases.Create(Collection(special.cases.ArtistsType))/Countryoforigin"],
				{"@com.sap.vocabularies.Common.v1.Label" : "Country of Origin"});

			assert.strictEqual(oModel.getMetaModel().getObject("/Artists/special.cases.Create"
					+ "/Countryoforigin@com.sap.vocabularies.Common.v1.Label"),
				"Country of Origin", "specific overload wins");
			assert.strictEqual(oModel.getMetaModel().getObject("/Artists/special.cases.Create"
					+ "/Countryoforigin@com.sap.vocabularies.Common.v1.ValueListWithFixedValues"),
				true, "fallback to annotation for all overloads");
			assert.deepEqual(oModel.getMetaModel().getObject("/Artists/special.cases.Create"
					+ "/Countryoforigin@com.sap.vocabularies.Common.v1.ValueListReferences"),
				["../countryoforigin/$metadata"]);
		});
	});

	//*********************************************************************************************
	// Scenario: Use "ignoreAnnotationsFromMetadata" parameter. Check that annotations from an
	// annotation file are not ignored. Check that a value list model does not ignore annotations
	// from its metadata.
	// JIRA: CPOUI5ODATAV4-1925
	QUnit.test("ignoreAnnotationsFromMetadata: value list model", function (assert) {
		var oMetaModel,
			oModel = this.createSpecialCasesModel({
				annotationURI : "/special/cases/annotations.xml",
				autoExpandSelect : true,
				// code under test
				ignoreAnnotationsFromMetadata : true
			}, {
				"/special/cases/annotations.xml"
					: {source : "odata/v4/data/annotations_special_cases.xml"},
				"/special/countryoforigin/$metadata"
					: {source : "odata/v4/data/metadata_countryoforigin.xml"}
			}),
			oValueListMapping = { // from metadata_countryoforigin.xml
				CollectionPath : "I_AIVS_CountryCode",
				Label : "Country Code Value Help",
				Parameters : [{
					$Type : "com.sap.vocabularies.Common.v1.ValueListParameterInOut",
					LocalDataProperty : {
						$PropertyPath : "Countryoforigin"
					},
					ValueListProperty : "CountryCode"
				}]
			};

		return this.createView(assert, "", oModel).then(function () {
			oMetaModel = oModel.getMetaModel();

			return oMetaModel.requestData();
		}).then(function (mMetaData) {
			assert.deepEqual(mMetaData.$Annotations, { // from annotations_special_cases.xml
				"special.cases.Create/Countryoforigin" : {
					"@com.sap.vocabularies.Common.v1.ValueListReferences" : [
						"../countryoforigin/$metadata"
					]
				}
			}, "no annotations except from annotationURI");
			delete mMetaData.$Annotations;
			assert.notOk(JSON.stringify(mMetaData).includes("@"), "no inline annotations");

			return oMetaModel.requestValueListInfo("/Artists/special.cases.Create/Countryoforigin");
		}).then(function (mQualifier2ValueListType) {
			var oValueListModel = mQualifier2ValueListType[""].$model;

			delete mQualifier2ValueListType[""].$model;
			assert.deepEqual(mQualifier2ValueListType, {"" : oValueListMapping});

			return oValueListModel.getMetaModel().requestData();
		}).then(function (mValueListMetaData) {
			assert.deepEqual(mValueListMetaData.$Annotations, {
				"special.cases.Create/Countryoforigin" : {
					"@com.sap.vocabularies.Common.v1.ValueListMapping" : oValueListMapping
				}
			}, "annotations from metadata");
		});
	});

	//*********************************************************************************************
	// Scenario: Use "ignoreAnnotationsFromMetadata" parameter. Check that annotations from
	// metadata are also ignored for cross-service references.
	// JIRA: CPOUI5ODATAV4-1925
	QUnit.test("ignoreAnnotationsFromMetadata: cross-service references", function (assert) {
		// code under test
		var oMetaModel,
			oModel = this.createTeaBusiModel({ignoreAnnotationsFromMetadata : true});

		return this.createView(assert, "", oModel).then(function () {
			oMetaModel = oModel.getMetaModel();

			return oMetaModel.requestObject("/Equipments/EQUIPMENT_2_PRODUCT/SupplierIdentifier");
		}).then(function (mPropertyMetadata) {
			var mMetaData = oMetaModel.getData();

			assert.deepEqual(mPropertyMetadata, {
				$Nullable : false,
				$Type : "Edm.Int32",
				$kind : "Property"
			});
			assert.strictEqual(
				mMetaData["com.sap.gateway.default.iwbep.tea_busi.v0001."].$kind,
				"Schema");
			assert.strictEqual(
				mMetaData["com.sap.gateway.default.iwbep.tea_busi_product.v0001."].$kind,
				"Schema");
			assert.deepEqual(mMetaData.$Annotations, {}, "Look, ma - no annotations!");
			delete mMetaData.$Annotations;
			assert.notOk(JSON.stringify(mMetaData).includes("@"), "no inline annotations");
		});
	});

	//*********************************************************************************************
	// Scenario: Create on a relative binding with $expand refreshes the newly created entity so
	// that navigation properties are available. Context#refresh is then used.
	// JIRA: CPOUI5UISERVICESV3-1814
	QUnit.test("Create on a relative binding with $expand", function (assert) {
		var oCreatedContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			oTableBinding,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}">\
	<Text id="count" text="{headerContext>$count}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\', parameters : {$select : \'Messages\'}}">\
		<Text id="position" text="{ItemPosition}"/>\
		<Input id="quantity" value="{Quantity}"/>\
		<Input id="product" value="{SOITEM_2_PRODUCT/ProductID}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest({
				batchNo : 1,
				url : "SalesOrderList('1')?$select=SalesOrderID"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,Messages,Quantity,SalesOrderID;"
						+ "$expand=SOITEM_2_PRODUCT($select=ProductID))"
			}, {
				SalesOrderID : "1",
				SO_2_SOITEM : [{
					ItemPosition : "10",
					Messages : [],
					Quantity : "7",
					SalesOrderID : "1",
					SOITEM_2_PRODUCT : {ProductID : "2"}
				}]
			})
			.expectChange("count")
			.expectChange("position", ["10"])
			.expectChange("quantity", ["7.000"])
			.expectChange("product", ["2"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oTableBinding = oTable.getBinding("items");

			that.expectChange("count", "1");

			that.oView.setModel(that.oView.getModel(), "headerContext");
			that.oView.byId("count")
				.setBindingContext(oTableBinding.getHeaderContext(), "headerContext");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "SalesOrderList('1')/SO_2_SOITEM",
					payload : {}
				}, {
					SalesOrderID : "1",
					ItemPosition : "20"
				})
				.expectRequest({
					batchNo : 3,
					url : "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')"
						+ "?$select=ItemPosition,Messages,Quantity,SalesOrderID"
						+ "&$expand=SOITEM_2_PRODUCT($select=ProductID)"
				}, {
					ItemPosition : "20",
					Messages : [{
						code : "23",
						message : "Enter a minimum quantity of 2",
						numericSeverity : 3,
						target : "Quantity"
					}],
					Quantity : "0",
					SalesOrderID : "1",
					SOITEM_2_PRODUCT : {ProductID : "3"}
				})
				.expectChange("count", "2")
				// position becomes "" and product null, as _Cache#drillDown resolves with
				// null for ItemPosition and undefined for SOITEM_2_PRODUCT/ProductID. These values
				// are formatted differently by sap.ui.model.odata.type.String#formatValue
				.expectChange("position", ["", "10"])
				.expectChange("quantity", [null, "7.000"])
				.expectChange("product", ["", "2"])
				.expectChange("position", ["20"])
				.expectChange("quantity", ["0.000"])
				.expectChange("product", ["3"])
				.expectMessages([{
					code : "23",
					message : "Enter a minimum quantity of 2",
					target : "/SalesOrderList('1')"
						+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')/Quantity",
					type : "Warning"
				}]);

			// code under test
			oCreatedContext = oTableBinding.create();

			return Promise.all([
				oCreatedContext.created(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oQuantityField = oTable.getItems()[0].getCells()[1];

			return that.checkValueState(assert, oQuantityField, "Warning",
				"Enter a minimum quantity of 2");
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')"
					+ "?$select=ItemPosition,Messages,Quantity,SalesOrderID"
					+ "&$expand=SOITEM_2_PRODUCT($select=ProductID)", {
					ItemPosition : "20",
					Messages : [{
						code : "0815",
						message : "Best Product Ever",
						numericSeverity : 2,
						target : "SOITEM_2_PRODUCT/ProductID"
					}],
					Quantity : "2",
					SalesOrderID : "1",
					SOITEM_2_PRODUCT : {ProductID : "42"}
				})
				.expectChange("quantity", ["2.000"])
				.expectChange("product", ["42"])
				.expectMessages([{
					code : "0815",
					message : "Best Product Ever",
					target : "/SalesOrderList('1')"
						+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')"
						+ "/SOITEM_2_PRODUCT/ProductID",
					type : "Information"
				}]);

			return Promise.all([
				// code under test
				oCreatedContext.requestRefresh("$auto", false),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oProductField = oTable.getItems()[0].getCells()[2];

			return that.checkValueState(assert, oProductField, "Information", "Best Product Ever");
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Messages,Quantity,SalesOrderID"
					+ "&$expand=SOITEM_2_PRODUCT($select=ProductID)"
					+ "&$filter=SalesOrderID eq '1'", {
					value : [{ // simulate that entity still matches list's filter
						ItemPosition : "20",
						Messages : [{
							code : "0123",
							message : "Keep on buying!",
							numericSeverity : 1,
							target : "SOITEM_2_PRODUCT/ProductID"
						}],
						Quantity : "3",
						SalesOrderID : "1",
						SOITEM_2_PRODUCT : {ProductID : "42"}
					}]
				})
				.expectChange("quantity", ["3.000"])
				.expectMessages([{
					code : "0123",
					message : "Keep on buying!",
					target : "/SalesOrderList('1')"
						+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')"
						+ "/SOITEM_2_PRODUCT/ProductID",
					type : "Success"
				}]);

			return Promise.all([
				// code under test
				oCreatedContext.requestRefresh("$auto", true),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			var oProductField = oTable.getItems()[0].getCells()[2];

			return that.checkValueState(assert, oProductField, "Success", "Keep on buying!");
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Messages,Quantity,SalesOrderID"
					+ "&$expand=SOITEM_2_PRODUCT($select=ProductID)"
					+ "&$filter=SalesOrderID eq '1'", {
					value : [] // simulate that entity does not match list's filter anymore
				})
				.expectChange("count", "1")
				.expectChange("position", ["10"])
				.expectChange("quantity", ["7.000"])
				.expectChange("product", ["2"])
				.expectMessages([]); // message for removed row must disappear!

			return Promise.all([
				// code under test
				oCreatedContext.requestRefresh("$auto", true),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Call Context#setProperty for a property that is bound and has already been read
	// from the back end. The property binding is updated and a PATCH request is sent via update
	// group ID. The Server returns a bound message.
	// JIRA: CPOUI5UISERVICESV3-1790
	QUnit.test("Context#setProperty: read/write", function (assert) {
		var oPromise,
			that = this;

		return this.createSetPropertyScenario(assert).then(function (oContext) {
			that.expectChange("name", "Best Team Ever");

			// code under test
			oPromise = oContext.setProperty("Name", "Best Team Ever");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					payload : {Name : "Best Team Ever"},
					url : "TEAMS('TEAM_01')"
				}, {
					Name : "Best Team Ever",
					Team_Id : "TEAM_01",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "CODE",
							message : "What a stupid name!",
							numericSeverity : 3,
							target : "Name",
							transition : false
						}]
					}
				})
				.expectMessages([{
					code : "CODE",
					message : "What a stupid name!",
					target : "/TEAMS('TEAM_01')/Name",
					type : "Warning"
				}]);

			return Promise.all([
				that.oModel.submitBatch("update"),
				oPromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, "name", "Warning", "What a stupid name!");
		});
	});

	//*********************************************************************************************
	// Scenario: Call Context#setProperty for a property that is bound and has already been read
	// from the back end. The request fails and property and binding are reset.
	// BCP: 2070481590
	//
	// The error message is reported to the message model automatically.
	// JIRA: CPOUI5ODATAV4-1106
	QUnit.test("Context#setProperty: rejected", function (assert) {
		var oContext, oPromise,
			that = this;

		return this.createSetPropertyScenario(assert).then(function (oContext0) {
			that.expectChange("name", "Best Team Ever");

			// code under test
			oContext = oContext0;
			oPromise = oContext.setProperty("Name", "Best Team Ever");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					payload : {Name : "Best Team Ever"},
					url : "TEAMS('TEAM_01')"
				}, createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}])
				.expectChange("name", "Team #1");

			that.oLogMock.expects("error")
				.withExactArgs("Failed to update path /TEAMS('TEAM_01')/Name",
					sinon.match("Request intentionally failed"), sContext);

			return Promise.all([
				that.oModel.submitBatch("update"),
				oPromise.then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, "Request intentionally failed");
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oContext.getProperty("Name"), "Team #1");
			assert.notOk(that.oModel.hasPendingChanges("update"));
		});
	});

	//*********************************************************************************************
	// Scenario: Call Context#setProperty with bRetry for a property that is bound and has already
	// been read from the back end. The first request fails. When calling submitBatch again, a
	// second request is sent and succeeds.
	// BCP: 2070480907
	QUnit.test("Context#setProperty: bRetry", function (assert) {
		var oBinding,
			oContext,
			iPatchCompleted = 0,
			iPatchSent = 0,
			oPromise,
			that = this;

		return this.createSetPropertyScenario(assert).then(function (oContext0) {
			oContext = oContext0;
			oBinding = oContext.getBinding();

			that.expectChange("name", "Foo")
				.expectRequest({
					method : "PATCH",
					payload : {Name : "Foo"},
					url : "TEAMS('TEAM_01')"
				}, createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			that.oLogMock.expects("error")
				.withExactArgs("Failed to update path /TEAMS('TEAM_01')/Name",
					sinon.match("Request intentionally failed"), sContext);

			oBinding.attachPatchSent(function () {
				iPatchSent += 1;
			});
			oBinding.attachPatchCompleted(function (oEvent) {
				iPatchCompleted += 1;
				assert.strictEqual(oEvent.getParameter("success"), iPatchCompleted === 2);
			});

			// code under test
			oPromise = oContext.setProperty("Name", "Foo", undefined, true);

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oContext.getProperty("Name"), "Foo");
			assert.ok(that.oModel.hasPendingChanges("update"));
			assert.strictEqual(iPatchSent, 1);
			assert.strictEqual(iPatchCompleted, 1);

			that.expectRequest({
					method : "PATCH",
					payload : {Name : "Foo"},
					url : "TEAMS('TEAM_01')"
				});

			return Promise.all([
				// code under test
				that.oModel.submitBatch("update"),
				oPromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.notOk(that.oModel.hasPendingChanges("update"));
			assert.strictEqual(iPatchSent, 2);
			assert.strictEqual(iPatchCompleted, 2);
		});
	});

	//*********************************************************************************************
	// Scenario: Create a context binding for an entity and call setProperty at its bound context
	// w/o reading before. A PATCH request for the property should be sent.
	// JIRA: CPOUI5UISERVICESV3-1790
	//
	// See that additional calls to #setProperty get merged into a single PATCH request and that
	// #getProperty returns the current value.
	// BCP: 2170193264
	QUnit.test("Context#setProperty: write only", function (assert) {
		var oContext,
			iNoPatchCompleted = 0,
			iNoPatchSent = 0,
			oYetAnotherContext,
			that = this;

		return this.createView(assert).then(function () {
			var oContextBinding = that.oModel.bindContext("/TEAMS('TEAM_01')");

			oContext = oContextBinding.getBoundContext();
			oYetAnotherContext = that.oModel.bindContext("/TEAMS('TEAM_02')").getBoundContext();

			oContextBinding.attachPatchCompleted(function (oEvent) {
				iNoPatchCompleted += 1;
				assert.strictEqual(oEvent.getParameter("success"), true);
			});
			oContextBinding.attachPatchSent(function () {
				iNoPatchSent += 1;
			});
			that.expectRequest({
					headers : {"If-Match" : "*"},
					method : "PATCH",
					payload : {MEMBER_COUNT : 99, Name : "Best Team Ever"},
					url : "TEAMS('TEAM_01')"
				})
				.expectRequest({
					headers : {"If-Match" : "*"},
					method : "PATCH",
					payload : {Name : "Yet another team!"},
					url : "TEAMS('TEAM_02')"
				});

			return Promise.all([
				// code under test (BCP: 2170193264)
				oContext.setProperty("MEMBER_COUNT", 99),
				oContext.setProperty("Name", "n/a"),
				// code under test
				oContext.setProperty("Name", "Best Team Ever"),
				// code under test
				oYetAnotherContext.setProperty("Name", "Yet another team!"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(iNoPatchCompleted, 1);
			assert.strictEqual(iNoPatchSent, 1);

			// code under test
			assert.strictEqual(oContext.getProperty("MEMBER_COUNT"), 99);
			assert.strictEqual(oContext.getProperty("Name"), "Best Team Ever");
			assert.strictEqual(oYetAnotherContext.getProperty("Name"), "Yet another team!");

			that.oLogMock.expects("error").withExactArgs(
				"Failed to drill-down into MEMBER_COUNT, invalid segment: MEMBER_COUNT",
				sTeaBusi + "TEAMS('TEAM_02')",
				"sap.ui.model.odata.v4.lib._Cache");

			// code under test
			assert.strictEqual(oYetAnotherContext.getProperty("MEMBER_COUNT"), undefined);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity via the model. There is a list binding having a context for this
	// entity. This context must be destroyed and the count adjusted.
	// A relative ODCB w/o cache and with a path ending in a single-valued navigation property
	// depends on the deleted context. Its onDelete is then called after the ODLB has already
	// deleted the context, but before the destruction (which is done in a prerendering task). In
	// order to determine its canonical path the bound context of the ODCB must take the key
	// predicate from the cache data which is already gone. Ensure that this problem does not end up
	// in the message manager.
	// JIRA: CPOUI5ODATAV4-1511
	// JIRA: CPOUI5ODATAV4-1593: The list has pending changes in the deleted and in another context
[false, true].forEach(function (bKeepAlive) {
	QUnit.test("CPOUI5ODATAV4-1511: ODLB, kept=" + bKeepAlive, function (assert) {
		var oContext,
			oListBinding,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oNote1Promise,
			oNote3Promise,
			fnOnDelete = sinon.spy(),
			oTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<Table growing="true" growingThreshold="3" id="table" items="{path : \'/SalesOrderList\', \
		parameters : {$count : true, $select : \'Messages\'}}">\
	<Text id="listId" text="{SalesOrderID}"/>\
	<Input id="note" value="{Note}"/>\
</Table>\
<FlexBox id="objectPage" binding="{SO_2_BP}">\
	<Text id="id" text="{BusinessPartnerID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$count=true&$select=Messages,Note,SalesOrderID"
				+ "&$skip=0&$top=3", {
				"@odata.count" : "5",
				value : [{
					Messages : [{
						message : "To be deleted",
						numericSeverity : 2,
						target : ""
					}],
					Note : "Note 1",
					SalesOrderID : "1"
				}, {
					Messages : [],
					Note : "Note 2",
					SalesOrderID : "2"
				}, {
					Messages : [],
					Note : "Note 3",
					SalesOrderID : "3"
				}]
			})
			.expectChange("listId", ["1", "2", "3"])
			.expectChange("note", ["Note 1", "Note 2", "Note 3"])
			.expectChange("count")
			.expectChange("id")
			.expectMessages([{
				code : undefined,
				message : "To be deleted",
				target : "/SalesOrderList('1')",
				type : "Information"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("count", "5")
				.expectRequest("SalesOrderList('1')?$select=SO_2_BP"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID)",
					{SO_2_BP : {BusinessPartnerID : "B1"}}
				)
				.expectChange("id", "B1");

			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("items");
			oContext = oTable.getItems()[0].getBindingContext();
			that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());
			that.oView.byId("objectPage").setBindingContext(oContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", ["Note 1 (changed)"]);

			oNote1Promise = oContext.setProperty("Note", "Note 1 (changed)");

			return that.waitForChanges(assert);
		}).then(function () {
			if (bKeepAlive) {
				that.expectRequest("SalesOrderList?$count=true&$select=Messages,Note,SalesOrderID"
						+ "&$orderby=SalesOrderID desc&$skip=0&$top=3", {
						"@odata.count" : "5",
						value : [
							{Messages : [], Note : "Note 5", SalesOrderID : "5"},
							{Messages : [], Note : "Note 4", SalesOrderID : "4"},
							{Messages : [], Note : "Note 3", SalesOrderID : "3"}
						]
					})
					.expectChange("listId", ["5", "4"])
					.expectChange("note", ["Note 5", "Note 4"])
					.expectMessages([]);

				oContext.setKeepAlive(true, fnOnDelete);
				oListBinding.sort(new Sorter("SalesOrderID", true));

				return that.waitForChanges(assert);
			}
		}).then(function () {
			that.expectChange("note", [,, "Note 3 (changed)"]);

			oNote3Promise = oTable.getItems()[2].getBindingContext()
				.setProperty("Note", "Note 3 (changed)");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "DELETE",
					headers : {"If-Match" : "*"},
					url : "SalesOrderList('1')"
				});
			if (bKeepAlive) {
				that.expectRequest("SalesOrderList?$count=true&$filter=not (SalesOrderID eq '1')"
					+ "&$top=0", {
					"@odata.count" : "4",
					value : []
				});
			} else {
				that.expectRequest("SalesOrderList?$count=true&$select=Messages,Note,SalesOrderID"
						+ "&$skip=2&$top=1", {
						"@odata.count" : "4",
						value : [{Messages : [], Note : "Note 4", SalesOrderID : "4"}]
					})
					.expectChange("listId", [,, "4"])
					.expectChange("note", ["Note 1"]) // -> resetChanges before the list update
					.expectChange("note", [,, "Note 4"]);
			}
			that.expectChange("count", "4")
				.expectChange("id", null)
				.expectCanceledError("Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectMessages([]);

			return Promise.all([
				// code under test
				oModel.delete("/SalesOrderList('1')", "$auto"),
				checkCanceled(assert, oNote1Promise),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('3')",
					payload : {Note : "Note 3 (changed)"}
				});

			return Promise.all([
				oModel.submitBatch("update"),
				oNote3Promise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(fnOnDelete.called, bKeepAlive);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Delete an entity via the model. The bound context of a context binding points to
	// this entity.
	// JIRA: CPOUI5ODATAV4-1511
	// JIRA: CPOUI5ODATAV4-1593: There are pending changes in the context and in a dependent list
	QUnit.test("CPOUI5ODATAV4-1511: ODCB, bound context", function (assert) {
		var oModel = this.createSpecialCasesModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oNamePromise,
			oPricePromise,
			sView = '\
<FlexBox id="form" binding="{\
		path : \'/Artists(ArtistID=\\\'1\\\',IsActiveEntity=true)/BestFriend\',\
		parameters : {$select : \'Messages\'}}">\
	<Text id="id" text="{ArtistID}"/>\
	<Input id="name" value="{Name}"/>\
	<Table id="publications" \
			items="{path : \'_Publication\', parameters : {$$ownRequest : true}}">\
		<Input id="price" value="{Price}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='1',IsActiveEntity=true)/BestFriend"
				+ "?$select=ArtistID,IsActiveEntity,Messages,Name", {
				ArtistID : "2",
				IsActiveEntity : true,
				Messages : [{
					message : "To be deleted",
					numericSeverity : 2,
					target : ""
				}],
				Name : "The Beatles"
			})
			.expectRequest("Artists(ArtistID='1',IsActiveEntity=true)/BestFriend/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100",
					{value : [{Price : "19.99", PublicationID : "P1"}]})
			.expectChange("id", "2")
			.expectChange("name", "The Beatles")
			.expectChange("price", ["19.99"])
			.expectMessages([{
				code : undefined,
				message : "To be deleted",
				target : "/Artists(ArtistID='1',IsActiveEntity=true)/BestFriend",
				type : "Information"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("name", "The Beatles (changed)")
				.expectChange("price", ["12.99"]);

			oNamePromise = that.oView.byId("form").getBindingContext()
				.setProperty("Name", "The Beatles (changed)");
			oPricePromise = that.oView.byId("publications").getItems()[0].getBindingContext()
				.setProperty("Price", "12.99");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectCanceledError(
				"Failed to update path /Artists(ArtistID='1',IsActiveEntity=true)/BestFriend/Name",
				"Request canceled: PATCH Artists(ArtistID='2',IsActiveEntity=true); group: update");
			that.expectCanceledError("Failed to update path"
				+ " /Artists(ArtistID='1',IsActiveEntity=true)/BestFriend/_Publication('P1')/Price",
				"Request canceled: PATCH Artists(ArtistID='2',IsActiveEntity=true)"
				+ "/_Publication('P1'); group: update");
			that.expectRequest({
					method : "DELETE",
					headers : {"If-Match" : "*"},
					url : "Artists(ArtistID='2',IsActiveEntity=true)"
				})
				.expectChange("id", null)
				.expectChange("name", "The Beatles")
				.expectChange("name", null)
				.expectChange("price", ["19.99"])
				.expectMessages([]);

			return Promise.all([
				// code under test
				oModel.delete("/Artists(ArtistID='2',IsActiveEntity=true)", "$auto"),
				checkCanceled(assert, oNamePromise),
				checkCanceled(assert, oPricePromise),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity via the model. The return value context of a context binding
	// points to this entity.
	// JIRA: CPOUI5ODATAV4-1511
	QUnit.test("CPOUI5ODATAV4-1511: ODCB, return value context", function (assert) {
		var oForm,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="active" text="{IsActiveEntity}"/>\
</FlexBox>',
			that = this;

		this.expectChange("id")
			.expectChange("active");

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = oModel.bindContext("/Artists(ArtistID='1',IsActiveEntity=true)",
				undefined, {$select : ["Messages"]});

			that.expectRequest("Artists(ArtistID='1',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity,Messages", {
				ArtistID : "1",
				IsActiveEntity : true,
				Messages : []
			})
			.expectChange("id", "1")
			.expectChange("active", "Yes");

			oForm = that.oView.byId("form");
			oForm.setBindingContext(oBinding.getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			var oOperationBinding = oModel.bindContext("special.cases.EditAction(...)",
					oForm.getBindingContext(), {$$inheritExpandSelect : true});

			that.expectRequest({
					method : "POST",
					payload : {},
					url : "Artists(ArtistID='1',IsActiveEntity=true)/special.cases.EditAction"
						+ "?$select=ArtistID,IsActiveEntity,Messages"
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Messages : [{
						message : "To be deleted",
						numericSeverity : 2,
						target : ""
					}]
				})
				.expectMessages([{
					code : undefined,
					message : "To be deleted",
					target : "/Artists(ArtistID='1',IsActiveEntity=false)",
					type : "Information"
				}]);

			return Promise.all([
				oOperationBinding.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aResult) {
			that.expectChange("active", "No");

			that.oView.byId("form").setBindingContext(aResult[0]); // return value context

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "DELETE",
					headers : {"If-Match" : "*"},
					url : "Artists(ArtistID='1',IsActiveEntity=false)"
				})
				.expectChange("id", null)
				.expectChange("active", null)
				.expectMessages([]);

			return Promise.all([
				// code under test
				oModel.delete("/Artists(ArtistID='1',IsActiveEntity=false)"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Invoke a bound action, this returns a return value context although the path
	// contains navigation properties.
	// JIRA: CPOUI5ODATAV4-2096
[false, true].forEach(function (bInheritExpandSelect) {
	["TEAM_01", "TEAM_02"].forEach(function (sTeamId) {
		["1", "2"].forEach(function (sEmployeeId) {
				var sTitle = "CPOUI5ODATAV4-2096 - Bound Action with RVC, Team changed: "
						+ (sTeamId === "TEAM_02") + ", EmployeeId changed: " + (sEmployeeId === "2")
						+ ", bInheritExpandSelect: " + bInheritExpandSelect;

	QUnit.test(sTitle, async function (assert) {
		var sChangeTeamAction
				= "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sRVCPath = "/TEAMS('" + sTeamId + "')/TEAM_2_EMPLOYEES('" + sEmployeeId + "')",
			sView = '\
<Table id="teams" items="{path : \'/TEAMS\'}">\
	<Text id="teamId" text="{Team_Id}"/>\
</Table>\
<Table id="employees" items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$$ownRequest : true}}">\
	<Input id="name" value="{Name}"/>\
	<Text id="team" text="{TEAM_ID}"/>\
</Table>';

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=100", {
				value : [{Team_Id : "TEAM_01"}, {Team_Id : "TEAM_02"}]
			})
			.expectChange("teamId", ["TEAM_01", "TEAM_02"])
			.expectChange("name", [])
			.expectChange("team", []);

		await this.createView(assert, sView, oModel);

		this.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name,TEAM_ID"
				+ "&$skip=0&$top=100", {
				value : [{ID : "1", Name : "Jonathan Smith", TEAM_ID : "TEAM_01"}]
			})
			.expectChange("name", ["Jonathan Smith"])
			.expectChange("team", ["TEAM_01"]);

		this.oView.byId("employees").setBindingContext(
			this.oView.byId("teams").getBinding("items").getCurrentContexts()[0]);

		await this.waitForChanges(assert);

		const oResponse = {
				Age : "42",
				EMPLOYEE_2_TEAM : {
					Team_Id : sTeamId
				},
				ID : sEmployeeId
			};

		if (bInheritExpandSelect) {
			oResponse["Name"] = "Jonathan Smith";
			oResponse["TEAM_ID"] = sTeamId;
		}

		const oEmployeesBinding = this.oView.byId("employees").getBinding("items");
		const oEmployeeContext = oEmployeesBinding.getCurrentContexts()[0];
		const oActionBinding = this.oModel.bindContext(sChangeTeamAction + "(...)",
			oEmployeeContext, {
				$select : ["Age"],
				$$inheritExpandSelect : bInheritExpandSelect
			});

		this.expectRequest({
				method : "POST",
				payload : {
					TeamID : sTeamId
				},
				url : "TEAMS('TEAM_01')/TEAM_2_EMPLOYEES('1')" + "/" + sChangeTeamAction
					+ (bInheritExpandSelect
						? "?$select=Age,ID,Name,TEAM_ID"
						: "?$select=Age,ID")
					+ "&$expand=EMPLOYEE_2_TEAM($select=Team_Id)"
			}, oResponse);

		if (sTeamId === "TEAM_02" && sEmployeeId === "1" && bInheritExpandSelect) {
			this.expectChange("team", ["TEAM_02"]);
		}

		const [oReturnValueContext] = await Promise.all([
			oActionBinding
				.setParameter("TeamID", sTeamId)
				.invoke(),
			this.waitForChanges(assert)
		]);

		assert.strictEqual(oReturnValueContext.getPath(), sRVCPath);
	});
		});
	});
});

	//*********************************************************************************************
	// Scenario: Delete an entity via the model. This must not stumble over bindings below a not-yet
	// destroyed context of an ODLB which is already unresolved (kept in mPreviousContextsByPath),
	// JIRA: CPOUI5ODATAV4-1941
	QUnit.test("CPOUI5ODATAV4-1941: ODM#delete: parked context", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" items="{SalesOrderList}">\
	<Text id="order" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="objectPage" binding="{SO_2_BP}">\
	<Text id="bp" text="{BusinessPartnerID}"/>\
</FlexBox>',
			that = this;

		this.expectChange("order", [])
			.expectChange("bp");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100",
					{value : [{SalesOrderID : "SO1"}]})
				.expectChange("order", ["SO1"]);

			oTable = that.oView.byId("table");
			oTable.setBindingContext(oModel.createBindingContext("/"));

			return that.waitForChanges(assert, "bind");
		}).then(function () {
			that.expectRequest("SalesOrderList('SO1')?$select=SO_2_BP"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID)",
					{SO_2_BP : {BusinessPartnerID : "BP1"}})
				.expectChange("bp", "BP1");

			that.oView.byId("objectPage").setBindingContext(
				oTable.getItems()[0].getBindingContext());

			return that.waitForChanges(assert, "object page");
		}).then(function () {
			oTable.setBindingContext(null);

			that.expectRequest({
					method : "DELETE",
					headers : {"If-Match" : "*"},
					url : "ProductList('P1')"
				});

			return Promise.all([
				oModel.delete("/ProductList('P1')"),
				that.waitForChanges(assert, "unbind & delete")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Delete an entity via ODM#delete while it is also being deleted using the context.
	// There is an ODCB w/ own cache below this deleted, but not yet destroyed context. Ensure that
	// the iteration over all bindings in ODM#delete does not fail in this ODCB.
	// BCP: 2380008681
	//
	// Ensure that the request contains custom query options (BCP: 2380034674)
	QUnit.test("BCP: 2380008681: ODM#delete: deleted context", function (assert) {
		var oContext,
			oModel = this.createSalesOrdersModel123({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="listId" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="objectPage" binding="{path : \'\', parameters : {$$ownRequest : true}}">\
	<Text id="id" text="{SalesOrderID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?sap-client=123&$select=SalesOrderID&$skip=0&$top=100",
				{value : [{"@odata.etag" : "etag", SalesOrderID : "1"}]})
			.expectChange("listId", ["1"])
			.expectChange("id");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')?sap-client=123&$select=SalesOrderID",
					{SalesOrderID : "1"})
				.expectChange("id", "1");

			oContext = that.oView.byId("table").getBinding("items").getCurrentContexts()[0];
			that.oView.byId("objectPage").setBindingContext(oContext);

			return that.waitForChanges(assert, "object page");
		}).then(function () {
			that.expectRequest({
					method : "DELETE",
					headers : {"If-Match" : "etag"},
					url : "SalesOrderList('1')?sap-client=123"
				})
				.expectRequest({
					method : "DELETE",
					headers : {"If-Match" : "*"},
					url : "SalesOrderList('1')?sap-client=123"
				})
				.expectChange("id", null);

			return Promise.all([
				oContext.delete(),
				// code under test
				oModel.delete("/SalesOrderList('1')"),
				that.waitForChanges(assert, "delete")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Declarative event handlers can refer to property bindings.
	// JIRA: CPOUI5UISERVICESV3-1912
	QUnit.test("Declarative event handlers", function (assert) {
		var done = assert.async(),
			oController = {
				onPress : function (sNetAmount) {
					assert.strictEqual(sNetAmount, "2,000.00");
					done();
				}
			},
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Button id="button" press=".onPress(${path : \'NetAmount\', targetType : \'string\'})"\
		text="{NetAmount}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=NetAmount,SalesOrderID&$skip=0&$top=100", {
				value : [{
					NetAmount : "2000",
					SalesOrderID : "4711"
				}, {
					NetAmount : "4000",
					SalesOrderID : "4712"
				}]
			})
			.expectChange("button", ["2,000.00", "4,000.00"]);

		this.createView(assert, sView, oModel, oController).then(function () {
			that.oView.byId("table").getItems()[0].getCells()[0].firePress();
		});
	});

	//*********************************************************************************************
	// Scenario: Use list binding programmatically.
	// JIRA: CPOUI5UISERVICESV3-1871
	QUnit.test("Use list binding programmatically", function (assert) {
		var done = assert.async(),
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			that = this;

		this.createView(assert, "", oModel).then(function () {
			var oBinding = oModel.bindList("/SalesOrderList");

			that.expectRequest("SalesOrderList?$skip=0&$top=10", {
				value : [{
					SalesOrderID : "4711"
				}, {
					SalesOrderID : "4712"
				}]
			});

			oBinding.attachChange(function (oEvent) {
				var aContexts = oBinding.getContexts(0, 10);

				if (!oEvent.getParameter("detailedReason")) {
					assert.strictEqual(aContexts.length, 2);
					assert.strictEqual(aContexts[0].getProperty("SalesOrderID"), "4711");
					assert.strictEqual(aContexts[1].getProperty("SalesOrderID"), "4712");
					done();
				}
			});
			oBinding.attachRefresh(function () {
				oBinding.getContexts(0, 10);
			});
			oBinding.initialize();
		});
	});

	//*********************************************************************************************
	// Scenario: Reduce path by removing partner attributes SO_2_SOITEM and SOITEM_2_SO, so that
	// "SOITEM_2_SO/CurrencyCode" is not expanded, but taken from the parent sales order in the same
	// cache and written back to it.
	// JIRA: CPOUI5UISERVICESV3-1877
	QUnit.test("Reduce path: property in same cache", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}">\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text id="note" text="{Note}"/>\
		<Input id="soCurrencyCode" value="{SOITEM_2_SO/CurrencyCode}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=CurrencyCode,SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID)", {
				"@odata.etag" : "ETag",
				CurrencyCode : "EUR",
				SalesOrderID : "1",
				SO_2_SOITEM : [{
					ItemPosition : "10",
					Note : "Foo",
					SalesOrderID : "1"
				}]
			})
			.expectChange("note", ["Foo"])
			.expectChange("soCurrencyCode", ["EUR"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("table").getItems()[0].getCells()[1].getBinding("value");

			that.expectChange("soCurrencyCode", ["USD"])
				.expectRequest({
					method : "PATCH",
					headers : {"If-Match" : "ETag"},
					url : "SalesOrderList('1')",
					payload : {CurrencyCode : "USD"}
				}, {
					CurrencyCode : "USD",
					SalesOrderID : "1"
				});

			oBinding.setValue("USD");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Reduce path by removing partner attributes SO_2_SOITEM and SOITEM_2_SO. Simulate an
	// In-Parameter of a value help for which the value is cached in the parent binding. Do this for
	// a creation row, too.
	// JIRA: CPOUI5UISERVICESV3-1877
	// JIRA: CPOUI5UISERVICESV3-1942
	QUnit.test("Reduce path: property in parent cache", function (assert) {
		var oCreationRowContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Text id="soCurrencyCode" text="{CurrencyCode}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>\
<FlexBox id="creationRow">\
	<Text id="creationRow::note" text="{Note}"/>\
</FlexBox>\
<FlexBox id="valueHelp">\
	<Input id="valueHelp::currencyCode" value="{SOITEM_2_SO/CurrencyCode}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=CurrencyCode,SalesOrderID", {
				CurrencyCode : "EUR",
				SalesOrderID : "1"
			})
			.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$select=ItemPosition,Note,SalesOrderID"
				+ "&$skip=0&$top=100", {
				value : [{
					ItemPosition : "10",
					Note : "Foo",
					SalesOrderID : "1"
				}]
			})
			.expectChange("note", ["Foo"])
			.expectChange("soCurrencyCode", "EUR")
			.expectChange("valueHelp::currencyCode");

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");

			that.expectChange("valueHelp::currencyCode", "EUR");

			// start value help
			that.oView.byId("valueHelp").setBindingContext(
				oTable.getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("valueHelp::currencyCode", null);

			// stop value help
			that.oView.byId("valueHelp").setBindingContext(null);

			return that.waitForChanges(assert);
		}).then(function () {
			var oCreationRowListBinding, oTableBinding;

			that.expectChange("valueHelp::currencyCode", "EUR");

			// create and initialize creation row
			oTableBinding = oTable.getBinding("items");
			oCreationRowListBinding = that.oModel.bindList(oTableBinding.getPath(),
				oTableBinding.getContext(), undefined, undefined,
				{$$updateGroupId : "doNotSubmit"});
			oCreationRowContext = oCreationRowListBinding.create();
			that.oView.byId("creationRow").setBindingContext(oCreationRowContext);

			// start value help on creation row
			that.oView.byId("valueHelp").setBindingContext(oCreationRowContext);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("soCurrencyCode", "USD")
				.expectChange("valueHelp::currencyCode", "USD");

			// the PATCH must not be sent!
			that.oView.byId("valueHelp::currencyCode").getBinding("value").setValue("USD");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("valueHelp::currencyCode", null);

			// delete creation row to avoid errors in destroy
			checkCanceled(assert, oCreationRowContext.created());
			oCreationRowContext.delete();
		});
	});

	//*********************************************************************************************
	// Scenario: Reduce path by removing multiple pairs of partner attributes.
	// JIRA: CPOUI5UISERVICESV3-1877
	QUnit.test("Reduce path by removing multiple pairs of partner attributes", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/As(1)}">\
	<FlexBox binding="{AtoB}">\
		<Table id="table" items="{BtoDs}">\
			<Text id="aValue" text="{DtoB/BtoA/AValue}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>';

		this.expectRequest("As(1)?$select=AID,AValue"
				+ "&$expand=AtoB($select=BID;$expand=BtoDs($select=DID))", {
				AID : 1,
				AValue : 42,
				AtoB : {
					BID : 2,
					BtoDs : [{
						DID : 3
					}]
				}
			})
			.expectChange("aValue", ["42"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Reduce path by removing multiple pairs of partner attributes. See that AValue is
	// taken from two caches above.
	// JIRA: CPOUI5UISERVICESV3-1877
	QUnit.test("Reduce path and step up multiple caches", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/As(1)}">\
	<FlexBox binding="{path : \'AtoB\', parameters : {$$ownRequest : true}}">\
		<Text text="{BValue}"/>\
		<Table id="table" items="{path : \'BtoDs\', parameters : {$$ownRequest : true}}">\
			<Text text="{DValue}"/>\
			<Text id="aValue" text="{DtoB/BtoA/AValue}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>';

		this.expectRequest("As(1)?$select=AID,AValue", {
				AID : 1,
				AValue : 42
			})
			.expectRequest("As(1)/AtoB?$select=BID,BValue", {
				BID : 2,
				BValue : 102
			})
			.expectRequest("As(1)/AtoB/BtoDs?$select=DID,DValue&$skip=0&$top=100", {
				value : [
					{DID : 3, DValue : 103},
					{DID : 4, DValue : 104}
				]
			})
			.expectChange("aValue", ["42", "42"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Reduced path must not be shorter than root binding's path.
	// JIRA: CPOUI5UISERVICESV3-1877
	QUnit.test("Reduced path must not be shorter than root binding's path", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/As(1)/AtoB}">\
	<Text id="aValue" text="{BtoA/AValue}"/>\
	<Table id="table" items="{BtoDs}">\
		<Text id="table::aValue" text="{DtoB/BtoA/AValue}"/>\
	</Table>\
</FlexBox>';

		this.expectRequest("As(1)/AtoB?$select=BID"
				+ "&$expand=BtoA($select=AID,AValue),BtoDs($select=DID)", {
				BID : 2,
				BtoA : {
					AID : 1,
					AValue : 42
				},
				BtoDs : [{
					DID : 3
				}]
			})
			.expectChange("aValue", "42")
			.expectChange("table::aValue", ["42"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Path reduction and change listener
	// "defaultChannel" has a reducible path. See that it is properly deregistered with the delete,
	// so that the refresh promise resolves.
	// BCP: 2370061110
	QUnit.test("BCP: 2370061110", async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sView = `
<FlexBox id="form" binding="{/Artists(ArtistID='1',IsActiveEntity=false)}">
	<Text id="defaultChannel" text="{_Publication/_Artist/defaultChannel}"/>
</FlexBox>`;

		this.expectRequest("Artists(ArtistID='1',IsActiveEntity=false)"
				+ "?$select=ArtistID,IsActiveEntity,defaultChannel", {
				ArtistID : "1",
				IsActiveEntity : false,
				defaultChannel : "test"
			})
			.expectChange("defaultChannel", "test");

		await this.createView(assert, sView, oModel);

		this.expectChange("defaultChannel", null)
			.expectRequest("DELETE Artists(ArtistID='1',IsActiveEntity=false)");

		const oContext = this.oView.byId("form").getBindingContext();

		await Promise.all([
			oContext.delete(),
			oContext.getBinding().requestRefresh(),
			this.waitForChanges(assert, "delete")
		]);
	});

	//*********************************************************************************************
	// Scenario: Operation on reduceable path. The operation path will not be reduced, but the
	// reduced path must be used to access the binding parameter.
	// JIRA: CPOUI5UISERVICESV3-1877
	QUnit.test("Operation on reduceable path", function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}">\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>\
<FlexBox id="form" binding="{SOITEM_2_SO/' + sAction + '(...)}">\
	<Text id="status" text="{LifecycleStatus}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID)", {
				"@odata.etag" : "ETag",
				SalesOrderID : "1",
				SO_2_SOITEM : [{
					ItemPosition : "10",
					Note : "Foo",
					SalesOrderID : "1"
				}]
			})
			.expectChange("note", ["Foo"])
			.expectChange("status");

		return this.createView(assert, sView, oModel).then(function () {
			var oForm = that.oView.byId("form");

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')"
						+ "/SOITEM_2_SO/" + sAction, // TODO reduce operation path
					headers : {"If-Match" : "ETag"},
					payload : {}
				}, {
					LifecycleStatus : "C",
					SalesOrderID : "1"
				})
				.expectChange("status", null) // initialization due to #setContext
				.expectChange("status", "C");

			oForm.setBindingContext(
				that.oView.byId("table").getItems()[0].getBindingContext());
			oForm.getElementBinding().invoke();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Partner attributes are in the path to a collection. Ensure that the path is reduced
	// and all properties including $count can be accessed. Check also that it does not clash with
	// unreduced list bindings.
	// JIRA: CPOUI5UISERVICESV3-1877
	// Sync data access is possible although oCachePromise becomes pending again.
	// JIRA: CPOUI5ODATAV4-204
	QUnit.test("Partner attributes in path to collection, CPOUI5ODATAV4-204", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Bs(1)}">\
	<Table id="table" items="{BtoA/AtoB/BtoDs}">\
		<Text id="bValue" text="{DtoB/BValue}"/>\
		<Text id="dValue" text="{DValue}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("Bs(1)?$select=BID,BValue&$expand=BtoA($select=AID"
				+ ";$expand=AtoB($select=BID;$expand=BtoDs($select=DID,DValue)))", {
				BID : 1,
				BValue : 101,
				BtoA : {
					AtoB : {
						BtoDs : [
							{DID : 2, DValue : 99},
							{DID : 3, DValue : 98}
						]
					}
				}
			})
			.expectChange("bValue", ["101", "101"])
			.expectChange("dValue", ["99", "98"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oListBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("Bs(1)/BtoA/AtoB/BtoDs?$select=DID,DValue&$orderby=DValue"
					+ "&$skip=0&$top=100", {
					value : [
						{DID : 3, DValue : 98},
						{DID : 2, DValue : 99}
					],
					"BtoDs@odata.count" : "2"
				})
				.expectChange("dValue", ["98", "99"]);

			// code under test
			oListBinding.sort(new Sorter("DValue"));

			// code under test: sync data access...
			assert.strictEqual(oListBinding.getContext().getProperty("BValue"), 101);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Partner attributes are in the path to a property, but reduction is impossible
	// because the parent binding has a different update group with submit mode API.
	// JIRA: CPOUI5UISERVICESV3-1877
	// JIRA: CPOUI5UISERVICESV3-1944
	QUnit.test("Partner attributes in path to collection, other updateGroupId", function (assert) {
		var oModel = this.createSpecialCasesModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			sView = '\
<FlexBox binding="{/Bs(1)}">\
	<Text id="bValue" text="{BValue}"/>\
	<Table items="{BtoDs}">\
		<Text id="bValue::table1" text="{DtoB/BValue}"/>\
	</Table>\
	<Table items="{path : \'BtoDs\', parameters : {$$updateGroupId : \'$auto\'}}">\
		<Text id="bValue::table2" text="{DtoB/BValue}"/>\
	</Table>\
</FlexBox>';

		this.expectRequest("Bs(1)?$select=BID,BValue&$expand=BtoDs($select=DID)", {
				BID : 1,
				BValue : 101,
				BtoDs : [
					{DID : 2},
					{DID : 3}
				]
			})
			.expectRequest("Bs(1)/BtoDs?$select=DID&$expand=DtoB($select=BID,BValue)"
				+ "&$skip=0&$top=100", {
				value : [{
					DID : 2,
					DtoB : {BID : 1, BValue : 101}
				}, {
					DID : 3,
					DtoB : {BID : 1, BValue : 101}
				}]
			})
			.expectChange("bValue", "101")
			.expectChange("bValue::table1", ["101", "101"])
			.expectChange("bValue::table2", ["101", "101"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Request data from property binding
	QUnit.test("ODPrB access value async via API", function (assert) {
		var oModel = this.createSalesOrdersModel(),
			oPropertyBinding = oModel.bindProperty("/SalesOrderList('1')/NetAmount"),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			that.expectRequest("SalesOrderList('1')/NetAmount", {value : 42});

			// code under test
			return oPropertyBinding.requestValue().then(function (vValue) {
				assert.strictEqual(vValue, 42);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Request data from context binding
	QUnit.test("ODCB access value async via API", function (assert) {
		var oModel = this.createSalesOrdersModel(),
			oContextBinding = oModel.bindContext("/SalesOrderList('1')"),
			oSalesOrder = {
				NetAmount : "42",
				SalesOrderID : "1",
				TaxAmount : "117"
			},
			oSalesOrderResponse = Object.assign({}, oSalesOrder),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			that.expectRequest("SalesOrderList('1')", oSalesOrderResponse);

			// code under test
			return oContextBinding.requestObject().then(function (oResponse) {
				assert.deepEqual(oResponse, oSalesOrder);
				assert.notStrictEqual(oResponse, oSalesOrderResponse);

				return oContextBinding.requestObject("TaxAmount").then(function (vValue) {
					assert.strictEqual(vValue, "117");
				});
			});
		});
	});

	//*********************************************************************************************
	// Scenario: List binding without own cache, parent cache is a single cache. Create a new row
	// at top and request a side-effects refresh for the collection. Server returns a different
	// order with the newly persisted row at bottom.
	QUnit.test("BCP: 2280105633", function (assert) {
		var oListBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oNewContext,
			sView = '\
<FlexBox binding="{/SalesOrderList(\'1\')}">\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID)", {
				SalesOrderID : "1",
				SO_2_SOITEM : [{
					ItemPosition : "10",
					Note : "Foo",
					SalesOrderID : "1"
				}, {
					ItemPosition : "20",
					Note : "Bar",
					SalesOrderID : "1"
				}]
			})
			.expectChange("note", ["Foo", "Bar"]);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("items");

			that.expectChange("note", ["New", "Foo", "Bar"])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList('1')/SO_2_SOITEM",
					payload : {Note : "New"}
				}, {
					ItemPosition : "30",
					Note : "New",
					SalesOrderID : "1"
				})
				.expectRequest("SalesOrderList('1')?$select=SO_2_SOITEM"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID)", {
					SO_2_SOITEM : [{
						ItemPosition : "10",
						Note : "Foo",
						SalesOrderID : "1"
					}, {
						ItemPosition : "20",
						Note : "Bar",
						SalesOrderID : "1"
					}, {
						ItemPosition : "30",
						Note : "New",
						SalesOrderID : "1"
					}]
				})
				.expectChange("note", ["Foo", "Bar", "New"]);

			oNewContext = oListBinding.create({Note : "New"}, true);

			return Promise.all([
				// code under test
				oListBinding.getContext().requestSideEffects(["SO_2_SOITEM"]),
				oNewContext.created(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.deepEqual(oListBinding.getAllCurrentContexts().map(getPath), [
				"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')",
				"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='20')",
				"/SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='30')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: requestSideEffects must not refresh a dependent list binding in case it is a
	// "creation row" which means it only contains transient contexts and never read data.
	// JIRA: CPOUI5UISERVICESV3-1943
	//
	// Allow side effect to refresh a dependent list binding even if it only contains transient
	// contexts.
	// JIRA: CPOUI5ODATAV4-37
	//
	// Keep all inline creation rows during a side-effects refresh; make sure $count is correct even
	// when a filter is involved. (Note: for simplicity, $filter is not really shown here.)
	// JIRA: CPOUI5ODATAV4-1384
[false, true].forEach(function (bEmpty) {
	[false, true].forEach(function (bSuccess) {
		[false, true].forEach(function (bFound) {
			var sTitle = "CPOUI5ODATAV4-37: items table is empty = " + bEmpty
					+ "; creation succeeds = " + bSuccess
					+ "; created item is part of side effect response = " + bFound;

			if (!bSuccess && bFound) {
				return;
			}

	QUnit.test(sTitle, function (assert) {
		var oCreationRowContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oNewContext,
			oTableBinding,
			// imagine we had a $filter : \'NoteLanguage ne null\' or similar for the table
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Input id="soCurrencyCode" value="{CurrencyCode}"/>\
	<Text id="count" text="{headerContext>$count}"/>\
	<Table id="table" growing="true" growingThreshold="2" items="{path : \'SO_2_SOITEM\',\
			parameters : {$$ownRequest : true, $count : true}}">\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>\
<FlexBox id="creationRow">\
	<Input id="creationRow::note" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=CurrencyCode,SalesOrderID", {
				CurrencyCode : "EUR",
				SalesOrderID : "1"
			})
			.expectChange("soCurrencyCode", "EUR")
			.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$count=true"
				+ "&$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=2", {
				"@odata.count" : bEmpty ? "0" : "3",
				value : bEmpty ? [] : [{
					ItemPosition : "10",
					Note : "Foo",
					SalesOrderID : "1"
				}, {
					ItemPosition : "20",
					Note : "Bar",
					SalesOrderID : "1"
				}]
			})
			.expectChange("note", bEmpty ? [] : ["Foo", "Bar"])
			.expectChange("count")
			.expectChange("creationRow::note");

		return this.createView(assert, sView, oModel).then(function () {
			oTableBinding = that.oView.byId("table").getBinding("items");

			that.expectChange("count", bEmpty ? "0" : "3");

			// code under test
			that.oView.setModel(that.oView.getModel(), "headerContext");
			that.oView.byId("count").setBindingContext(oTableBinding.getHeaderContext(),
				"headerContext");

			return that.waitForChanges(assert, "$count");
		}).then(function () {
			var oCreationRowListBinding;

			oCreationRowListBinding = oModel.bindList(oTableBinding.getPath(),
				oTableBinding.getContext(), undefined, undefined,
				{$$updateGroupId : "doNotSubmit"});

			that.expectChange("creationRow::note", "New item note");

			// initialize creation row
			oCreationRowContext = oCreationRowListBinding.create({Note : "New item note"});
			that.oView.byId("creationRow").setBindingContext(oCreationRowContext);

			return that.waitForChanges(assert, "creationRow");
		}).then(function () {
			var aItems;

			that.expectChange("count", bEmpty ? "1" : "4")
				.expectChange("note", ["First new row"]);
			that.expectRequest({
					batchNo : 2,
					method : "POST",
					payload : {Note : "First new row"},
					url : "SalesOrderList('1')/SO_2_SOITEM"
				}, bSuccess ? {
					ItemPosition : "0",
					Note : "First *new* row",
					NoteLanguage : "ignored",
					SalesOrderID : "1"
				} : createErrorInsideBatch())
				.expectMessages(bSuccess ? [] : [{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			if (!bSuccess) {
				that.oLogMock.expects("error")
					.withArgs("POST on 'SalesOrderList('1')/SO_2_SOITEM' failed"
						+ "; will be repeated automatically");
				that.oLogMock.expects("error")
					.withArgs("Failed to request side effects");
				that.oLogMock.expects("error")
					.withArgs("Failed to get contexts for " + sSalesOrderService
						+ "SalesOrderList('1')/SO_2_SOITEM with start index 0 and length 2");
			}

			// add transient row to items table
			oNewContext = oTableBinding.create({}, /*bSkipRefresh*/false, /*bAtEnd*/false,
				/*bInactive*/true);
			oNewContext.setProperty("Note", "First new row"); // activate

			aItems = [{
				ItemPosition : "10",
				Note : "Foo - side effect",
				SalesOrderID : "1"
			}, {
				ItemPosition : "20",
				Note : "Bar - side effect",
				SalesOrderID : "1"
			}];
			if (bFound) {
				aItems.unshift({
					ItemPosition : "0",
					Note : "n/a",
					SalesOrderID : "1"
				});
				aItems.length = 2;
			} // else: "First new row" not part of this read range
			that.expectRequest({
					batchNo : 2,
					url : "SalesOrderList('1')/SO_2_SOITEM"
						+ "?$count=true&$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=2"
				}, { // ignored if !bSuccess; else bEmpty does not play a role anymore
					"@odata.count" : "4",
					value : aItems
				});
			if (bSuccess) {
				that.expectChange("note", ["First *new* row", "Foo - side effect"]);
				if (bFound) {
					if (bEmpty) { // now we see this $count for the 1st time
						that.expectChange("count", "4");
					}
				} else {
					// we cannot tell if "First new row" is affected by our imaginative $filter...
					that.expectRequest({
							batchNo : 3,
							url : "SalesOrderList('1')/SO_2_SOITEM?$count=true"
								+ "&$filter=not (SalesOrderID eq '1' and ItemPosition eq '0')"
								+ "&$top=0"
						}, {
							"@odata.count" : "4", ///... looks like it is
							value : []
						})
						.expectChange("count", "5");
				}
				that.expectRequest({ // see /*bSkipRefresh*/false
						batchNo : 3,
						url : "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0')"
							+ "?$select=ItemPosition,Note,SalesOrderID"
					}, {
						ItemPosition : "0",
						Note : "First **new** row",
						SalesOrderID : "1"
					})
					.expectChange("note", ["First **new** row"]);
			}

			// code under test: requestSideEffects promise resolves, "creationRow::note" unchanged
			return Promise.all([
				oTableBinding.getContext().requestSideEffects(["SO_2_SOITEM"])
					.then(bSuccess ? null : mustFail(assert), function (oError0) {
						assert.notOk(bSuccess);
						assert.strictEqual(oError0.message, sPreviousFailed);
						assert.strictEqual(oError0.cause.message, "Request intentionally failed");
					}),
				bSuccess && oNewContext.created(),
				that.waitForChanges(assert, "requestSideEffects")
			]);
		}).then(function () {
			assert.strictEqual(oNewContext.getBinding(), oTableBinding);
			assert.strictEqual(oNewContext.getIndex(), 0);
			assert.strictEqual(oNewContext.getProperty("Note"),
				bSuccess ? "First **new** row" : "First new row");
			assert.notOk("NoteLanguage" in oNewContext.getObject(), "updateSelected :-)");

			that.expectChange("note", ["*First new row*"]);

			return Promise.all([
				// code under test
				oNewContext.setProperty("Note", "*First new row*", null),
				that.waitForChanges(assert, "check that new context still works fine")
			]);
		}).then(function () {
			that.expectChange("creationRow::note", "Changed item note");

			// code under test: no error on edit in transient context after requestSideEffects
			that.oView.byId("creationRow::note").getBinding("value").setValue("Changed item note");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("creationRow::note", null);
			if (!bSuccess) {
				that.expectChange("count", bEmpty ? "0" : "3"); // @see oNewContext.delete() below
				if (!bEmpty) {
					that.expectChange("note", [, "Bar"]);
				}
			}

			return Promise.all([
				checkCanceled(assert, oCreationRowContext.created()),
				// cleanup: delete creation row to avoid error on view destruction
				oCreationRowContext.delete(),
				bSuccess || checkCanceled(assert, oNewContext.created()),
				bSuccess || oNewContext.delete(),
				that.waitForChanges(assert)
			]);
		});
	});
		});
	});
});

	//*********************************************************************************************
	// Scenario: ODataModel#hasPendingChanges works synchronously as expected:
	//  - it detects pending parked changes
	//  - it considers reset changes
	//  - changing a value and immediately resetting it
	//  - in combination with creation row and late property bindings
	// JIRA: CPOUI5UISERVICESV3-1946 ODataModel#hasPendingChanges with group ID
	// JIRA: CPOUI5UISERVICESV3-1955 ODataModel#hasPendingChanges does also work for new entities
	QUnit.test("ODataModel#hasPendingChanges: late properties and creation row", function (assert) {
		var oCreationRowContext,
			oCreationRowListBinding,
			oFormBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTableBinding,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Input id="soCurrencyCode" value="{CurrencyCode}"/>\
	<Table id="table" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>\
<FlexBox id="creationRow">\
	<Input id="creationRow::note" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=CurrencyCode,SalesOrderID", {
				CurrencyCode : "EUR",
				SalesOrderID : "1"
			})
			.expectRequest("SalesOrderList('1')/SO_2_SOITEM?$select=ItemPosition,Note,SalesOrderID"
				+ "&$skip=0&$top=100", {
				value : [{
					ItemPosition : "10",
					Note : "Foo",
					SalesOrderID : "1"
				}]
			})
			.expectChange("note", ["Foo"])
			.expectChange("soCurrencyCode", "EUR")
			.expectChange("creationRow::note");

		return this.createView(assert, sView, oModel).then(function () {
			var oError = createErrorInsideBatch({message : "Invalid currency code"});

			oFormBinding = that.oView.byId("form").getObjectBinding();
			that.oLogMock.expects("error")
				.withArgs("Failed to update path /SalesOrderList('1')/CurrencyCode");
			that.expectRequest({
					method : "PATCH",
					payload : {CurrencyCode : "invalid"},
					url : "SalesOrderList('1')"
				}, oError)
				.expectChange("soCurrencyCode", "invalid")
				.expectMessages([{
					code : "CODE",
					message : "Invalid currency code",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			// invoke error to see that hasPendingChanges finds also parked changes
			that.oView.byId("soCurrencyCode").getBinding("value").setValue("invalid");

			assert.ok(oModel.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges("$auto"));
			assert.ok(oFormBinding.hasPendingChanges(), "form is dirty");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectCanceledError("Failed to update path /SalesOrderList('1')/CurrencyCode",
					"Request canceled: PATCH SalesOrderList('1'); group: $parked.$auto")
				.expectChange("soCurrencyCode", "EUR");

			// remove parked changes
			oModel.resetChanges("$auto");

			assert.notOk(oModel.hasPendingChanges());
			assert.notOk(oModel.hasPendingChanges("$auto"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("soCurrencyCode", "USD");

			that.oView.byId("soCurrencyCode").getBinding("value").setValue("USD");

			assert.ok(oModel.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges("$auto"));

			that.expectCanceledError("Failed to update path /SalesOrderList('1')/CurrencyCode",
					"Request canceled: PATCH SalesOrderList('1'); group: $auto")
				.expectChange("soCurrencyCode", "EUR");

			oModel.resetChanges("$auto");

			assert.notOk(oModel.hasPendingChanges());
			assert.notOk(oModel.hasPendingChanges("$auto"));

			return that.waitForChanges(assert);
		}).then(function () {
			oTableBinding = that.oView.byId("table").getBinding("items");
			oCreationRowListBinding = oModel.bindList(oTableBinding.getPath(),
				oTableBinding.getContext(), undefined, undefined,
				{$$updateGroupId : "doNotSubmit"});

			that.expectChange("creationRow::note", "New item note");

			// initialize creation row
			oCreationRowContext = oCreationRowListBinding.create({Note : "New item note"});
			that.oView.byId("creationRow").setBindingContext(oCreationRowContext);

			assert.ok(oFormBinding.hasPendingChanges());
			assert.ok(oCreationRowListBinding.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges(), "consider all groups");
			assert.notOk(oModel.hasPendingChanges("$auto"));
			assert.ok(oModel.hasPendingChanges("doNotSubmit"), "creation row has changes");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("creationRow::note", null);

			return Promise.all([
				checkCanceled(assert, oCreationRowContext.created()),
				// cleanup: delete creation row to avoid error on view destruction
				oCreationRowContext.delete(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.notOk(oFormBinding.hasPendingChanges());
			assert.notOk(oCreationRowListBinding.hasPendingChanges());
			assert.notOk(oModel.hasPendingChanges(), "consider all groups");
			assert.notOk(oModel.hasPendingChanges("$auto"));
			assert.notOk(oModel.hasPendingChanges("doNotSubmit"), "creation row has changes");
		});
	});

	//*********************************************************************************************
	// Scenario: Create a row. See that the city (a nested property inside the address) is removed,
	// when the POST response nulls the address (the complex property containing it).
	// JIRA: CPOUI5UISERVICESV3-1878
	// Also checks that setting properties with group ID null on a transient context is not
	// reflected in the POST payload.
	// JIRA: CPOUI5ODATAV4-114
	QUnit.test("create removes a nested property", function (assert) {
		var oCreatedContext,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			sView = '\
<Table id="table" items="{/BusinessPartnerList}">\
	<Text id="city" text="{Address/City}"/>\
	<Text id="type" text="{Address/AddressType}"/>\
	<Text id="company" text="{CompanyName}"/>\
</Table>',
			that = this;

		this.expectRequest("BusinessPartnerList?$select=Address/AddressType,Address/City"
				+ ",BusinessPartnerID,CompanyName&$skip=0&$top=100", {value : []})
			.expectChange("city", [])
			.expectChange("type", [])
			.expectChange("company", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("city", ["Heidelberg"])
				// CPOUI5ODATAV4-114
				.expectChange("type", ["42"])
				.expectChange("company", ["Nestle"])
				.expectMessages([{
					message : "The entity will be created via group 'update'. Cannot patch via"
						+ " group '$direct'",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			that.oLogMock.expects("error")
				.withArgs(sinon.match(function (sMessage) {
					return normalizeUID(sMessage)
						=== "Failed to update path /BusinessPartnerList($uid=...)/Address/City";
				}));

			oCreatedContext = that.oView.byId("table").getBinding("items").create({
				Address : {City : "Heidelberg"}
			}, true);

			return Promise.all([
				// code under test (CPOUI5ODATAV4-14)
				oCreatedContext.setProperty("Address/City", "St. Ingbert", "$direct")
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message, "The entity will be created via group"
							+ " 'update'. Cannot patch via group '$direct'");
					}),
				// code under test (CPOUI5ODATAV4-114)
				oCreatedContext.setProperty("Address/AddressType", "42", null),
				oCreatedContext.setProperty("CompanyName", "Nestle", null),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "BusinessPartnerList",
					payload : {Address : {City : "Heidelberg"}}
				}, {
					Address : null,
					BusinessPartnerId : "1",
					CompanyName : "SAP"
				})
				.expectChange("city", [""])
				.expectChange("type", [""])
				.expectChange("company", ["SAP"]);

			return Promise.all([
				oModel.submitBatch("update"),
				oCreatedContext.created(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Creation of an entity fails due to a network error. A subsequent call to
	// requestSideEffects repeats the failed POST in the same $batch.
	// JIRA: CPOUI5UISERVICESV3-1936
[{
	expectations : function () {
		this.expectRequest({
				batchNo : 3,
				method : "POST",
				payload : {Note : "Created"},
				url : "BusinessPartnerList('4711')/BP_2_SO"
			}, {
				Note : "Created",
				SalesOrderID : "43"
			})
			.expectRequest({
				batchNo : 3,
				method : "POST",
				payload : {Note : "Created as well"},
				url : "BusinessPartnerList('4711')/BP_2_SO"
			}, {
				Note : "Created as well",
				SalesOrderID : "44"
			})
			.expectRequest({
				batchNo : 3,
				url : "BusinessPartnerList('4711')?$select=BP_2_SO"
					+ "&$expand=BP_2_SO($select=Note,SalesOrderID)"
			}, {
				BusinessPartnerID : "4711",
				BP_2_SO : [{
					Note : "Unrealistic",
					SalesOrderID : "44"
				}, {
					Note : "Side",
					SalesOrderID : "43"
				}, {
					Note : "Effect",
					SalesOrderID : "0500000001"
				}]
			})
			.expectChange("id", ["44", "43"])
			// Context#getIndex returns a negative number because the ODLB has been reset and thus
			// this.iCreatedContexts = 0;
			// #create invokes Context#refreshDependentBindings before #rsE invokes
			// ODPaB#refreshDependentListBindingsWithoutCache, which seems natural (1st response is
			// processed 1st). Not sure how JIRA: CPOUI5ODATAV4-288 could help here.
			.expectChange("note", "Side", -1)
			.expectChange("note", "Unrealistic", -2)
			.expectChange("note", [,, "Effect"]);
			//TODO .expectChange("note", ["Unrealistic", "Side", "Effect"]);
	},
	text : "Repeated POST succeeds"
}, {
	expectations : function () {
		var oCausingError = createError();

		this.oLogMock.expects("error").withArgs("POST on 'BusinessPartnerList('4711')/BP_2_SO'"
			+ " failed; will be repeated automatically").twice();
		this.oLogMock.expects("error").withArgs("$batch failed");
		this.oLogMock.expects("error").withArgs("Failed to request side effects");

		this.expectRequest({
				batchNo : 3,
				method : "POST",
				payload : {Note : "Created"},
				url : "BusinessPartnerList('4711')/BP_2_SO"
			}, oCausingError)
			.expectRequest({
				batchNo : 3,
				method : "POST",
				payload : {Note : "Created as well"},
				url : "BusinessPartnerList('4711')/BP_2_SO"
			}) // no response required
			.expectRequest({
				batchNo : 3,
				url : "BusinessPartnerList('4711')?$select=BP_2_SO"
					+ "&$expand=BP_2_SO($select=Note,SalesOrderID)"
			}) // no response required
			.expectMessages([{
				message : "Communication error: 500 ",
				persistent : true,
				technical : true,
				technicalDetails : {
					httpStatus : 500 // CPOUI5ODATAV4-428
				},
				type : "Error"
			}, {
				message : "HTTP request was not processed because $batch failed",
				persistent : true,
				technical : true,
				technicalDetails : {
					httpStatus : 500 // CPOUI5ODATAV4-428
				},
				type : "Error"
			}]);

		return oCausingError;
	},
	text : "Repeated POST fails"
}].forEach(function (oFixture) {
	QUnit.test("requestSideEffects repeats failed POST - " + oFixture.text, function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTableBinding,
			sView = '\
<FlexBox id="form" binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" items="{BP_2_SO}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID"
				+ "&$expand=BP_2_SO($select=Note,SalesOrderID)", {
				BusinessPartnerID : "4711",
				BP_2_SO : [{
					Note : "Test",
					SalesOrderID : "0500000001"
				}]
			})
			.expectChange("id", ["0500000001"])
			.expectChange("note", ["Test"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.oLogMock.expects("error").withArgs("POST on 'BusinessPartnerList('4711')/BP_2_SO'"
				+ " failed; will be repeated automatically").twice();
			that.oLogMock.expects("error").withArgs("$batch failed");

			that.expectChange("id", ["", "", "0500000001"])
				.expectChange("note", ["Created as well", "Created", "Test"])
				.expectRequest({
					batchNo : 2,
					method : "POST",
					payload : {Note : "Created"},
					url : "BusinessPartnerList('4711')/BP_2_SO"
				}, createError())
				.expectRequest({
					batchNo : 2,
					method : "POST",
					payload : {Note : "Created as well"},
					url : "BusinessPartnerList('4711')/BP_2_SO"
				}) // no response required
				.expectMessages([{
					message : "Communication error: 500 ",
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					message : "HTTP request was not processed because $batch failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			oTableBinding = that.oView.byId("table").getBinding("items");
			oTableBinding.create({Note : "Created"}, /*bSkipRefresh*/true);
			oTableBinding.create({Note : "Created as well"}, /*bSkipRefresh*/true);

			return that.waitForChanges(assert, "2 POSTs fail initially");
		}).then(function () {
			var oCausingError;

			assert.equal(oTableBinding.getLength(), 3);

			// remove persistent, technical messages from above
			Messaging.removeAllMessages();
			that.expectMessages([]);

			oCausingError = oFixture.expectations.call(that);

			return Promise.all([
				// code under test
				that.oView.byId("form").getBindingContext().requestSideEffects([{
					$NavigationPropertyPath : "BP_2_SO"
				}]).then(function () {
					assert.notOk(oCausingError);
				}, function (oError) {
					if (!(oCausingError && oError.cause === oCausingError)) {
						throw oError;
					}
				}),
				that.waitForChanges(assert, "different expectations")
			]);
		}).then(function () {
			var aContexts = oTableBinding.getCurrentContexts();

			assert.equal(oTableBinding.getLength(), 3);
			assert.strictEqual(aContexts[0].getIndex(), 0);
			assert.strictEqual(aContexts[1].getIndex(), 1);
			assert.strictEqual(aContexts[2].getIndex(), 2);

			if (aContexts[0].isTransient()) {
				assertIndices(assert, aContexts, [-2, -1, 0]);

				that.expectRequest("DELETE SalesOrderList('0500000001')");

				return Promise.all([
					// code under test (BCP: 2170049510)
					aContexts[2].delete(),
					that.waitForChanges(assert, "BCP: 2170049510")
				]);
			}
		});
	});
});

	//*********************************************************************************************
	// Scenario: Creation of an entity fails due to a network error. A subsequent call to
	// requestSideEffects repeats the failed POST in the same $batch but fails again. All transient
	// contexts are kept, even if not visible.
	// JIRA: CPOUI5UISERVICESV3-1764 (now: CPOUI5ODATAV4-1361)
	QUnit.test("requestSideEffects keeps invisible transient contexts", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oNewContext,
			oTable,
			oTableBinding,
			sView = '\
<t:Table id="table" rows="{/SalesOrderList}" threshold="0" visibleRowCount="2">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=2", {
				value : [
					{Note : "Test 1", SalesOrderID : "0500000001"},
					{Note : "Test 2", SalesOrderID : "0500000002"}
				]
			})
			.expectChange("id", ["0500000001", "0500000002"])
			.expectChange("note", ["Test 1", "Test 2"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.oLogMock.expects("error")
				.withExactArgs("POST on 'SalesOrderList' failed; will be repeated automatically",
					sinon.match("Request intentionally failed"), sODLB);

			that.expectRequest({
					method : "POST",
					payload : {Note : "Created"},
					url : "SalesOrderList"
				}, createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}])
				.expectChange("id", ["", "0500000001"])
				.expectChange("note", ["Created", "Test 1"]);

			oTable = that.oView.byId("table");
			oTableBinding = oTable.getBinding("rows");
			oNewContext = oTableBinding.create({Note : "Created"}, /*bSkipRefresh*/true);

			return that.waitForChanges(assert, "creation fails");
		}).then(function () {
			that.expectChange("id", [, "0500000001", "0500000002"])
				.expectChange("note", [, "Test 1", "Test 2"]);

			// scroll down
			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert, "scroll down");
		}).then(function () {
			var oError = createErrorInsideBatch();

			// remove persistent, technical messages from above
			Messaging.removeAllMessages();

			that.oLogMock.expects("error")
				.withExactArgs("POST on 'SalesOrderList' failed; will be repeated automatically",
					sinon.match(oError.error.message), sODLB);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to get contexts for " + sSalesOrderService + "SalesOrderList"
					+ " with start index 1 and length 2",
					sinon.match(sPreviousFailed),
					sODLB);

			that.expectRequest({
					batchNo : 3,
					method : "POST",
					payload : {Note : "Created"},
					url : "SalesOrderList"
				}, oError)
				.expectRequest({
					batchNo : 3,
					url : "SalesOrderList?$select=Note,SalesOrderID&$skip=1&$top=2"
				}) // no response required
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				// code under test
				oTableBinding.getHeaderContext().requestSideEffects([{
					$NavigationPropertyPath : ""
				}]).then(mustFail(assert), function (oError0) {
					assert.strictEqual(oError0.message, sPreviousFailed);
				}),
				that.waitForChanges(assert, "repeat POST but fail again")
			]);
		}).then(function () {
			oNewContext.setProperty("Note", "Updated", null); // do not invoke POST again
			assert.strictEqual(oNewContext.getProperty("Note"), "Updated");

			that.expectChange("id", ["", "0500000001"])
				.expectChange("note", ["Updated", "Test 1"]);

			// scroll up
			oTable.setFirstVisibleRow(0);

			return that.waitForChanges(assert, "scroll up");
		});
	});

	//*********************************************************************************************
	// Scenario: Creating an entity and POST is still pending while requestSideEffects is called.
	// requestSideEffect must wait for the POST.
	// JIRA: CPOUI5UISERVICESV3-1936
	QUnit.test("requestSideEffects waits for pending POST", function (assert) {
		var oCreatedRowContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oRequestSideEffectsPromise,
			fnRespond,
			oTableBinding,
			sView = '\
<FlexBox id="form" binding="{/BusinessPartnerList(\'4711\')}">\
	<Table id="table" items="{BP_2_SO}">\
		<Text id="id" text="{SalesOrderID}"/>\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID"
				+ "&$expand=BP_2_SO($select=Note,SalesOrderID)", {
				BusinessPartnerID : "4711",
				BP_2_SO : [{
					Note : "Test",
					SalesOrderID : "0500000001"
				}]
			})
			.expectChange("id", ["0500000001"])
			.expectChange("note", ["Test"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.oLogMock.expects("error").withArgs("$batch failed");
			that.oLogMock.expects("error")
				.withExactArgs("POST on 'BusinessPartnerList('4711')/BP_2_SO' failed; "
					+ "will be repeated automatically", sinon.match.string, sODLB);

			that.expectRequest({
					method : "POST",
					payload : {Note : "Created"},
					url : "BusinessPartnerList('4711')/BP_2_SO"
				}, new Promise(function (_resolve, reject) {
					fnRespond = reject.bind(null, createError()); // take care of timing
				}))
				.expectChange("id", ["", "0500000001"])
				.expectChange("note", ["Created", "Test"]);

			oTableBinding = that.oView.byId("table").getBinding("items");
			oCreatedRowContext = oTableBinding.create({Note : "Created"}, /*bSkipRefresh*/true);

			return that.waitForChanges(assert);
		}).then(function () {
			var oFormContext = that.oView.byId("form").getBindingContext();

			// expect no requests as fnRespond not invoked yet

			// code under test - requestSideEffects has to wait for POST to finish
			oRequestSideEffectsPromise = oFormContext.requestSideEffects(["BP_2_SO"]);

			return that.waitForChanges(assert); // no real changes but for sake of consistency
		}).then(function () {
			that.expectMessages([{
					message : "Communication error: 500 ",
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					message : "HTTP request was not processed because $batch failed",
					persistent : true,
					technical : true,
					type : "Error"
				}])
				.expectRequest({
					batchNo : 3,
					method : "POST",
					payload : {Note : "Created"},
					url : "BusinessPartnerList('4711')/BP_2_SO"
				}, {
					Note : "Created",
					SalesOrderID : "43"
				})
				.expectRequest({
					batchNo : 3,
					url : "BusinessPartnerList('4711')?$select=BP_2_SO"
						+ "&$expand=BP_2_SO($select=Note,SalesOrderID)"
				}, {
					BusinessPartnerID : "4711",
					BP_2_SO : [{
						Note : "Created",
						SalesOrderID : "43"
					}, {
						Note : "Test",
						SalesOrderID : "0500000001"
					}]
				})
				.expectChange("id", ["43"]);

			// invocation here shall invoke all requests
			fnRespond();

			return Promise.all([
				// code under test
				oRequestSideEffectsPromise,
				oCreatedRowContext.created(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Change an entity and PATCH is still pending while requestSideEffects is called.
	// requestSideEffect must wait for the PATCH.
	// JIRA: CPOUI5UISERVICESV3-1936
	QUnit.test("requestSideEffects waits for pending PATCH", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oName,
			oRequestSideEffectsPromise,
			fnRespond,
			sView = '\
<FlexBox id="form" binding="{/BusinessPartnerList(\'4711\')}">\
	<Input id="name" value="{CompanyName}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('4711')?$select=BusinessPartnerID,CompanyName", {
				BusinessPartnerID : "4711",
				CompanyName : "SAP AG"
			})
			.expectChange("name", "SAP AG");

		return this.createView(assert, sView, oModel).then(function () {
			that.oLogMock.expects("error").withArgs("Failed to update path "
				+ "/BusinessPartnerList('4711')/CompanyName");
			that.oLogMock.expects("error").withArgs("$batch failed");

			that.expectRequest({
					method : "PATCH",
					payload : {CompanyName : "SAP SE"},
					url : "BusinessPartnerList('4711')"
				}, new Promise(function (_resolve, reject) {
					fnRespond = reject.bind(null, createError()); // take care of timing
				}))
				.expectChange("name", "SAP SE");

			oName = that.oView.byId("name");
			oName.getBinding("value").setValue("SAP SE");

			return that.waitForChanges(assert);
		}).then(function () {
			var oFormContext = that.oView.byId("form").getBindingContext();

			// expect no requests as fnRespond not invoked yet

			// code under test - requestSideEffects has to wait for POST to finish
			oRequestSideEffectsPromise = oFormContext.requestSideEffects([""]);

			return that.waitForChanges(assert); // no real changes but for sake of consistency
		}).then(function () {
			that.expectMessages([{
					message : "Communication error: 500 ",
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					message : "HTTP request was not processed because $batch failed",
					persistent : true,
					technical : true,
					type : "Error"
				}])
				.expectRequest({
					batchNo : 3,
					method : "PATCH",
					payload : {CompanyName : "SAP SE"},
					url : "BusinessPartnerList('4711')"
				}, {/* response does not matter here */})
				.expectRequest({
					batchNo : 3,
					url : "BusinessPartnerList('4711')?$select=BusinessPartnerID,CompanyName"
				}, {
					BusinessPartnerID : "4711",
					CompanyName : "SAP SE"
				});

			// invocation here shall invoke all requests
			fnRespond();

			return Promise.all([
				// code under test
				oRequestSideEffectsPromise,
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: requestSideEffects refreshes properties at the parent entity with the help of path
	// reduction via partner attributes. See that bubbling up is necessary again when processing the
	// reduced path in the parent context.
	// JIRA: CPOUI5ODATAV4-103
	// Extended with a collection-valued structural property and a collection-valued navigation
	// property.
	// JIRA: CPOUI5ODATAV4-221
	// For a context of a list binding, both a refresh of the whole collection and changes to
	// structural properties only ({"$PropertyPath":"*"}) are requested at the same time. Also, both
	// a refresh of the whole collection and of a single item ({$NavigationPropertyPath : ""}) are
	// requested at the same time. No duplicate requests are invoked, no errors happen.
	// BCP: 2070206648
	QUnit.test("requestSideEffects: path reduction", function (assert) {
		var oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{path : \'/SalesOrderList(\\\'42\\\')\', parameters : {$select : \'Messages\'}}">\
	<FlexBox binding="{}">\
		<Text id="note" text="{Note}"/>\
		<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
			<Text id="position" text="{ItemPosition}"/>\
			<Text id="amount" text="{GrossAmount}"/>\
		</Table>\
		<Table id="schedules" items="{path : \'SO_2_SCHDL\', parameters : {$$ownRequest : true}}">\
			<Text id="key" text="{ScheduleKey}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=Messages,Note,SalesOrderID", {
				Note : "Note",
				SalesOrderID : "42"
			})
			.expectChange("note", "Note")
			.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$select=GrossAmount,ItemPosition"
				+ ",SalesOrderID&$skip=0&$top=100", {
				value : [
					{GrossAmount : "3.14", ItemPosition : "0010", SalesOrderID : "42"},
					{GrossAmount : "2.72", ItemPosition : "0020", SalesOrderID : "42"}
				]
			})
			.expectChange("position", ["0010", "0020"])
			.expectChange("amount", ["3.14", "2.72"])
			.expectRequest("SalesOrderList('42')/SO_2_SCHDL?$select=ScheduleKey&$skip=0&$top=100",
				{value : [{ScheduleKey : "A"}]})
			.expectChange("key", ["A"]);

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("items").getItems()[0].getBindingContext();

			that.expectRequest("SalesOrderList('42')?$select=Messages,Note",
					{Note : "refreshed Note"})
				.expectRequest("SalesOrderList('42')/SO_2_SOITEM"
					+ "?$select=GrossAmount,ItemPosition,SalesOrderID"
					+ "&$filter=SalesOrderID eq '42' and ItemPosition eq '0010'", {
					value : [
						{GrossAmount : "1.41", ItemPosition : "0010", SalesOrderID : "42"}
					]
				})
				.expectRequest("SalesOrderList('42')/SO_2_SCHDL?$select=ScheduleKey"
					+ "&$skip=0&$top=100", {value : [{ScheduleKey : "B"}]})
				.expectChange("note", "refreshed Note")
				.expectChange("amount", ["1.41"])
				.expectChange("key", ["B"]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects([
					{$PropertyPath : "GrossAmount"},
					{$PropertyPath : "SOITEM_2_SO/Messages"},
					{$PropertyPath : "SOITEM_2_SO/Note"},
					{$NavigationPropertyPath : "SOITEM_2_SO/SO_2_SCHDL"}
				]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$select=GrossAmount,ItemPosition"
					+ ",SalesOrderID&$skip=0&$top=100", {
					value : [
						{GrossAmount : "10.42", ItemPosition : "0010", SalesOrderID : "42"},
						{GrossAmount : "30.42", ItemPosition : "0030", SalesOrderID : "42"}
					]
				})
				.expectChange("position", [, "0030"])
				.expectChange("amount", ["10.42", "30.42"]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects([
					{$PropertyPath : "*"}, // must not lead to failure (original BCP issue)
					{$NavigationPropertyPath : "SOITEM_2_SO/SO_2_SOITEM"}
				]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$select=GrossAmount,ItemPosition"
					+ ",SalesOrderID&$skip=0&$top=100", {
					value : [
						{GrossAmount : "110.42", ItemPosition : "0010", SalesOrderID : "42"},
						{GrossAmount : "130.42", ItemPosition : "0030", SalesOrderID : "42"},
						{GrossAmount : "140.42", ItemPosition : "0040", SalesOrderID : "42"}
					]
				})
				.expectChange("position", [,, "0040"])
				.expectChange("amount", ["110.42", "130.42", "140.42"]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects([
					{$NavigationPropertyPath : ""}, // should not invoke a duplicate request
					{$NavigationPropertyPath : "SOITEM_2_SO/SO_2_SOITEM"}
				]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Use requestSideEffects to refresh the property AValue in a parent cache of a list
	// binding using a different API group ID. The table has a reference to this property via
	// partner attributes. Due to the group ID mismatch, it cannot reuse the value, but has to
	// request it again.
	// Ensure that requestSideEffects refreshes both copies. (This proves that we must reduce
	// collection-valued properties anywhere in the path. It also proves that we must refresh
	// partially reduced paths: "/As(1)/AValue" and "/As(1)/AtoCs(2)/CtoA/AValue" from the original
	// "/As(1)/AtoCs(2)/CtoD/DtoC/CtoA/AValue".
	// JIRA: CPOUI5ODATAV4-221
	QUnit.test("requestSideEffects: parent cache of a list binding", function (assert) {
		var oModel = this.createSpecialCasesModel({
				autoExpandSelect : true,
				updateGroupId : "update1"
			}),
			sView = '\
<FlexBox binding="{/As(1)}">\
	<Text id="avalue::form" text="{AValue}"/>\
	<Table id="table" items="{path : \'AtoCs\', parameters : {$$updateGroupId : \'update2\'}}">\
		<Text id="cid" text="{CID}"/>\
		<Text id="avalue::table" text="{CtoA/AValue}"/>\
	</Table>\
</FlexBox>\
<FlexBox id="form" binding="{CtoD}">\
	<Text text="{DID}"/>\
	<Text id="dvalue" text="{DValue}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("As(1)?$select=AID,AValue", {
				AID : 1,
				AValue : 11
			})
			.expectChange("avalue::form", "11")
			.expectRequest("As(1)/AtoCs?$select=CID&$expand=CtoA($select=AID,AValue)"
				+ "&$skip=0&$top=100", {
				value : [{
					CID : 2,
					CtoA : {
						AID : 1,
						AValue : 11
					},
					CValue : 21
				}]
			})
			.expectChange("avalue::table", ["11"])
			.expectChange("cid", ["2"])
			.expectChange("dvalue");

		return this.createView(assert, sView, oModel).then(function () {
			// combined late property requests
			// see that DID does not occur twice in $Select when requested late
			that.expectRequest("As(1)/AtoCs(2)?$select=CtoD&$expand=CtoD($select=DID,DValue)", {
					CtoD : {
						DID : 3,
						DValue : 103
					}
				})
				.expectChange("dvalue", "103");

			that.oView.byId("form").setBindingContext(
				that.oView.byId("table").getItems()[0].getBindingContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("As(1)?$select=AValue",
					{AValue : 121}) // unrealistic, but shows the link between response and control
				.expectChange("avalue::form", "121")
				.expectRequest("As(1)/AtoCs?$select=CID&$expand=CtoA($select=AID,AValue)"
					+ "&$filter=CID eq 2", {
					value : [{
						CID : 2,
						CtoA : {
							AID : 1,
							AValue : 122 // unrealistic, see above
						}
					}]
				})
				.expectChange("avalue::table", ["122"]);

			// code under test
			return Promise.all([
				that.oView.byId("form").getBindingContext()
					.requestSideEffects([{$PropertyPath : "DtoC/CtoA/AValue"}], "$auto"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: requestSideEffects is called at a binding w/o cache and has to delegate to a
	// context of the parent binding. Additionally it requests a property from this parent binding
	// with the help of path reduction via partner attributes. See that only one request is
	// necessary.
	// JIRA: CPOUI5ODATAV4-103
	QUnit.test("requestSideEffects: path reduction and bubble up", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/As(1)}">\
	<Text id="aValue" text="{AValue}"/>\
	<FlexBox id="bInstance" binding="{AtoB}">\
		<Text id="bValue" text="{BValue}"/>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("As(1)?$select=AID,AValue&$expand=AtoB($select=BID,BValue)", {
				AID : 1,
				AValue : 11,
				AtoB : {
					BID : 2,
					BValue : 12
				}
			})
			.expectChange("aValue", "11")
			.expectChange("bValue", "12");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("bInstance").getElementBinding().getBoundContext();

			that.expectRequest("As(1)?$select=AValue&$expand=AtoB($select=BID,BValue)", {
					AValue : 111,
					AtoB : {
						BID : 2,
						BValue : 112
					}
				})
				.expectChange("aValue", "111")
				.expectChange("bValue", "112");

			return Promise.all([
				// code under test
				oContext.requestSideEffects(["BtoA/AValue", "BValue"]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh a context binding w/o property bindings invoking a request. Ensure that
	// dependent bindings refresh and that the promise resolves.
	// JIRA: CPOUI5ODATAV4-293
	QUnit.test("ODCB: requestRefresh w/o own request", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/BusinessPartnerList(\'42\')}">\
	<Table id="table" items="{path : \'BP_2_SO\', parameters : {$$ownRequest : true}}">\
		<Text id="note" text="{Note}" />\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('42')/BP_2_SO?$select=Note,SalesOrderID"
				+ "&$skip=0&$top=100", {
				value : [{
					Note : "Test",
					SalesOrderID : "0500000001"
				}]
			})
			.expectChange("note", ["Test"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("BusinessPartnerList('42')/BP_2_SO?$select=Note,SalesOrderID"
					+ "&$skip=0&$top=100", {
					value : [{
						Note : "Test - updated",
						SalesOrderID : "0500000001"
					}]
				})
				.expectChange("note", ["Test - updated"]);

			return Promise.all([
				that.oView.byId("form").getBindingContext().requestRefresh(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: hasPendingChanges and resetChanges work even while late child bindings are trying
	// to reuse the parent binding's cache.
	// JIRA: CPOUI5UISERVICESV3-1981, CPOUI5UISERVICESV3-1994
	//
	// Additionally, observe the "propertyChange" event and cancellation of its promise
	// JIRA: CPOUI5ODATAV4-1919
	QUnit.test("hasPendingChanges + resetChanges work for late child bindings", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oPromise,
			sView = '\
<Table id="orders" items="{path : \'/SalesOrderList\', parameters : {\
		$expand : {\
			SO_2_SOITEM : {\
				$select : [\'ItemPosition\',\'Note\',\'SalesOrderID\']\
			}\
		},\
		$select : \'Note\'\
	}}">\
	<Input id="note" value="{Note}"/>\
</Table>\
<Table id="items" items="{SO_2_SOITEM}">\
	<Text id="itemNote" text="{Note}"/>\
</Table>',
			that = this;

		// code under test
		oModel.attachPropertyChange(function (oEvent) {
			oPromise = oEvent.getParameter("promise");
		});

		this.expectRequest("SalesOrderList"
				+ "?$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID)"
				+ "&$select=Note,SalesOrderID"
				+ "&$skip=0&$top=100", {
				value : [{
					Note : "SO_1",
					SalesOrderID : "1",
					SO_2_SOITEM : [{
						ItemPosition : "10",
						Note : "Item_10",
						SalesOrderID : "1"
					}]
				}]
			})
			.expectChange("note", ["SO_1"])
			.expectChange("itemNote", []);

		return this.createView(assert, sView, oModel).then(function () {
			var oOrdersTable = that.oView.byId("orders"),
				oOrdersBinding = oOrdersTable.getBinding("items");

			that.expectChange("note", ["SO_1 changed"])
				.expectChange("note", ["SO_1"]);

			oOrdersTable.getItems()[0].getCells()[0].getBinding("value").setValue("SO_1 changed");

			assert.ok(oPromise, "propertyChange fired sync");

			// code under test
			assert.ok(oOrdersBinding.hasPendingChanges());

			that.expectChange("itemNote", ["Item_10"]);

			// Observe hasPendingChanges while the child binding is checking whether it can use the
			// parent cache
			that.oView.byId("items").setBindingContext(oOrdersBinding.getCurrentContexts()[0]);

			// code under test
			assert.ok(oOrdersBinding.hasPendingChanges());

			that.expectCanceledError("Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: $auto");

			return Promise.all([
				oOrdersBinding.resetChanges().then(function () {
					// code under test
					assert.notOk(oOrdersBinding.hasPendingChanges());
				}),
				checkCanceled(assert, oPromise),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Show that a property binding for the first element of an expanded collection works
	// w/o sending own requests, even if system query options are present for that expand.
	// BCP: 2280025746
	QUnit.test("BCP: 2280025746", function (assert) {
		var sView = '\
<Table items="{path : \'/SalesOrderList\', parameters : {\
		$expand : {\
			SO_2_SOITEM : {\
				$count : true,\
				$filter : \'Note ne \\\'\\\'\',\
				$levels : 1,\
				$orderby : \'ItemPosition\',\
				$search : \'covfefe\'\
			}\
		}\
	}}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Text id="item0Note" text="{SO_2_SOITEM/0/Note}"/>\
</Table>';

		this.expectRequest("SalesOrderList?$expand=SO_2_SOITEM($count=true;$filter=Note ne ''"
				+ ";$levels=1;$orderby=ItemPosition;$search=covfefe;$select=ItemPosition,Note"
				+ ",SalesOrderID)&$select=SalesOrderID&$skip=0&$top=100", {
				value : [{
					SalesOrderID : "1",
					SO_2_SOITEM : [{
						"@odata.count" : "1",
						ItemPosition : "10",
						Note : "covfefe",
						SalesOrderID : "1"
					}]
				}]
			})
			.expectChange("id", ["1"])
			.expectChange("item0Note", ["covfefe"]);

		return this.createView(assert, sView,
			this.createSalesOrdersModel({autoExpandSelect : true}));
	});

	//*********************************************************************************************
	// Scenario: Create a new entity without using a UI and persist it.
	// ODataModel#hasPendingChanges and ODataListBinding#hasPendingChanges work as expected even if
	// late properties below a list binding want to reuse the parent binding's cache. Relative list
	// binding without an own cache is necessary because determination whether cache can be used or
	// not is async.
	// Resetting pending changes works synchronously.
	// JIRA: CPOUI5UISERVICESV3-1981, CPOUI5UISERVICESV3-1994
	//
	// CPOUI5UISERVICESV3-1994 is obsolete now because the cache promise remains resolved and
	// resetChangesForPath can always run synchronously
	// BCP: 2370141835
[
	// late dependent binding does not influence hasPendingChanges for a parent list binding with a
	// persisted created entity.
	function (assert, oModel, oBinding, oCreatedContext) {
		this.expectChange("note", "New");

		this.oView.byId("form").setBindingContext(oCreatedContext);

		// code under test
		assert.notOk(oModel.hasPendingChanges());
		assert.notOk(oBinding.hasPendingChanges());

		return this.waitForChanges(assert);
	},
	// modify a persisted created entity; hasPendingChanges is not influenced by late properties;
	// resetChanges reverts changes synchronously (BCP: 2370141835)
	function (assert, oModel, oBinding, oCreatedContext) {
		var oPropertyBinding = oModel.bindProperty("Note", oCreatedContext);

		oPropertyBinding.initialize();
		oPropertyBinding.setValue("Modified"); // no change event; reset is done synchronously
		this.oView.byId("form").setBindingContext(oCreatedContext);

		// code under test
		assert.ok(oModel.hasPendingChanges());
		assert.ok(oBinding.hasPendingChanges());

		this.expectCanceledError("Failed to update path /SalesOrderList('43')/Note",
				"Request canceled: PATCH SalesOrderList('43'); group: $auto")
			.expectChange("note", "New");

		return Promise.all([
			// code under test
			oBinding.resetChanges().then(function () {
				// code under test
				assert.notOk(oModel.hasPendingChanges());
				assert.notOk(oBinding.hasPendingChanges());
			}),
			this.waitForChanges(assert)
		]);
	}
].forEach(function (fnTest, i) {
	var sTitle = "hasPendingChanges/resetChanges: late properties for a list binding without a UI"
			+ " and with a persisted created entity, #" + i;

	QUnit.test(sTitle, function (assert) {
		var oCreatedContext,
			oListBindingWithoutUI,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form">\
	<Text id="note" text="{Note}"/>\
	<Table id="items" items="{SO_2_SOITEM}">\
		<Text text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		oListBindingWithoutUI = oModel.bindList("/SalesOrderList", null, [], [],
			{$expand : {SO_2_SOITEM : null}});

		this.expectChange("note");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {}
				}, {
					Note : "New",
					SalesOrderID : "43"
				})
				.expectRequest("SalesOrderList('43')?$expand=SO_2_SOITEM", {
					Note : "New",
					SalesOrderID : "43",
					SO_2_SOITEM : []
				});

			oCreatedContext = oListBindingWithoutUI.create();

			// code under test
			assert.ok(oModel.hasPendingChanges());
			assert.ok(oListBindingWithoutUI.hasPendingChanges());

			return Promise.all([
				oCreatedContext.created(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// code under test
			assert.notOk(oModel.hasPendingChanges());
			assert.notOk(oListBindingWithoutUI.hasPendingChanges());

			return fnTest.call(that, assert, oModel, oListBindingWithoutUI, oCreatedContext);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Create a new entity without using a UI and reset it immediately. No request is
	// added to the queue and ODataModel#hasPendingChanges and ODataListBinding#hasPendingChanges
	// work as expected.
	// JIRA: CPOUI5UISERVICESV3-1994
	//
	// hasPendingChanges(true) must not be affected (SNOW: DINC0025951)
	QUnit.test("create an entity and immediately reset changes (no UI) V3-1994", function (assert) {
		var // use autoExpandSelect so that the cache is created asynchronously
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oListBindingWithoutUI = oModel.bindList("/SalesOrderList"),
				oCreatedPromise = oListBindingWithoutUI.create({}, true).created();

			assert.ok(oModel.hasPendingChanges());
			assert.ok(oListBindingWithoutUI.hasPendingChanges());
			assert.notOk(oListBindingWithoutUI.hasPendingChanges(true), "SNOW: DINC0025951");
			assert.strictEqual(oListBindingWithoutUI.getLength(), 1 + 10/*length is not final*/);

			return oListBindingWithoutUI.resetChanges().then(function () {
				assert.notOk(oModel.hasPendingChanges());
				assert.notOk(oListBindingWithoutUI.hasPendingChanges());
				assert.strictEqual(oListBindingWithoutUI.getLength(), 0);

				return Promise.all([
					checkCanceled(assert, oCreatedPromise),
					that.waitForChanges(assert) // to get all group locks unlocked
				]);
			});
		});
	});

	//*********************************************************************************************
	// In a binding with a transient context call hasPendingChanges and resetChanges in between a
	// sort and a filter. See that the transient context is removed.
	// Due to the sort before, resetChanges has to wait for the new cache. But the subsequent filter
	// starts building a new cache, so that the fetchCache for the sort becomes obsolete (which
	// caused resetChanges to fail).
	//
	// SNOW: DINC0025951 (hasPendingChanges)
	// SNOW: DINC0027242 (resetChanges)
	QUnit.test("DINC0027242", async function (assert) {
		const oModel = this.createSalesOrdersModel(
			{autoExpandSelect : true, updateGroupId : "noSubmit"});
		const sView = `
<Table id="table" items="{/SalesOrderList}">
	<Text id="id" text="{SalesOrderID}"/>
</Table>
`;
		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100",
				{value : [{SalesOrderID : "1"}]})
			.expectChange("id", ["1"]);

		await this.createView(assert, sView, oModel);

		this.expectChange("id", ["new", "1"]);

		const oBinding = this.oView.byId("table").getBinding("items");
		const oCreatedContext = oBinding.create({SalesOrderID : "new"});

		await this.waitForChanges(assert, "create");

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$orderby=SalesOrderID"
				+ "&$filter=SalesOrderID gt '0'&$skip=0&$top=99",
				{value : [{SalesOrderID : "1"}]})
			.expectChange("id", ["1"])
			// trying to fill the gap after deleting the transient context
			.expectRequest("SalesOrderList?$select=SalesOrderID&$orderby=SalesOrderID"
				+ "&$filter=SalesOrderID gt '0'&$skip=99&$top=1",
				{value : []});

		// code under test
		oBinding.sort(new Sorter("SalesOrderID"));
		assert.ok(oBinding.hasPendingChanges());
		assert.notOk(oBinding.hasPendingChanges(true), "SNOW: DINC0025951");
		const oResetChangesPromise = oBinding.resetChanges();
		oBinding.filter(new Filter("SalesOrderID", FilterOperator.GT, "0"));

		await Promise.all([
			oResetChangesPromise,
			checkCanceled(assert, oCreatedContext.created()),
			this.waitForChanges(assert, "sort, resetChanges, filter")
		]);

		assert.deepEqual(
			oBinding.getAllCurrentContexts().map(getPath),
			["/SalesOrderList('1')"]
		);
	});

	//*********************************************************************************************
	// Scenario: Create a new entity within a relative binding which is created via controller
	// code. Verify that ODataBinding#resetChanges works properly even if the cache for the list
	// binding is not yet available.
	// JIRA: CPOUI5UISERVICESV3-1994
	QUnit.test("Create relative via controller + resetChanges on parent", function (assert) {
		var oFormBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Table id="table" items="{SO_2_SOITEM}">\
		<Text id="note" text="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID)", {
				SalesOrderID : "1",
				SO_2_SOITEM : [{
					ItemPosition : "10",
					Note : "Foo",
					SalesOrderID : "1"
				}]
			})
			.expectChange("note", ["Foo"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oCreatedPromise;

			oFormBinding = that.oView.byId("form").getObjectBinding();
			oCreatedPromise = oModel.bindList("SO_2_SOITEM",
				oFormBinding.getBoundContext(), undefined, undefined,
				{$$updateGroupId : "doNotSubmit"}).create({}, true).created();

			return Promise.all([
				// code under test
				oFormBinding.resetChanges(),
				oCreatedPromise.then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message,
						"Request canceled: POST SalesOrderList('1')/SO_2_SOITEM; group: doNotSubmit"
					);
					assert.ok(oError.canceled);
				})
			]);
		}).then(function () {
			assert.notOk(oFormBinding.hasPendingChanges());
		});
	});

	//*********************************************************************************************
	// Scenario: Unpark a failed patch while requesting side effects. See that the PATCH response is
	// processed before the GET response.
	// JIRA: CPOUI5UISERVICESV3-1878
	QUnit.test("unpark keeps response processing order", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'4711\')}">\
	<Input id="note" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('4711')?$select=Note,SalesOrderID", {
				Note : "original",
				SalesOrderID : "4711"
			})
			.expectChange("note", "original");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("note", "modified")
				.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('4711')",
					payload : {Note : "modified"}
				}, createErrorInsideBatch({target : "Note"}))
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					target : "/SalesOrderList('4711')/Note",
					technical : true,
					type : "Error"
				}]);

			that.oLogMock.expects("error")
				.withArgs("Failed to update path /SalesOrderList('4711')/Note");

			that.oView.byId("note").getBinding("value").setValue("modified");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('4711')",
					payload : {Note : "modified"}
				}, {
					Note : "modified",
					SalesOrderID : "4711"
				})
				.expectRequest("SalesOrderList('4711')?$select=Note", {
					Note : "side effect"
				})
				.expectChange("note", "side effect");

			return Promise.all([
				that.oView.byId("form").getObjectBinding().getBoundContext()
					.requestSideEffects([{$PropertyPath : "Note"}]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// The application sets a custom header via model API and the following request contains the
	// custom header. Note that the integration test framework only allows for observing headers for
	// individual requests inside the $batch but not for the $batch itself.
	QUnit.test("ODataModel#changeHttpHeaders", function (assert) {
		var mHeaders = {Authorization : "Bearer xyz"},
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '<Text id="name" text="{/EMPLOYEES(0)/Name}"/>',
			that = this;

		this.expectRequest("EMPLOYEES(0)/Name", {value : "Frederic Fall"})
			.expectChange("name", "Frederic Fall");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					headers : mHeaders,
					url : "EMPLOYEES(0)/Name"
				}, {value : "Frederic Fall"});

			// code under test
			oModel.changeHttpHeaders(mHeaders);

			that.oView.byId("name").getBinding("text").refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Test whether UI5 configuration "securityTokenHandlers" is used to set security token headers
	//
	// JIRA: CPOUI5ODATAV4-1083
[false, true].forEach(function (bEarlyRequests) {
	QUnit.test("securityTokenHandlers: earlyRequests: " + bEarlyRequests, function (assert) {
		var oModel,
			mExpectedHeaders = {
				SomeSecurityTokenHeader : "foo",
				SomeOtherSecurityTokenHeader : "bar",
				"X-CSRF-Token" : undefined // Note: this is not sent by jQuery.ajax()
			},
			sView = '<Text id="name" text="{/EMPLOYEES(0)/Name}"/>',
			that = this;

		function securityTokenHandler0(sServiceUrl) {
			assert.strictEqual(sServiceUrl, sTeaBusi);
			return undefined; // not responsible
		}

		function securityTokenHandler1(sServiceUrl) {
			assert.strictEqual(sServiceUrl, sTeaBusi);
			return Promise.resolve({
				SomeSecurityTokenHeader : "foo",
				SomeOtherSecurityTokenHeader : "bar"
			});
		}

		function securityTokenHandler2() {
			return Promise.resolve({
				SomeSecurityTokenHeader : "only first matching handler wins"
			});
		}

		// code under test
		Security.setSecurityTokenHandlers([
			securityTokenHandler0,
			securityTokenHandler1,
			securityTokenHandler2
		]);

		oModel = this.createTeaBusiModel({autoExpandSelect : true, earlyRequests : bEarlyRequests});

		this.expectRequest({
					headers : mExpectedHeaders,
					url : "EMPLOYEES(0)/Name"
				}, {value : "Frederic Fall"})
			.expectChange("name", "Frederic Fall");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					headers : mExpectedHeaders,
					url : "EMPLOYEES(0)/Name"
				}, {value : "Frederic Fall"});

			that.oView.byId("name").getBinding("text").refresh();

			return that.waitForChanges(assert);
		}).finally(function () {
			Security.setSecurityTokenHandlers([]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Server-driven paging with sap.m.Table
	// We expect a "growing" table to only load data when invoked by the end-user via the "More"
	// button: There are no repeated requests in case the server-side page size is 2 and thus
	// smaller than the table's growing threshold and just the first page is displayed with less
	// data. The next request is only sent when the end user wants to see "More".
	// JIRA: CPOUI5UISERVICESV3-1908
	QUnit.test("Server-driven paging with sap.m.Table", function (assert) {
		var sView = '\
<Table id="table" items="{/EMPLOYEES}" growing="true" growingThreshold="10">\
	<Text id="text" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$skip=0&$top=10", {
				value : [
					{ID : "1", Name : "Peter Burke"},
					{ID : "2", Name : "Frederic Fall"}
				],
				"@odata.nextLink" : "~nextLink"
			})
			.expectChange("text", ["Peter Burke", "Frederic Fall"]);

		return this.createView(assert, sView).then(function () {
			that.expectRequest("EMPLOYEES?$skip=2&$top=18", {
					value : [
						{ID : "3", Name : "John Field"},
						{ID : "4", Name : "Susan Bay"}
					],
					"@odata.nextLink" : "~nextLink1"
				})
				.expectChange("text", [,, "John Field", "Susan Bay"]);

			that.oView.byId("table").requestItems();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Server-driven paging with sap.ui.table.Table
	// Read with server-driven paging in "gaps" does not remove elements behind the gap
	// JIRA: CPOUI5UISERVICESV3-1908
	//
	// Scenario: All contexts of a bound list available on the client are returned without firing
	// any request.
	// JIRA: CPOUI5MODELS-741
	QUnit.test("Server-driven paging with t:Table: no remove behind gap", function (assert) {
		var oListBinding,
			oTable,
			sView = '\
<t:Table id="table" rows="{/EMPLOYEES}" threshold="0" visibleRowCount="3">\
	<Text id="text" text="{Name}"/>\
</t:Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$skip=0&$top=3", {
				value : [
					{ID : "1", Name : "Peter Burke"},
					{ID : "2", Name : "Frederic Fall"}
				],
				"@odata.nextLink" : "~nextLink"
			})
			.expectRequest("EMPLOYEES?$skip=2&$top=1", {
				value : [
					{ID : "3", Name : "Carla Blue"}
				]
			})
			.expectChange("text", ["Peter Burke", "Frederic Fall", "Carla Blue"]);

		return this.createView(assert, sView).then(function () {
			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("rows");

			// code under test (CPOUI5MODELS-741)
			assert.deepEqual(oListBinding.getAllCurrentContexts().map(getPath), [
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')"
			]);

			that.expectRequest("EMPLOYEES?$skip=7&$top=3", {
					value : [
						{ID : "8", Name : "John Field"},
						{ID : "9", Name : "Susan Bay"}
					],
					"@odata.nextLink" : "~nextLink1"
				})
				.expectRequest("EMPLOYEES?$skip=9&$top=1", {
					value : [
						{ID : "10", Name : "Daniel Red"}
					]
				})
				.expectChange("text", [,,,,,,, "John Field", "Susan Bay", "Daniel Red"]);

			oTable.setFirstVisibleRow(7);

			return that.waitForChanges(assert);
		}).then(function () {
			// code under test (CPOUI5MODELS-741)
			assert.deepEqual(oListBinding.getAllCurrentContexts().map(getPath), [
				"/EMPLOYEES('1')",
				"/EMPLOYEES('2')",
				"/EMPLOYEES('3')",
				"/EMPLOYEES('8')",
				"/EMPLOYEES('9')",
				"/EMPLOYEES('10')"
			]);

			that.expectRequest("EMPLOYEES?$skip=3&$top=3", {
					value : [
						{ID : "4", Name : "Alice Grey"},
						{ID : "5", Name : "Bob Green"}
					],
					"@odata.nextLink" : "~nextLink2"
				})
				.expectRequest("EMPLOYEES?$skip=5&$top=1", {
					value : [
						{ID : "6", Name : "Erica Brown"}
					]
				})
				.expectChange("text", [,,, "Alice Grey", "Bob Green", "Erica Brown"]);

			oTable.setFirstVisibleRow(3);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("text", [,,,,,,, "John Field", "Susan Bay", "Daniel Red"]);

			oTable.setFirstVisibleRow(7);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Server-driven paging with sap.ui.table.Table
	// Requests following the first request which returned an @odata.nextLink do not request
	//   the prefetch size to avoid server load.
	// JIRA: CPOUI5UISERVICESV3-2018
	QUnit.test("Server-driven paging with t:Table: do not read prefetch", function (assert) {
		var sView = '\
<t:Table id="table" rows="{/EMPLOYEES}" visibleRowCount="3">\
	<Text id="text" text="{Name}"/>\
</t:Table>';

		this.expectRequest("EMPLOYEES?$skip=0&$top=103", {
				value : [
					{ID : "1", Name : "Peter Burke"},
					{ID : "2", Name : "Frederic Fall"}
				],
				"@odata.nextLink" : "~nextLink"
			})
			// request after response with @odata.nextLink does not consider prefetch size
			.expectRequest("EMPLOYEES?$skip=2&$top=1", {
				value : [
					{ID : "3", Name : "John Field"}
				]
			})
			.expectChange("text", ["Peter Burke", "Frederic Fall", "John Field"]);

		return this.createView(assert, sView);
	});

	//*********************************************************************************************
	// Scenario: Server-driven paging with requestContexts iterates @odata.nextLink until the
	// originally requested number of entities has been read.
	// JIRA: CPOUI5UISERVICESV3-1908
	//TODO Enhance test to cover the following cases distinguished regarding number of entities
	// requested by requestContexts
	// 1. server has less entities
	// 2. server has more entities
	// 3. @odata.nextLink sequence from responses results in (a) less or (b) more entities than
	//    requested
	QUnit.skip("Server-driven paging with OLDB#requestContexts", function (assert) {
		var that = this;

		return this.createView(assert).then(function () {
			var oBinding = that.oModel.bindList("/EMPLOYEES"),
				oPromise;

			that.expectRequest("EMPLOYEES?$skip=0&$top=3", {
					value : [
						{ID : "1", Name : "Peter Burke"},
						{ID : "2", Name : "Frederic Fall"}
					],
					"@odata.nextLink" : "~nextLink"
				})
				.expectRequest("~nextLink", {
					value : [
						{ID : "3", Name : "John Field"}
					]
				});

			// code under test
			oPromise = oBinding.requestContexts(0, 3).then(function (aContexts) {
				assert.deepEqual(aContexts.map(getPath), [
					"/EMPLOYEES('1')",
					"/EMPLOYEES('2')",
					"/EMPLOYEES('3')"
				]);
			});

			return Promise.all([
				oPromise,
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A property binding with a path using a collection navigation property must not
	// cause an invalid late property request.
	QUnit.test("BCP: 1970517588 - invalid property path", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/TEAMS(\'TEAM_01\')}">\
	<Text id="teamId" text="{Team_Id}"/>\
	<Text id="name" text="{TEAM_2_EMPLOYEES/Name}"/>\
</FlexBox>';

		this.oLogMock.expects("error")
			.withArgs("Failed to drill-down into TEAM_2_EMPLOYEES/Name, invalid segment: Name");

		this.expectRequest("TEAMS('TEAM_01')?$select=Team_Id"
				+ "&$expand=TEAM_2_EMPLOYEES($select=ID,Name)", {
				Team_Id : "TEAM_01",
				TEAM_2_EMPLOYEES : []
			})
			.expectChange("teamId", "TEAM_01")
			.expectChange("name", null);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Cache is immutable although oCachePromise becomes pending again. The list binding
	// inside the details must not prevent other bindings from sending their own request.
	// JIRA: CPOUI5UISERVICESV3-2025
	// Sync data access is possible although oCachePromise becomes pending again.
	// JIRA: CPOUI5ODATAV4-204
	QUnit.test("CPOUI5UISERVICESV3-2025, CPOUI5ODATAV4-204", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Text id="teamId" text="{Team_Id}"/>\
</Table>\
<FlexBox id="detail">\
	<Table id="employees" items="{TEAM_2_EMPLOYEES}">\
		<Text id="name" text="{Name}"/>\
	</Table>\
	<Text id="managerId" text="{MANAGER_ID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=100", {
				value : [{
					Team_Id : "TEAM_01"
				}]
			})
			.expectChange("teamId", ["TEAM_01"])
			.expectChange("name", [])
			.expectChange("managerId");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("table").getItems()[0].getBindingContext();

			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name&$skip=0&$top=100",
					{value : [{ID : "2", Name : "Frederic Fall"}]})
				.expectChange("name", ["Frederic Fall"])
				.expectRequest("TEAMS('TEAM_01')?$select=MANAGER_ID", {MANAGER_ID : "5"})
				.expectChange("managerId", "5");

			// code under test: bindings inside "detail" form need to send their own requests
			that.oView.byId("detail").setBindingContext(oContext);

			// code under test: sync data access...
			assert.deepEqual(oContext.getObject(), {Team_Id : "TEAM_01"});

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A list binding is used by a control, has already delivered its virtual context and
	// is about to remove it again. In between these two "change" events, #suspend and #resume is
	// used (say by controller code).
	// Avoid "Uncaught Error: Must not call method when the binding's root binding is suspended:
	// sap.ui.model.odata.v4.ODataListBinding: /|TEAMS"
	// JIRA: CPOUI5UISERVICESV3-2033
	QUnit.test("CPOUI5UISERVICESV3-2033", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{TEAMS}">\
	<Text id="teamId" text="{Team_Id}"/>\
</Table>',
			that = this;

		this.expectChange("teamId", []);

		return this.createView(assert, sView, oModel).then(function () {
			var oRootContext = that.oModel.createBindingContext("/"),
				oTable = that.oView.byId("table"),
				oListBinding = oTable.getBinding("items");

			that.expectCanceledError("Cache discarded as a new cache has been created")
				.expectCanceledError("Cache discarded as a new cache has been created")
				.expectCanceledError(sODLB + ": /|TEAMS: Failed to enhance query options for"
						+ " auto-$expand/$select for child Team_Id",
					"Cache discarded as a new cache has been created")
				.expectRequest("TEAMS?$select=Team_Id&$orderby=Team_Id&$filter=Budget gt 42"
					+ "&$skip=0&$top=100", {
					value : [{
						Team_Id : "TEAM_01"
					}]
				})
				.expectChange("teamId", ["TEAM_01"]);

			oTable.setBindingContext(oRootContext);
			oListBinding.suspend();
			oListBinding.filter(new Filter("Budget", FilterOperator.GT, 42));
			oListBinding.sort(new Sorter("Team_Id"));
			oListBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Controller code sets a field control property, but needs to avoid a PATCH request.
	// Later on, that property is overwritten again by some server response.
	// A (context) binding that did not yet read its data does not allow setting a property w/o a
	// PATCH request.
	// JIRA: CPOUI5ODATAV4-14
	// Additionally we show that it is possible to prevent a PATCH request by a binding parameter
	// $$noPatch : true
	// JIRA: CPOUI5ODATAV4-53
	// BCP: 2070052679 - allow to set a value for a property beneath a null :1 navigation property
	QUnit.test("CPOUI5ODATAV4-14", function (assert) {
		var oBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/TEAMS(\'42\')}" id="form">\
	<Input id="name" value="{Name}"/>\
	<Input id="budget" value="{path : \'Budget\', parameters : {$$noPatch : true}}"/>\
	<Input id="teamId"\
		value="{path : \'TEAM_2_MANAGER/TEAM_ID\', parameters : {$$noPatch : true}}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('42')?$select=Budget,Name,Team_Id"
				+ "&$expand=TEAM_2_MANAGER($select=ID,TEAM_ID)", {
				Budget : 1234,
				Name : "Team #1",
				Team_Id : "42",
				TEAM_2_MANAGER : null
			})
			.expectChange("budget", "1,234")
			.expectChange("name", "Team #1")
			.expectChange("teamId", "");

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("form").getObjectBinding();

			that.expectChange("name", "changed");
			// expect no PATCH request!

			return Promise.all([
				// code under test
				oBinding.getBoundContext().setProperty("Name", "changed", null),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("TEAMS('42')?$select=Budget,Name,Team_Id"
					+ "&$expand=TEAM_2_MANAGER($select=ID,TEAM_ID)", {
					Budget : 1234,
					Name : "Team #1",
					Team_Id : "42",
					TEAM_2_MANAGER : null
				})
				.expectChange("name", "Team #1");

			oBinding.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			var oContextBinding = oModel.bindContext("/TEAMS('42')");

			that.oLogMock.expects("error")
				.withExactArgs("Failed to update path /TEAMS('42')/Name",
					sinon.match("Unexpected request: GET TEAMS('42')"), sContext);

			that.expectMessages([{
				message : "Unexpected request: GET TEAMS('42')",
				persistent : true,
				technical : true,
				type : "Error"
			}]);

			return Promise.all([
				oContextBinding.getBoundContext().setProperty("Name", "changed", null)
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message,
							"Unexpected request: GET TEAMS('42')");
					}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("budget", "54,321")
				.expectChange("teamId", "42");
			// expect no PATCH request!

			return Promise.all([
				// code under test
				// JIRA: CPOUI5ODATAV4-53
				that.oView.byId("budget").getBinding("value").setValue(54321),
				that.oView.byId("teamId").getBinding("value").setValue("42"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("TEAMS('42')?$select=Budget,Name,Team_Id"
					+ "&$expand=TEAM_2_MANAGER($select=ID,TEAM_ID)", {
					Budget : 1234,
					Name : "Team #1",
					Team_Id : "42",
					TEAM_2_MANAGER : null
				})
				.expectChange("budget", "1,234")
				.expectChange("teamId", "");

			oBinding.refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: For a transient entity, a text property from a *:1 related entity is updated w/o a
	// PATCH. This must not fail, even though there is (of course) no key predicate for that related
	// entity known (yet).
	// BCP: 2070199671
	QUnit.test("BCP: 2070199671", function () {
		var oModel = this.createTeaBusiModel({updateGroupId : "doNotSubmit"}),
			oListBinding = oModel.bindList("/TEAMS"),
			oTransientContext = oListBinding.create({TEAM_2_MANAGER : {}});

		// code under test
		return oTransientContext.setProperty("TEAM_2_MANAGER/TEAM_ID", "42", null);
	});

	//*********************************************************************************************
	// Scenario: Use v4.Context#setProperty to update a property value in a way which becomes async,
	// change the binding's parent context in the meantime. Check that setting the property value
	// fails instead of changing the wrong data or so.
	// JIRA: CPOUI5ODATAV4-14
	QUnit.test("CPOUI5ODATAV4-108 what if context has changed in the meantime", function (assert) {
		var oModel = this.createTeaBusiModel({groupId : "$direct"}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oModel = that.oModel,
				oContextBinding = oModel.bindContext("Manager_to_Team"),
				fnRespond;

			oContextBinding.setContext(
				oModel.bindContext("/MANAGERS('1')", null, {$expand : "Manager_to_Team"})
					.getBoundContext());

			that.expectRequest("MANAGERS('1')?$expand=Manager_to_Team",
					new Promise(function (resolve) {
						fnRespond = resolve.bind(null, {
							ID : "1",
							Manager_to_Team : {
								Name : "Team #1",
								Team_Id : "Team_01"
							}
						});
					})
				)
				.expectMessages([{
					message : sinon.match.string, // browser-specific TypeError, see below
					persistent : true,
					technical : true,
					type : "Error"
				}], true);
			that.oLogMock.expects("error")
				.withArgs("Failed to update path /MANAGERS('1')/Manager_to_Team/Name");

			return Promise.all([
				oContextBinding.getBoundContext().setProperty("Name", "Darth Vader")
					.then(mustFail(assert), function () {
						// TypeError: Cannot read property 'resolve' of undefined
						// --> setProperty fails somehow because the old bound context has already
						// been destroyed; this is OK and better than changing the wrong data or so
						assert.ok(true);
					}),
				resolveLater(function () {
					oContextBinding.setContext(
						oModel.bindContext("/MANAGERS('2')", null, {$expand : "Manager_to_Team"})
							.getBoundContext());
					fnRespond();
				}, 10),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A PATCH (not shown here) invokes a side effect for the whole object page, while
	// a paginator switches to another item. The side effect's GET is thus ignored because the
	// cache for the old item is already inactive; thus the promise fails. Due to this failure, the
	// old cache was restored, which was wrong. Timing is essential!
	// BCP: 1970600374
	QUnit.test("BCP: 1970600374 (CPOUI5ODATAV4-34)", function (assert) {
		var oInput,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{path : \'\', parameters : {$$ownRequest : true}}">\
	<Input id="name" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			oInput = that.oView.byId("name");

			that.expectRequest("TEAMS('TEAM_01')?$select=Name,Team_Id", {
					Name : "Team #1",
					Team_Id : "TEAM_01"
				})
				.expectChange("name", "Team #1");
			that.oView.setBindingContext(oModel.bindContext("/TEAMS('TEAM_01')").getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			var sErrorMessage = sODCB + ": /TEAMS('TEAM_02')|"
					+ " is ignoring response from inactive cache: " + sTeaBusi
					+ "TEAMS('TEAM_01')?$select=Name,Team_Id",
				oPromise,
				fnRespond;

			// 1st, request side effects
			that.expectRequest("TEAMS('TEAM_01')?$select=Name,Team_Id",
					new Promise(function (resolve) {
						fnRespond = resolve.bind(null, {
							Name : "n/a",
							Team_Id : "TEAM_01"
						});
					}));

			oPromise = oInput.getBindingContext().requestSideEffects([""]);

			// 2nd, switch to different context
			that.expectRequest("TEAMS('TEAM_02')?$select=Name,Team_Id", {
					Name : "Team #2",
					Team_Id : "TEAM_02"
				})
				.expectCanceledError("Failed to read path /TEAMS('TEAM_01')", sErrorMessage)
				.expectCanceledError("Failed to read path /TEAMS('TEAM_01')/Name", sErrorMessage)
				.expectChange("name", "Team #2");

			setTimeout(function () {
				// pagination invoked by separate event --> new task
				that.oView.setBindingContext(
					oModel.bindContext("/TEAMS('TEAM_02')").getBoundContext());
				setTimeout(fnRespond, 0);
			}, 0);

			return Promise.all([
				oPromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectChange("name", "Palpatine")
				.expectRequest({
					method : "PATCH",
					payload : {Name : "Palpatine"},
					url : "TEAMS('TEAM_02')"
				}, {/* response does not matter here */});

			oInput.getBinding("value").setValue("Palpatine");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A PATCH (not shown here) invokes a side effect for the whole list, while a
	// paginator switches to another item. The side effect's GET is thus ignored because the cache
	// for the old item is already inactive; thus an internal promise fails. Due to this failure,
	// the old cache was restored, which was wrong. Timing is essential!
	// Follow-up to BCP: 1970600374 with an ODLB instead of an ODCB.
	// Then we switch back to the old item and the cache is reused. Show that the side effect was
	// not ignored.
	// JIRA: CPOUI5ODATAV4-34
	// The API Context#requestSideEffects must not fail only because the refresh response arrives
	// too late.
	// JIRA: CPOUI5ODATAV4-980
	QUnit.test("CPOUI5ODATAV4-34: ODLB instead of ODCB", function (assert) {
		var oContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="table" items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$$ownRequest : true}}">\
	<Input id="name" value="{Name}"/>\
</Table>',
			that = this;

		this.expectChange("name", []);

		return this.createView(assert, sView, oModel).then(function () {
			oContext = oModel.bindContext("/TEAMS('TEAM_01')").getBoundContext();
			oTable = that.oView.byId("table");

			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name"
					+ "&$skip=0&$top=100", {
					value : [{ID : "1", Name : "Jonathan Smith"}]
				})
				.expectChange("name", ["Jonathan Smith"]);

			oTable.setBindingContext(oContext);

			return that.waitForChanges(assert);
		}).then(function () {
			var oBinding, oPromise, fnRespond;

			// 1st, request side effects
			that.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name"
					+ "&$skip=0&$top=100",
					new Promise(function (resolve) {
						fnRespond = resolve.bind(null, {
							value : [{ID : "1", Name : "Darth Vader"}]
						});
					}));

			oBinding = oTable.getBinding("items");
			oPromise = oBinding.getHeaderContext().requestSideEffects([""]);

			// 2nd, switch to different context
			that.expectRequest("TEAMS('TEAM_02')/TEAM_2_EMPLOYEES?$select=ID,Name"
					+ "&$skip=0&$top=100", {
					value : [{ID : "2", Name : "Frederic Fall"}]
				})
				.expectCanceledError("Failed to get contexts for " + sTeaBusi
						+ "TEAMS('TEAM_01')/TEAM_2_EMPLOYEES with start index 0 and length 100",
					sODLB + ": /TEAMS('TEAM_02')|TEAM_2_EMPLOYEES"
						+ " is ignoring response from inactive cache: " + sTeaBusi
						+ "TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name")
				.expectChange("name", ["Frederic Fall"]);

			setTimeout(function () {
				// pagination invoked by separate event --> new task
				oTable.setBindingContext(oModel.bindContext("/TEAMS('TEAM_02')").getBoundContext());
				setTimeout(fnRespond, 0);
			}, 0);

			return Promise.all([
				oPromise,
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// 3rd, change a value
			var oInput = oTable.getItems()[0].getCells()[0]; // Note: different instance now!

			that.expectChange("name", ["Palpatine"])
				.expectRequest({
					method : "PATCH",
					payload : {Name : "Palpatine"},
					url : "EMPLOYEES('2')"
				}, {/* response does not matter here */});

			oInput.getBinding("value").setValue("Palpatine");

			return that.waitForChanges(assert);
		}).then(function () {
			// 4th, switch back again
			that.expectChange("name", ["Darth Vader"]);

			oTable.setBindingContext(oContext);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A list binding refreshes itself completely due to a side effect, but that GET fails
	// and thus the old cache is restored. Check that transient contexts are properly preserved.
	// JIRA: CPOUI5ODATAV4-34
	QUnit.test("CPOUI5ODATAV4-34: bKeepCacheOnError & transient rows", function (assert) {
		var oListBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			oNewContext,
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Input id="name" value="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100", {
				value : [
					{Name : "Team 01", Team_Id : "Team_01"},
					{Name : "Team 02", Team_Id : "Team_02"}
				]
			})
			.expectChange("name", ["Team 01", "Team 02"]);

		return this.createView(assert, sView, oModel).then(function () {
			// create a transient row
			that.expectChange("name", ["Team 00", "Team 01", "Team 02"]);

			oListBinding = that.oView.byId("table").getBinding("items");
			oNewContext = oListBinding.create({Name : "Team 00", Team_Id : "Team_00"}, true);

			assert.strictEqual(oNewContext.getIndex(), 0);
			assertIndices(assert, oListBinding.getCurrentContexts(), [-1, 0, 1]);

			return that.waitForChanges(assert);
		}).then(function () {
			var oError = new Error("418 I'm a teapot"),
				oSideEffectsPromise;

			// refresh via side effect fails
			that.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=99", oError)
				.expectMessages([{
					message : oError.message,
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to get contexts for " + sTeaBusi
						+ "TEAMS with start index 0 and length 100",
					sinon.match.string, sODLB);

			oSideEffectsPromise = oListBinding.getHeaderContext()
				.requestSideEffects([{$NavigationPropertyPath : ""}], "$direct");

			//TODO fix Context#getIndex to not return -1; [...]
			// assert.strictEqual(oNewContext.getIndex(), 0);

			return Promise.all([
				oSideEffectsPromise.then(mustFail(assert), function (oError0) {
					assert.strictEqual(oError0, oError);
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oNewContext.getIndex(), 0);
			assertIndices(assert, oListBinding.getCurrentContexts(), [-1, 0, 1]);

			that.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {Name : "Team 00", Team_Id : "Team_00"}
				}, {Name : "Team 00", Team_Id : "Team_00"});

			return Promise.all([
				oModel.submitBatch("update"),
				oNewContext.created(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Two concurrent requestSideEffects refreshing the same list. The first
	// requestSideEffects will then fail because its cache is no longer active, but it must not
	// destroy the second one.
	// BCP: 2080439734
	QUnit.test("BCP: 2080439734: concurrent requestSideEffects", function (assert) {
		var oHeaderContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oPromise1,
			oPromise2,
			fnResolve,
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Input id="name" value="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100", {
				value : [
					{Name : "Team 01", Team_Id : "01"}
				]
			})
			.expectChange("name", ["Team 01"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100",
					new Promise(function (resolve) { fnResolve = resolve; })
				);

			oHeaderContext = that.oView.byId("table").getBinding("items").getHeaderContext();

			// code under test
			oPromise1 = oHeaderContext.requestSideEffects([""]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectCanceledError("Failed to get contexts for " + sTeaBusi
						+ "TEAMS with start index 0 and length 100",
					sODLB + ": /TEAMS is ignoring response from inactive cache: " + sTeaBusi
						+ "TEAMS?$select=Name,Team_Id")
				.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100", {
					value : [
						{Name : "Team 01*", Team_Id : "01"}
					]
				})
				.expectChange("name", ["Team 01*"]);

			// code under test
			oPromise2 = oHeaderContext.requestSideEffects([""]);
			// now respond the first request
			fnResolve({value : [/*n/a*/]});

			return Promise.all([
				oPromise1,
				oPromise2,
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: AnnotationHelper.format is called for an annotation that points to a property typed
	// with an EDM type that is not mapped to a UI5 type
	// BCP: 2080062941
	testXMLTemplating("BCP: 2080062941",
		"createSpecialCasesModel",
' template:require="{\'AnnotationHelper\':\'sap/ui/model/odata/v4/AnnotationHelper\'}">\
<template:alias name="format" value="AnnotationHelper.format">\
	<template:repeat \
		list="{meta>/special.cases.EntityWithUnsupportedEdmTypes/@com.sap.vocabularies.UI.v1.SelectionFields}"\
		var="field">\
			<Input value="{field>@@format}"/>\
	</template:repeat>\
</template:alias>', '\
<Input value="{Binary}"/>\
<Input value="{Duration}"/>');

	//*********************************************************************************************
	// Scenario: An empty $NavigationPropertyPath is annotated as a side effect target. "All
	// affected entities need to be explicitly listed. An empty path means the annotation target."
	// --> We expect the caller to map {$NavigationPropertyPath : ""} to {$PropertyPath : "*"} in
	// order to opt-in to this interpretation.
	//
	// BCP: 2070022577
	//
	// Scenario 2: Two GET requests for side effects are merged. One is expecting changes for
	// structural properties only ("*") and fails if a key predicate changes. The other allows that
	// a complete navigation property changes; it does not fail if a key predicate changes. Make
	// sure that the check for unexpected changes of key predicates does not fail due to this
	// merging.
	// BCP: 2170263464
	//
	// There is an ODCB with empty path in between, sending own requests (see "standalone"). Its
	// side effect GET must not be merged to ensure that response processing is not skipped.
	// BCP: 2180419641
	QUnit.test("requestSideEffects: {$PropertyPath : '*'}", function (assert) {
		var oContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}" id="form">\
	<Text id="city" text="{Address/City}"/>\
	<Text id="name" text="{Name}"/>\
	<Text binding="{BestPublication}" id="price0" text="{Price}"/>\
	<FlexBox binding="{BestFriend/BestFriend}">\
		<Text id="friends_friend0" text="{Name}"/>\
		<Text binding="{BestPublication}" id="price1" text="{Price}"/>\
	</FlexBox>\
	<FlexBox binding="{path : \'\', parameters : {$$ownRequest : true}}" id="standalone">\
		<Text id="friends_friend1" text="{BestFriend/BestFriend/Name}"/>\
	</FlexBox>\
	<FlexBox binding="{}" id="section">\
		<Text binding="{path : \'DraftAdministrativeData\', parameters : {$$ownRequest : true}}"\
			id="inProcessByUser" text="{InProcessByUser}"/>\
	</FlexBox>\
	<Table id="table" items="{path : \'_Publication\', parameters : {$$ownRequest : true}}">\
		<Text id="price2" text="{Price}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
				+ ";$expand=BestFriend($select=ArtistID,IsActiveEntity,Name))", {
				ArtistID : "42",
				BestFriend : {
					ArtistID : "23",
					BestFriend : {
						ArtistID : "24",
						IsActiveEntity : true,
						Name : "Best Friend"
					},
					IsActiveEntity : true
				},
				IsActiveEntity : true
			})
			.expectChange("friends_friend1", "Best Friend")
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/DraftAdministrativeData"
				+ "?$select=DraftID,InProcessByUser", {
				DraftID : "1",
				InProcessByUser : "foo"
			})
			.expectChange("inProcessByUser", "foo")
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
				+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [{
						Price : "9.99",
						// Note: this key property is essential for the $filter below!
						PublicationID : "42-0"
					}]
				})
			.expectChange("price2", ["9.99"])
			.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
				+ "?$select=Address/City,ArtistID,IsActiveEntity,Name"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
					+ ";$expand=BestFriend($select=ArtistID,IsActiveEntity,Name"
						+ ";$expand=BestPublication($select=Price,PublicationID)))"
				+ ",BestPublication($select=Price,PublicationID)", {
				Address : {
					City : "Heidelberg"
				},
				ArtistID : "42",
				BestFriend : {
					ArtistID : "23",
					BestFriend : {
						ArtistID : "24",
						BestPublication : {
							Price : "8.88",
							PublicationID : "24-0"
						},
						IsActiveEntity : true,
						Name : "Best Friend"
					},
					IsActiveEntity : true
				},
				BestPublication : {
					Price : "9.99",
					PublicationID : "42-0"
				},
				IsActiveEntity : true,
				Name : "Hour Frustrated"
			})
			.expectChange("city", "Heidelberg")
			.expectChange("name", "Hour Frustrated")
			.expectChange("price0", "9.99")
			.expectChange("friends_friend0", "Best Friend")
			.expectChange("price1", "8.88");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("form").getBindingContext();

			// Note: BestFriend, BestPublication, and DraftAdministrativeData unaffected!
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=Address/City,ArtistID,IsActiveEntity,Name", {
					Address : {
						City : "Walldorf"
					},
					ArtistID : "42",
					IsActiveEntity : true,
					Name : "Minute Frustrated"
				})
				.expectChange("city", "Walldorf")
				.expectChange("name", "Minute Frustrated")
				//TODO avoid this useless GET for key properties only!
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity", {
					ArtistID : "42",
					IsActiveEntity : true
				});

			return Promise.all([
				// code under test
				oContext.requestSideEffects([{$PropertyPath : "*"}]),
				that.waitForChanges(assert, "*")
			]);
		}).then(function () {
			var sError = "Key predicate of 'BestFriend' changed"
					+ " from (ArtistID='23',IsActiveEntity=true)"
					+ " to (ArtistID='s.o.else',IsActiveEntity=true)";

			// Note: BestFriend/BestFriend unaffected!
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity)", {
					BestFriend : {
						ArtistID : "s.o.else", // this is NOT expected to happen --> see error below
						IsActiveEntity : true
					}
				})
				.expectMessages([{
					message : sError,
					persistent : true,
					technical : true,
					type : "Error"
				}])
				//TODO avoid this useless GET for key properties only? no changes allowed anyway!
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
					+ "?$select=BestFriend&$expand=BestFriend($select=ArtistID,IsActiveEntity)", {
					BestFriend : {
						ArtistID : "23",
						IsActiveEntity : true
					}
				});
			that.oLogMock.expects("error").withArgs("Failed to request side effects");

			return Promise.all([
				// code under test
				oContext.requestSideEffects(["BestFriend/*"])
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message, sError);
					}),
				that.waitForChanges(assert, "BestFriend/*")
			]);
		}).then(function () {
			// Note: BestFriend/BestFriend's BestPublication unaffected!
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
						+ ";$expand=BestFriend($select=ArtistID,IsActiveEntity,Name))", {
					BestFriend : {
						ArtistID : "23",
						BestFriend : {
							ArtistID : "24",
							IsActiveEntity : true,
							Name : "TAFKAP"
						},
						IsActiveEntity : true
					}
				})
				.expectChange("friends_friend0", "TAFKAP")
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
						+ ";$expand=BestFriend($select=ArtistID,IsActiveEntity,Name))", {
					BestFriend : {
						ArtistID : "23",
						BestFriend : {
							ArtistID : "24",
							IsActiveEntity : true,
							Name : "TAFKAP"
						},
						IsActiveEntity : true
					}
				})
				.expectChange("friends_friend1", "TAFKAP");

			return Promise.all([
				// code under test
				oContext.requestSideEffects([{$PropertyPath : "BestFriend/BestFriend/*"}]),
				that.waitForChanges(assert, "BestFriend/BestFriend/*")
			]);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
						+ ";$expand=BestFriend($select=ArtistID,IsActiveEntity"
							+ ";$expand=BestPublication($select=Price,PublicationID)))", {});

			return Promise.all([
				// code under test
				oContext.requestSideEffects(["BestFriend/BestFriend/BestPublication/*"]),
				that.waitForChanges(assert, "BestFriend/BestFriend/BestPublication/*")
			]);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$filter=PublicationID eq '42-0'", {
					value : [{
						Price : "9.09",
						PublicationID : "42-0"
					}]
				})
				.expectChange("price2", ["9.09"]);

			return Promise.all([
				// code under test
				oContext.requestSideEffects([{$PropertyPath : "_Publication/*"}]),
				that.waitForChanges(assert, "_Publication/*")
			]);
		}).then(function () {
			var oHeaderContext = that.oView.byId("table").getBinding("items").getHeaderContext();

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$filter=PublicationID eq '42-0'", {
					value : [{
						Price : "9.01",
						PublicationID : "42-0"
					}]
				})
				.expectChange("price2", ["9.01"]);

			return Promise.all([
				// code under test
				oHeaderContext.requestSideEffects([{$PropertyPath : "*"}]),
				that.waitForChanges(assert, "* (@ _Publication)")
			]);
		}).then(function () {
			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
						+ ";$expand=BestFriend($select=ArtistID,IsActiveEntity,Name"
							+ ";$expand=BestPublication($select=Price,PublicationID)))"
					+ ",BestPublication($select=Price,PublicationID)", {
					BestFriend : {
						ArtistID : "23",
						BestFriend : {
							ArtistID : "42", // this change must not result in an error
							BestPublication : {
								Price : "2.22",
								PublicationID : "42-0"
							},
							IsActiveEntity : true,
							Name : "Princess"
						},
						IsActiveEntity : true
					},
					BestPublication : {
						Price : "-2.22", // unrealistic but useful, should be 2.22: see pub. "42-0"
						PublicationID : "42-0"
					}
				})
				.expectChange("price1", "2.22")
				.expectChange("friends_friend0", "Princess")
				.expectChange("price0", "-2.22")
				.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity"
						+ ";$expand=BestFriend($select=ArtistID,IsActiveEntity,Name))", {
					BestFriend : {
						ArtistID : "23",
						BestFriend : {
							ArtistID : "42",
							IsActiveEntity : true,
							Name : "Princess"
						},
						IsActiveEntity : true
					}
				})
				.expectChange("friends_friend1", "Princess");

			return Promise.all([
				// code under test (BCP: 2170263464)
				oContext.requestSideEffects(["BestPublication/*"]),
				oContext.requestSideEffects(["BestFriend"]),
				that.waitForChanges(assert, "Scenario 2")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Get a property value from an ODataListBinding bound to a sap.m.Table while the
	// table is reading data to grow. W/o autoExpandSelect, we just drop the key property from the
	// response in order to use indices instead of key predicates in context paths.
	// JIRA: CPOUI5ODATAV4-115
[false, true].forEach(function (bAutoExpandSelect) {
	var oSalesOrder = bAutoExpandSelect
			? {SalesOrderID : "01", Note : "Note 1"}
			: {Note : "Note 1"},
		sSelect = bAutoExpandSelect ? "$select=Note,SalesOrderID&" : "",
		sTitle = "Context#getProperty while table is reading, autoExpandSelect = "
			+ bAutoExpandSelect,
		sView = '\
<Table id="table" growing="true" growingThreshold="1"\
		items="{path : \'/SalesOrderList\', parameters : {$count : true}}">\
	<Text id="note" text="{Note}"/>\
</Table>';

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : bAutoExpandSelect}),
			that = this;

		this.expectRequest("SalesOrderList?$count=true&" + sSelect + "$skip=0&$top=1", {
				"@odata.count" : "42",
				value : [oSalesOrder]
			})
			.expectChange("note", ["Note 1"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oTable = that.oView.byId("table"),
				oHeaderContext = oTable.getBinding("items").getHeaderContext();

			// Note: "$tail" does not yield a red test here, it's created only on demand
			["$byPredicate", "$created", "length"].forEach(function (sProperty) {
				assert.throws(function () {
					oHeaderContext.getObject(sProperty);
				}, new Error("Invalid header path: " + sProperty));
			});
			that.expectRequest("SalesOrderList?$count=true&" + sSelect + "$skip=1&$top=1", {
					"@odata.count" : "23",
					value : [{Note : "Note 2"}]
				})
				.expectChange("note", [, "Note 2"]);

			oTable.requestItems(); // show more items

			assert.strictEqual(
				// code under test
				oTable.getItems()[0].getBindingContext().getProperty("Note"),
				"Note 1");
			// code under test
			assert.strictEqual(oHeaderContext.getProperty("$count"), 42);

			return Promise.all([
				// code under test
				oHeaderContext.requestProperty("1/Note").then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, "Invalid header path: 1/Note");
				}),
				oHeaderContext.requestProperty("$count").then(function (oResult) {
					assert.strictEqual(oResult, 23);
				}),
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: list binding is used to create an entity, but the metadata could not be loaded
	// JIRA: CPOUI5ODATAV4-231
	QUnit.test("CPOUI5ODATAV4-231: ODLB#create failed due to failed $metadata", function (assert) {
		var oModel = this.createModel("/invalid/model/", {}, {
				"/invalid/model/$metadata" : {code : 500}
			}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oListBinding = oModel.bindList("/People");

			that.oLogMock.expects("error")
				.withExactArgs("GET /invalid/model/$metadata",
					"Could not load metadata: 500 Internal Server Error",
					"sap.ui.model.odata.v4.lib._MetadataRequestor");
			// Note: this error message is a bit misleading ;-)
			that.oLogMock.expects("error")
				.withExactArgs("POST on 'People' failed; will be repeated automatically",
					sinon.match("Could not load metadata: 500 Internal Server Error"), sODLB);
			that.expectRequest({
					method : "POST",
					url : "People",
					payload : {}
				})
				.expectMessages([{
					message : "Could not load metadata: 500 Internal Server Error",
					persistent : true,
					technical : true,
					technicalDetails : {
						httpStatus : 500 // CPOUI5ODATAV4-428
					},
					type : "Error"
				}]);

			return Promise.all([
				oListBinding.create().created().then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message,
							"Could not load metadata: 500 Internal Server Error");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A bound action is invoked, accompanied by a side effect. The action returns a
	// wrong response, but the side effect must win anyway!
	// BCP: 2070200175
	// JIRA: CPOUI5ODATAV4-288
	// Note that before the fix for BCP 2080268833 this worked more or less accidentally. The "C"
	// from the POST was not applied because the cache was busy from requestSideEffects and did not
	// deliver the old predicate, so the binding parameter was not updated.
	QUnit.test("BCP: 2070200175, CPOUI5ODATAV4-288: POST > GET", function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Text id="status" text="{LifecycleStatus}"/>\
	<FlexBox id="action" binding="{' + sAction + '(...)}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=LifecycleStatus,SalesOrderID", {
				LifecycleStatus : "N",
				SalesOrderID : "1"
			})
			.expectChange("status", "N");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('1')/" + sAction,
					payload : {}
				}, {
					LifecycleStatus : "N", // Note: wrong response, should be "C"
					SalesOrderID : "1"
				})
				.expectRequest("SalesOrderList('1')?$select=LifecycleStatus", {
					LifecycleStatus : "C"
				})
				.expectChange("status", "C");

			return Promise.all([
				that.oView.byId("action").getObjectBinding().invoke(),
				that.oView.byId("form").getBindingContext().requestSideEffects(["LifecycleStatus"]),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: "Prefer:handling=strict"
	// Invoke an action with an fnOnStrictHandlingFailed callback given in order to have the
	// "Prefer:handling=strict" HTTP header set. bConfirm controls how the callback is resolved.
	//
	// JIRA: CPOUI5ODATAV4-943
	// BCP: 2280172148 more than one action in change set + check that the right callback is called
	//
	// Invoke three actions in a changeset, each with a fnOnStrictHandlingFailed handler. The batch
	// fails due to strict-handling and the response contains error messages for the first and
	// second request or only for the first. No error message for the third request. See that each
	// handler is called with the correct (or none) errors.
	// SNOW: DINC0032238
[true, false].forEach(function (bConfirm) {
	[true, false].forEach(function (bDifferentContentIDs) {
		const sTitle = "CPOUI5ODATAV4-943: handling=strict, confirm=" + bConfirm
			+ ", different content IDs=" + bDifferentContentIDs;
	QUnit.test(sTitle, function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oAction0Promise,
			oAction1Promise,
			oAction2Promise,
			oErrorObject = {
				details : [{
					"@Common.numericSeverity" : 3,
					code : "CODE1",
					"@SAP__core.ContentID" : "0.0",
					message : "Note is empty",
					target : "SalesOrder/Note"
				}, {
					"@Common.numericSeverity" : 3,
					code : "CODE1",
					"@SAP__core.ContentID" : "0.0",
					message : "Note is empty",
					target : "SalesOrder/Note"
				}, {
					"@Common.numericSeverity" : 2,
					code : "CODE2",
					"@SAP__core.ContentID" : "0.0",
					message : "Some unbound info"
				}]
			},
			oError,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			fnResolve0,
			fnResolve1,
			fnResolve2,
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="status" text="{LifecycleStatus}"/>\
</Table>',
			that = this;

		function onStrictHandlingFailed0(aMessages) {
			assert.strictEqual(aMessages[0].getMessage(), "Note is empty");
			assert.strictEqual(aMessages[0].getCode(), "CODE1");
			assert.strictEqual(aMessages[0].getTargets()[0], "/SalesOrderList('0')/Note");
			assert.strictEqual(aMessages[0].getType(), "Warning");
			if (bDifferentContentIDs) {
				assert.strictEqual(aMessages.length, 1);
			} else {
				assert.strictEqual(aMessages.length, 3);
				assert.strictEqual(aMessages[1].getMessage(), "Note is empty");
				assert.strictEqual(aMessages[1].getCode(), "CODE1");
				assert.strictEqual(aMessages[1].getTargets()[0], "/SalesOrderList('0')/Note");
				assert.strictEqual(aMessages[1].getType(), "Warning");
				assert.strictEqual(aMessages[2].getMessage(), "Some unbound info");
				assert.strictEqual(aMessages[2].getCode(), "CODE2");
				assert.strictEqual(aMessages[2].getTargets()[0], "");
				assert.strictEqual(aMessages[2].getType(), "Information");
			}
			return new Promise(function (resolve) {
				fnResolve0 = resolve;
			});
		}

		function onStrictHandlingFailed1(aMessages) {
			if (bDifferentContentIDs) {
				assert.strictEqual(aMessages.length, 2);
				assert.strictEqual(aMessages[0].getMessage(), "Note is empty");
				assert.strictEqual(aMessages[0].getCode(), "CODE1");
				assert.strictEqual(aMessages[0].getTargets()[0], "/SalesOrderList('1')/Note");
				assert.strictEqual(aMessages[0].getType(), "Warning");
				assert.strictEqual(aMessages[1].getMessage(), "Some unbound info");
				assert.strictEqual(aMessages[1].getCode(), "CODE2");
				assert.strictEqual(aMessages[1].getTargets()[0], "");
				assert.strictEqual(aMessages[1].getType(), "Information");
			} else {
				assert.strictEqual(aMessages.length, 0);
			}
			return new Promise(function (resolve) {
				fnResolve1 = resolve;
			});
		}

		function onStrictHandlingFailed2(aMessages) {
			assert.strictEqual(aMessages.length, 0);
			return new Promise(function (resolve) {
				fnResolve2 = resolve;
			});
		}

		// change detail ContentID from 0.0 to 1.0 for the second and third message
		if (bDifferentContentIDs) {
			oErrorObject.details[1]["@SAP__core.ContentID"] = "1.0";
			oErrorObject.details[2]["@SAP__core.ContentID"] = "1.0";
		}
		oError = createErrorInsideBatch(oErrorObject, 412);

		this.expectRequest("SalesOrderList?$select=LifecycleStatus,SalesOrderID&$skip=0&$top=100", {
				value : [{
						LifecycleStatus : "N0",
						SalesOrderID : "0"
					}, {
						LifecycleStatus : "N1",
						SalesOrderID : "1"
					}, {
						LifecycleStatus : "N2",
						SalesOrderID : "2"
				}]
			})
			.expectChange("status", ["N0", "N1", "N2"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					batchNo : 2,
					changeSetNo : 1,
					headers : {
						Prefer : "handling=strict"
					},
					method : "POST",
					url : "SalesOrderList('0')/" + sAction,
					payload : {}
				}, oError, {
					"Preference-Applied" : "handling=strict"
				})
				.expectRequest({
					batchNo : 2,
					changeSetNo : 1,
					headers : {
						Prefer : "handling=strict"
					},
					method : "POST",
					url : "SalesOrderList('1')/" + sAction,
					payload : {}
				}/*response does not matter*/)
				.expectRequest({
					batchNo : 2,
					changeSetNo : 1,
					headers : {
						Prefer : "handling=strict"
					},
					method : "POST",
					url : "SalesOrderList('2')/" + sAction,
					payload : {}
				}/*response does not matter*/);

			const oListBinding = that.oView.byId("table").getBinding("items");
			const aContexts = oListBinding.getCurrentContexts();

			// code under test
			oAction0Promise = that.oModel.bindContext(sAction + "(...)", aContexts[0])
				.invoke("$auto", false, onStrictHandlingFailed0);
			oAction1Promise = that.oModel.bindContext(sAction + "(...)", aContexts[1])
				.invoke("$auto", false, onStrictHandlingFailed1);
			oAction2Promise = that.oModel.bindContext(sAction + "(...)", aContexts[2])
				.invoke("$auto", false, onStrictHandlingFailed2);

			return that.waitForChanges(assert);
		}).then(function () {
			if (bConfirm) {
				that.expectRequest({
						batchNo : 3,
						changeSetNo : 1,
						method : "POST",
						url : "SalesOrderList('0')/" + sAction,
						payload : {}
					}, {
						LifecycleStatus : "C0",
						SalesOrderID : "0"
					})
					.expectRequest({
						batchNo : 3,
						changeSetNo : 1,
						method : "POST",
						url : "SalesOrderList('1')/" + sAction,
						payload : {}
					}, {
						LifecycleStatus : "C1",
						SalesOrderID : "1"
					})
					.expectRequest({
						batchNo : 3,
						changeSetNo : 1,
						method : "POST",
						url : "SalesOrderList('2')/" + sAction,
						payload : {}
					}, {
						LifecycleStatus : "C2",
						SalesOrderID : "2"
					})
					.expectChange("status", ["C0", "C1", "C2"]);
			} else {
				that.expectCanceledError("Failed to invoke /SalesOrderList('0')/" + sAction
						+ "(...)", "Action canceled due to strict handling");
				that.expectCanceledError("Failed to invoke /SalesOrderList('1')/" + sAction
						+ "(...)", "Action canceled due to strict handling");
				that.expectCanceledError("Failed to invoke /SalesOrderList('2')/" + sAction
						+ "(...)", "Action canceled due to strict handling");
			}

			// code under test - resolve call ensures that the handler is actually called
			fnResolve0(bConfirm);
			fnResolve1(bConfirm);
			fnResolve2(bConfirm);

			return Promise.all([
				oAction0Promise.then(function () {
					assert.ok(bConfirm);
				}, function (oError) {
					assert.notOk(bConfirm);
					assert.strictEqual(oError.message, "Action canceled due to strict handling");
					assert.strictEqual(oError.canceled, true);
				}),
				oAction1Promise.then(function () {
					assert.ok(bConfirm);
				}, function (oError) {
					assert.notOk(bConfirm);
					assert.strictEqual(oError.message, "Action canceled due to strict handling");
					assert.strictEqual(oError.canceled, true);
				}),
				oAction2Promise.then(function () {
					assert.ok(bConfirm);
				}, function (oError) {
					assert.notOk(bConfirm);
					assert.strictEqual(oError.message, "Action canceled due to strict handling");
					assert.strictEqual(oError.canceled, true);
				}),
				that.waitForChanges(assert)
			]);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: "Prefer:handling=strict"
	// 1. Successful invocation of a) a bound and b) an unbound action with "handling=strict" in the
	//    same change set
	// 2. Another invocation of a bound action with "handling=strict" in a different change set (of
	//    the same $batch) that will result in a rejection of this action
	// 3. Test whether "handling=strict" is allowed only for an action
	//
	// JIRA: CPOUI5ODATAV4-943
	QUnit.test("CPOUI5ODATAV4-943: handling=strict, many strict invocations", function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'0\')}">\
	<Text id="status" text="{LifecycleStatus}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('0')?$select=LifecycleStatus,SalesOrderID", {
				LifecycleStatus : "N",
				SalesOrderID : "0"
			})
			.expectChange("status", "N");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("form").getBindingContext();

			that.oLogMock.expects("error")
				.withExactArgs("Failed to invoke /SalesOrderList('0')/"
					+ "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm(...)",
					sinon.match(
						"All requests with strict handling must belong to the same change set"),
					sODCB);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to invoke /GetProductStock(...)",
					sinon.match("Not an action: /GetProductStock(...)"), sODCB);
			that.expectRequest({
					headers : {
						Prefer : "handling=strict"
					},
					method : "POST",
					url : "SalesOrderList('0')/" + sAction,
					payload : {}
				}, {
					LifecycleStatus : "C",
					SalesOrderID : "0"
				})
				.expectRequest({
					headers : {
						Prefer : "handling=strict"
					},
					method : "POST",
					url : "RegenerateEPMData",
					payload : {}
				}, {})
				.expectRequest("GetProductStock()", {})
				.expectChange("status", "C")
				.expectMessages([{
					message : "All requests with strict handling must belong to the same change"
						+ " set",
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					message : "Not an action: /GetProductStock(...)",
					persistent : true,
					technical : true,
					type : "Error"
			}]);

			return Promise.all([
				// only to issue a GET request (non change set) at the beginning
				oModel.bindContext("/GetProductStock(...)")
					.invoke("confirm"),
				// code under test (1a)
				oModel.bindContext(sAction + "(...)", oContext)
					.invoke("confirm", false, function () {}),
				// code under test (1b)
				oModel.bindContext("/RegenerateEPMData(...)")
					.invoke("confirm", false, function () {}),
				oModel.submitBatch("confirm"), //create 2nd change set in $batch
				// code under test (2)
				oModel.bindContext(sAction + "(...)", oContext)
					.invoke("confirm", false, function () {})
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message,
							"All requests with strict handling must belong to the same change set");
					}),
				// code under test (3)
				oModel.bindContext("/GetProductStock(...)")
					.invoke("confirm", false, function () {})
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message,
							"Not an action: /GetProductStock(...)");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: "Prefer:handling=strict"
	// Two actions in one batch in separate change sets.
	// First one succeeds with a warning state message.
	// Second one fails due to a strict handling error, but without error details.
	// Show that the warning state message of the first action can be retrieved in the
	// fnStrictHandlingFailed callback.
	//
	// JIRA: CPOUI5ODATAV4-1034
	QUnit.test("CPOUI5ODATAV4-1034: handling=strict, simulate draft save", function (assert) {
		var sConfirmAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			sGoodsAction = "com.sap.gateway.default.zui5_epm_sample.v0002."
				+ "SalesOrder_GoodsIssueCreated",
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "confirm"
			}),
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'42\')}">\
	<Text id="status" text="{LifecycleStatus}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=LifecycleStatus,SalesOrderID", {
				LifecycleStatus : "N",
				SalesOrderID : "42"
			})
			.expectChange("status", "N");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("form").getBindingContext(),
				oConfirmBinding = oModel.bindContext(sConfirmAction + "(...)", oContext),
				oError = createErrorInsideBatch({
					code : "STRICT",
					message : "Strict Handling"
				}, 412),
				oGoodsBinding = oModel.bindContext(sGoodsAction + "(...)", oContext);

			function fnStrictHandlingFailed(aMessages) {
				assert.deepEqual(aMessages, [], "no details in strict error response");
				// code under test
				aMessages = oContext.getMessages();
				assert.strictEqual(aMessages.length, 1);
				assert.strictEqual(aMessages[0].message, "Incorrect LifecycleStatus");

				return Promise.resolve(false);
			}

			that.expectRequest({
					method : "POST",
					headers : {},
					url : "SalesOrderList('42')/" + sConfirmAction,
					payload : {}
				}, {
					LifecycleStatus : "C",
					SalesOrderID : "42",
					Messages : [{
						code : "CODE",
						message : "Incorrect LifecycleStatus",
						numericSeverity : 3,
						target : "LifecycleStatus",
						transition : false
					}]
				})
				.expectChange("status", "C")
				.expectRequest({
					headers : {
						Prefer : "handling=strict"
					},
					method : "POST",
					url : "SalesOrderList('42')/" + sGoodsAction,
					payload : {}
				}, oError, {
					"Preference-Applied" : "handling=strict"
				})
				.expectCanceledError("Failed to invoke /SalesOrderList('42')/" + sGoodsAction
					+ "(...)", "Action canceled due to strict handling")
				.expectMessages([{
					code : "CODE",
					message : "Incorrect LifecycleStatus",
					targets : [
						"/SalesOrderList('42')/LifecycleStatus"
					],
					type : "Warning"
				}]);

			// code under test
			return Promise.all([
				oConfirmBinding.invoke("confirm"),
				oModel.submitBatch("confirm"),
				checkCanceled(assert,
					oGoodsBinding.invoke("confirm", false, fnStrictHandlingFailed)),
				oModel.submitBatch("confirm"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A list binding with $$sharedRequest below another list binding.
	// JIRA: CPOUI5ODATAV4-269
	QUnit.test("CPOUI5ODATAV4-269: Nested lists and $$sharedRequest", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
	<List growing="true" growingThreshold="3" \
			items="{parameters : {$$sharedRequest : true}, path : \'/MANAGERS\',\
			templateShareable : false}">\
		<CustomListItem>\
			<Text id="id" text="{ID}"/>\
		</CustomListItem>\
	</List>\
</Table>';

		this.rIgnoredCanceledErrors = /^Cache discarded as a new cache has been created$/;
		// Timing: whether the inner list binding for the virtual context is destroyed early...
		// this.expectCanceledError("Cache discarded as a new cache has been created")
		//     .expectCanceledError(sODLB + ": /MANAGERS: Failed to enhance query options for"
		//         + " auto-$expand/$select for child ID",
		//         "Cache discarded as a new cache has been created");
		this.expectRequest("EMPLOYEES?$select=ID,Name&$skip=0&$top=100", {
				value : [
					{ID : "2", Name : "Frederic Fall"}
				]
			})
			.expectChange("name", ["Frederic Fall"])
			.expectRequest("MANAGERS?$select=ID&$skip=0&$top=3", {
				value : [{ID : "M1"}, {ID : "M2"}, {ID : "M3"}]
			})
			.expectChange("id", ["M1", "M2", "M3"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Multiple absolute list bindings share the same requests in order to avoid redundant
	// value help requests.
	// JIRA: CPOUI5ODATAV4-269
	QUnit.test("CPOUI5ODATAV4-269: Avoid redundant value help requests", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'1\')}">\
	<Text id="name1" text="{Name}"/>\
	<List id="list1" growing="true" growingThreshold="3" \
			items="{parameters : {$$sharedRequest : true}, path : \'/MANAGERS\'}">\
		<CustomListItem>\
			<Text id="id1" text="{ID}"/>\
		</CustomListItem>\
	</List>\
</FlexBox>\
<FlexBox binding="{/EMPLOYEES(\'2\')}">\
	<Text id="name2" text="{Name}"/>\
	<List id="list2" growing="true" growingThreshold="3" \
			items="{parameters : {$$sharedRequest : true}, path : \'/MANAGERS\'}">\
		<CustomListItem>\
			<Text id="id2" text="{ID}"/>\
		</CustomListItem>\
	</List>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')?$select=ID,Name", {ID : "1", Name : "Frederic Fall"})
			.expectChange("name1", "Frederic Fall")
			.expectRequest("EMPLOYEES('2')?$select=ID,Name", {ID : "2", Name : "Jonathan Smith"})
			.expectChange("name2", "Jonathan Smith")
			.expectRequest("MANAGERS?$select=ID&$skip=0&$top=3", {
				value : [{ID : "M1"}, {ID : "M2"}, {ID : "M3"}]
			})
			.expectChange("id1", ["M1", "M2", "M3"])
			.expectChange("id2", ["M1", "M2", "M3"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("MANAGERS?$select=ID&$orderby=ID desc&$skip=0&$top=3", {
					value : [{ID : "M9"}, {ID : "M8"}, {ID : "M7"}]
				})
				.expectChange("id1", ["M9", "M8", "M7"]);

			// code under test - sort 1st list
			that.oView.byId("list1").getBinding("items").sort(new Sorter("ID", true));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("MANAGERS?$select=ID&$skip=3&$top=3", {
					value : [{ID : "M4"}, {ID : "M5"}, {ID : "M6"}]
				})
				.expectChange("id2", [,,, "M4", "M5", "M6"]);

			// code under test
			that.oView.byId("list2").requestItems();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Call sort and immediately afterwards filter. The response of sort comes while the
	// new cache for filter has already been created and must be ignored by the binding.
	// JIRA: CPOUI5ODATAV4-269
[false, true].forEach(function (bSharedRequest) {
	var sTitle = "CPOUI5ODATAV4-269: obsoleted response, $$sharedRequest=" + bSharedRequest;

	QUnit.test(sTitle, function (assert) {
		var sParameters = bSharedRequest ? "$$sharedRequest : true" : "",
			fnRespond,
			sView = '\
<Table id="table" items="{path : \'/EMPLOYEES\', parameters : {' + sParameters + '}}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$skip=0&$top=100", {
				value : [
					{Name : "Frederic Fall"},
					{Name : "Jonathan Smith"},
					{Name : "Peter Burke"}
				]
			})
			.expectChange("name", ["Frederic Fall", "Jonathan Smith", "Peter Burke"]);

		return this.createView(assert, sView).then(function () {
			var oBinding = that.oView.byId("table").getBinding("items");

			that.expectRequest("EMPLOYEES?$orderby=Name&$skip=0&$top=100", {
					value : [/*n/a*/]
				})
				.expectRequest("EMPLOYEES?$orderby=Name&$filter=AGE gt 42&$skip=0&$top=100",
					new Promise(function (resolve) {
						fnRespond = resolve;
					})
				);

			oBinding.sort(new Sorter("Name"));
			oBinding.filter(new Filter("AGE", FilterOperator.GT, 42));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectCanceledError("Failed to get contexts for " + sTeaBusi
						+ "EMPLOYEES with start index 0 and length 100",
					sODLB + ": /EMPLOYEES is ignoring response from inactive cache: " + sTeaBusi
						+ "EMPLOYEES?$orderby=Name")
				.expectChange("name", ["Jonathan Smith"]);

			fnRespond({value : [{Name : "Jonathan Smith"}]});

			return that.waitForChanges(assert);
		});
	});
});

	//*********************************************************************************************
	// Scenario: You want to use AnnotationHelper.value for a property in the following cases:
	// 1. /Artists/Name - structural property of an entity type
	// 2. /Artists/BestFriend/IsActiveEntity - structural property reached via navigation
	// 3. /Artists/Address/ZIP - structural property of a complex type
	// 4. /Artists/special.cases.SendAutograph/$Parameter/Address/ZIP - structural property of a
	//   complex type used as operation parameter
	// 5. /Artists/special.cases.SendAutograph/$Parameter/_it/Name - structural property of an
	//  entity type reached via the binding parameter of an operation
	// JIRA: CPOUI5ODATAV4-104
	testXMLTemplating("AnnotationHelper#value on properties",
		"createSpecialCasesModel",
	' template:require="{\'AnnotationHelper\':\'sap/ui/model/odata/v4/AnnotationHelper\'}">\
		<template:alias name="value" value="AnnotationHelper.value">\
			<Input value="{meta>/Artists/Name@@value}"/>\
			<Input value="{meta>/Artists/BestFriend/IsActiveEntity@@value}"/>\
			<Input value="{meta>/Artists/Address/ZIP@@value}"/>\
			<Input value="{meta>/Artists/special.cases.SendAutograph/$Parameter/Address/ZIP@@value}"/>\
			<Input value="{meta>/Artists/special.cases.SendAutograph/$Parameter/_it/Name@@value}"/>\
		</template:alias>',
		'<Input value="{Name}"/>\
		<Input value="{IsActiveEntity}"/>\
		<Input value="{ZIP}"/>\
		<Input value="{ZIP}"/>\
		<Input value="{Name}"/>');

	//*********************************************************************************************
	// Scenario: You want to use AnnotationHelper.value inside a "14.5.12 Expression edm:Path" or
	// "14.5.13 Expression edm:PropertyPath"
	// JIRA: CPOUI5ODATAV4-104
	testXMLTemplating("AnnotationHelper#value inside path object",
		"createSpecialCasesModel",
	' template:require="{\'AnnotationHelper\':\'sap/ui/model/odata/v4/AnnotationHelper\'}">\
		<template:alias name="value" value="AnnotationHelper.value">\
			<Input value="{meta>/Artists/@com.sap.vocabularies.UI.v1.SelectionFields/0/$PropertyPath@@value}"/>\
			<Input value="{meta>/Artists/@com.sap.vocabularies.UI.v1.SelectionFields/1/$PropertyPath@@value}"/>\
			<Input value="{meta>/Artists/ArtistID@com.sap.vocabularies.Common.v1.Text/$Path@@value}"/>\
		</template:alias>',
		'<Input value="{Name}"/>\
		<Input value="{BestFriend/Name}"/>\
		<Input value="{Name}"/>');

	//*********************************************************************************************
	// Scenario: You want to use AnnotationHelper.format for a property in the following cases:
	// 1. /Artists/Name - structural property of an entity type
	// 2. /Artists/BestFriend/IsActiveEntity - structural property reached via navigation
	// 3. /Artists/Address/ZIP - structural property of a complex type
	// 4. /Artists/special.cases.SendAutograph/$Parameter/Address/ZIP - structural property of a
	//   complex type used as operation parameter
	// 5. /Artists/special.cases.SendAutograph/$Parameter/_it/Name - structural property of an
	//  entity type reached via the binding parameter of an operation
	// JIRA: CPOUI5ODATAV4-104
	testXMLTemplating("AnnotationHelper#format on properties",
		"createSpecialCasesModel",
	' template:require="{\'AnnotationHelper\':\'sap/ui/model/odata/v4/AnnotationHelper\'}">\
		<template:alias name="format" value="AnnotationHelper.format">\
			<Input value="{meta>/Artists/Name@@format}"/>\
			<Input value="{meta>/Artists/BestFriend/IsActiveEntity@@format}"/>\
			<Input value="{meta>/Artists/Address/ZIP@@format}"/>\
			<Input value="{meta>/Artists/special.cases.SendAutograph/$Parameter/Address/ZIP@@format}"/>\
			<Input value="{meta>/Artists/special.cases.SendAutograph/$Parameter/_it/Name@@format}"/>\
		</template:alias>',
		'<Input value="{path:\'Name\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':255},formatOptions:{\'parseKeepsEmptyString\':true}}"/>\
		<Input value="{path:\'IsActiveEntity\',type:\'sap.ui.model.odata.type.Boolean\',\
			constraints:{\'nullable\':false}}"/>\
		<Input value="{path:\'ZIP\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':5},formatOptions:{\'parseKeepsEmptyString\':true}}"/>\
		<Input value="{path:\'ZIP\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':5},formatOptions:{\'parseKeepsEmptyString\':true}}"/>\
		<Input value="{path:\'Name\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':255},formatOptions:{\'parseKeepsEmptyString\':true}}"/>');

	//*********************************************************************************************
	// Scenario: You want to use AnnotationHelper.format inside a "14.5.12 Expression edm:Path" or
	// "14.5.13 Expression edm:PropertyPath"
	// JIRA: CPOUI5ODATAV4-104
	testXMLTemplating("AnnotationHelper#format inside path object",
		"createSpecialCasesModel",
	' template:require="{\'AnnotationHelper\':\'sap/ui/model/odata/v4/AnnotationHelper\'}">\
		<template:alias name="format" value="AnnotationHelper.format">\
			<Input value="{meta>/Artists/@com.sap.vocabularies.UI.v1.SelectionFields/0/$PropertyPath@@format}"/>\
			<Input value="{meta>/Artists/@com.sap.vocabularies.UI.v1.SelectionFields/1/$PropertyPath@@format}"/>\
			<Input value="{meta>/Artists/ArtistID@com.sap.vocabularies.Common.v1.Text/$Path@@format}"/>\
		</template:alias>',
		'<Input value="{path:\'Name\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':255},formatOptions:{\'parseKeepsEmptyString\':true}}"/>\
		<Input value="{path:\'BestFriend/Name\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':255},formatOptions:{\'parseKeepsEmptyString\':true}}"/>\
		<Input value="{path:\'Name\',type:\'sap.ui.model.odata.type.String\',\
			constraints:{\'maxLength\':255},formatOptions:{\'parseKeepsEmptyString\':true}}"/>');

	//*********************************************************************************************
	// Scenario: Nested list binding inside table:Table with auto-$expand/$select (virtual context).
	// The nested list binding for the virtual context is destroyed before its prerendering task
	// runs.
	// Note: Avoid nested absolute bindings until CPOUIFTEAMB-1379 is solved.
	// Note: Equipment's ID should not matter here.
	// BCP: 2080140429
	QUnit.test("BCP: 2080140429", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<t:Table rows="{/EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
	<List items="{path : \'EMPLOYEE_2_EQUIPMENTS\', templateShareable : false}">\
		<CustomListItem>\
			<Text id="category" text="{Category}"/>\
		</CustomListItem>\
	</List>\
</t:Table>';

		this.expectRequest("EMPLOYEES?$select=ID,Name"
				+ "&$expand=EMPLOYEE_2_EQUIPMENTS($select=Category,ID)&$skip=0&$top=110", {
				value : [{
					EMPLOYEE_2_EQUIPMENTS : [
						{Category : "F1", ID : 21},
						{Category : "F2", ID : 22},
						{Category : "F3", ID : 23}
					],
					ID : "2",
					Name : "Frederic Fall"
				}, {
					EMPLOYEE_2_EQUIPMENTS : [
						{Category : "J1", ID : 31},
						{Category : "J2", ID : 32},
						{Category : "J3", ID : 33}
					],
					ID : "3",
					Name : "Jonathan Smith"
				}]
			})
			.expectChange("name", ["Frederic Fall", "Jonathan Smith"])
			.expectChange("category", ["J1", "J2", "J3"])
			.expectChange("category", ["F1", "F2", "F3"]);

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: Create a context in a nested table w/o cache and see that error message and success
	// message are bound to the corresponding control.
	// BCP: 2070272170
	// JIRA: CPOUI5ODATAV4-849
	QUnit.test("BCP: 2070272170", function (assert) {
		var oCreatedContext,
			oInput,
			oTable,
			sView = '\
<Table id="employees" items="{path : \'/EMPLOYEES\',\
		parameters : {$expand : {\'EMPLOYEE_2_EQUIPMENTS\' : null}}}">\
	<Text id="id" text="{ID}"/>\
</Table>\
<Table id="equipments" items="{EMPLOYEE_2_EQUIPMENTS}">\
	<Input id="category" value="{Category}"/>\
	<Input id="equipmentID" value="{ID}"/>\
	<Input id="equipmentName" value="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$expand=EMPLOYEE_2_EQUIPMENTS&$skip=0&$top=100", {
				value : [{
					ID : "1",
					EMPLOYEE_2_EQUIPMENTS : [{Category : "F1", ID : 11, Name : "F1-11"}]
				}]
			})
			.expectChange("id", ["1"])
			.expectChange("category", [])
			.expectChange("equipmentID", [])
			.expectChange("equipmentName", []);

		return this.createView(assert, sView).then(function () {
			that.expectChange("category", ["F1"])
				.expectChange("equipmentID", ["11"])
				.expectChange("equipmentName", ["F1-11"]);

			oTable = that.oView.byId("equipments");
			oTable.setBindingContext(
				that.oView.byId("employees").getItems()[0].getBindingContext()
			);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("category", ["F2", "F1"])
				.expectChange("equipmentID", [null, "11"])
				.expectChange("equipmentName", ["", "F1-11"])
				.expectRequest({
					method : "POST",
					payload : {Category : "F2"},
					url : "EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS"
				}, createErrorInsideBatch({
					message : "Invalid category",
					target : "Category",
					"@Common.additionalTargets" : ["ID", "Name"]
				}))
				.expectMessages([{
					code : "CODE",
					message : "Invalid category",
					persistent : true,
					targets : [
						"/EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS($uid=...)/Category",
						"/EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS($uid=...)/ID",
						"/EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS($uid=...)/Name"
					],
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withArgs("POST on 'EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS' failed;"
					+ " will be repeated automatically");

			oCreatedContext = oTable.getBinding("items").create({Category : "F2"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			oInput = oTable.getItems()[0].getCells()[0];

			return that.checkValueState(assert, oInput, "Error", "Invalid category");
		}).then(function () {
			that.expectChange("category", ["F3"])
				.expectChange("equipmentID", ["33"])
				.expectChange("equipmentName", ["F3-33"])
				.expectRequest({
					method : "POST",
					payload : {Category : "F3"},
					url : "EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS"
				}, {
					Category : "F3",
					ID : 33,
					Name : "F3-33",
					__FAKE__Messages : [{
						code : "CODE",
						message : "Correct category",
						numericSeverity : 1,
						target : "Category",
						additionalTargets : ["ID", "Name"]
					}]
				})
				.expectMessages([{
					code : "CODE",
					message : "Correct category",
					targets : [
						"/EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS(Category='F3',ID=33)/Category",
						"/EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS(Category='F3',ID=33)/ID",
						"/EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS(Category='F3',ID=33)/Name"
					],
					type : "Success"
				}]);

			Messaging.removeAllMessages();
			oInput.getBinding("value").setValue("F3");

			return Promise.all([
				oCreatedContext.created(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return that.checkValueState(assert, oInput, "Success", "Correct category");
		});
	});

	//*********************************************************************************************
	// Scenario: for a list binding, side effects are requested which should only affect structural
	// properties of a related entity, but in fact that entity's identity changes unexpectedly.
	// The requestSideEffects API detects this situation and throws an error.
	QUnit.test("requestSideEffects: key predicate changed beneath ODLB", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/Artists}">\
	<Text id="friend" text="{BestFriend/Name}"/>\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)&$skip=0&$top=100", {
				value : [{
					ArtistID : "XYZ",
					BestFriend : {
						ArtistID : "23",
						IsActiveEntity : true,
						Name : "Best Friend"
					},
					IsActiveEntity : true,
					Name : "Missy Eliot"
				}]
			})
			.expectChange("friend", ["Best Friend"])
			.expectChange("name", ["Missy Eliot"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oHeaderContext = that.oView.byId("table").getBinding("items").getHeaderContext();

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
					+ "&$filter=ArtistID eq 'XYZ' and IsActiveEntity eq true", {
					value : [{
						ArtistID : "XYZ",
						BestFriend : {
							ArtistID : "s.o.else",
							IsActiveEntity : true,
							Name : "Yet Another Best Friend"
						},
						IsActiveEntity : true
					}]
				})
				.expectChange("friend", ["Yet Another Best Friend"]);
			that.oLogMock.expects("error").withArgs("Failed to request side effects");

			return Promise.all([
				// code under test
				oHeaderContext.requestSideEffects([
						// this must not allow BestFriend/ArtistID to change
						{$NavigationPropertyPath : "Best"},
						{$PropertyPath : "BestFriend/*"}
					])
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message, "Key predicate of"
							+ " '(ArtistID='XYZ',IsActiveEntity=true)/BestFriend'"
							+ " changed from (ArtistID='23',IsActiveEntity=true)"
							+ " to (ArtistID='s.o.else',IsActiveEntity=true)");
					}),
				that.waitForChanges(assert, "*")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Use grouping with a list binding, -then change a group key value dynamically-.
	// Grouping changes after a refresh, but is not properly reflected with E.C.D.
	//
	// BCP: 2080132822
	//
	// A nested list binding inside a table row is destroyed before data for its refresh arrives.
	// If the nested list binding uses E.C.D., addt'l issues have to be avoided.
	// BCP: 360698 / 2021
[
	undefined,
	"AGE",
	function (oContext) {
		return oContext.getProperty("AGE");
	}
].forEach(function (vKey, i) {
	QUnit.test("BCP: 2080132822 - grouping, #" + i, function (assert) {
		var that = this,
			oController = {
				getGroupHeader : function (oGroupInfo) {
					that.checkValue(assert, oGroupInfo.key, "groupHeader");
					// Note: no need to really return an instance here
					// return new CustomListItem({content : [
					//     new Text({text : oGroupInfo.key})
					// ]});
				}
			},
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table growing="true" id="table" items="{\
		groupHeaderFactory : \'.getGroupHeader\',\
		path : \'/EMPLOYEES\',\
		sorter : {group : true, path : \'AGE\'}\
	}">\
	<ColumnListItem>\
		<Text id="age" text="{AGE}"/>\
		<List growing="true" items="{path : \'EMPLOYEE_2_EQUIPMENTS\', templateShareable : false}">\
			<CustomListItem>\
				<Text id="category" text="{Category}"/>\
			</CustomListItem>\
		</List>\
		<Text id="name" text="{Name}"/>\
	</ColumnListItem>\
</Table>';
		//TODO <Text id="age" text="{AGE}"/> should not be needed for auto-$expand/$select here!

		function checkItems(aItems, aExpectedMetadataNames, aExpectedContent) {
			assert.deepEqual(aItems.map(function (oItem) {
				return oItem.getMetadata().getName();
			}), aExpectedMetadataNames);
			assert.deepEqual(aItems.map(function (oItem) {
				return oItem.getTitle
					? oItem.getTitle() // GroupHeaderListItem
					: oItem.getCells().map(function (oCell) {
						return oCell.getText
							? oCell.getText()
							: oCell.getItems().map(function (oCustomListItem) { // List
								return oCustomListItem.getContent()[0].getText();
							}).join();
					}).join();
			}), aExpectedContent);
		}

		this.expectRequest("EMPLOYEES?$orderby=AGE&$select=AGE,ID,Name"
				+ "&$expand=EMPLOYEE_2_EQUIPMENTS($select=Category,ID)&$skip=0&$top=20", {
				value : [{
					AGE : 23,
					EMPLOYEE_2_EQUIPMENTS : [{Category : "F1", ID : 21}],
					ID : "2",
					Name : "Frederic Fall"
				}, {
					AGE : 42,
					EMPLOYEE_2_EQUIPMENTS : [{Category : "J1", ID : 31}],
					ID : "3",
					Name : "Jonathan Smith"
				}, {
					AGE : 42,
					EMPLOYEE_2_EQUIPMENTS : [{Category : "P1", ID : 41}],
					ID : "4",
					Name : "Peter Burke"
				}]
			})
			.expectChange("age", ["23", "42", "42"])
			.expectChange("groupHeader", 23)
			.expectChange("groupHeader", 42)
			.expectChange("category", ["P1"])
			.expectChange("category", ["J1"])
			.expectChange("category", ["F1"])
			.expectChange("name", ["Frederic Fall", "Jonathan Smith", "Peter Burke"]);

		return this.createView(assert, sView, oModel, oController).then(function () {
			var oItemsBinding;

			oTable = that.oView.byId("table");
			oItemsBinding = oTable.getBinding("items");
			checkItems(oTable.getItems(), [
				"sap.m.GroupHeaderListItem",
				"sap.m.ColumnListItem",
				"sap.m.GroupHeaderListItem",
				"sap.m.ColumnListItem",
				"sap.m.ColumnListItem"
			], ["23", "23,F1,Frederic Fall", "42", "42,J1,Jonathan Smith", "42,P1,Peter Burke"]);

			//TODO how could changes to a property affect the list's grouping?
			// @see v2.ODataListBinding#checkUpdate
			// oItemsBinding.getCurrentContexts()[0].setProperty("AGE", 42, null);

			// code under test
			oItemsBinding.enableExtendedChangeDetection(false, vKey);

			that.expectRequest("EMPLOYEES?$orderby=AGE&$select=AGE,ID,Name"
					+ "&$expand=EMPLOYEE_2_EQUIPMENTS($select=Category,ID)&$skip=0&$top=20", {
					value : [{
						AGE : 42, // surprise!
						EMPLOYEE_2_EQUIPMENTS : [{Category : "F1*", ID : 21}],
						ID : "2",
						Name : "Frederic Fall"
					}, {
						AGE : 42,
						EMPLOYEE_2_EQUIPMENTS : [],
						ID : "3",
						Name : "Jonathan Smith"
					}, {
						AGE : 42,
						EMPLOYEE_2_EQUIPMENTS : [
							{Category : "P1", ID : 41},
							{Category : "P2", ID : 42}
						],
						ID : "4",
						Name : "Peter Burke"
					}]
				})
				.expectCanceledError("Failed to get contexts for " + sTeaBusi
						+ "EMPLOYEES('2')/EMPLOYEE_2_EQUIPMENTS with start index 0 and length 20",
					"Binding already destroyed")
				.expectCanceledError("Failed to get contexts for " + sTeaBusi
						+ "EMPLOYEES('3')/EMPLOYEE_2_EQUIPMENTS with start index 0 and length 20",
					"Binding already destroyed")
				.expectCanceledError("Failed to get contexts for " + sTeaBusi
						+ "EMPLOYEES('4')/EMPLOYEE_2_EQUIPMENTS with start index 0 and length 20",
					"Binding already destroyed")
				.expectChange("age", ["42", "42", "42"]) // Note: no real E.C.D. with grouping
				.expectChange("groupHeader", 42)
				.expectChange("category", ["P1", "P2"])
				.expectChange("category", [])
				.expectChange("category", ["F1*"])
				.expectChange("name", ["Frederic Fall", "Jonathan Smith", "Peter Burke"]);

			// BCP: 360698 / 2021 - This outer refresh also causes all inner ODLB to refresh and
			// request data from the parent cache. But due to grouping, ManagedObject first destroys
			// all rows - before the data response arrives at the inner ODLB!
			// code under test
			oItemsBinding.refresh();

			return that.waitForChanges(assert);
		}).then(function () {
			checkItems(oTable.getItems(), [
				"sap.m.GroupHeaderListItem",
				"sap.m.ColumnListItem",
				"sap.m.ColumnListItem",
				"sap.m.ColumnListItem"
			], ["42", "42,F1*,Frederic Fall", "42,,Jonathan Smith", "42,P1,P2,Peter Burke"]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: FlexBox as a control that does not override updateItems but has E.C.D enabled.
	// BCP: 2180095696
[false, true].forEach(function (bAutoExpandSelect) {
	QUnit.test("BCP: 2180095696, bAutoExpandSelect = " + bAutoExpandSelect, function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : bAutoExpandSelect}),
			sView = '\
<FlexBox id="flexBox" items="{/EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		// force enable E.C.D. for FlexBox
		FlexBox.prototype.bUseExtendedChangeDetection = true;

		this.expectRequest("EMPLOYEES?"
			+ (bAutoExpandSelect ? "$select=ID,Name&" : "")
			+ "$skip=0&$top=100", {
				value : [
					{ID : "2", Name : "Frederic Fall"},
					{ID : "3", Name : "Jonathan Smith"}
				]
			})
			.expectChange("name", ["Frederic Fall", "Jonathan Smith"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("EMPLOYEES?"
				+ (bAutoExpandSelect ? "$select=ID,Name&" : "")
				+ "$orderby=Name desc&$skip=0&$top=100", {
					value : [
						{ID : "3", Name : "Jonathan Smith"},
						{ID : "2", Name : "Frederic Fall"}
					]
				})
				.expectChange("name", ["Jonathan Smith", "Frederic Fall"]);

			// code under test
			that.oView.byId("flexBox").getBinding("items").sort(new Sorter("Name", true));

			return that.waitForChanges(assert);
		}).finally(function () {
			// reset E.C.D.
			delete FlexBox.prototype.bUseExtendedChangeDetection;
		});
	});
});

	//*********************************************************************************************
	// Scenario: Interleaving suspend/resume sequences and E.C.D. The first one causes a refresh,
	// the second one does not change anything. This caused a deadlock because a locking _GroupLock
	// remained.
	// BCP: 2380034885
	QUnit.test("BCP: 2380034885", function (assert) {
		var oBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			fnResolve,
			sView = '\
<Table id="table" growing="true" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=20",
				{value : [{SalesOrderID : "1"}]})
			.expectChange("id", ["1"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID"
					+ "&$filter=SalesOrderID ne '1'&$skip=0&$top=20",
					new Promise(function (resolve) {
						fnResolve = resolve.bind(null, {value : []});
					})
				);

			oBinding = that.oView.byId("table").getBinding("items");
			oBinding.suspend();
			oBinding.filter(new Filter("SalesOrderID", FilterOperator.NE, "1"));
			oBinding.resume();

			return that.waitForChanges(assert, "suspend/filter/resume");
		}).then(function () {
			oBinding.suspend();
			oBinding.resume();

			fnResolve();

			return that.waitForChanges(assert, "suspend/resume");
		});
	});

	//*********************************************************************************************
	// Scenario: A value list model is used multiple times, but the request is shared.
	// JIRA: CPOUI5ODATAV4-344
[false, true].forEach(function (bAutoExpandSelect) {
	var sTitle = "$$sharedRequest and ODMM#getOrCreateSharedModel, bAutoExpandSelect = "
			+ bAutoExpandSelect;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSalesOrdersModel({}, {
				"/sap/opu/odata4/sap/zui5_testv4/f4/sap/d_pr_type-fv/0001;ps=%27default-zui5_epm_sample-0002%27;va=%27com.sap.gateway.default.zui5_epm_sample.v0002.ET-PRODUCT.TYPE_CODE%27/$metadata"
					: {source : "odata/v4/data/VH_ProductTypeCode.xml"}
			}),
			sView = '\
<FlexBox binding="{/ProductList(\'1\')}">\
	<Text id="typeCode1" text="{TypeCode}"/>\
	<List id="list1"\
		items="{path : \'/D_PR_TYPE_FV_SET\', suspended : true}">\
		<CustomListItem>\
			<Text id="description1" text="{DESCRIPTION}"/>\
		</CustomListItem>\
	</List>\
</FlexBox>\
<FlexBox binding="{/ProductList(\'2\')}">\
	<Text id="typeCode2" text="{TypeCode}"/>\
	<List id="list2"\
		items="{path : \'/D_PR_TYPE_FV_SET\', suspended : true}">\
		<CustomListItem>\
			<Text id="description2" text="{DESCRIPTION}"/>\
		</CustomListItem>\
	</List>\
</FlexBox>',
			that = this;

		this.expectRequest("ProductList('1')", {ProductID : "1", TypeCode : "AD"})
			.expectChange("description1", [])
			.expectChange("typeCode1", "AD")
			.expectRequest("ProductList('2')", {ProductID : "2", TypeCode : "PR"})
			.expectChange("description2", [])
			.expectChange("typeCode2", "PR");

		return this.createView(assert, sView, oModel).then(function () {
			return that.oView.byId("typeCode1").getBinding("text")
				.requestValueListInfo(bAutoExpandSelect);
		}).then(function (mValueListInfo) {
			var oValueListModel = mValueListInfo[""].$model;

			that.expectRequest("D_PR_TYPE_FV_SET?"
					+ (bAutoExpandSelect ? "$select=DESCRIPTION,FIELD_VALUE&" : "")
					+ "$skip=0&$top=100", {
					value : [{
						DESCRIPTION : "Anno Domini",
						FIELD_VALUE : "AD"
					}, {
						DESCRIPTION : "Public Relations",
						FIELD_VALUE : "PR"
					}]
				})
				.expectChange("description1", ["Anno Domini", "Public Relations"])
				.expectChange("description2", ["Anno Domini", "Public Relations"]);

			// code under test
			that.oView.byId("list1").setModel(oValueListModel).getBinding("items").resume();
			that.oView.byId("list2").setModel(oValueListModel).getBinding("items").resume();

			return that.waitForChanges(assert);
		});
	});
});

	//*********************************************************************************************
	// Scenario: A value list model is sorted and changes are reflected on the UI.
	// BCP: 2080320093
	QUnit.test("BCP: 2080320093: sharedRequests and sort", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true, sharedRequests : true}),
			sView = '\
<Table id="table" growing="true" growingThreshold="2" items="{path : \'/ProductList\'}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("ProductList?$select=Name,ProductID&$skip=0&$top=2", {
				value : [{
						Name : "Notebook 15",
						ProductID : "HT-1015"
					}, {
						Name : "Notebook 16",
						ProductID : "HT-1016"
				}]
			})
			.expectChange("name", ["Notebook 15", "Notebook 16"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("ProductList?$select=Name,ProductID&$orderby=Name desc"
					+ "&$skip=0&$top=2", {
					value : [{
						Name : "Notebook 24",
						ProductID : "HT-1024"
					}, {
						Name : "Notebook 23",
						ProductID : "HT-1023"
					}]
				})
				.expectChange("name", ["Notebook 24", "Notebook 23"]);

			// code under test
			that.oView.byId("table").getBinding("items").sort(new Sorter("Name", true));

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Invoking an action is forbidden for models with shared requests.
	// JIRA: CPOUI5ODATAV4-344
	QUnit.test("sharedRequests forbids action invoke", function (assert) {
		var oModel = this.createTeaBusiModel({sharedRequests : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var oAction = oModel.bindContext("/ChangeTeamBudgetByID(...)"),
				sMessage = sTeaBusi + "ChangeTeamBudgetByID is read-only";

			that.oLogMock.expects("error")
				.withExactArgs("Failed to invoke /ChangeTeamBudgetByID(...)",
					sinon.match(sMessage), sODCB);

			return oAction.invoke().then(mustFail(assert), function (oError) {
				assert.strictEqual(oError.message, sMessage);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: <template:repeat> over more than Model#iSizeLimit (= 100) entries.
	// BCP: 002075129500002532232020 (253223 / 2020)
	QUnit.test("BCP: 002075129500002532232020", function (assert) {
		var oMetaModel = this.createSpecialCasesModel().getMetaModel(),
			sTemplate = '\
<template:repeat list="{meta>/As/$Type/$Key}">\
	<Text text="{meta>}"/>\
</template:repeat>',
			that = this;

		return oMetaModel.requestObject("/As/$Type/$Key").then(function (aKeys) {
			var i,
				sView = "";

			// DON'T TRY THIS AT HOME, KIDZ!
			aKeys.length = 0;
			for (i = 0; i < 200; i += 1) {
				aKeys.push("" + i);
				sView += '<Text text="' + i + '"/>';
			}

			return that.doTestXMLTemplating(assert,
				{models : {meta : oMetaModel}}, sTemplate, sView);
		});
	});

	//*********************************************************************************************
	// Scenario: create at end w/o $count, but after everything has been read
	QUnit.test("ODLB: create at end w/o $count", function (assert) {
		var sView = '\
<Table id="table" items="{/EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$skip=0&$top=100", {
				value : [{Name : "Frederic Fall"}]
			})
			.expectChange("name", ["Frederic Fall"]);

		return this.createView(assert, sView).then(function () {
			var oBinding = that.oView.byId("table").getBinding("items");

			that.expectChange("name", [, "John Doe"])
				.expectRequest({
					method : "POST",
					url : "EMPLOYEES",
					payload : {Name : "John Doe"}
				}, {/*response does not matter here*/});

			return Promise.all([
				// code under test
				oBinding.create({Name : "John Doe"}, true, true),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: create at end w/ $count, before read is finished
	// BCP: 2070486792
	//
	// #changeParameters before resolving the ODLB (JIRA: CPOUI5ODATAV4-2408)
	QUnit.test("ODLB: create at end w/ $count before read", function (assert) {
		var oBinding,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" growing="true" growingThreshold="2" items="{EMPLOYEES}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectChange("name", []);

		return this.createView(assert, sView, oModel).then(function () {
			// Note: GET invoked by 1st #create - one transient taken into account for prefetch
			that.expectRequest("EMPLOYEES?$count=true&$select=ID,Name&$skip=0&$top=3", {
					"@odata.count" : "1",
					value : [{ID : "1", Name : "Frederic Fall"}]
				})
				.expectRequest({
					method : "POST",
					url : "EMPLOYEES",
					payload : {Name : "John Doe"}
				}, {
					ID : "new1",
					Name : "John Doe"
				})
				.expectRequest({
					method : "POST",
					url : "EMPLOYEES",
					payload : {Name : "Jane Doe"}
				}, {
					ID : "new2",
					Name : "Jane Doe"
				})
				.expectChange("name", ["Frederic Fall", "John Doe"]);

			oBinding = that.oView.byId("table").getBinding("items");
			// code under test (JIRA: CPOUI5ODATAV4-2408)
			oBinding.changeParameters({$count : true});
			oBinding.setContext(that.oModel.createBindingContext("/"));

			// code under test
			return Promise.all([
				oBinding.create({Name : "John Doe"}, true, true).created(),
				oBinding.create({Name : "Jane Doe"}, true, true).created(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			return oBinding.requestContexts(0, 10).then(function (aContexts) {
				assert.strictEqual(aContexts[0].isTransient(), undefined);
				assert.strictEqual(aContexts[1].isTransient(), false);
				assert.strictEqual(aContexts[2].isTransient(), false);
				assert.deepEqual(aContexts.map(getPath), [
					"/EMPLOYEES('1')",
					"/EMPLOYEES('new1')",
					"/EMPLOYEES('new2')"
				]);
			});
		});
	});

	//*********************************************************************************************
	// Scenario: List binding with a navigation property using a context binding. Create three rows
	// at once. See that the third context is not destroyed during this process.
	// BCP: 2370141835
	QUnit.test("BCP: 2370141835", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<Table id="table" items="{/EMPLOYEES}">
	<Text text="{ID}"/>
	<Text binding="{EMPLOYEE_2_MANAGER}" id="managerId" text="{ID}"/>
</Table>`;

		this.expectRequest("EMPLOYEES?$select=ID&$expand=EMPLOYEE_2_MANAGER($select=ID)"
				+ "&$skip=0&$top=100", {value : []})
			.expectChange("managerId", []);

		await this.createView(assert, sView, oModel);

		this.expectChange("managerId", ["", "", ""])
			.expectRequest({method : "POST", url : "EMPLOYEES", payload : {}}, {ID : "0"})
			.expectRequest({method : "POST", url : "EMPLOYEES", payload : {}}, {ID : "1"})
			.expectRequest({method : "POST", url : "EMPLOYEES", payload : {}}, {ID : "2"})
			.expectRequest("EMPLOYEES('0')?$select=ID&$expand=EMPLOYEE_2_MANAGER($select=ID)",
				{ID : "0", EMPLOYEE_2_MANAGER : {ID : "10"}})
			.expectRequest("EMPLOYEES('1')?$select=ID&$expand=EMPLOYEE_2_MANAGER($select=ID)",
				{ID : "1", EMPLOYEE_2_MANAGER : {ID : "11"}})
			.expectRequest("EMPLOYEES('2')?$select=ID&$expand=EMPLOYEE_2_MANAGER($select=ID)",
				{ID : "2", EMPLOYEE_2_MANAGER : {ID : "12"}})
			.expectChange("managerId", ["12", "11", "10"]);

		const oBinding = this.oView.byId("table").getBinding("items");
		// code under test
		const oContext0 = oBinding.create();
		const oContext1 = oBinding.create();
		const oContext2 = oBinding.create();

		await Promise.all([
			oContext0.created(),
			oContext1.created(),
			oContext2.created(),
			this.waitForChanges(assert, "create")
		]);
	});

	//*********************************************************************************************
	// Scenario: Multiple creation rows, grid table
	// (1) create three creation rows immediately after setContext
	// (2) set note in first creation row -> failed POST, context still transient
	// (3) call submitBatch("$auto") -> successful POST only for the first creation row, its context
	//     not transient any more
	// (4) delete second creation row while still inactive
	// (5) set note in third creation row -> successful POST, context not transient any more
	//
	// JIRA: CPOUI5ODATAV4-1264
	// JIRA: CPOUI5ODATAV4-1380 (allow SubmitMode.API)
	//
	// Selection on inactive context which is then deleted and destroyed (JIRA: CPOUI5ODATAV4-1943).
	// Selection is cleared on successful deletion (JIRA: CPOUI5ODATAV4-2053).
[false, true].forEach(function (bAPI) {
	QUnit.test("Multiple creation rows, grid table, SubmitMode.API = " + bAPI, function (assert) {
		var oBinding,
			oContext1,
			oContext2,
			oContext3,
			iEventCount = 0,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : bAPI ? "update" : undefined
			}),
			sView = '\
<Text id="count" text="{$count}"/>\
<t:Table id="table" rows="{path : \'SO_2_SOITEM\',\
		parameters : {$count : true, $$ownRequest : true}}">\
	<Text id="inactive" text="{= %{@$ui5.context.isInactive} }"/>\
	<Text id="position" text="{ItemPosition}"/>\
	<Input id="note" value="{Note}"/>\
</t:Table>',
			that = this;

		this.expectChange("count")
			.expectChange("inactive", [])
			.expectChange("position", [])
			.expectChange("note", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("inactive", [true, true, true])
				.expectChange("position", ["", "", ""])
				.expectChange("note", ["default note", "", ""])
				.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$count=true"
					+ "&$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=110", {
					"@odata.count" : "1",
					value : [{ItemPosition : "0010", Note : "Note 10", SalesOrderID : "42"}]
				})
				.expectChange("count", "1")
				.expectChange("inactive", [undefined,,, true])
				.expectChange("position", ["0010",,, ""])
				.expectChange("note", ["Note 10", "default note",, ""]);

			oBinding = that.oView.byId("table").getBinding("rows");
			oBinding.setContext(oModel.createBindingContext("/SalesOrderList('42')"));
			that.oView.byId("count").setBindingContext(oBinding.getHeaderContext());
			oBinding.attachCreateActivate(function () {
				iEventCount += 1;
			});

			// code under test (oInitialData, bSkipRefresh, bAtEnd, bInactive)
			oContext1 = oBinding.create({Note : "default note"}, true, true, true);
			oContext2 = oBinding.create({}, true, true, true);
			oContext3 = oBinding.create({}, true, true, true);

			assert.strictEqual(oModel.hasPendingChanges(), false);
			assert.strictEqual(oModel.hasPendingChanges("$auto"), false);
			assert.strictEqual(oBinding.hasPendingChanges(), false);
			assert.strictEqual(oContext1.isInactive(), true);
			assert.strictEqual(oContext2.isInactive(), true);
			assert.strictEqual(oContext3.isInactive(), true);
			assert.strictEqual(oContext1.isTransient(), true);
			assert.strictEqual(oContext2.isTransient(), true);
			assert.strictEqual(oContext3.isTransient(), true);
			assert.strictEqual(normalizeUID(oContext1.toString()),
				"/SalesOrderList('42')/SO_2_SOITEM($uid=...)[-1;inactive]",
				"Context#toString: inactive");

			return Promise.all([
				bAPI && oModel.submitBatch("update"), // no POST sent
				that.waitForChanges(assert, "(1)")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 1);
			assert.strictEqual(oBinding.getLength(), 4);
			assert.strictEqual(oBinding.isLengthFinal(), true);

			that.oLogMock.expects("error")
				.withExactArgs("POST on 'SalesOrderList('42')/SO_2_SOITEM' failed; "
					+ "will be repeated automatically",
					sinon.match("Request intentionally failed"), sODLB);
			that.expectChange("count", "2")
				.expectChange("note", [, "Note 1"])
				.expectChange("inactive", [, false])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList('42')/SO_2_SOITEM",
					payload : {Note : "Note 1"}
				}, createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			// code under test
			oContext1.setProperty("Note", "Note 1");

			assert.strictEqual(oBinding.getCount(), 2);
			assert.strictEqual(oBinding.getLength(), 4);
			assert.strictEqual(oBinding.isLengthFinal(), true);
			assert.strictEqual(oContext1.hasPendingChanges(), true);
			assert.strictEqual(oContext1.isInactive(), false);
			assert.strictEqual(oContext1.isTransient(), true);
			assert.strictEqual(normalizeUID(oContext1.toString()),
				"/SalesOrderList('42')/SO_2_SOITEM($uid=...)[-1;transient]",
				"Context#toString: transient");
			assert.strictEqual(iEventCount, 1, "createActivate was fired");

			return Promise.all([
				bAPI && oModel.submitBatch("update"),
				that.waitForChanges(assert, "(2)")
			]);
		}).then(function () {
			var sGroupId = bAPI ? "update" : "$auto";

			assert.strictEqual(oContext1.hasPendingChanges(), true);
			assert.strictEqual(oContext1.isInactive(), false);
			assert.strictEqual(oContext1.isTransient(), true);

			that.expectRequest({
					$ContentID : undefined,
					batchNo : 3,
					changeSetNo : 1,
					groupId : sGroupId,
					method : "POST",
					payload : {Note : "Note 1"},
					url : "SalesOrderList('42')/SO_2_SOITEM"
				}, {
					SalesOrderID : "42",
					ItemPosition : "0020",
					Note : "Note 1"
				})
				.expectRequest({
					$ContentID : undefined,
					batchNo : 3,
					changeSetNo : 2, // new changeset via submitBatch("$auto")
					groupId : sGroupId,
					method : "POST",
					payload : {},
					url : "RegenerateEPMData"
				}, {/* don't care */})
				.expectChange("position", [, "0020"]);

			return Promise.all([
				// code under test
				oModel.submitBatch(sGroupId),
				// code under test (JIRA: CPOUI5ODATAV4-2134)
				oModel.bindContext("/RegenerateEPMData(...)").invoke(sGroupId),
				oContext1.created(),
				that.waitForChanges(assert, "(3)")
			]);
		}).then(function () {
			assert.strictEqual(oContext1.hasPendingChanges(), false);
			assert.strictEqual(oContext1.isInactive(), false);
			assert.strictEqual(oContext1.isTransient(), false);
			assert.strictEqual(oContext1.toString(),
				"/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0020')"
					+ "[-1;createdPersisted]",
				"Context#toString: createdPersisted");

			// code under test
			oContext2.setSelected(true);

			// code under test
			oContext2.delete();

			assert.strictEqual(normalizeUID(oContext2.toString()),
				"/SalesOrderList('42')/SO_2_SOITEM($uid=...)[-9007199254740991;deleted]",
				"Context#toString: deleted");
			checkSelected(assert, oContext2, undefined, "JIRA: CPOUI5ODATAV4-2053");

			return Promise.all([
				checkCanceled(assert, oContext2.created()),
				that.waitForChanges(assert, "(4)")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 2);
			assert.strictEqual(oBinding.getLength(), 3);
			assert.strictEqual(oBinding.isLengthFinal(), true);
			assert.strictEqual(normalizeUID(oContext2.toString()),
				"/SalesOrderList('42')/SO_2_SOITEM($uid=...)[-9007199254740991;destroyed]",
				"Context#toString: destroyed");
			assert.notOk(oContext2.isSelected(), "JIRA: CPOUI5ODATAV4-1943");
			assert.throws(() => {
				oContext2.getProperty("@$ui5.context.isSelected");
				// TypeError("Cannot read properties of undefined (reading 'checkSuspended')")
			}, "Binding already gone (JIRA: CPOUI5ODATAV4-1944)");

			that.expectChange("count", "3")
				.expectChange("note", [,, "Note 3"])
				.expectChange("inactive", [,, false])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList('42')/SO_2_SOITEM",
					payload : {Note : "Note 3"}
				}, {
					SalesOrderID : "42",
					ItemPosition : "0030",
					Note : "Note 3"
				})
				.expectChange("position", [,, "0030"]);

			// code under test
			oContext3.setProperty("Note", "Note 3");

			assert.strictEqual(oContext3.hasPendingChanges(), true);
			assert.strictEqual(oContext3.isInactive(), false);
			assert.strictEqual(oContext3.isTransient(), true);
			assert.strictEqual(iEventCount, 2, "createActivate was fired");

			return Promise.all([
				bAPI && oModel.submitBatch("update"),
				oContext3.created(),
				that.waitForChanges(assert, "(5)")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 3);
			assert.strictEqual(oBinding.getLength(), 3);
			assert.strictEqual(oBinding.isLengthFinal(), true);
			assert.strictEqual(oContext3.hasPendingChanges(), false);
			assert.strictEqual(oContext3.isInactive(), false);
			assert.strictEqual(oContext3.isTransient(), false);
			assert.strictEqual(iEventCount, 2, "no further createActivate events");
		});
	});
});

	//*********************************************************************************************
	// A list binding for a complex type is refreshed, while a context (last segment of path without
	// key predicate) is selected
	// SNOW: DINC0029552
	QUnit.test("DINC0029552", async function (assert) {
		const oModel = this.createSalesOrdersModel();
		const sView = `
<Table id="list" items="{/SalesOrderList('0')/Messages}">
	<Text id="code" text="{code}"/>
</Table>`;

		this.expectRequest("SalesOrderList('0')/Messages?$skip=0&$top=100", {
				value : [{code : "42"}]
			})
			.expectChange("code", ["42"]);

		await this.createView(assert, sView, oModel);

		const oTableBinding = this.oView.byId("list").getBinding("items");
		oTableBinding.getCurrentContexts()[0].setSelected(true);

		assert.strictEqual(oTableBinding.getCurrentContexts()[0].getPath(),
			"/SalesOrderList('0')/Messages/0");

		this.expectRequest("SalesOrderList('0')/Messages?$skip=0&$top=100", {
				value : [{code : "23"}]
			})
			.expectChange("code", ["23"]);

		// code under test
		oModel.refresh();

		await this.waitForChanges(assert);
	});

	//*********************************************************************************************
	// Scenario: Multiple creation rows, grid table
	//
	// Create contexts at different insert positions (CPOUI5ODATAV4-1379):
	//   "end of end", "end of start", "start of end" (not allowed), "start of start"
	// Switch parent context via setContext (CPOUI5ODATAV4-1450)
	//
	// (1) read items
	// (2a) add three inline creation rows (ICR)
	// (2b) try to add two ICRs and expect the "start of end" exception at the second creation
	// (3) switch parent context via setContext
	// (4) switch parent context back, ICRs are still present
	// (5) cleanup test: delete all ICRs
[{
	title : "end of end",
	firstInsertAtEnd : true,
	secondInsertAtEnd : true,
	secondExpectChange : [, "First", "Second", "Third"],
	fourthExpectChange : ["Note 10", "First", "Second", "Third"],
	fifthExpectChange : []
}, {
	title : "end of start",
	firstInsertAtEnd : false,
	secondInsertAtEnd : true,
	secondExpectChange : ["First", "Second", "Third", "Note 10"],
	fourthExpectChange : ["First", "Second", "Third", "Note 10"],
	fifthExpectChange : ["Note 10"]
}, {
	title : "start of end (not allowed)",
	firstInsertAtEnd : true,
	secondInsertAtEnd : false,
	secondExpectChange : [, "First"]
}, {
	title : "start of start",
	firstInsertAtEnd : false,
	secondInsertAtEnd : false,
	secondExpectChange : ["Third", "Second", "First", "Note 10"],
	fourthExpectChange : ["Third", "Second", "First", "Note 10"],
	fifthExpectChange : ["Note 10"]
}].forEach(function (oFixture) {
	var sTitle = "Multiple inline creation rows, grid table; insert position: " + oFixture.title;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oBindingContext,
			oContext0,
			oContext1,
			oContext2,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<t:Table id="table" rows="{path : \'SO_2_SOITEM\',\
		parameters : {$$ownRequest : true}}">\
	<Text id="note" text="{Note}"/>\
</t:Table>',
			that = this;

		this.expectChange("note", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("note", ["Note 10"])
				.expectRequest("SalesOrderList('42')/SO_2_SOITEM?"
					+ "$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=110", {
					value : [{SalesOrderID : "42", Note : "Note 10"}]
				});

			oBindingContext = oModel.createBindingContext("/SalesOrderList('42')");
			oBinding = that.oView.byId("table").getBinding("rows");
			oBinding.setContext(oBindingContext);

			return that.waitForChanges(assert, "(1) read SOITEMs");
		}).then(function () {
			that.expectChange("note", oFixture.secondExpectChange);

			// code under test
			oContext0 = oBinding.create({Note : "First"}, true, oFixture.firstInsertAtEnd, true);

			if (!oFixture.secondInsertAtEnd && oFixture.firstInsertAtEnd) {
				assert.throws(function () {
					// code under test
					oBinding.create({Note : "Second"}, true, oFixture.secondInsertAtEnd, true);
				}, new Error("Cannot create at the start after creation at end"));

				assert.strictEqual(oBinding.iCreatedContexts, 1);

				return that.waitForChanges(assert, "(2a) add ICRs (throws)");
			}
			// code under test
			oContext1 = oBinding.create({Note : "Second"}, true, oFixture.secondInsertAtEnd, true);
			oContext2 = oBinding.create({Note : "Third"}, true, oFixture.secondInsertAtEnd, true);

			assert.strictEqual(oBinding.iCreatedContexts, 3);

			// code under test
			assert.strictEqual(oBinding.isFirstCreateAtEnd(), oFixture.firstInsertAtEnd);

			return that.waitForChanges(assert, "(2b) add ICRs").then(function () {
				that.expectChange("note", ["Note 43"])
					.expectRequest("SalesOrderList('43')/SO_2_SOITEM?"
						+ "$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=110", {
						value : [{SalesOrderID : "43", Note : "Note 43"}]
					});

				// code under test
				oBinding.setContext(oModel.createBindingContext("/SalesOrderList('43')"));

				assert.strictEqual(oBinding.iCreatedContexts, 0);

				return that.waitForChanges(assert, "(3) switch binding context");
			}).then(function () {
				that.expectChange("note", oFixture.fourthExpectChange);

				// code under test
				oBinding.setContext(oBindingContext);

				return that.waitForChanges(assert, "(4) switch binding context back");
			}).then(function () {
				that.expectChange("note", oFixture.fifthExpectChange);

				assert.strictEqual(oBinding.iCreatedContexts, 3);

				oContext0.delete();
				oContext1.delete();
				oContext2.delete();

				assert.strictEqual(oBinding.iCreatedContexts, 0);

				return Promise.all([
					checkCanceled(assert, oContext0.created()),
					checkCanceled(assert, oContext1.created()),
					checkCanceled(assert, oContext2.created()),
					that.waitForChanges(assert, "(5) delete inline creation rows")
				]);
			});
		});
	});
});

	//*********************************************************************************************
	// Scenario: Apply the filter for messages on a table with persisted and inactive rows, but only
	// messages for inactive rows. See that the persisted rows disappear w/o a request, and see that
	// selected APIs do not invoke requests afterwards.
	// Run each test with a grid table, a responsive table, and a responsive table with growing
	// enablement. Check that #setAggregation does not work with Filter.NONE, download URL is null,
	// and #requestContexts (with Filter.NONE) returns transient rows only without a GET request.
	// (1) Add two inline creation rows, keep one persisted context alive.
	// (2) Change a property of the first creation row, the activation fails with a message
	// (3) Call #requestFilterForMessages, see that it is Filter.NONE, apply it, and see that only
	//     the transient and kept-alive contexts remain w/o a request
	// (4) Call #requestSideEffects, see that all rows remain
	// (5) Call the given API function and see that nothing happens (except refresh for the kept-
	//     alive context)
	// (6) Create another kept-alive context via getKeepAliveContext
	// (7) Activate and persist the first row, create a new inactive row, fail to activate it, and
	//     release the kept-alive contexts
	// (8) Call #requestSideEffects, see that all rows remain, including the created persisted one
	// (9) Call the given API function again and see that the created persisted row disappears
	// (10) Remove the filter and see that data is requested from the server
	// JIRA: CPOUI5ODATAV4-2321
[
	{desc : "grid table", table : "t:Table", parameters : "", rows : "rows", top : 110},
	{desc : "responsive table", table : "Table", parameters : "", rows : "items", top : 100},
	{desc : "growing table", table : "Table", parameters : 'growing="true"', rows : "items",
		top : 20}
].forEach((o) => {
	[
		"changeParameters", "filter", "refresh", "resume", "sort"
	].forEach((sMethod) => {
	QUnit.test(`Filter.NONE & ${sMethod}, ${o.desc}`, async function (assert) {
		const oModel = this.createSalesOrdersModel({autoExpandSelect : true});
		const sView = `
<${o.table} id="table" ${o.parameters} ${o.rows}="{path : '/SalesOrderList',
		parameters : {$count : true, $filter : 'SalesOrderID ne \\'0\\'', $$ownRequest : true}}">
	<Text text="{SalesOrderID}"/>
	<Input value="{Note}"/>
</${o.table}>`;

		const createActivateCallback = (oEvent) => {
			const oCreatedContext = oEvent.getParameter("context");

			if (oCreatedContext.getProperty("Note").length <= 3) {
				this.expectMessages([{
					message : "Note must be longer than 3 chars",
					target : "/SalesOrderList($uid=...)/Note",
					type : "Error"
				}]);
				Messaging.addMessages(new Message({
					message : "Note must be longer than 3 chars",
					processor : oModel,
					target : oCreatedContext.getPath() + "/Note",
					type : "Error"
				}));
				oEvent.preventDefault();
			} else {
				Messaging.removeAllMessages(); // there can only be one message at a time
				this.expectMessages([]);
			}
		};

		this.expectRequest("SalesOrderList?$count=true&$filter=SalesOrderID ne '0'"
				+ "&$select=Note,SalesOrderID&$skip=0&$top=" + o.top, {
				"@odata.count" : "2",
				value : [
					{Note : "Note 42", SalesOrderID : "42"},
					{Note : "Note 43", SalesOrderID : "43"}
				]
			});

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oBinding = oTable.getBinding("rows") ?? oTable.getBinding("items");

		checkTable("after creating view", assert, oTable, [
			"/SalesOrderList('42')",
			"/SalesOrderList('43')"
		], [
			["42", "Note 42"],
			["43", "Note 43"]
		]);
		assert.strictEqual(oBinding.getCount(), 2);

		const oKeptAliveContext0 = oBinding.getCurrentContexts()[0];
		oKeptAliveContext0.setKeepAlive(true);

		oBinding.attachCreateActivate(createActivateCallback);

		const oContext0 = oBinding.create(undefined, true, true, true);
		const oContext1 = oBinding.create({Note : "bar"}, true, true, true);

		await resolveLater(); // table update takes a moment

		checkTable("create inline creation rows", assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('42')",
			"/SalesOrderList('43')"
		], [
			["42", "Note 42"],
			["43", "Note 43"],
			["", ""],
			["", "bar"]
		]);
		assert.strictEqual(oBinding.getCount(), 2);

		oContext0.setProperty("Note", "foo");

		await resolveLater(); // table update takes a moment

		checkTable("set property, fail activation", assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('42')",
			"/SalesOrderList('43')"
		], [
			["42", "Note 42"],
			["43", "Note 43"],
			["", "foo"],
			["", "bar"]
		]);
		assert.strictEqual(oBinding.getCount(), 2);

		// code under test
		assert.strictEqual(await oBinding.requestFilterForMessages(), Filter.NONE);
		oBinding.filter(Filter.NONE);

		assert.strictEqual(oBinding.getCount(), undefined, "cache not ready");

		await resolveLater(); // table update takes a moment

		checkTable("Filter.NONE set", assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('42')" // kept-alive
		], [
			["", "foo"],
			["", "bar"]
		], 2);
		assert.strictEqual(oBinding.getCount(), 0);

		// code under test
		const aContexts = await oBinding.requestContexts();
		assert.deepEqual(aContexts.map(getNormalizedPath), [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)"
		], "requestContexts");

		// code under test
		assert.strictEqual(oBinding.getDownloadUrl(), null);
		assert.strictEqual(await oBinding.requestDownloadUrl(), null);

		assert.throws(() => {
			// code under test
			oBinding.setAggregation({hierarchyQualifier : "X"});
		}, new Error("Cannot combine Filter.NONE with $$aggregation"));

		this.expectRequest("SalesOrderList?$filter=SalesOrderID eq '42'"
			+ "&$select=Note,SalesOrderID",
			{value : [{Note : "Note 42", SalesOrderID : "42"}]});

		// code under test
		oBinding.getHeaderContext().requestSideEffects([""]);

		await this.waitForChanges(assert, "requestSideEffects");

		checkTable(sMethod, assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('42')"
		], [
			["", "foo"],
			["", "bar"]
		], 2);
		assert.strictEqual(oBinding.getCount(), 0);

		switch (sMethod) {
			case "changeParameters":
				// code under test
				oBinding.changeParameters({$search : "covfefe"});
				break;

			case "filter":
				// code under test
				oBinding.filter(new Filter("Note", FilterOperator.NE, "4711"), FilterType.Control);
				break;

			case "resume":
				// code under test
				oBinding.suspend();
				oBinding.sort(new Sorter("SalesOrderID"));
				oBinding.filter(new Filter("Note", FilterOperator.NE, "4711"), FilterType.Control);
				oBinding.changeParameters({$search : "covfefe"});
				oBinding.resume();
				break;

			case "sort":
				// code under test
				oBinding.sort(new Sorter("SalesOrderID"));
				break;

			case "refresh":
				this.expectRequest("SalesOrderList?$filter=SalesOrderID eq '42'"
						+ "&$select=Note,SalesOrderID",
						{value : [{Note : "Note 42", SalesOrderID : "42"}]});

				// code under test
				oBinding.refresh();
				break;

			// no default
		}

		await this.waitForChanges(assert, "test API " + sMethod);

		// no change expected
		checkTable(sMethod, assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('42')"
		], [
			["", "foo"],
			["", "bar"]
		], 2);
		assert.strictEqual(oBinding.getCount(), 0);

		this.expectRequest("SalesOrderList('43')?$select=SalesOrderID", {SalesOrderID : "43"});

		// code under test
		const oKeptAliveContext1 = oBinding.getKeepAliveContext("/SalesOrderList('43')");

		await this.waitForChanges(assert, "getKeepAliveContext");

		checkTable("getKeepAliveContext", assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('42')",
			"/SalesOrderList('43')"
		], [
			["", "foo"],
			["", "bar"]
		], 2);
		assert.strictEqual(oBinding.getCount(), 0);
		assert.strictEqual(oKeptAliveContext1.getIndex(), undefined);

		this.expectRequest({
				method : "POST",
				url : "SalesOrderList",
				payload : {Note : "foobar"}
			}, {
				Note : "foobar*",
				SalesOrderID : "44"
			});

		// code under test (activate first row)
		oContext0.setProperty("Note", "foobar");
		assert.strictEqual(oBinding.getCount(), 1);

		const oContext2 = oBinding.create(undefined, true, true, true);
		// activation fails
		oContext2.setProperty("Note", "baz");

		// code under test (release kept contexts)
		oKeptAliveContext0.setKeepAlive(false);
		oKeptAliveContext1.setKeepAlive(false);

		await Promise.all([
			oContext0.created(),
			this.waitForChanges(assert, "activate first row and add a new inactive one")
		]);

		checkTable("third inline creation row added, first row persisted", assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('44')"
		], [
			["44", "foobar*"],
			["", "bar"],
			["", "baz"]
		]);
		assert.strictEqual(oBinding.getCount(), 1);

		this.expectRequest("SalesOrderList?$filter=SalesOrderID eq '44'&$select=Note,SalesOrderID",
				{value : [{Note : "foobar**", SalesOrderID : "44"}]});

		await Promise.all([
			// code under test
			oBinding.getHeaderContext().requestSideEffects([""]),
			this.waitForChanges(assert, "requestSideEffects")
		]);

		checkTable("after requestSideEffects", assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('44')"
		], [
			["44", "foobar**"],
			["", "bar"],
			["", "baz"]
		]);
		assert.strictEqual(oBinding.getCount(), 1);

		let sFilter = "SalesOrderID ne '0'";
		let sOptions = "";

		switch (sMethod) {
			case "changeParameters":
				sOptions = "&$search=fefecov";
				// code under test
				oBinding.changeParameters({$search : "fefecov"});
				break;

			case "filter":
				sFilter = `Note ne '1174' and (${sFilter})`;
				// code under test
				oBinding.filter(new Filter("Note", FilterOperator.NE, "1174"), FilterType.Control);
				break;

			case "resume":
				sFilter = `Note ne '1174' and (${sFilter})`;
				sOptions = "&$search=fefecov&$orderby=SalesOrderID desc";
				// code under test
				oBinding.suspend();
				oBinding.sort(new Sorter("SalesOrderID", true));
				oBinding.filter(new Filter("Note", FilterOperator.NE, "1174"), FilterType.Control);
				oBinding.changeParameters({$search : "fefecov"});
				oBinding.resume();
				break;

			case "sort":
				sOptions = "&$orderby=SalesOrderID desc";
				// code under test
				oBinding.sort(new Sorter("SalesOrderID", true));
				break;

			case "refresh":
				// code under test
				oBinding.refresh();
				break;

			// no default
		}

		await resolveLater(); // table update takes a moment

		checkTable("created persisted row gets removed", assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)"
		], [
			["", "bar"],
			["", "baz"]
		]);
		assert.strictEqual(oBinding.getCount(), 0);

		this.expectRequest("SalesOrderList?$count=true&$filter=" + sFilter
				+ "&$select=Note,SalesOrderID" + sOptions + "&$skip=0&$top=" + o.top, {
				"@odata.count" : "3",
				value : [
					{Note : "Note 42", SalesOrderID : "42"},
					{Note : "Note 43", SalesOrderID : "43"},
					{Note : "foobar*", SalesOrderID : "44"}
				]
			});

		// code under test
		oBinding.filter();

		await this.waitForChanges(assert, "remove filter");

		checkTable("remove filter", assert, oTable, [
			"/SalesOrderList($uid=...)",
			"/SalesOrderList($uid=...)",
			"/SalesOrderList('42')",
			"/SalesOrderList('43')",
			"/SalesOrderList('44')"
		], [
			["42", "Note 42"],
			["43", "Note 43"],
			["44", "foobar*"],
			["", "bar"],
			["", "baz"]
		]);
		assert.strictEqual(oBinding.getCount(), 3);

		assert.strictEqual(oContext1.isInactive(), true);
		assert.strictEqual(oContext2.isInactive(), 1);
	});
	});
});

	//*********************************************************************************************
	// Scenario: Nested list binding w/o own cache. Filter it with Filter.NONE so it creates an
	// own cache. Persisted rows disappear.
	QUnit.test("Filter.NONE w/o cache", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"});
		const sView = `
<FlexBox binding="{/TEAMS('1')}">
	<Table id="table" items="{TEAM_2_EMPLOYEES}">
		<Text id="id" text="{ID}"/>
	</Table>
</FlexBox>`;

		this.expectRequest("TEAMS('1')?$select=Team_Id&$expand=TEAM_2_EMPLOYEES($select=ID)",
				{Team_Id : "1", TEAM_2_EMPLOYEES : [{ID : "10"}, {ID : "20"}]})
			.expectChange("id", ["10", "20"]);

		await this.createView(assert, sView, oModel);
		const oBinding = this.oView.byId("table").getBinding("items");

		assert.strictEqual(oBinding.getLength(), 2);

		// code under test
		oBinding.filter(Filter.NONE);

		assert.strictEqual(oBinding.getLength(), 0);

		await this.waitForChanges(assert);
	});

	//*********************************************************************************************
	// Scenario: relative ODLB w/o own cache; switch binding context via setContext with transient
	// rows present. Switch back and expect that transient rows survived.
	//
	// JIRA: CPOUI5ODATAV4-1450
	QUnit.test("ODLB w/o own cache: setContext with transient rows", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oFirstBindingContext,
			oListBinding,
			sView = '\
<FlexBox id="flexbox" binding="{/SalesOrderList(\'42\')}">\
	<t:Table id="table" rows="{path : \'SO_2_SOITEM\', \
			parameters : {$$updateGroupId : \'update\', $count: true}}">\
		<Text id="note" text="{Note}"/>\
	</t:Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')/SO_2_SOITEM?"
				+ "$count=true&$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=110", {
				"@odata.count" : "1",
				value : [{SalesOrderID : "42", Note : "Note 10"}]
			})
			.expectChange("note", ["Note 10"]);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("table").getBinding("rows");
			oFirstBindingContext = that.oView.byId("table").getBindingContext();

			that.expectChange("note", ["First", "Note 10"]);

			oListBinding.create({Note : "First"}, true, false, false);

			assert.strictEqual(oListBinding.aContexts[0].isTransient(), true);
			assert.strictEqual(oListBinding.aContexts.length, 2);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", ["Note 43"])
				.expectRequest("SalesOrderList('43')/SO_2_SOITEM?"
					+ "$count=true&$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=110", {
					"@odata.count" : "1",
					value : [{SalesOrderID : "43", Note : "Note 43"}]
				});

			// code under test
			that.oView.byId("table").setBindingContext(
				oModel.createBindingContext("/SalesOrderList('43')"));

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(oListBinding.aContexts[0].isTransient(), undefined);
			assert.strictEqual(oListBinding.aContexts.length, 1);

			that.expectChange("note", ["First", "Note 10"]);

			// code under test
			that.oView.byId("table").setBindingContext(oFirstBindingContext);

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(oListBinding.aContexts[0].isTransient(), true);
			assert.strictEqual(oListBinding.aContexts.length, 2);
		});
	});

	//*********************************************************************************************
	// Scenario: Create a row and delete it again. Then request more data and check the count.
	//
	// JIRA: CPOUI5ODATAV4-1321
	QUnit.test("create, delete and paging", function (assert) {
		var oBinding,
			oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Text id="count" text="{$count}"/>\
<Table growing="true" growingThreshold="2" id="listReport"\
		items="{path : \'/BusinessPartnerList\', parameters : {$count : true}}">\
	<Text id="id" text="{BusinessPartnerID}"/>\
</Table>',
			that = this;

		this.expectRequest("BusinessPartnerList?$count=true&$select=BusinessPartnerID"
				+ "&$skip=0&$top=2", {
				"@odata.count" : "3",
				value : [
					{BusinessPartnerID : "4711"},
					{BusinessPartnerID : "4712"}
				]
			})
			.expectChange("count")
			.expectChange("id", ["4711", "4712"]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("listReport").getBinding("items");

			that.expectChange("count", "3");
			that.oView.byId("count").setBindingContext(oBinding.getHeaderContext());

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("count", "4")
				.expectChange("id", ["", ""])
				.expectRequest({
					method : "POST",
					payload : {},
					url : "BusinessPartnerList"
				}, {BusinessPartnerID : "new1"})
				.expectChange("id", [, "new1"]);

			oContext = oBinding.create({}, true);
			oBinding.create({}, true, false, /*bInactive*/true);

			that.checkMoreButton(assert, "[2/5]");

			return Promise.all([
				oContext.created(),
				that.waitForChanges(assert, "create")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 4, "count of elements");

			that.expectRequest("DELETE BusinessPartnerList('new1')")
				.expectChange("count", "3")
				.expectChange("id", [, "4711"]);

			return Promise.all([
				oContext.delete(),
				that.waitForChanges(assert, "delete")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 3, "count of elements");
			that.checkMoreButton(assert, "[2/4]");

			that.expectRequest("BusinessPartnerList?$count=true&$select=BusinessPartnerID"
					+ "&$skip=2&$top=1", {
					"@odata.count" : "3",
					value : [{BusinessPartnerID : "4713"}]
				})
				.expectChange("id", [/*inactive*/, /*4711*/, "4712", "4713"]);

			that.oView.byId("listReport").requestItems();

			return that.waitForChanges(assert, "paging");
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 3, "count of elements");
			assert.strictEqual(oBinding.getLength(), 4, "length of elements");
		});
	});

	//*********************************************************************************************
	// Scenario: Create a model with metadataUrlParams. See that the main $metadata request contains
	// sap-context-token, sap-language, and sap-client -> see this.createModel() below.
	// Further requests for $metadata references must not use sap-context-token.
	//
	// JIRA: CPOUI5ODATAV4-279
	QUnit.test("CPOUI5ODATAV4-279", function (assert) {
		var oModel;

		oModel = this.createModel(sTeaBusi + "?sap-client=279", {
			earlyRequests : true,
			metadataUrlParams : {
				"sap-context-token" : "20200716120000",
				"sap-language" : "EN"
			}
		}, {
			"HEAD /sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001/?sap-client=279" : {},
			"/sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001/$metadata?sap-client=279&sap-context-token=20200716120000&sap-language=EN"
				: {source : "odata/v4/data/metadata.xml"},
			"/sap/opu/odata4/IWBEP/TEA/default/iwbep/tea_busi_product/0001/$metadata?sap-client=279&sap-language=EN"
				: {source : "odata/v4/data/metadata_tea_busi_product.xml"}
		});

		return oModel.getMetaModel()
			.requestObject("/Equipments/EQUIPMENT_2_PRODUCT/PRODUCT_2_CATEGORY/$Type")
			.then(function (sName) {
				assert.strictEqual(sName,
					"com.sap.gateway.default.iwbep.tea_busi_product.v0001.Category");
			});
	});

	//*********************************************************************************************
	// Scenario:
	// 1. List report and object page showing a sales order. Use an update group. Ensure that
	//    the object page shares the list report's cache, but needs late properties.
	// 2. Select a sales order and see that late properties are requested. Keep its context alive.
	// 3. Filter the list, so that the context drops out of it. Check that the context is still
	//    alive and has its data.
	//    BCP: 2170211215 Check that #setAggregation is throwing an error (mPreviousContextsByPath)
	// 4. Modify a property. See that the list has pending changes.
	// 5. Delete the filter. Expect no request for the late properties.
	// 6. Refresh (JIRA: CPOUI5ODATAV4-1382)
	// 7. Submit the list's pending changes. (JIRA: CPOUI5ODATAV4-1104)
	// 8. Filter the list, so that the context remains. Give the sales order a new ETag. See that
	//    the late properties are requested again.
	// 9. BCP: 2170211215 Check that #setAggregation is throwing an error (aContexts)
	// JIRA: CPOUI5ODATAV4-340
	//
	// See that setKeepAlive(false) is not possible with pending changes (BCP: 2380044672)
	QUnit.test("CPOUI5ODATAV4-340: Context#setKeepAlive", function (assert) {
		var oKeptContext,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			oTableBinding,
			sView = '\
<Table id="listReport" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Input id="buyerId" value="{BuyerID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [{"@odata.etag" : "etag1", SalesOrderID : "1"}]
			})
			.expectChange("id", ["1"])
			.expectChange("buyerId");

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("listReport");
			oTableBinding = oTable.getBinding("items");
			oKeptContext = oTable.getItems()[0].getBindingContext();

			that.expectRequest("SalesOrderList('1')?$select=BuyerID",
					{"@odata.etag" : "etag1", BuyerID : "42"})
				.expectChange("buyerId", "42");

			// code under test
			oKeptContext.setKeepAlive(true);
			that.oView.byId("objectPage").setBindingContext(oKeptContext);

			return that.waitForChanges(assert, "(2)");
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$filter=SalesOrderID ne '1'"
					+ "&$skip=0&$top=100",
					{value : []}
				);

			oTableBinding.filter(new Filter("SalesOrderID", FilterOperator.NE, "1"));

			assert.throws(function () {
				oTableBinding.setAggregation({});
			}, new Error("Cannot set $$aggregation due to a kept-alive context"));

			return that.waitForChanges(assert, "(3)");
		}).then(function () {
			assert.strictEqual(oKeptContext.isKeepAlive(), true);
			assert.strictEqual(oKeptContext.getIndex(), undefined);
			assert.strictEqual(oKeptContext.getProperty("BuyerID"), "42");

			that.expectChange("buyerId", "42a");

			that.oView.byId("buyerId").getBinding("value").setValue("42a");

			return that.waitForChanges(assert, "(4)");
		}).then(function () {
			assert.ok(oTableBinding.hasPendingChanges());

			assert.throws(function () {
				oKeptContext.setKeepAlive(false); // BCP: 2380044672
			}, new Error("Not allowed due to pending changes: " + oKeptContext));

			that.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
					value : [{"@odata.etag" : "etag1", SalesOrderID : "1"}]
				})
				.expectChange("id", ["1"]);
				// expect no request for late properties

			oTableBinding.filter();

			return that.waitForChanges(assert, "(5)");
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
					value : [{"@odata.etag" : "etag1", SalesOrderID : "1"}]
				});

			return Promise.all([
				// code under test
				oTableBinding.requestRefresh(),
				that.waitForChanges(assert, "(6)")
			]);
		}).then(function () {
			assert.ok(oTableBinding.hasPendingChanges());
			assert.notOk(oTableBinding.hasPendingChanges(/*bIgnoreKeptAlive*/true));
			assert.strictEqual(oKeptContext.getProperty("BuyerID"), "42a", "change kept alive");

			that.expectChange("buyerId", "42b")
				.expectRequest({
					headers : {"If-Match" : "etag1"},
					method : "PATCH",
					url : "SalesOrderList('1')",
					payload : {BuyerID : "42b"}
				}, {"@odata.etag" : "etag2", BuyerID : "42c", SalesOrderID : "1"})
				.expectChange("buyerId", "42c");

			return Promise.all([
				oKeptContext.setProperty("BuyerID", "42b"),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, "(7)")
			]);
		}).then(function () {
			assert.strictEqual(oKeptContext.getProperty("BuyerID"), "42c");
			assert.notOk(oTableBinding.hasPendingChanges());
			assert.strictEqual(oKeptContext.getIndex(), 0);

			that.expectRequest("SalesOrderList?$select=SalesOrderID&$filter=SalesOrderID eq '1'"
					+ "&$skip=0&$top=100", {
					value : [{"@odata.etag" : "etag3", SalesOrderID : "1"}]
				})
				.expectRequest("SalesOrderList('1')?$select=BuyerID",
					{"@odata.etag" : "etag3", BuyerID : "42*"})
				.expectChange("buyerId", "42*");

			oTableBinding.filter(new Filter("SalesOrderID", FilterOperator.EQ, "1"));

			return that.waitForChanges(assert, "(8)");
		}).then(function () {
			assert.throws(function () {
				oTableBinding.setAggregation({});
			}, new Error("Cannot set $$aggregation due to a kept-alive context"));
		});
	});

	//*********************************************************************************************
	// Scenario: A property of a kept-alive context is modified while the context is not in the
	// collection. Via paging it becomes part of the collection, but the ETag was changed on the
	// server.
	// JIRA: CPOUI5ODATAV4-340
	//
	// Scenario: All contexts of a bound list available on the client are returned, including
	// kept-alive contexts that are not in the collection.
	// JIRA: CPOUI5MODELS-782
	QUnit.test("CPOUI5ODATAV4-340: Context#setKeepAlive, update conflict", function (assert) {
		var oKeptContext,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oTable,
			oTableBinding,
			sView = '\
<Table id="listReport" growing="true" growingThreshold="1" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Input id="buyerId" value="{BuyerID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=1", {
				value : [{"@odata.etag" : "etag1", SalesOrderID : "1"}]
			})
			.expectChange("id", ["1"])
			.expectChange("buyerId");

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("listReport");
			oTableBinding = oTable.getBinding("items");
			oKeptContext = oTable.getItems()[0].getBindingContext();

			that.expectRequest("SalesOrderList('1')?$select=BuyerID",
					{"@odata.etag" : "etag1", BuyerID : "42"})
				.expectChange("buyerId", "42");

			// code under test
			oKeptContext.setKeepAlive(true);
			that.oView.byId("objectPage").setBindingContext(oKeptContext);

			// code under test (CPOUI5MODELS-782)
			assert.deepEqual(oTableBinding.getAllCurrentContexts().map(getPath),
				["/SalesOrderList('1')"]);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$orderby=SalesOrderID desc"
					+ "&$skip=0&$top=1", {
					value : [{"@odata.etag" : "etag2", SalesOrderID : "2"}]
				})
				.expectChange("id", ["2"]);

			oTableBinding.sort(new Sorter("SalesOrderID", true));

			return that.waitForChanges(assert);
		}).then(function () {
			// code under test (CPOUI5MODELS-782)
			assert.deepEqual(oTableBinding.getAllCurrentContexts().map(getPath),
				["/SalesOrderList('2')", "/SalesOrderList('1')"]);

			that.expectChange("buyerId", "42a");

			that.oView.byId("buyerId").getBinding("value").setValue("42a");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID&$orderby=SalesOrderID desc"
					+ "&$skip=1&$top=1", {
					value : [{"@odata.etag" : "etag1*", SalesOrderID : "1"}]
				})
				.expectMessages([{
					message : "Modified on client and on server: SalesOrderList('1')",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			that.oLogMock.expects("error")
				.withArgs("Failed to get contexts for " + sSalesOrderService
					+ "SalesOrderList with start index 0 and length 2",
					sinon.match("Modified on client and on server: SalesOrderList('1')"));

			// show more items
			oTable.requestItems();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: As application developer you want to use Context#requestProperty in your
	// controller code with the following use cases:
	// 1. Request a single non-nested property
	// 2. Request a nested property for a single-valued navigation property
	// 3. Request an array of properties
	// JIRA: CPOUI5ODATAV4-339
	// BCP: 2080303042
	//
	// Avoid endless loop when (mock) server does not respond properly (BCP: 2280141880)
	QUnit.test("Context#requestProperty (JIRA: CPOUI5ODATAV4-339)", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oContext = oModel.bindContext("/SalesOrderList('1')").getBoundContext(),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=Note,SalesOrderID", {
				"@odata.etag" : "etag",
				Note : "Test",
				SalesOrderID : "1"
			});

			return Promise.all([
				// code under test - 1. Single non-nested property
				oContext.requestProperty("Note").then(function (sNote) {
					assert.strictEqual(sNote, "Test");
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=SO_2_BP"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID,CompanyName)", {
				"@odata.etag" : "etag",
				SO_2_BP : {
					BusinessPartnerID : "42",
					CompanyName : "SAP"
				}
			});

			return Promise.all([
				// code under test - 2. Single nested property
				oContext.requestProperty("SO_2_BP/CompanyName").then(function (sCompanyName) {
					assert.strictEqual(sCompanyName, "SAP");
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=BillingStatus,NetAmount", {
				"@odata.etag" : "etag",
				BillingStatus : "S",
				NetAmount : "1234"
			});

			return Promise.all([
				// code under test - 3. Array of properties
				oContext.requestProperty([
					"BillingStatus", "NetAmount", "Note"
				]).then(function (aValues) {
					assert.deepEqual(aValues, ["S", "1234", "Test"]);
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=NoteLanguage", {
				"@odata.etag" : "etag"
				// NoteLanguage is missing by mistake --> avoid endless loop
			});
			that.oLogMock.expects("error")
				.withArgs("Failed to drill-down into NoteLanguage, invalid segment: NoteLanguage");

			return Promise.all([
				// code under test
				oContext.requestProperty("NoteLanguage").then(function (sNoteLanguage) {
					assert.strictEqual(sNoteLanguage, undefined);
				}),
				that.waitForChanges(assert, "avoid endless loop")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Both the data request for an entity and the data request for a property return
	// status 204 (No Content).
	// BCP: 2080293614
["$direct", "$auto"].forEach(function (sGroupId) {
	QUnit.test("BCP: 2080293614, " + sGroupId, function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true, groupId : sGroupId}),
			sView = '\
<FlexBox binding="{/Artists(ArtistUUID=xyz,IsActiveEntity=false)/BestPublication}">\
	<Text id="price" text="{Price}"/>\
</FlexBox>\
<Text id="currency" \
	text="{/Artists(ArtistUUID=xyz,IsActiveEntity=false)/BestPublication/CurrencyCode}"/>';

		this.expectRequest("Artists(ArtistUUID=xyz,IsActiveEntity=false)/BestPublication"
				+ "?$select=Price,PublicationID")
			.expectRequest("Artists(ArtistUUID=xyz,IsActiveEntity=false)/BestPublication"
				+ "/CurrencyCode")
			.expectChange("price", null)
			.expectChange("currency", "");

		return this.createView(assert, sView, oModel);
	});
});

	//*********************************************************************************************
	// Scenario:
	// 1. Create a view with a list report containing sales orders.
	// 2. Keep the first context of the table alive.
	// 3. (optional) Filter the list by gross amount, so that the context drops out of it. This
	//    implies that the new count must be requested after deleting the context. This request can
	//    result in a changed or unchanged count.
	// 4. Create and save a new sales order, add an inactive context.
	// 5. Delete the kept-alive context (immediately or deferredly). Check that the context is
	//    deleted (if immediately) and a request for $count is sent (filtering out the new and the
	//    deleted sales order) if the context was not in the list anymore.
	// 6. Submit and observe the delete request if necessary
	// 7. Check that the context has been destroyed
	// JIRA: CPOUI5ODATAV4-365
	// JIRA: CPOUI5ODATAV4-473
	// JIRA: CPOUI5ODATAV4-1638
[
	{bCountHasChanged : true, bDeferred : false, bFilter : false},
	{bCountHasChanged : false, bDeferred : false, bFilter : true},
	{bCountHasChanged : true, bDeferred : false, bFilter : true},
	{bCountHasChanged : false, bDeferred : true, bFilter : true},
	{bCountHasChanged : true, bDeferred : true, bFilter : true}
].forEach(function (oFixture) {
	var sTitle = "CPOUI5ODATAV4-365: Delete kept-alive context " + JSON.stringify(oFixture);

	QUnit.test(sTitle, function (assert) {
		var oDeletePromise,
			oKeptContext,
			oListBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			fnOnBeforeDestroy = sinon.spy(),
			oTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<Table id="listReport" growing="true" growingThreshold="3"\
		items="{path : \'/SalesOrderList\', parameters : {$count : true}}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID&$skip=0&$top=3", {
				"@odata.count" : "102",
				value : [{SalesOrderID : "1"}, {SalesOrderID : "2"}, {SalesOrderID : "3"}]
			})
			.expectChange("count")
			.expectChange("id", ["1", "2", "3"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("listReport");
			oListBinding = that.oView.byId("listReport").getBinding("items");

			that.expectChange("count", "102");

			that.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());

			return that.waitForChanges(assert, "count");
		}).then(function () {
			oKeptContext = oTable.getItems()[0].getBindingContext();

			oKeptContext.setKeepAlive(true, fnOnBeforeDestroy);
			assert.ok(oKeptContext.isKeepAlive(), "(2)");

			if (oFixture.bFilter) {
				that.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID"
						+ "&$filter=GrossAmount gt 1000&$skip=0&$top=3", {
						"@odata.count" : "42",
						value : [{SalesOrderID : "3"}, {SalesOrderID : "4"}, {SalesOrderID : "5"}]
					})
					.expectChange("id", [, "4", "5"])
					.expectChange("count", "42");

				oListBinding.filter(new Filter("GrossAmount", FilterOperator.GT, 1000));
			}

			return that.waitForChanges(assert, "(3)");
		}).then(function () {
			var oCreatedPromise;

			that.checkMoreButton(assert, oFixture.bFilter ? "[3/42]" : "[3/102]");

			that.expectChange("id", ["", ""])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {}
				}, {SalesOrderID : "new"})
				.expectChange("count", oFixture.bFilter ? "43" : "103")
				.expectChange("id", [, "new"]);

				oCreatedPromise = oListBinding.create({}, true);
				oListBinding.create({}, true, false, true);

			return Promise.all([
				oCreatedPromise,
				that.waitForChanges(assert, "(4)")
			]);
		}).then(function () {
			var iBatch = oFixture.bFilter ? 4 : 3;

			that.checkMoreButton(assert, oFixture.bFilter ? "[3/44]" : "[3/104]");

			if (!oFixture.bDeferred) {
				that.expectRequest({
						groupId : "$auto.foo",
						batchNo : iBatch,
						method : "DELETE",
						url : "SalesOrderList('1')"
					});
			}

			if (oFixture.bFilter) {
				that.expectRequest({
						groupId : oFixture.bDeferred ? "$auto" : "$auto.foo",
						batchNo : iBatch,
						url : "SalesOrderList?$count=true"
							+ "&$filter=(GrossAmount gt 1000) and not (SalesOrderID eq '1'"
								+ " or SalesOrderID eq 'new')"
							+ "&$top=0"
					}, {
						"@odata.count" : oFixture.bCountHasChanged ? "41" : "42",
						value : []
					});
			} else {
				that.expectChange("id", [, /*new*/, "2"]);
			}

			if (oFixture.bCountHasChanged) {
				that.expectChange("count", oFixture.bFilter ? "42" : "102");
			}

			// code under test
			oDeletePromise = oKeptContext.delete(oFixture.bDeferred ? "update" : "$auto.foo");

			return Promise.all([
				oFixture.bDeferred || oDeletePromise,
				that.waitForChanges(assert, "(5)")
			]);
		}).then(function () {
			if (oFixture.bFilter) {
				that.checkMoreButton(assert, oFixture.bCountHasChanged ? "[3/43]" : "[3/44]");
			} else {
				that.checkMoreButton(assert, "[3/103]");
			}

			return that.waitForChanges(assert, "await rendering so that the context is destroyed");
		}).then(function () {
			if (!oFixture.bDeferred) {
				return;
			}

			that.expectRequest("DELETE SalesOrderList('1')");

			return Promise.all([
				oDeletePromise,
				oModel.submitBatch("update"),
				that.waitForChanges(assert, "submit")
			]);
		}).then(function () {
			sinon.assert.calledOnceWithExactly(fnOnBeforeDestroy);
		});
	});
});

	//*********************************************************************************************
	// Scenario:
	// List with a kept-alive context that is not part of the collection. Delete the kept-alive
	// context. The deletion fails with 404 because the entity does not exist any more in back end.
	// This means that the request for $count within the same $batch also fails and needs to be
	// repeated.
	// JIRA: CPOUI5ODATAV4-480
	QUnit.test("CPOUI5ODATAV4-480", function (assert) {
		var that = this;

		return this.createKeepAliveScenario(assert, true).then(function (oKeptContext) {
			that.checkMoreButton(assert, "[2/27]");

			that.expectRequest({
					batchNo : 4,
					headers : {
						"If-Match" : "etag1"
					},
					method : "DELETE",
					url : "SalesOrderList('1')"
				}, createErrorInsideBatch(null, 404))
				.expectRequest({
					batchNo : 4,
					url : "SalesOrderList?$count=true"
						+ "&$filter=(GrossAmount gt 123) and not (SalesOrderID eq '1')&$top=0"
				}) // response does not matter, fails with DELETE in same $batch
				.expectChange("objectPageGrossAmount", null)
				.expectChange("objectPageNote", null)
				.expectRequest({
					batchNo : 5,
					url : "SalesOrderList?$count=true"
						+ "&$filter=(GrossAmount gt 123) and not (SalesOrderID eq '1')&$top=0"
				}, {
					"@odata.count" : "38",
					value : []
				});

			// code under test
			oKeptContext.delete();

			return that.waitForChanges(assert);
		}).then(function () {
			that.checkMoreButton(assert, "[2/38]");
		});
	});

	//*********************************************************************************************
	// Scenario: A control property is initially not bound, but has a fixed value. Then it becomes
	// bound with a relative path but no binding context. The fixed value should be replaced.
	// JIRA: CPOUI5ODATAV4-363
	QUnit.skip("ODataPropertyBinding#initialize while not resolved", function (assert) {
		var sView = '<Text id="text" text="fixed value"/>',
			that = this;

		// Note: this.expectChange("text") cannot handle a scenario w/o binding

		return this.createView(assert, sView).then(function () {
			var fnResolve,
				oPromise = new Promise(function (resolve) {
					fnResolve = resolve;
				}),
				oText = that.oView.byId("text");

			assert.strictEqual(oText.getText(), "fixed value");

			// code under test
			oText.bindText("Name");

			//TODO is this the right expectation?
			// #checkUpdateInternal says "an unresolved binding only fires if it had a value before"
			// --> no event :-(
			oText.getBinding("text").attachEventOnce("change", function () {
				assert.strictEqual(oText.getText(), undefined);

				fnResolve();
			});

			return oPromise;
		});
	});

	//*********************************************************************************************
	// Scenario: An annotation with $If comparing a number is evaluated.
	// JIRA: CPOUI5ODATAV4-408
	QUnit.test("CPOUI5ODATAV4-408: $If comparing a number", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/As(1)}">\
	<Text id="avalue" text="{AValue}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("As(1)?$select=AID,AValue", {
				AID : 1,
				AValue : 1000 // Edm.Int16
			})
			.expectChange("avalue", "1,000");

		return this.createView(assert, sView, oModel).then(function () {
			var oMetaModel = oModel.getMetaModel(),
				oContext = oMetaModel.createBindingContext(
					"/As/AID@com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers"),
				vRawValue = oContext.getObject(),
				// "{=odata.collection(['in',(%{AValue}>10)?'maybe':undefined])}"
				sBinding = AnnotationHelper.value(vRawValue, {context : oContext}),
				oText = new Text({text : sBinding, models : oModel});

			oText.setBindingContext(that.oView.byId("form").getBindingContext());

			return Promise.all(oText.getBinding("text").getBindings().map(function (oBinding) {
				return oBinding.requestValue();
			})).then(function () {
				assert.strictEqual(oText.getText(), "in,maybe");
			});
		});
	});

	//*********************************************************************************************
	// Scenario: Evaluate "ValueListRelevantQualifiers" annotation with late property request.
	// JIRA: CPOUI5ODATAV4-408
[1, 11].forEach(function (iValue) {
	var sTitle = "CPOUI5ODATAV4-408: ValueListRelevantQualifiers, value=" + iValue;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/As(1)}">\
	<Text id="aid" text="{AID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("As(1)?$select=AID", {AID : 1})
			.expectChange("aid", "1");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("As(1)?$select=AValue", {
					AValue : iValue // Edm.Int16
				});

			// code under test
			return that.oView.byId("aid").getBinding("text").requestValueListInfo();
		}).then(function (mQualifier2ValueListType) {
			assert.deepEqual(
				Object.keys(mQualifier2ValueListType),
				iValue > 10 ? ["in", "maybe"] : ["in"]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Evaluate "ValueListRelevantQualifiers" annotation even when
	// "ValueListWithFixedValues" is present.
	// JIRA: CPOUI5ODATAV4-1251
	// BCP: 2280012068 ValueListWithFixedValues takes precedence over SearchSupported
[0, 1].forEach(function (iValue) {
	var sTitle = "CPOUI5ODATAV4-1251: ValueListRelevantQualifiers and ValueListWithFixedValues"
			+ ", value=" + iValue;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/Bs(1)}">\
	<Text id="bid" text="{BID}"/>\
	<Text id="bvalue" text="{BValue}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Bs(1)?$select=BID,BValue", {BID : 1, BValue : iValue})
			.expectChange("bid", "1")
			.expectChange("bvalue", "" + iValue);

		return this.createView(assert, sView, oModel).then(function () {
			// code under test
			return that.oView.byId("bid").getBinding("text").requestValueListInfo();
		}).then(function (mQualifier2ValueListType) {
			delete mQualifier2ValueListType[""].$model;
			assert.deepEqual(mQualifier2ValueListType, {
				"" : {
					Label : iValue ? "Second label" : "First label",
					$qualifier : iValue ? "one" : "zero"
				}
			});
		});
	});
});

	//*********************************************************************************************
	// Scenario: Evaluate "ValueListRelevantQualifiers" annotation with Partner NavigationProperty.
	// BCP: 2380132332
[0, 1].forEach(function (iValue) {
	QUnit.test("BCP: 2380132332, value=" + iValue, async function (assert) {
		const oModel = this.createSpecialCasesModel({autoExpandSelect : true});
		const sView = `
<FlexBox id="outer" binding="{/As(0)}">
	<Text id="aid" text="{AID}"/>
	<Text id="avalue" text="{AValue}"/>
	<FlexBox id="inner" binding="{AtoCs(1)}">
		<Text id="cid" text="{CID}"/>
		<Text id="cvalue" text="{CValue}"/>
	</FlexBox>
</FlexBox>`;

		//TODO why is all of AtoCs expanded here?
		this.expectRequest("As(0)?$select=AID,AValue&$expand=AtoCs($select=CID,CValue)", {
				AID : 0,
				AValue : iValue,
				AtoCs : [{
					CID : 1,
					CValue : 1
				}]
			})
			.expectChange("aid", "0")
			.expectChange("avalue", "" + iValue)
			.expectChange("cid", "1")
			.expectChange("cvalue", "1");

		await this.createView(assert, sView, oModel);

		const oContext = this.oView.byId("inner").getBindingContext();
		assert.strictEqual(oContext.getPath(), "/As(0)/AtoCs(1)");

		// code under test
		const mQualifier2ValueListType = await oModel.getMetaModel()
			.requestValueListInfo("/As/AtoCs/CtoEs/EValue", true, oContext);

		if (iValue === 1) {
			delete mQualifier2ValueListType["same"]?.$model;
			assert.deepEqual(mQualifier2ValueListType, {
				same : {
					Label : "Same label ;-)"
				}
			});
		} else {
			assert.deepEqual(mQualifier2ValueListType, {}, "empty");
		}
	});
});

	//*********************************************************************************************
	// Scenario: With the binding parameter <code>$$ignoreMessages</code> the application developer
	// can control whether messages are displayed at the control. It works for
	// <code>sap.ui.model.odata.v4.ODataPropertyBinding</code>s and composite bindings containing
	// such bindings.
	// JIRA: CPOUI5MODELS-290
	QUnit.test("ODataPropertyBindings and CompositeBindings: $$ignoreMessages", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="objectPage" binding="{path : \'/EMPLOYEES(\\\'1\\\')\', \
	parameters : {$select : \'__CT__FAKE__Message/__FAKE__Messages\'}}">\
		<Input id="Name0" value="{Name}"/>\
		<Input id="Name1" value="{path : \'Name\', parameters : {$$ignoreMessages : false}}"/>\
		<Input id="Name2" value="{path : \'Name\', parameters : {$$ignoreMessages : true}}"/>\
		<Input id="Composite0" value="{= ${ID} + ${value : \' - \'} + ${path : \'Name\'}}"/>\
		<Input id="Composite1" value="{= ${ID} + ${value : \' - \'} + ${\
			path : \'Name\',\
			parameters : {$$ignoreMessages : false}\
		}}"/>\
		<Input id="Composite2" value="{= ${ID} + ${value : \' - \'} + ${\
			path : \'Name\',\
			parameters : {$$ignoreMessages : true}\
		}}"/>\
		<Input id="Composite3" value="{parts : [\'ID\', {value : \'-\'}, {\
			path : \'Name\',\
			parameters : {$$ignoreMessages : false}\
		}]}"/>\
		<Input id="Composite4" value="{parts : [\'ID\', {value : \'-\'}, {\
			path : \'Name\',\
			parameters : {$$ignoreMessages : true}\
		}]}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')"
				+ "?$select=ID,Name,__CT__FAKE__Message/__FAKE__Messages", {
				ID : "1",
				Name : "Name",
				__CT__FAKE__Message : {
					__FAKE__Messages : [{
						code : "1",
						message : "Foo",
						numericSeverity : 3,
						target : "Name",
						transition : false
					}]
				}
			})
			.expectChange("Name0", "Name")
			.expectChange("Name1", "Name")
			.expectChange("Name2", "Name")
			.expectMessages([{
				code : "1",
				message : "Foo",
				target : "/EMPLOYEES('1')/Name",
				type : "Warning"
			}]);

		// code under test
		return this.createView(assert, sView, oModel).then(function () {
			assert.strictEqual(that.oView.byId("Composite0").getValue(), "1 - Name");
			assert.strictEqual(that.oView.byId("Composite1").getValue(), "1 - Name");
			assert.strictEqual(that.oView.byId("Composite2").getValue(), "1 - Name");
			assert.strictEqual(that.oView.byId("Composite3").getValue(), "1 - Name");
			assert.strictEqual(that.oView.byId("Composite4").getValue(), "1 - Name");
			return Promise.all([
				that.checkValueState(assert, "Name0", "Warning", "Foo"),
				that.checkValueState(assert, "Name1", "Warning", "Foo"),
				that.checkValueState(assert, "Name2", "None", ""),
				that.checkValueState(assert, "Composite0", "Warning", "Foo"),
				that.checkValueState(assert, "Composite1", "Warning", "Foo"),
				that.checkValueState(assert, "Composite2", "None", ""),
				that.checkValueState(assert, "Composite3", "Warning", "Foo"),
				that.checkValueState(assert, "Composite4", "None", ""),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario:
	// Refresh a kept-alive context that is not part of the collection (B1). After refresh this
	// context is not in the collection and has new data (A1).
	// JIRA: CPOUI5ODATAV4-366
	//
	// Selection and data binding for selection (JIRA: CPOUI5ODATAV4-1943, CPOUI5ODATAV4-1944).
	QUnit.test("CPOUI5ODATAV4-366: Context#refresh on a context that is not in the collection"
			+ "; after refresh that context is not in the collection", function (assert) {
		var oKeptContext,
			that = this;

		return this.createKeepAliveScenario(assert, true).then(function (oKeptContext0) {
			that.expectRequest("SalesOrderList?$filter=SalesOrderID eq '1'"
					+ "&$select=GrossAmount,Note,SalesOrderID", {
					value : [{GrossAmount : "199", Note : "After refresh", SalesOrderID : "1"}]
				})
				.expectChange("objectPageGrossAmount", "199.00")
				.expectChange("objectPageNote", "After refresh")
				.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100", {
					value : [/*does not matter*/]
				});

			oKeptContext = oKeptContext0;

			// code under test
			oKeptContext.setSelected(true);

			// code under test
			oKeptContext.refresh(undefined, true);

			return that.waitForChanges(assert, "(3)");
		}).then(function () {
			// code under test
			checkSelected(assert, oKeptContext, true);
		});
	});

	//*********************************************************************************************
	// Scenario:
	// Refresh a kept-alive context that is not part of the collection (B1). After refresh the
	// entity is deleted (A3).
	// JIRA: CPOUI5ODATAV4-366
	QUnit.test("CPOUI5ODATAV4-366: Context#refresh on a context that is not in the collection"
			+ "; after refresh the entity is deleted", function (assert) {
		var fnOnBeforeDestroy = sinon.spy(),
			that = this;

		return this.createKeepAliveScenario(assert, true, fnOnBeforeDestroy)
			.then(function (oKeptContext) {
				that.expectRequest("SalesOrderList?$filter=SalesOrderID eq '1'"
						+ "&$select=GrossAmount,Note,SalesOrderID", {
						value : []
					})
					.expectChange("objectPageGrossAmount", null)
					.expectChange("objectPageNote", null);

				// code under test
				oKeptContext.refresh(undefined, true);

				return that.waitForChanges(assert, "(3)");
			}).then(function () {
				sinon.assert.calledOnceWithExactly(fnOnBeforeDestroy);
			});
	});

	//*********************************************************************************************
	// Scenario:
	// Refresh a kept-alive context that is part of the collection (B2). After refresh this context
	// is not in the collection and has new data (A1).
	// JIRA: CPOUI5ODATAV4-366
	QUnit.test("CPOUI5ODATAV4-366: Context#refresh on a context that is in the collection"
			+ "; after refresh that context is not in the collection", function (assert) {
		var that = this;

		return this.createKeepAliveScenario(assert, false).then(function (oKeptContext) {
			that.expectRequest({
					batchNo : 3,
					url : "SalesOrderList?$filter=SalesOrderID eq '1'"
						+ "&$select=GrossAmount,Note,SalesOrderID"
				}, {
					value : [{GrossAmount : "199", Note : "After refresh", SalesOrderID : "1"}]
				})
				.expectRequest({
					batchNo : 3,
					url : "SalesOrderList?$filter=(GrossAmount le 150) and SalesOrderID eq '1'"
						+ "&$count=true&$top=0"
				}, {
					"@odata.count" : "0",
					value : []
				})
				.expectChange("objectPageGrossAmount", "199.00")
				.expectChange("objectPageNote", "After refresh")
				.expectChange("grossAmount", ["199.00"]) // FIXME: JIRA: CPOUI5ODATAV4-524
				// as context is no longer part of the collection the list requests a new context
				.expectRequest({
					batchNo : 4,
					url : "SalesOrderList?$count=true&$filter=GrossAmount le 150"
						+ "&$select=GrossAmount,SalesOrderID&$skip=1&$top=1"
				}, {
					"@odata.count" : "41",
					value : [{GrossAmount : "120", SalesOrderID : "4"}]
				})
				.expectChange("id", [, "4"])
				.expectChange("grossAmount", [, "120.00"])
				.expectRequest({
					batchNo : 4,
					url : "SalesOrderList('1')/SO_2_SOITEM"
						+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100"
				}, {
					value : [/*does not matter*/]
				});

			// code under test
			oKeptContext.refresh(undefined, true);

			return that.waitForChanges(assert, "(2)");
		}).then(function () {
			assert.equal(
				that.oView.byId("listReport").getItems()[0].getBindingContext().getPath(),
				"/SalesOrderList('2')");
		});
	});

	//*********************************************************************************************
	// Scenario:
	// Refresh a kept-alive context that is part of the collection (B2). After refresh this context
	// is in the collection (A2).
	// JIRA: CPOUI5ODATAV4-366
	QUnit.test("CPOUI5ODATAV4-366: Context#refresh on a context that is in the collection"
			+ "; after refresh that context is in the collection", function (assert) {
		var that = this;

		return this.createKeepAliveScenario(assert, false).then(function (oKeptContext) {
			that.expectRequest({
					batchNo : 3,
					url : "SalesOrderList?$filter=SalesOrderID eq '1'"
						+ "&$select=GrossAmount,Note,SalesOrderID"
				}, {
					value : [{GrossAmount : "140", Note : "After refresh", SalesOrderID : "1"}]
				})
				.expectRequest({
					batchNo : 3,
					url : "SalesOrderList?$filter=(GrossAmount le 150) and SalesOrderID eq '1'"
						+ "&$count=true&$top=0"
				}, {
					"@odata.count" : "1",
					value : []
				})
				.expectChange("objectPageGrossAmount", "140.00")
				.expectChange("objectPageNote", "After refresh")
				.expectChange("grossAmount", ["140.00"])
				.expectRequest({
					batchNo : 4,
					url : "SalesOrderList('1')/SO_2_SOITEM"
						+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100"
				}, {
					value : [/*does not matter*/]
				});

			// code under test
			oKeptContext.refresh(undefined, true);

			return that.waitForChanges(assert, "(2)");
		});
	});

	//*********************************************************************************************
	// Scenario:
	// Refresh a kept-alive context that is part of the collection (B2). After refresh the
	// entity is deleted (A3).
	// JIRA: CPOUI5ODATAV4-366
	QUnit.test("CPOUI5ODATAV4-366: Context#refresh on a context that is in the collection"
		+ ", after refresh the entity is deleted", function (assert) {
		var fnOnBeforeDestroy = sinon.spy(),
			that = this;

		return this.createKeepAliveScenario(assert, false, fnOnBeforeDestroy)
			.then(function (oKeptContext) {
				that.expectRequest({
						batchNo : 3,
						url : "SalesOrderList?$filter=SalesOrderID eq '1'"
							+ "&$select=GrossAmount,Note,SalesOrderID"
					}, {
						value : []
					})
					.expectRequest({
						batchNo : 3,
						url : "SalesOrderList?$filter=(GrossAmount le 150) and SalesOrderID eq '1'"
							+ "&$count=true&$top=0"
					}, {
						"@odata.count" : "0",
						value : []
					})
					.expectChange("objectPageGrossAmount", null)
					.expectChange("objectPageNote", null)
					// as context is no longer part of aContexts the list requests a new context
					.expectRequest({
						batchNo : 4,
						url : "SalesOrderList?$count=true&$filter=GrossAmount le 150"
							+ "&$select=GrossAmount,SalesOrderID&$skip=1&$top=1"
					}, {
						"@odata.count" : "41",
						value : [{GrossAmount : "120", SalesOrderID : "4"}]
					})
					.expectChange("id", [, "4"])
					.expectChange("grossAmount", [, "120.00"]);

				// code under test
				oKeptContext.refresh(undefined, true);

				return that.waitForChanges(assert, "(2)");
			}).then(function () {
				sinon.assert.calledOnceWithExactly(fnOnBeforeDestroy);
				assert.equal(
					that.oView.byId("listReport").getItems()[0].getBindingContext().getPath(),
					"/SalesOrderList('2')");
			});
	});

	//*********************************************************************************************
	// Refresh a single context on a table w/o count that has loaded all data (bLengthFinal = true).
	// After refresh the context is no longer part of the table. Expect the behavior is independent
	// of keep-alive and there is no further data request after the context leaves the collection.
[false, true].forEach(function (bKeepAlive) {
	var sTitle = "CPOUI5ODATAV4-366: Context#refresh w/o $count & paging does not reload data"
		+ ", bKeepAlive = " + bKeepAlive;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{path : \'/SalesOrderList\',\
		filters : {path : \'GrossAmount\', operator : \'LE\', value1 : 150}}">\
	<Text id="grossAmount" text="{GrossAmount}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$filter=GrossAmount le 150"
				+ "&$select=GrossAmount,SalesOrderID&$skip=0&$top=100", {
				value : [
					{GrossAmount : "123", SalesOrderID : "1"},
					// Note: the number of remaining contexts does not matter
					{GrossAmount : "99", SalesOrderID : "2"},
					{GrossAmount : "101", SalesOrderID : "3"}
				]
			});

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("table").getItems()[0].getBindingContext();

			if (bKeepAlive) {
				oContext.setKeepAlive(true);

				that.expectRequest("SalesOrderList?$filter=SalesOrderID eq '1'"
						+ "&$select=GrossAmount,SalesOrderID", {
						value : [{GrossAmount : "190", SalesOrderID : "1"}]
					})
					.expectRequest("SalesOrderList"
						+ "?$filter=(GrossAmount le 150) and SalesOrderID eq '1'"
						+ "&$count=true&$top=0", {
						"@odata.count" : "0",
						value : []
					});
			} else {
				that.expectRequest("SalesOrderList"
						+ "?$filter=(GrossAmount le 150) and SalesOrderID eq '1'"
						+ "&$select=GrossAmount,SalesOrderID", {
						value : []
					});
			}

			// code under test
			oContext.refresh(undefined, true);

			return that.waitForChanges(assert);
		});
	});
});

	//*********************************************************************************************
	// Refresh a table with a kept-alive context, but no late properties.
	QUnit.test("BCP: 476620 / 2022 (002075129500004766202022)", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="grossAmount" text="{GrossAmount}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=0&$top=100", {
				value : [{GrossAmount : "123", SalesOrderID : "1"}]
			})
			.expectChange("grossAmount", ["123.00"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("table").getItems()[0].getBindingContext();

			oContext.setKeepAlive(true);

			that.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID"
					+ "&$filter=SalesOrderID eq '1'", {
					value : [{GrossAmount : "321", SalesOrderID : "1"}]
				})
				.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=0&$top=100", {
					value : [{GrossAmount : "n/a", SalesOrderID : "1"}]
				})
				.expectChange("grossAmount", ["321.00"]);

			// code under test
			oContext.getBinding().refresh();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A binding drills down via key predicate into a missing element. Depending on
	// whether or not the collection itself is empty, drill-down fails or just logs.
	// BCP: 2070374495
	QUnit.test("$byPredicate for empty collections", function (assert) {
		var oModel = this.createSpecialCasesModel(),
			sView = '\
<FlexBox binding="{path : \'/Artists(ArtistID=\\\'ABC\\\',IsActiveEntity=false)\',\
	parameters : {$expand : {_Friend : null, _Publication : null}}}">\
	<Text id="id" text="{ArtistID}"/>\
	<Text text="{_Friend(ArtistID=\'bar\',IsActiveEntity=false)/ArtistID}"/>\
	<Text text="{_Publication(\'foo\')/PublicationID}"/>\
</FlexBox>';

		this.oLogMock.expects("error").withArgs("Failed to drill-down into"
			+ " _Friend(ArtistID='bar',IsActiveEntity=false)/ArtistID"
			+ ", invalid segment: _Friend(ArtistID='bar',IsActiveEntity=false)");
		this.oLogMock.expects("error").withArgs("Failed to drill-down into"
			+ " _Publication('foo')/PublicationID, invalid segment: _Publication('foo')");
		this.expectRequest("Artists(ArtistID=\'ABC\',IsActiveEntity=false)"
				+ "?$expand=_Friend,_Publication", {
				ArtistID : "ABC",
				IsActiveEntity : false,
				_Friend : [{
					ArtistID : "n/a",
					IsActiveEntity : true
				}],
				_Publication : []
			})
			.expectChange("id", "ABC");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Refresh a single kept context that is in the collection of a list binding w/o any $filter or
	// $search. Only a query for the existence of the entity is sent. No additional query to check
	// if the entity is still in the collection is sent.
	// JIRA: CPOUI5ODATAV4-366
	//
	// See that a failed request causes Context#refresh to reject.
	// JIRA: CPOUI5ODATAV4-980
	//
	// Request the messages for the kept-alive context
	// JIRA: CPOUI5ODATAV4-981
	QUnit.test("CPOUI5ODATAV4-366: kept-context in collection only one request", function (assert) {
		var oContext,
			oInput,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Input id="grossAmount" value="{GrossAmount}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=0&$top=100", {
				value : [
					{GrossAmount : "123", SalesOrderID : "1"},
					// The following items must not be refreshed
					{GrossAmount : "99", SalesOrderID : "2"}
				]
			})
			.expectChange("grossAmount", ["123.00", "99.00"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=Messages", {
					Messages : [{
						message : "Just a message",
						numericSeverity : 2,
						target : "GrossAmount"
					}]
				})
				.expectMessages([{
					message : "Just a message",
					target : "/SalesOrderList('1')/GrossAmount",
					type : "Information"
				}]);

			oContext = that.oView.byId("table").getItems()[0].getBindingContext();
			oContext.setKeepAlive(true, null, true);

			return that.waitForChanges(assert);
		}).then(function () {
			oInput = that.oView.byId("table").getItems()[0].getCells()[0];
			return that.checkValueState(assert, oInput, "Information", "Just a message");
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=GrossAmount,Messages,SalesOrderID"
					+ "&$filter=SalesOrderID eq '1'", {
					value : [{GrossAmount : "190", Messages : [], SalesOrderID : "1"}]
				})
				.expectChange("grossAmount", ["190.00"])
				.expectMessages([]);

			// code under test
			oContext.refresh(undefined, true);

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, oInput, "None", "");
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=GrossAmount,Messages,SalesOrderID",
					createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withArgs("Failed to refresh entity: /SalesOrderList('1')[0]");

			return Promise.all([
				// code under test
				oContext.requestRefresh().then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, "Request intentionally failed");
				}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Context binding with nested list binding having another nested list binding with
	// own cache. A new entry in the outer list binding is created. There are no requests for the
	// inner list binding as long the new entity is not persisted. Once the entity is persisted, the
	// data for the inner list binding is fetched.
	// BCP: 2070459149
	//
	// Also test w/o autoExpandSelect and see that no context can be created in the inner list
	// JIRA: CPOUI5ODATAV4-1973
[false, true].forEach(function (bAutoExpandSelect) {
	var sTitle = "BCP: 2070459149: transient context + nested ODLB w/ own cache, autoExpandSelect="
			+ bAutoExpandSelect;

	QUnit.test(sTitle, function (assert) {
		var oContext,
			oModel = this.createTeaBusiModel(
				{autoExpandSelect : bAutoExpandSelect, updateGroupId : "update"}),
			sParameters = bAutoExpandSelect
				? ""
				: ", parameters : {$select : 'Team_Id',"
					+ " $expand : {TEAM_2_EMPLOYEES : {$select : 'ID,Name'}}}",
			sView = '\
<FlexBox binding="{path : \'/TEAMS(\\\'1\\\')\'' + sParameters + '}">\
	<Text id="id" text="{Team_Id}"/>\
	<Table id="employees" items="{TEAM_2_EMPLOYEES}">\
		<Text id="name" text="{Name}"/>\
		<List items="{path : \'EMPLOYEE_2_EQUIPMENTS\', parameters : {$$ownRequest : true}, \
			templateShareable : false}">\
			<CustomListItem>\
				<Text id="category" text="{Category}"/>\
			</CustomListItem>\
		</List>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('1')?$select=Team_Id&$expand=TEAM_2_EMPLOYEES($select=ID,Name)", {
				Team_Id : "1",
				TEAM_2_EMPLOYEES : []
			})
			.expectChange("id", "1")
			.expectChange("name", [])
			.expectChange("category", []);

		return this.createView(assert, sView, oModel).then(function () {
			var oEmployeesList = that.oView.byId("employees");

			that.expectChange("name", ["John Doe"]);

			// code under test
			oContext = oEmployeesList.getBinding("items").create({Name : "John Doe"}, true);

			if (!bAutoExpandSelect) {
				assert.throws(function () {
					// code under test
					oEmployeesList.getItems()[0].getCells()[1].getBinding("items").create();
				}, new Error("Deep create is only supported with autoExpandSelect"));
			}

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "TEAMS('1')/TEAM_2_EMPLOYEES",
					payload : {Name : "John Doe"}
				}, {ID : "2", Name : "John Doe"})
				.expectRequest("TEAMS('1')/TEAM_2_EMPLOYEES('2')/EMPLOYEE_2_EQUIPMENTS?"
					+ (bAutoExpandSelect ? "$select=Category,ID&" : "") + "$skip=0&$top=100", {
					value : [{Category : "Electronics", ID : "1"}]
				})
				.expectChange("category", ["Electronics"]);

			return Promise.all([
				that.oModel.submitBatch("update"),
				oContext.created(),
				that.waitForChanges(assert)
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Context binding with nested list binding having a nested context binding with own
	// cache. A new entry in the list binding is created. There are no requests for the inner
	// context binding as long the new entity is not persisted. Once the entity is persisted, the
	// data for the inner context binding is fetched.
	// BCP: 2070459149
	QUnit.test("BCP: 2070459149: transient context + nested ODCB w/ own cache", function (assert) {
		var oContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<FlexBox binding="{/TEAMS(\'1\')}">\
	<Table id="employees" items="{TEAM_2_EMPLOYEES}">\
		<Text id="name" text="{Name}"/>\
		<FlexBox binding="{path : \'EMPLOYEE_2_MANAGER\', parameters : {$$ownRequest : true}}">\
			<Text id="teamId" text="{TEAM_ID}"/>\
		</FlexBox>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('1')?$select=Team_Id&$expand=TEAM_2_EMPLOYEES($select=ID,Name)", {
				Team_Id : "1",
				TEAM_2_EMPLOYEES : []
			})
			.expectChange("name", [])
			.expectChange("teamId", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("name", ["John Doe"])
				.expectChange("teamId", [""]);

			// code under test
			oContext = that.oView.byId("employees").getBinding("items")
				.create({Name : "John Doe"}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "TEAMS('1')/TEAM_2_EMPLOYEES",
					payload : {Name : "John Doe"}
				}, {ID : "2", Name : "John Doe"})
				.expectRequest("TEAMS('1')/TEAM_2_EMPLOYEES('2')/EMPLOYEE_2_MANAGER"
					+ "?$select=ID,TEAM_ID", {ID : "23", TEAM_ID : "1"})
				.expectChange("teamId", ["1"]);

			return Promise.all([
				that.oModel.submitBatch("update"),
				oContext.created(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A list binding with one kept-alive context outside the collection and a second one
	// inside the collection. Refresh the list binding and see that the kept-alive context
	// outside the collection is also refreshed. Mark a third context as kept-alive context and
	// refresh again. One of the kept-alive entities does not exist anymore, in that case the
	// fnOnBeforeDestroy callback is called.
	// Afterwards request side effects for the gross amount property and check that it is also
	// requested for the kept-alive entities that are not in the collection.
	// JIRA: CPOUI5ODATAV4-488
	// JIRA: CPOUI5ODATAV4-579
	// JIRA: CPOUI5ODATAV4-411
	//
	// See that the list refresh does not include late properties (JIRA: CPOUI5ODATAV4-544).
	//
	// In the end, request side effects for an empty list to see that kept-alive entities are still
	// requested.
	//
	// Do likewise for selection which implicitly keeps alive (JIRA: CPOUI5ODATAV4-2053).
	// Select via setSelected and setting the client-side annotation (JIRA: CPOUI5ODATAV4-1944).
	// Filter removes selection (JIRA: CPOUI5ODATAV4-2203).
[false, true].forEach(function (bImplicitly) {
	[false, true].forEach(function (bUseAnnotation) {
		var sTitle = "CPOUI5ODATAV4-488: Refresh w/" + (bImplicitly ? " implicitly" : "")
				+ " kept-alive context, selection via annotation=" + bUseAnnotation;

	QUnit.test(sTitle, function (assert) {
		var oKeptContext,
			oKeptContext2,
			oListBinding,
			fnOnBeforeDestroy = sinon.spy(),
			oTable,
			that = this;

		return this.createKeepAliveScenario(assert, true).then(function (oKeptContext0) {
			oKeptContext = oKeptContext0;
			oTable = that.oView.byId("listReport");
			oListBinding = oKeptContext.getBinding();

			// 2nd kept-alive context (CPOUI5ODATAV4-579)
			oKeptContext2 = oTable.getItems()[0].getBindingContext();
			if (bImplicitly) {
				setSelected(bUseAnnotation, oKeptContext, true);
				oKeptContext.setKeepAlive(false);
				setSelected(bUseAnnotation, oKeptContext2, true);
				checkSelected(assert, oKeptContext, true);
				checkSelected(assert, oKeptContext2, true);
			} else {
				oKeptContext2.setKeepAlive(true);
			}

			that.expectRequest({
					batchNo : 4,
					url : "SalesOrderList"
						+ "?$filter=SalesOrderID eq '1' or SalesOrderID eq '2'"
						+ "&$select=GrossAmount,Note,SalesOrderID&$top=2"
				}, {
					value : [{
						GrossAmount : "50",
						Note : "After refresh",
						SalesOrderID : "1"
					}, {
						GrossAmount : "149.1",
						Note : "Note 2",
						SalesOrderID : "2"
					}]
				})
				.expectChange("objectPageGrossAmount", "50.00")
				.expectChange("objectPageNote", "After refresh")
				.expectRequest({
					batchNo : 4,
					url : "SalesOrderList?$count=true&$filter=GrossAmount gt 123"
						+ "&$select=GrossAmount,SalesOrderID&$skip=0&$top=2"
				}, {
					"@odata.count" : "27",
					value : [{
						GrossAmount : "149.1",
						SalesOrderID : "2"
					}, {
						GrossAmount : "789.1",
						SalesOrderID : "3"
					}]
				})
				.expectChange("grossAmount", ["149.10", "789.10"])
				.expectRequest({
					batchNo : 4,
					url : "SalesOrderList('1')/SO_2_SOITEM"
						+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100"
				}, {
					value : [{
						ItemPosition : "0020",
						SalesOrderID : "1"
					}]
				})
				.expectChange("itemPosition", ["0020"]);

			oListBinding.refresh();

			return that.waitForChanges(assert, "Step 1: Refresh the list (w/ two kept contexts)");
		}).then(function () {
			var oKeptContext3 = oTable.getItems()[1].getBindingContext();

			if (bImplicitly) {
				setSelected(bUseAnnotation, oKeptContext3, true);
				checkSelected(assert, oKeptContext3, true);
			} else {
				// 3rd kept-alive ontext (CPOUI5ODATAV4-579)
				oKeptContext3.setKeepAlive(true, fnOnBeforeDestroy);
			}

			that.expectRequest({
					batchNo : 5,
					url : "SalesOrderList?$filter=SalesOrderID eq '1' or SalesOrderID eq '2'"
						+ " or SalesOrderID eq '3'&$select=GrossAmount,Note,SalesOrderID&$top=3"
				}, {
					value : [{
						GrossAmount : "50.2",
						Note : "After refresh 2",
						SalesOrderID : "1"
					}, {
						GrossAmount : "149.2",
						Note : "Note 2",
						SalesOrderID : "2"
					}] // Note: SalesOrderID : "3" is missing here!
				})
				.expectChange("objectPageGrossAmount", "50.20")
				.expectChange("objectPageNote", "After refresh 2")
				.expectRequest({
					batchNo : 5,
					url : "SalesOrderList?$count=true&$filter=GrossAmount gt 123"
						+ "&$select=GrossAmount,SalesOrderID&$skip=0&$top=2"
				}, {
					"@odata.count" : "26",
					value : [{
						GrossAmount : "149.2",
						SalesOrderID : "2"
					}, {
						GrossAmount : "789.2",
						SalesOrderID : "4"
					}]
				})
				.expectChange("id", [, "4"])
				.expectChange("grossAmount", ["149.20", "789.20"])
				.expectRequest({
					batchNo : 5,
					url : "SalesOrderList('1')/SO_2_SOITEM"
						+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100"
				}, {
					value : [{
						ItemPosition : "0030",
						SalesOrderID : "1"
					}]
				})
				.expectChange("itemPosition", ["0030"]);

			oListBinding.refresh();

			return that.waitForChanges(assert, "Step 2: Refresh the list (w/ three kept contexts)");
		}).then(function () {
			if (bImplicitly) {
				sinon.assert.notCalled(fnOnBeforeDestroy);
			} else {
				sinon.assert.calledOnceWithExactly(fnOnBeforeDestroy);
			}

			that.expectRequest("SalesOrderList?$filter=SalesOrderID eq '2' or SalesOrderID eq '4'"
					+ " or SalesOrderID eq '1'&$select=GrossAmount,SalesOrderID&$top=3", {
					value : [{
						GrossAmount : "149.3",
						SalesOrderID : "2"
					}, {
						GrossAmount : "789.3",
						SalesOrderID : "4"
					}, {
						GrossAmount : "50.3",
						SalesOrderID : "1"
					}]
				})
				.expectChange("grossAmount", ["149.30", "789.30"])
				.expectChange("objectPageGrossAmount", "50.30");

			return Promise.all([
				// code under test
				oListBinding.getHeaderContext().requestSideEffects(["GrossAmount"]),
				that.waitForChanges(assert, "Step 3: request side effects with kept contexts")
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList?$filter=SalesOrderID eq '2' or SalesOrderID eq '4'"
					+ "&$select=GrossAmount,SalesOrderID&$top=2", {
					value : [{
						GrossAmount : "149.4",
						SalesOrderID : "2"
					}, {
						GrossAmount : "789.4",
						SalesOrderID : "4"
					}]
				})
				.expectChange("grossAmount", ["149.40", "789.40"])
				.expectChange("objectPageGrossAmount", null)
				.expectChange("objectPageNote", null);

			that.oView.byId("objectPage").setBindingContext(null);
			oKeptContext.setKeepAlive(false);
			setSelected(bUseAnnotation, oKeptContext, false);
			// in case of !bImplicitly and !bUseAnnotation oKeptContext was never selected.
			// the annotation stays undefined if it is set (repeatedly) to false then.
			checkSelected(assert, oKeptContext, bImplicitly || bUseAnnotation ? false : undefined);

			return Promise.all([
				// code under test
				oListBinding.getHeaderContext().requestSideEffects(["GrossAmount"]),
				that.waitForChanges(assert,
					"Step 4: request side effects with kept contexts not yet destroyed")
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList?$count=true&$filter=GrossAmount lt 0"
					+ "&$select=GrossAmount,SalesOrderID&$skip=0&$top=2", {
					"@odata.count" : "0",
					value : []
				});

			oListBinding.filter(new Filter("GrossAmount", FilterOperator.LT, 0));

			return that.waitForChanges(assert, "filter to make list empty");
		}).then(function () {
			if (bImplicitly) { // Filter removes selection (JIRA: CPOUI5ODATAV4-2203)
				return;
			}

			that.expectRequest("SalesOrderList?$filter=SalesOrderID eq '2'"
					+ "&$select=GrossAmount,SalesOrderID", {
					value : [{
						GrossAmount : "149.5",
						SalesOrderID : "2"
					}]
				});

			return Promise.all([
				// code under test
				oListBinding.getHeaderContext().requestSideEffects(["GrossAmount"]),
				that.waitForChanges(assert, "request side effects for kept contexts only")
			]).then(function () {
				assert.strictEqual(oKeptContext2.getProperty("GrossAmount"), "149.5");
			});
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: Hidden absolute context binding provides binding context for object page, therein a
	// list binding for items, and on the sub-object of an item, another list binding with even more
	// details. Make sure that those list bindings do not use old cached data in case the hidden
	// root binding is new.
	//
	// -Do the same with a "binding context" as root.- We do not support this!
	//
	// JIRA: CPOUI5ODATAV4-766
[function (oModel) {
	var oHiddenBinding = oModel.bindContext("/TEAMS('42')");

	return oHiddenBinding.getBoundContext();
// }, function (oModel) {
//     return oModel.createBindingContext("/TEAMS('42')");
}].forEach(function (fnCreateContext, i) {
	QUnit.test("CPOUI5ODATAV4-766: re-read dependent if parent is new, #" + i, function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oObjectPage,
			oOldRoot,
			oSubObjectPage,
			sView = '\
<FlexBox id="objectPage" binding="{}">\
	<Text id="name" text="{Name}"/>\
	<Table id="employees"\
			items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$$ownRequest : true}}">\
		<Text id="age" text="{AGE}"/>\
	</Table>\
</FlexBox>\
<FlexBox id="subObjectPage" binding="{}">\
	<Table id="equipments"\
			items="{path : \'EMPLOYEE_2_EQUIPMENTS\', parameters : {$$ownRequest : true}}">\
		<Text id="category" text="{Category}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("name")
			.expectChange("age", [])
			.expectChange("category", []);

		return this.createView(assert, sView, oModel).then(function () {
			oObjectPage = that.oView.byId("objectPage");
			oOldRoot = fnCreateContext(oModel);

			that.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES?$select=AGE,ID&$skip=0&$top=100", {
					value : [{
						AGE : 31,
						ID : "1"
					}, {
						AGE : 32,
						ID : "2"
					}]
				})
				.expectRequest("TEAMS('42')?$select=Name,Team_Id", {
					Name : "Team 42",
					Team_Id : "42"
				})
				.expectChange("name", "Team 42")
				.expectChange("age", ["31", "32"]);

			// code under test
			oObjectPage.setBindingContext(oOldRoot);

			return that.waitForChanges(assert, "Show team");
		}).then(function () {
			var oEmployeesBinding = that.oView.byId("employees").getBinding("items");

			oSubObjectPage = that.oView.byId("subObjectPage");

			that.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES('1')/EMPLOYEE_2_EQUIPMENTS"
					+ "?$select=Category,ID&$skip=0&$top=100", {
					value : [{
						Category : "C1.1",
						ID : "1.1"
					}, {
						Category : "C1.2",
						ID : "1.2"
					}]
				})
				.expectChange("category", ["C1.1", "C1.2"]);

			// code under test
			oSubObjectPage.setBindingContext(oEmployeesBinding.getCurrentContexts()[0]);

			return that.waitForChanges(assert, "Show employee");
		}).then(function () {
			var oNewRoot = fnCreateContext(oModel);

			that.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES?$select=AGE,ID&$skip=0&$top=100", {
					value : [{
						AGE : 33,
						ID : "3"
					}, {
						AGE : 34,
						ID : "4"
					}]
				})
				.expectRequest("TEAMS('42')?$select=Name,Team_Id", {
					Name : "New Team 42",
					Team_Id : "42"
				})
				.expectChange("name", "New Team 42")
				.expectChange("age", ["33", "34"]);

			oSubObjectPage.setBindingContext(null);
			// code under test
			oObjectPage.setBindingContext(oNewRoot);

			return that.waitForChanges(assert, "Show team anew");
		}).then(function () {
			var oEmployeesBinding = that.oView.byId("employees").getBinding("items");

			that.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES('3')/EMPLOYEE_2_EQUIPMENTS"
					+ "?$select=Category,ID&$skip=0&$top=100", {
					value : [{
						Category : "C3.1",
						ID : "3.1"
					}, {
						Category : "C3.2",
						ID : "3.2"
					}]
				})
				.expectChange("category", ["C3.1", "C3.2"]);

			// code under test
			oSubObjectPage.setBindingContext(oEmployeesBinding.getCurrentContexts()[0]);

			return that.waitForChanges(assert, "Show employee anew");
		}).then(function () {
			// Note: while it might be unrealistic to go back to the old hidden binding, there is no
			// reason to read new data in this case
			that.expectChange("name", "Team 42") // Note: old data stored in oHiddenBinding's cache
				.expectChange("age", ["33", "34"]); // list binding fires "refresh" etc.

			oSubObjectPage.setBindingContext(null);
			// code under test
			oObjectPage.setBindingContext(oOldRoot);

			return that.waitForChanges(assert, "Show old team again");
		}).then(function () {
			var oEmployeesBinding = that.oView.byId("employees").getBinding("items");

			that.expectChange("category", ["C3.1", "C3.2"]);

			// code under test
			oSubObjectPage.setBindingContext(oEmployeesBinding.getCurrentContexts()[0]);

			return that.waitForChanges(assert, "Show employee again");
		});
	});
});

	//*********************************************************************************************
	// Scenario: Absolute list binding provides binding context for object page, therein a list
	// binding for items. Make sure the dependent list binding does not use old cached data in case
	// the root binding is new.
	//
	// JIRA: CPOUI5ODATAV4-766
	QUnit.test("CPOUI5ODATAV4-766: re-read dependent if parent list is new", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			oObjectPage,
			oOldRoot,
			sView = '\
<FlexBox id="objectPage" binding="{}">\
	<Text id="name" text="{Name}"/>\
	<Table id="employees"\
			items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$$ownRequest : true}}">\
		<Text id="age" text="{AGE}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("name")
			.expectChange("age", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("TEAMS?$skip=0&$top=1", {
					value : [{
						Name : "Team 42",
						Team_Id : "42"
					}]
				});

			return oModel.bindList("/TEAMS").requestContexts(0, 1);
		}).then(function (aContexts) {
			oObjectPage = that.oView.byId("objectPage");
			oOldRoot = aContexts[0];

			that.expectChange("name", "Team 42")
				.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES?$select=AGE,ID&$skip=0&$top=100", {
					value : [{
						AGE : 31,
						ID : "1"
					}, {
						AGE : 32,
						ID : "2"
					}]
				})
				.expectChange("age", ["31", "32"]);

			// code under test
			oObjectPage.setBindingContext(oOldRoot);

			return that.waitForChanges(assert, "Show team");
		}).then(function () {
			that.expectRequest("TEAMS?$skip=0&$top=1", {
					value : [{
						Name : "New Team 42",
						Team_Id : "42"
					}]
				});

			return oModel.bindList("/TEAMS").requestContexts(0, 1);
		}).then(function (aContexts) {
			that.expectChange("name", "New Team 42")
				.expectRequest("TEAMS('42')/TEAM_2_EMPLOYEES?$select=AGE,ID&$skip=0&$top=100", {
					value : [{
						AGE : 33,
						ID : "3"
					}, {
						AGE : 34,
						ID : "4"
					}]
				})
				.expectChange("age", ["33", "34"]);

			// code under test
			oObjectPage.setBindingContext(aContexts[0]);

			return that.waitForChanges(assert, "Show team anew");
		}).then(function () {
			// Note: while it might be unrealistic to go back to the old hidden binding, there is no
			// reason to read new data in this case
			that.expectChange("name", "Team 42") // Note: old data stored in hidden binding's cache
				.expectChange("age", ["33", "34"]); // list binding fires "refresh" etc.

			// code under test
			oObjectPage.setBindingContext(oOldRoot);

			return that.waitForChanges(assert, "Show old team again");
		});
	});

	//*********************************************************************************************
	// Scenario:
	// Refresh list with a kept-alive context that is part of the collection; after refresh the
	// entity is deleted.
	// JIRA: CPOUI5ODATAV4-578
	//
	// See that the list refresh does not include late properties.
	// JIRA: CPOUI5ODATAV4-544
	QUnit.test("CPOUI5ODATAV4-578: kept-alive entity of object page deleted", function (assert) {
		var oError = createErrorInsideBatch({message : "Not found"}),
			fnOnBeforeDestroy = sinon.spy(),
			that = this;

		return this.createKeepAliveScenario(assert, false, fnOnBeforeDestroy)
			.then(function (oKeptContext) {
				that.oLogMock.expects("error")
					.withExactArgs("Failed to get contexts for "
						+ sSalesOrderService + "SalesOrderList('1')/SO_2_SOITEM"
						+ " with start index 0 and length 100",
						sinon.match("Not found"), sODLB);

				that.expectRequest({
						batchNo : 3,
						url : "SalesOrderList?$filter=SalesOrderID eq '1'"
							+ "&$select=GrossAmount,Note,SalesOrderID"
					}, {
						value : []
					})
					.expectChange("objectPageGrossAmount", null)
					.expectChange("objectPageNote", null)
					.expectRequest({
						batchNo : 3,
						url : "SalesOrderList?$count=true&$filter=GrossAmount le 150"
							+ "&$select=GrossAmount,SalesOrderID&$skip=0&$top=2"
					}, {
						"@odata.count" : "41",
						value : [{
							GrossAmount : 149.1,
							SalesOrderID : "2"
						}, {
							GrossAmount : 99,
							SalesOrderID : "3"
						}]
					})
					.expectChange("id", [, "3"])
					.expectChange("grossAmount", ["149.10", "99.00"])
					.expectRequest({
						batchNo : 3,
						url : "SalesOrderList('1')/SO_2_SOITEM"
							+ "?$select=ItemPosition,SalesOrderID&$skip=0&$top=100"
					}, oError)
					.expectMessages([{
						code : "CODE",
						message : "Not found",
						persistent : true,
						technical : true,
						type : "Error"
					}]);

				return Promise.all([
					// code under test
					oKeptContext.getBinding().requestRefresh()
						.then(mustFail(assert), function (oError0) {
							assert.strictEqual(oError0.message, "Not found");
						}),
					that.waitForChanges(assert, "(3) refresh the list")
				]);
		}).then(function () {
			sinon.assert.calledOnceWithExactly(fnOnBeforeDestroy);
		});
	});

	//*********************************************************************************************
	// Scenario:
	// - Read an artist as main object with publications and messages
	// - Keep the first publication alive and show it in the subobject page
	// - Filter the publications so that the kept-alive one drops out
	// - See that its message is still active
	QUnit.test("CPOUI5ODATAV4-1873: isKeepAlive, filter & messages", function (assert) {
		var oBinding,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{path : \'/Artists(ArtistID=\\\'A1\\\',IsActiveEntity=true)\',\
		parameters : {$select : \'Messages\'}}">\
	<Text id="id" text="{ArtistID}"/>\
	<Table id="items" items="{path : \'_Publication\', parameters : {$$ownRequest : true}}">\
		<Text id="listPrice" text="{Price}"/>\
	</Table>\
</FlexBox>\
<FlexBox id="subobjectPage">\
	<Input id="price" value="{Price}"/>\
</FlexBox>',
			that = this;

			this.expectRequest("Artists(ArtistID='A1',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Messages", {
					ArtistID : "1",
					IsActiveEntity : true,
					Messages : [{
						message : "Just A Message",
						numericSeverity : 1,
						target : "_Publication('P1')/Price"
					}]
				})
				.expectRequest("Artists(ArtistID='A1',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$skip=0&$top=100", {
					value : [
						{PublicationID : "P1", Price : "7.99"},
						{PublicationID : "P2", Price : "12.99"}
					]
				})
				.expectChange("id", "1")
				.expectChange("listPrice", ["7.99", "12.99"])
				.expectChange("price")
				.expectMessages([{
					message : "Just A Message",
					target :
						"/Artists(ArtistID='A1',IsActiveEntity=true)/_Publication('P1')/Price",
					type : "Success"
				}]);

		return this.createView(assert, sView, oModel).then(function () {
			var oContext;

			oBinding = that.oView.byId("items").getBinding("items");
			oContext = oBinding.getCurrentContexts()[0];
			oContext.setKeepAlive(true);

			that.expectChange("price", "7.99");

			that.oView.byId("subobjectPage").setBindingContext(oContext);

			return that.waitForChanges(assert, "setKeepAlive & subobject page");
		}).then(function () {
			return that.checkValueState(assert, "price", "Success", "Just A Message");
		}).then(function () {
			that.expectRequest("Artists(ArtistID='A1',IsActiveEntity=true)/_Publication"
					+ "?$select=Price,PublicationID&$filter=Price gt 10.00&$skip=0&$top=100", {
					value : [
						{PublicationID : "P2", Price : "12.99"}
					]
				})
				.expectChange("listPrice", ["12.99"]);

			// code under test
			oBinding.filter(new Filter("Price", FilterOperator.GT, "10.00"));

			return that.waitForChanges(assert, "filter");
		}).then(function () {
			return that.checkValueState(assert, "price", "Success", "Just A Message");
		});
	});

	//*********************************************************************************************
	// Scenario: Flexible Column Layout, ODataModel#getKeepAliveContext
	// A list report and an object page are set up in different ways such that the object page shows
	// an active entity visible in the list report, including a manually requested late property for
	// the object-page. The result must not be influenced by the different scenarios.
	// Scenarios:
	// (1) Read the entities in the list and afterwards get an existing kept-alive context for the
	//     object page from it.
	//     Context#setKeepAlive (called indirectly) must request messages (JIRA: CPOUI5ODATAV4-981).
	//     JIRA: CPOUI5ODATAV4-1405
	// (2) Initially get the kept-alive context for the object page from the then-empty list and see
	//     that the page is set up using one $batch.
	//     JIRA: CPOUI5ODATAV4-1406
	// (3) Get the kept-alive context for the object page while the list is still unresolved, then
	//     resolve the list and perform the tests.
	//     JIRA: CPOUI5ODATAV4-1407
	// (4) Get the kept-alive context for the object page and perform the tests while the list is
	//     still unresolved. The object page must be useable nevertheless. In the end resolve the
	//     list and see that it is in sync with the object page.
	//     JIRA: CPOUI5ODATAV4-1407
	//
	//     Reset the keep-alive status and request the active entity again in this scenario.
	//     BCP: 441477 / 2023 (002075129400004414772023)
	// Steps:
	// (1) and (2) initialization in different order
	// (3) edit action
	// (4) setBindingContext for the draft
	// (5) change a property and request side effects
	// (6) cancel the draft
	// (7) resolve list if not done in (1) or (2)
	// The properties Name and defaultChannel are in both bindings and have to be kept in sync,
	// lastUsedChannel is only in the object page and must be requested as late property,
	// HasDraftEntity is the manually requested late property, sendsAutographs is only in the list
	// report and must be inherited by the action.
	// Check that for all GET requests including late property requests the dataRequested and
	// dataReceived events are fired at the model (JIRA: CPOUI5ODATAV4-1671)
// list, page: the step number in which they are initialized;
// patchNo: the batchNo of the $batch with the PATCH and the side effect request
[
	{list : 1, page : 2, patchNo : 5, title : "(1) first list, then object page"},
	{list : 1, page : 1, patchNo : 4, title : "(2) list and object page in the same batch"},
	{list : 2, page : 1, patchNo : 5, title : "(3) first object page, then list, then tests"},
	{list : 7, page : 1, patchNo : 4, title : "(4) first object page, then tests, then list"}
].forEach(function (oFixture) {
	QUnit.test("getKeepAliveContext: " + oFixture.title, function (assert) {
		var oActiveContext,
			iDataReceivedCount = 0,
			iDataRequestedCount = 0,
			oDraftContext,
			iExpectedEventCount = 0,
			bListResolved = false,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oObjectPage,
			sView = '\
<Table id="listReport"\ items="{path : \'Artists\', \
		parameters : {$$getKeepAliveContext : true, $$patchWithoutSideEffects : true,\
			$$ownRequest : true}}">\
	<Text id="listName" text="{Name}"/>\
	<Text id="listChannel" text="{defaultChannel}"/>\
	<Text id="sendsAutographs" text="{sendsAutographs}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="name" text="{Name}"/>\
	<Input id="defaultChannel" value="{defaultChannel}"/>\
	<Text id="lastUsedChannel" text="{lastUsedChannel}"/>\
	<Table items="{path : \'_Publication\', parameters : {$$ownRequest : true}}">\
		<Text id="publication" text="{PublicationID}"/>\
	</Table>\
</FlexBox>',
			that = this;

		function checkDataEvents() {
			assert.strictEqual(iDataRequestedCount, iExpectedEventCount, "dataRequested");
			assert.strictEqual(iDataReceivedCount, iExpectedEventCount, "dataReceived");
			iDataRequestedCount = iDataReceivedCount = iExpectedEventCount = 0;
		}

		function expectDataEvents(iCount) {
			iExpectedEventCount += iCount;
		}

		/*
		 * Resolves the list report and expects the corresponding request and changes.
		 * @param {number} iBatchNo - The number of the $batch for the request
		 */
		function initializeList(iBatchNo) {
			that.expectRequest({
					batchNo : iBatchNo,
					url : "Artists"
						+ "?$select=ArtistID,IsActiveEntity,Name,defaultChannel,sendsAutographs"
						+ "&$skip=0&$top=100"
				}, {
					value : [{
						"@odata.etag" : "etag.active1",
						ArtistID : "A1",
						IsActiveEntity : true,
						Name : "Artist 1",
						defaultChannel : "Channel 1",
						sendsAutographs : true
					}]
				})
				.expectChange("listName", ["Artist 1"])
				.expectChange("listChannel", ["Channel 1"])
				.expectChange("sendsAutographs", ["Yes"]);
			expectDataEvents(1);

			that.oView.byId("listReport").setBindingContext(oModel.createBindingContext("/"));
			bListResolved = true;
		}

		/*
		 * Gets a context for the active entity, binds the object page to it and expects the
		 * corresponding requests and changes.
		 * @param {number} iBatchNo - The number of the $batch for the entity request
		 * @param {boolean} bLate - Whether it is late, i.e. the list data is already there
		 * @returns {Promise} - The promise of the requestProperty for "HasDraftEntity"
		 */
		function initializeObjectPage(iBatchNo, bLate) {
			var oResponse = {
					"@odata.etag" : "etag.active1",
					HasDraftEntity : false,
					Messages : [{
						message : "Active message",
						numericSeverity : 2,
						target : "defaultChannel"
					}],
					lastUsedChannel : "Channel 2"
				};

			if (bLate) {
				that.expectRequest("Artists(ArtistID='A1',IsActiveEntity=true)"
						+ "?$select=HasDraftEntity,Messages,lastUsedChannel",
						oResponse);
			} else { // if not late, the list's properties are also part of the request
				that.expectRequest({
						batchNo : iBatchNo,
						url : "Artists(ArtistID='A1',IsActiveEntity=true)"
							+ "?$select=ArtistID,HasDraftEntity,IsActiveEntity,Messages,Name,"
							+ "defaultChannel,lastUsedChannel"
					}, Object.assign(oResponse, {
						ArtistID : "A1",
						IsActiveEntity : true,
						Name : "Artist 1",
						defaultChannel : "Channel 1"
					}));
			}
			that.expectRequest("Artists(ArtistID='A1',IsActiveEntity=true)/_Publication"
					+ "?$select=PublicationID&$skip=0&$top=100",
					{value : [{PublicationID : "P1"}]}
				)
				.expectChange("name", "Artist 1")
				.expectChange("defaultChannel", "Channel 1")
				.expectChange("lastUsedChannel", "Channel 2")
				.expectChange("publication", ["P1"])
				.expectMessages([{
					message : "Active message",
					target : "/Artists(ArtistID='A1',IsActiveEntity=true)/defaultChannel",
					type : "Information"
				}]);
			expectDataEvents(2);

			oActiveContext = that.oModel.getKeepAliveContext(
				"/Artists(ArtistID='A1',IsActiveEntity=true)", true,
				{$$patchWithoutSideEffects : true});
			oObjectPage.setBindingContext(oActiveContext);

			return oActiveContext.requestProperty("HasDraftEntity");
		}

		this.expectChange("listName", [])
			.expectChange("listChannel", [])
			.expectChange("sendsAutographs", [])
			.expectChange("name")
			.expectChange("defaultChannel")
			.expectChange("lastUsedChannel")
			.expectChange("publication", []);

		oModel.attachDataRequested(function () {
			iDataRequestedCount += 1;
		}).attachDataReceived(function () {
			iDataReceivedCount += 1;
		});

		return this.createView(assert, sView, oModel).then(function () {
			oObjectPage = that.oView.byId("objectPage");

			if (oFixture.list === 1) {
				initializeList(1);
			}
			return Promise.all([
				oFixture.page === 1 && initializeObjectPage(1, false),
				that.waitForChanges(assert, "(1) initialization")
			]);
		}).then(function () {
			checkDataEvents();
			if (oFixture.list === 2) {
				initializeList(2);
			}
			return Promise.all([
				oFixture.page === 2 && initializeObjectPage(2, true),
				that.waitForChanges(assert, "(2) initialization")
			]);
		}).then(function () {
			var oActionBinding = that.oModel.bindContext("special.cases.EditAction(...)",
					oObjectPage.getBindingContext(), {$$inheritExpandSelect : true}),
				oResponse = {
					"@odata.etag" : "etag.draft1",
					ArtistID : "A1",
					HasDraftEntity : false,
					IsActiveEntity : false,
					Messages : [{
						message : "Draft message",
						numericSeverity : 2,
						target : "defaultChannel"
					}],
					Name : "Artist 1",
					defaultChannel : "Channel 1",
					lastUsedChannel : "Channel 2"
				},
				sUrl = "Artists(ArtistID='A1',IsActiveEntity=true)/special.cases.EditAction"
					+ "?$select=ArtistID,HasDraftEntity,IsActiveEntity,Messages,Name,"
					+ "defaultChannel,lastUsedChannel";

			checkDataEvents();
			if (bListResolved) {
				sUrl += ",sendsAutographs";
				oResponse.sendsAutographs = true;
			}
			that.expectRequest({
					method : "POST",
					url : sUrl,
					headers : {"If-Match" : "etag.active1"},
					payload : {}
				}, oResponse)
				.expectMessages([{
					message : "Active message",
					target : "/Artists(ArtistID='A1',IsActiveEntity=true)/defaultChannel",
					type : "Information"
				}, {
					message : "Draft message",
					target : "/Artists(ArtistID='A1',IsActiveEntity=false)/defaultChannel",
					type : "Information"
				}]);

			return Promise.all([
				oActionBinding.invoke(undefined, undefined, undefined, /*bReplaceWithRVC*/true),
				that.waitForChanges(assert, "(3) edit action")
			]);
		}).then(function (aResults) {
			that.expectRequest("Artists(ArtistID='A1',IsActiveEntity=false)/_Publication"
					+ "?$select=PublicationID&$skip=0&$top=100",
					{value : [{PublicationID : "P1"}]}
				)
				.expectChange("publication", ["P1"]);
			expectDataEvents(1);

			oDraftContext = aResults[0];
			oObjectPage.setBindingContext(oDraftContext);

			return that.waitForChanges(assert, "(4) setBindingContext");
		}).then(function () {
			checkDataEvents();
			return that.checkValueState(assert, "defaultChannel", "Information", "Draft message");
		}).then(function () {
			that.expectChange("defaultChannel", "Channel 3")
				.expectRequest({
					batchNo : oFixture.patchNo,
					headers : {
						"If-Match" : "etag.draft1",
						Prefer : "return=minimal"
					},
					method : "PATCH",
					payload : {
						defaultChannel : "Channel 3"
					},
					url : "Artists(ArtistID='A1',IsActiveEntity=false)"
				}) // 204 No Content - no need to update the ETag when requesting side effects
				.expectRequest({
					batchNo : oFixture.patchNo,
					url : "Artists?$select=ArtistID,IsActiveEntity,Messages,defaultChannel"
						+ "&$filter=ArtistID eq 'A1' and IsActiveEntity eq false"
				}, {
					value : [{
						"@odata.etag" : "etag.draft2",
						ArtistID : "A1",
						IsActiveEntity : false,
						Messages : [{
							message : "Updated message",
							numericSeverity : 2,
							target : "defaultChannel"
						}],
						defaultChannel : "Channel 3*"
					}]
				})
				.expectChange("defaultChannel", "Channel 3*")
				.expectMessages([{
					message : "Active message",
					target : "/Artists(ArtistID='A1',IsActiveEntity=true)/defaultChannel",
					type : "Information"
				}, {
					message : "Updated message",
					target : "/Artists(ArtistID='A1',IsActiveEntity=false)/defaultChannel",
					type : "Information"
				}]);
			if (bListResolved) {
				that.expectChange("listChannel", ["Channel 3"])
					.expectChange("listChannel", ["Channel 3*"]);
			}
			expectDataEvents(0); // no events for requestSideEffects

			that.oView.byId("defaultChannel").getBinding("value").setValue("Channel 3");

			return Promise.all([
				oObjectPage.getBindingContext().requestSideEffects(["defaultChannel", "Messages"]),
				that.waitForChanges(assert, "(5) set property and request side effects")
			]);
		}).then(function () {
			checkDataEvents();
			return that.checkValueState(assert, "defaultChannel", "Information", "Updated message");
		}).then(function () {
			that.expectChange("defaultChannel", "Channel 1")
				.expectChange("publication", ["P1"])
				.expectMessages([{
					message : "Active message",
					target : "/Artists(ArtistID='A1',IsActiveEntity=true)/defaultChannel",
					type : "Information"
				}])
				.expectRequest("DELETE Artists(ArtistID='A1',IsActiveEntity=false)");
			if (bListResolved) {
				that.expectChange("listChannel", ["Channel 1"]);
			}

			oDraftContext.replaceWith(oActiveContext);
			oDraftContext.delete("$auto", true);
			oObjectPage.setBindingContext(oActiveContext);

			return that.waitForChanges(assert, "(6) cancel");
		}).then(function () {
			if (oFixture.list === 7) {
				oActiveContext.setKeepAlive(false);
				oActiveContext = that.oModel.getKeepAliveContext(
					"/Artists(ArtistID='A1',IsActiveEntity=true)", true,
					{$$patchWithoutSideEffects : true});
				initializeList(6);
			}

			return that.waitForChanges(assert, "(7) resolve list if not done yet");
		}).then(function () {
			checkDataEvents();
		});
	});
});

	//*********************************************************************************************
	// Scenario: Flexible Column Layout, ODataModel#getKeepAliveContext
	// List report with $$getKeepAliveContext. Object page requests a kept-alive context (incl.
	// messages) which the list already has as row context. Request a late property for the object
	// page, afterwards fetch more rows in the list to see that this late property is not selected
	// for the list
	// JIRA: CPOUI5ODATAV4-1405
[false, true].forEach(function (bRelative) {
	QUnit.test("getKeepAliveContext: row context, relative=" + bRelative, function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sPath = bRelative ? "Artists" : "/Artists",
			oTable,
			sView = '\
<Table id="list" growing="true" growingThreshold="2"\
		items="{path : \'' + sPath + '\', \
		parameters : {$$getKeepAliveContext : true, $$ownRequest : true}}">\
	<Text id="id" text="{ArtistID}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		function expectInitialRequest() {
			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity&$skip=0&$top=2", {
					value : [
						{ArtistID : "1", IsActiveEntity : true},
						{ArtistID : "2", IsActiveEntity : true}
					]
				})
				.expectChange("id", ["1", "2"]);
		}

		this.expectChange("id", [])
			.expectChange("name");
		if (!bRelative) {
			expectInitialRequest();
		}

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("list");
			if (bRelative) {
				expectInitialRequest();
				oTable.setBindingContext(oModel.createBindingContext("/"));
			}

			return that.waitForChanges(assert);
		}).then(function () {
			var oContext;

			that.expectRequest("Artists(ArtistID='1',IsActiveEntity=true)"
					+ "?$select=HasDraftEntity,Messages,Name",
					{HasDraftEntity : false, Messages : [], Name : "The Beatles"})
				.expectChange("name", "The Beatles");

			oContext
				= oModel.getKeepAliveContext("/Artists(ArtistID='1',IsActiveEntity=true)", true);
			that.oView.byId("objectPage").setBindingContext(oContext);

			return Promise.all([
				oContext.requestProperty("HasDraftEntity"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity&$skip=2&$top=2",
					{value : [{ArtistID : "3", IsActiveEntity : true}]})
				.expectChange("id", [,, "3"]);

			oTable.requestItems();

			return that.waitForChanges(assert);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Flexible Column Layout, ODataModel#getKeepAliveContext
	// List report with $$getKeepAliveContext. Object page requests a kept-alive context (incl.
	// messages) from the initial list. The list merges this entity later when requesting more
	// items. The property defaultChannel is only used in the list, lastUsedChannel only in the
	// object page and name is used in both.
	// JIRA: CPOUI5ODATAV4-1406
	QUnit.test("getKeepAliveContext: create context, merge later", function (assert) {
		var oContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="list" growing="true" growingThreshold="2" \
		items="{path : \'/Artists\', parameters : {$$getKeepAliveContext : true},\
		suspended : true}">\
	<Text id="listName" text="{Name}"/>\
	<Text id="defaultChannel" text="{defaultChannel}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Input id="name" value="{Name}"/>\
	<Text id="lastUsedChannel" text="{lastUsedChannel}"/>\
</FlexBox>',
			that = this;

		this.expectChange("listName", [])
			.expectChange("defaultChannel", [])
			.expectChange("name")
			.expectChange("lastUsedChannel");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name,defaultChannel"
					+ "&$skip=0&$top=2", {
					value : [{
						"@odata.etag" : "etag1",
						ArtistID : "1",
						IsActiveEntity : true,
						Name : "The Who",
						defaultChannel : "01"
					}, {
						"@odata.etag" : "etag2",
						ArtistID : "2",
						IsActiveEntity : true,
						Name : "The Rolling Stones",
						defaultChannel : "02"
					}]
				})
				.expectChange("defaultChannel", ["01", "02"])
				.expectChange("listName", ["The Who", "The Rolling Stones"])
				.expectRequest({
					groupId : "$auto.heroes",
					url : "Artists(ArtistID='3',IsActiveEntity=false)"
						+ "?$select=ArtistID,HasDraftEntity,IsActiveEntity,Messages,Name,"
						+ "lastUsedChannel"
				}, {
					"@odata.etag" : "etag3",
					ArtistID : "3",
					HasDraftEntity : false,
					IsActiveEntity : false,
					Messages : [],
					Name : "The Beatles",
					lastUsedChannel : "03"
				})
				.expectChange("name", "The Beatles")
				.expectChange("lastUsedChannel", "03");

			oTable = that.oView.byId("list");
			oTable.getBinding("items").resume();
			oContext = oModel.getKeepAliveContext("/Artists(ArtistID='3',IsActiveEntity=false)",
				true, {$$groupId : "$auto.heroes"});
			that.oView.byId("objectPage").setBindingContext(oContext);

			return Promise.all([
				oContext.requestProperty("HasDraftEntity"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oContext.getProperty("@odata.etag"), "etag3");

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name,defaultChannel"
					+ "&$skip=2&$top=2", {
					value : [{
						"@odata.etag" : "etag3",
						ArtistID : "3",
						IsActiveEntity : false,
						Name : "The Beatles",
						defaultChannel : "03"
					}]
				})
				.expectChange("listName", [,, "The Beatles"])
				.expectChange("defaultChannel", [,, "03"]);

			oTable.requestItems();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("name", "The Beatles (changed)")
				.expectChange("listName", [,, "The Beatles (changed)"])
				.expectRequest({
					method : "PATCH",
					headers : {"If-Match" : "etag3"},
					url : "Artists(ArtistID='3',IsActiveEntity=false)",
					payload : {Name : "The Beatles (changed)"}
				}, {
					"@odata.etag" : "etag3.1",
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "The Beatles (from server)"
				})
				.expectChange("listName", [,, "The Beatles (from server)"])
				.expectChange("name", "The Beatles (from server)");

			that.oView.byId("name").getBinding("value").setValue("The Beatles (changed)");

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(oContext.getProperty("@odata.etag"), "etag3.1");
		});
	});

	//*********************************************************************************************
	// Scenario: Flexible Column Layout, ODataModel#getKeepAliveContext
	// An object page requests a kept-alive context matching an entity in a relative binding with
	// $$getKeepAliveContext. This binding has a matching parked cache which must be ignored.
	// Immediately afterwards resolve the binding. Modify a property and see that list and object
	// page are in sync.
	// JIRA: CPOUI5ODATAV4-1407
	QUnit.test("getKeepAliveContext: immediately release temporary binding", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<Table id="list" items="{path : \'Artists\', parameters : {$$getKeepAliveContext : true,\
		$$ownRequest : true, foo : \'bar\', $count : true}}">\
	<Text id="listName" text="{Name}"/>\
	<Text id="defaultChannel" text="{defaultChannel}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Input id="name" value="{Name}"/>\
	<Text id="lastUsedChannel" text="{lastUsedChannel}"/>\
</FlexBox>',
			that = this;

		this.expectChange("listName", [])
			.expectChange("defaultChannel", [])
			.expectChange("name")
			.expectChange("lastUsedChannel");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists?foo=bar&$count=true"
					+ "&$select=ArtistID,IsActiveEntity,Name,defaultChannel&$skip=0&$top=100", {
					"@odata.count" : "1",
					value : [{
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "n/a", // must be ignored for the object page
						defaultChannel : "01"
					}]
				})
				.expectChange("listName", ["n/a"])
				.expectChange("defaultChannel", ["01"]);

			oTable = that.oView.byId("list");
			oTable.setBindingContext(oModel.createBindingContext("/"));

			return that.waitForChanges(assert);
		}).then(function () {
			oTable.setBindingContext(undefined);

			assert.strictEqual(oTable.getBinding("items").getLength(), 0);

			return that.waitForChanges(assert); // wait for UI update
		}).then(function () {
			that.expectRequest("Artists(ArtistID='1',IsActiveEntity=false)?foo=bar"
					+ "&$select=ArtistID,IsActiveEntity,Name,lastUsedChannel", {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "The Beatles",
					lastUsedChannel : "02"
				})
				.expectRequest("Artists?foo=bar&$count=true"
					+ "&$select=ArtistID,IsActiveEntity,Name,defaultChannel&$skip=0&$top=100", {
					"@odata.count" : "1",
					value : [{
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "The Beatles",
						defaultChannel : "01"
					}]
				})
				.expectChange("name", "The Beatles")
				.expectChange("lastUsedChannel", "02")
				.expectChange("listName", ["The Beatles"])
				.expectChange("defaultChannel", ["01"]);

			that.oView.byId("objectPage").setBindingContext(
				oModel.getKeepAliveContext("/Artists(ArtistID='1',IsActiveEntity=false)",
					false, {foo : "bar"})
			);
			oTable.setBindingContext(oModel.createBindingContext("/"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("name", "The Beatles (changed)")
				.expectChange("listName", ["The Beatles (changed)"])
				.expectRequest({
					method : "PATCH",
					url : "Artists(ArtistID='1',IsActiveEntity=false)?foo=bar",
					payload : {Name : "The Beatles (changed)"}
				}, {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "The Beatles (changed*)"
				})
				.expectChange("name", "The Beatles (changed*)")
				.expectChange("listName", ["The Beatles (changed*)"]);

			that.oView.byId("name").getBinding("value").setValue("The Beatles (changed)");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Flexible Column Layout, ODataModel#getKeepAliveContext
	// An object page requests a kept-alive context matching an entity in a suspended list binding
	// with $$getKeepAliveContext. Modify a property. Resume the list and see that list and object
	// page are in sync.
	// JIRA: CPOUI5ODATAV4-1525
	//
	// Consider kept-alive contexts w/o key properties (BCP: 2380040680)
	// Use the patchSent and patchCompleted event at the binding (BCP: 2370038583)
	QUnit.test("getKeepAliveContext: suspended", function (assert) {
		var oContext,
			oListBinding,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			iPatchSentCount = 0,
			iPatchCompletedCount = 0,
			sView = '\
<Table id="list" items="{path : \'/Artists\', parameters : {$$getKeepAliveContext : true},\
		suspended : true}">\
	<Text id="listName" text="{Name}"/>\
	<Text id="defaultChannel" text="{defaultChannel}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Input id="name" value="{Name}"/>\
	<Text id="lastUsedChannel" text="{lastUsedChannel}"/>\
</FlexBox>',
			that = this;

		this.expectChange("listName", [])
			.expectChange("defaultChannel", [])
			.expectChange("name")
			.expectChange("lastUsedChannel");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='1',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Name,lastUsedChannel", {
					ArtistID : "1",
					IsActiveEntity : false,
					Name : "The Beatles",
					lastUsedChannel : "02"
				})
				.expectChange("name", "The Beatles")
				.expectChange("lastUsedChannel", "02");

			oListBinding = that.oView.byId("list").getBinding("items");
			oContext = oModel.getKeepAliveContext("/Artists(ArtistID='1',IsActiveEntity=false)");
			that.oView.byId("objectPage").setBindingContext(oContext);
			oContext.getBinding().attachPatchSent(function () {
				iPatchSentCount += 1;
			});
			oContext.getBinding().attachPatchCompleted(function () {
				iPatchCompletedCount += 1;
			});

			return that.waitForChanges(assert, "getKeepAliveContext");
		}).then(function () {
			that.expectChange("name", "The Beatles (changed)")
				.expectRequest({
					method : "PATCH",
					url : "Artists(ArtistID='1',IsActiveEntity=false)",
					payload : {Name : "The Beatles (changed)"}
				}); // no response required

			that.oView.byId("name").getBinding("value").setValue("The Beatles (changed)");

			return that.waitForChanges(assert, "change name");
		}).then(function () {
			assert.strictEqual(iPatchSentCount, 1);
			assert.strictEqual(iPatchCompletedCount, 1);

			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name,defaultChannel"
					+ "&$skip=0&$top=100", {
					value : [{
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "The Beatles (changed)",
						defaultChannel : "01"
					}]
				})
				.expectChange("listName", ["The Beatles (changed)"])
				.expectChange("defaultChannel", ["01"]);

			oListBinding.resume();

			return that.waitForChanges(assert, "resume");
		}).then(function () {
			that.expectRequest("Artists(ArtistID='3',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity", {
					ArtistID : "3",
					IsActiveEntity : false
				}) // Note: key properties for kept-alive contexts are always requested
				.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name,defaultChannel,"
					// BCP 2380040680: the filter is not invalid because of missing key for '3'
					+ "lastUsedChannel&$filter=ArtistID eq '1' and IsActiveEntity eq false", {
					value : [{
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "The Beatles (changed)",
						defaultChannel : "01"
					}]
				})
				.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name,defaultChannel"
					+ "&$skip=0&$top=100", {
					value : [{
						ArtistID : "1",
						IsActiveEntity : false,
						Name : "The Beatles (changed)",
						defaultChannel : "01"
					}]
				});

			oContext = oModel.getKeepAliveContext("/Artists(ArtistID='3',IsActiveEntity=false)");

			return Promise.all([
				oContext.getBinding().requestRefresh(),
				that.waitForChanges(assert, "BCP: 2380040680")
			]);
		}).then(function () {
			oListBinding.suspend();

			assert.throws(function () {
				oModel.getKeepAliveContext("/Artists(ArtistID='1',IsActiveEntity=false)");
			}, new Error("Must not call method when the binding's root binding is suspended: "
				+ oListBinding));

			assert.throws(function () { // CPOUI5ODATAV4-1786
				oListBinding.getCurrentContexts()[0].resetChanges();
			}, new Error("Must not call method when the binding's root binding is suspended: "
				+ oListBinding));
		});
	});

	//*********************************************************************************************
	// Scenario: Flexible Column Layout, ODataModel#getKeepAliveContext
	// Object page requests a kept-alive context from an empty list. See that the object page
	// request's $select contains all properties from the list's $select even if there has not been
	// a late property yet.
	// Note that getKeepAliveContext requests the key properties (and poss. the messages). So in
	// order to have no late properties yet, the list must show all key properties, and messages
	// must not be requested. The test only has the shared property "Name" to avoid timing issues.
	// JIRA: CPOUI5ODATAV4-2190
	QUnit.test("getKeepAliveContext: properties from the list's $select", function (assert) {
		var oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<Table id="list" growing="true" growingThreshold="1" items="{path : \'Artists\',\
		parameters : {$$getKeepAliveContext : true, $$ownRequest : true}}">\
	<Text id="id" text="{ArtistID}"/>\
	<Text id="isActiveEntity" text="{IsActiveEntity}"/>\
	<Text id="listName" text="{Name}"/>\
	<Text id="listFriend" text="{BestFriend/Name}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="name" text="{Name}"/>\
	<Text id="friend" text="{BestFriend/Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("id", [])
			.expectChange("isActiveEntity", [])
			.expectChange("listName", [])
			.expectChange("listFriend", [])
			.expectChange("name")
			.expectChange("friend");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest({
					batchNo : 1,
					url : "Artists?$select=ArtistID,IsActiveEntity,Name"
						+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)&$skip=0&$top=1"
				}, {
					value : [{
						ArtistID : "1",
						IsActiveEntity : true,
						Name : "The Who",
						BestFriend : {
							ArtistID : "2",
							IsActiveEntity : true,
							Name : "The The"
						}
					}]
				})
				.expectRequest({
					batchNo : 1,
					url : "Artists(ArtistID='3',IsActiveEntity=false)"
						+ "?$select=ArtistID,IsActiveEntity,Name"
						+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)"
				}, {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "The Beatles",
					BestFriend : {
						ArtistID : "4",
						IsActiveEntity : true,
						Name : "The Rolling Stones"
					}
				})
				.expectChange("id", ["1"])
				.expectChange("isActiveEntity", ["Yes"])
				.expectChange("listName", ["The Who"])
				.expectChange("listFriend", ["The The"])
				.expectChange("name", "The Beatles")
				.expectChange("friend", "The Rolling Stones");

			that.oView.byId("list").setBindingContext(oModel.createBindingContext("/"));
			that.oView.byId("objectPage").setBindingContext(
				oModel.getKeepAliveContext("/Artists(ArtistID='3',IsActiveEntity=false)"));

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Flexible Column Layout, ODataModel#getKeepAliveContext
	// Object page requests a kept-alive context. The context's keep-alive status is removed, either
	// still in the temporary binding or hidden in the $$getKeepAliveContext binding. Later a
	// kept-alive context for the same path is requested; its data must be read from the server
	// again.
	// BCP: 441477 / 2023 (002075129400004414772023)
[false, true].forEach(function (bTemporary) {
	var sTitle = "BCP: 441477 / 2023: getKeepAliveContext, temporary=" + bTemporary;

	QUnit.test(sTitle, function (assert) {
		var oContext,
			oListBinding,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oObjectPage,
			sView = '\
<Table id="list" growing="true" growingThreshold="1"\
		items="{path : \'/Artists\', parameters : {$$getKeepAliveContext : true},\
			suspended : true}">\
	<Text id="listName" text="{Name}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectChange("listName", [])
			.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("Artists(ArtistID='3',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Name", {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "The Beatles"
				})
				.expectChange("name", "The Beatles");

			oContext = oModel.getKeepAliveContext("/Artists(ArtistID='3',IsActiveEntity=false)");
			oObjectPage = that.oView.byId("objectPage");
			oObjectPage.setBindingContext(oContext);

			return that.waitForChanges(assert, "1st getKeepAliveContext");
		}).then(function () {
			if (!bTemporary) {
				that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name"
						+ "&$skip=0&$top=1", {
						value : [{
							ArtistID : "1",
							IsActiveEntity : true,
							Name : "The Who"
						}]
					})
					.expectChange("listName", ["The Who"]);

				oListBinding = that.oView.byId("list").getBinding("items");
				oListBinding.resume();

				return that.waitForChanges(assert, "transfer to the list");
			}
		}).then(function () {
			if (!bTemporary) {
				assert.strictEqual(oContext.getBinding(), oListBinding, "transferred to the list");
			}

			that.expectChange("name", null);

			oObjectPage.setBindingContext(null); // unbind before destruction

			// code under test
			oContext.setKeepAlive(false);

			return that.waitForChanges(assert, "setKeepAlive(false)");
		}).then(function () {
			that.expectRequest("Artists(ArtistID='3',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Name", {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "The Beatles *"
				})
				.expectChange("name", "The Beatles *");

			oContext = oModel.getKeepAliveContext("/Artists(ArtistID='3',IsActiveEntity=false)");
			oObjectPage.setBindingContext(oContext);

			return that.waitForChanges(assert, "2nd getKeepAliveContext");
		});
	});
});

	//*********************************************************************************************
	// Scenario: Flexible Column Layout, ODataModel#getKeepAliveContext
	// Object page requests a hidden kept-alive context for a list with data. The context's
	// keep-alive status is removed. Later the entity is changed on the server and then loaded via
	// paging, it must show the new data.
	// BCP: 441477 / 2023 (002075129400004414772023)
[false, true].forEach(function (bETag) {
	var sTitle = "BCP: 441477 / 2023: getKeepAliveContext & paging, eTag=" + bETag;

	QUnit.test(sTitle, function (assert) {
		var oContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oObjectPage,
			sView = '\
<Table id="list" growing="true" growingThreshold="1" \
		items="{path : \'/Artists\', parameters : {$$getKeepAliveContext : true}}">\
	<Text id="listName" text="{Name}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="name" text="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name"
				+ "&$skip=0&$top=1", {
				value : [{
					ArtistID : "1",
					IsActiveEntity : true,
					Name : "The Who"
				}]
			})
			.expectChange("listName", ["The Who"])
			.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			var oResponse = {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "The Beatles"
				};

			if (bETag) {
				oResponse["@odata.etag"] = "etag1";
			}
			that.expectRequest("Artists(ArtistID='3',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Name",
					oResponse)
				.expectChange("name", "The Beatles");

			oContext = oModel.getKeepAliveContext("/Artists(ArtistID='3',IsActiveEntity=false)");
			oObjectPage = that.oView.byId("objectPage");
			oObjectPage.setBindingContext(oContext);

			return that.waitForChanges(assert, "getKeepAliveContext");
		}).then(function () {
			that.expectChange("name", null);

			oObjectPage.setBindingContext(null); // unbind before destruction

			// code under test
			oContext.setKeepAlive(false);

			return that.waitForChanges(assert, "setKeepAlive(false)");
		}).then(function () {
			var oResponse = {
					ArtistID : "3",
					IsActiveEntity : false,
					Name : "The Beatles *"
				};

			if (bETag) {
				oResponse["@odata.etag"] = "etag2";
			}
			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity,Name&$skip=1&$top=1",
					{value : [oResponse]})
				.expectChange("listName", [, "The Beatles *"]);

			that.oView.byId("list").requestItems();

			return that.waitForChanges(assert, "request more items");
		});
	});
});

	//*********************************************************************************************
	// Scenario: List report with absolute binding, object page with a late property. Ensure that
	// the late property is not requested for all rows of the list, but only for the single row that
	// needs it.
	// (1) sort
	// (2) filter
	// (3) changeParameters
	// (4) suspend/resume
	// JIRA: CPOUI5ODATAV4-874
	// (5) refresh (JIRA: CPOUI5ODATAV4-1382)
	//
	// Do likewise with a kept-alive context (JIRA: CPOUI5ODATAV4-926).
	//
	// Same while there are pending changes for the kept-alive context which must not block those
	// APIs, but survive and can be submitted later on. This includes a creation row which needs to
	// remain functional without blocking those APIs.
	// JIRA: CPOUI5ODATAV4-1104
	//
	// Selection is cleared on destruction (JIRA: CPOUI5ODATAV4-2053).
[false, true].forEach(function (bWithPendingChanges) {
	var sTitle = "Absolute ODLB: sort/filter/changeParameters/resume/refresh & late properties"
			+ ", with pending changes: " + bWithPendingChanges;

	QUnit.test(sTitle, function (assert) {
		var aContexts,
			oCreationRowContext,
			oListBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sNewNote,
			oSetPropertyPromise,
			sView = '\
<Table id="list" items="{/SalesOrderList}">\
	<Text id="listNote" text="{Note}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="note" text="{Note}"/>\
	<Text id="noteLanguage" text="{NoteLanguage}"/>\
</FlexBox>\
<FlexBox id="keptAlivePage">\
	<Text id="grossAmount" text="{GrossAmount}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
				value : [{
					Note : "Note 1",
					SalesOrderID : "1"
				}, {
					Note : "Note 2",
					SalesOrderID : "2"
				}]
			})
			.expectChange("listNote", ["Note 1", "Note 2"])
			.expectChange("note")
			.expectChange("noteLanguage")
			.expectChange("grossAmount");

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("list").getBinding("items");
			aContexts = oListBinding.getCurrentContexts();

			that.expectChange("note", "Note 1")
				.expectRequest("SalesOrderList('1')?$select=NoteLanguage", {NoteLanguage : "EN"})
				.expectChange("noteLanguage", "EN");

			that.oView.byId("objectPage").setBindingContext(aContexts[0]);

			that.expectRequest("SalesOrderList('2')?$select=GrossAmount", {GrossAmount : "2.00"})
				.expectChange("grossAmount", "2.00");
			that.oView.byId("keptAlivePage").setBindingContext(aContexts[1]);

			return that.waitForChanges(assert, "object page with late property");
		}).then(function () {
			var oNoPatchPromise;

			assert.notOk(oModel.hasPendingChanges());
			assert.notOk(oListBinding.hasPendingChanges());
			assert.notOk(aContexts[1].hasPendingChanges());

			if (bWithPendingChanges) {
				sNewNote = "pending";
				that.expectChange("listNote", [, sNewNote]);
				oSetPropertyPromise = aContexts[1].setProperty("Note", sNewNote, "update");

				// "creation row"
				oCreationRowContext
					= oModel.bindList("SO_2_SOITEM", aContexts[1], [], [],
						{$$updateGroupId : "doNotSubmit"})
					.create();
			} else { // Note: this does not count as a pending change!
				sNewNote = "no patch";
				// just try it to make sure nothing breaks
				that.expectChange("listNote", [, sNewNote]);
				oNoPatchPromise = aContexts[1].setProperty("Note", sNewNote, null);
			}
			aContexts[1].setKeepAlive(true); // change "keep alive" flag *after* PATCH exists

			return Promise.all([
				oNoPatchPromise,
				that.waitForChanges(assert, "(no) pending changes")
			]);
		}).then(function () {
			assert.strictEqual(oListBinding.hasPendingChanges(), bWithPendingChanges);
			assert.notOk(oListBinding.hasPendingChanges(/*bIgnoreKeptAlive*/true));

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$orderby=SalesOrderID desc&$skip=0&$top=100", {
					value : [{
						SalesOrderID : "2",
						Note : "Note 2.1"
					}, {
						SalesOrderID : "1",
						Note : "Note 1.1"
					}]
				})
				.expectChange("listNote", [sNewNote, "Note 1.1"])
				.expectChange("note", "Note 1.1")
				.expectRequest("SalesOrderList('1')?$select=NoteLanguage", {NoteLanguage : "FR"})
				.expectChange("noteLanguage", "FR");

			// code under test
			oListBinding.sort(new Sorter("SalesOrderID", /*descending*/true));

			return that.waitForChanges(assert, "(1) sort");
		}).then(function () {
			assert.strictEqual(oListBinding.hasPendingChanges(), bWithPendingChanges);
			assert.notOk(oListBinding.hasPendingChanges(/*bIgnoreKeptAlive*/true));

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$orderby=SalesOrderID desc&$filter=SalesOrderID eq '1'&$skip=0&$top=100", {
					value : [{
						Note : "Note 1.2",
						SalesOrderID : "1"
					}]
				})
				.expectChange("listNote", ["Note 1.2"])
				.expectChange("note", "Note 1.2")
				.expectRequest("SalesOrderList('1')?$select=NoteLanguage", {NoteLanguage : "DE"})
				.expectChange("noteLanguage", "DE");

			// code under test
			oListBinding.filter(new Filter("SalesOrderID", FilterOperator.EQ, "1"));

			return that.waitForChanges(assert, "(2) filter");
		}).then(function () {
			assert.strictEqual(oListBinding.hasPendingChanges(), bWithPendingChanges);
			assert.notOk(oListBinding.hasPendingChanges(/*bIgnoreKeptAlive*/true));

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$orderby=SalesOrderID desc&$filter=SalesOrderID eq '1'&foo=bar"
					+ "&$skip=0&$top=100", {
					value : [{
						Note : "Note 1.3",
						SalesOrderID : "1"
					}]
				})
				.expectChange("listNote", ["Note 1.3"])
				.expectChange("note", "Note 1.3")
				.expectRequest("SalesOrderList('1')?foo=bar&$select=NoteLanguage",
					{NoteLanguage : "IT"})
				.expectChange("noteLanguage", "IT");

			// code under test
			oListBinding.changeParameters({foo : "bar"});

			return that.waitForChanges(assert, "(3) changeParameters");
		}).then(function () {
			assert.strictEqual(oListBinding.hasPendingChanges(), bWithPendingChanges);
			assert.notOk(oListBinding.hasPendingChanges(/*bIgnoreKeptAlive*/true));

			if (!bWithPendingChanges) {
				sNewNote = "Note 2.4";
				that.expectRequest("SalesOrderList?$select=GrossAmount,Note,NoteLanguage"
						+ ",SalesOrderID&$filter=SalesOrderID eq '2'", {
						value : [{
							GrossAmount : "2.40",
							Note : sNewNote, // not shown on "keptAlivePage"
							NoteLanguage : "EN", // not shown on "keptAlivePage"
							SalesOrderID : "2"
						}]
					})
					.expectChange("grossAmount", "2.40");
			}
			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						Note : "Note 1.4",
						SalesOrderID : "1"
					}, {
						Note : "Note 2.4",
						SalesOrderID : "2"
					}]
				})
				.expectChange("listNote", ["Note 1.4", sNewNote])
				.expectChange("note", "Note 1.4")
				.expectRequest("SalesOrderList('1')?$select=NoteLanguage", {NoteLanguage : "ES"})
				.expectChange("noteLanguage", "ES");

			// code under test
			oListBinding.suspend();
			oListBinding.sort();
			oListBinding.filter();
			oListBinding.changeParameters({foo : undefined});
			oListBinding.refresh();
			oListBinding.resume();

			return that.waitForChanges(assert, "(4) suspend/resume");
		}).then(function () {
			assert.strictEqual(oListBinding.hasPendingChanges(), bWithPendingChanges);
			assert.notOk(oListBinding.hasPendingChanges(/*bIgnoreKeptAlive*/true));

			if (!bWithPendingChanges) {
				sNewNote = "Note 2.5";
				that.expectRequest("SalesOrderList?$select=GrossAmount,Note,NoteLanguage"
						+ ",SalesOrderID&$filter=SalesOrderID eq '2'", {
						value : [{
							GrossAmount : "3.00",
							Note : sNewNote, // not shown on "keptAlivePage"
							NoteLanguage : "EN", // not shown on "keptAlivePage"
							SalesOrderID : "2"
						}]
					})
					.expectChange("listNote", [, sNewNote])
					.expectChange("grossAmount", "3.00");
			}
			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						Note : "Note 1.5",
						SalesOrderID : "1"
					}, {
						Note : sNewNote,
						SalesOrderID : "2"
					}]
				})
				.expectChange("listNote", ["Note 1.5"])
				.expectChange("note", "Note 1.5")
				.expectRequest("SalesOrderList('1')?$select=NoteLanguage", {NoteLanguage : "JP"})
				.expectChange("noteLanguage", "JP");

			return Promise.all([
				oListBinding.requestRefresh(),
				that.waitForChanges(assert, "(5) refresh")
			]);
		}).then(function () {
			var oSetPropertyPromise2;

			assert.strictEqual(oListBinding.hasPendingChanges(), bWithPendingChanges);
			assert.notOk(oListBinding.hasPendingChanges(/*bIgnoreKeptAlive*/true));
			assert.strictEqual(aContexts[1].getProperty("Note"), sNewNote);

			if (bWithPendingChanges) {
				that.expectChange("listNote", [, "updated"]);

				// code under test
				oSetPropertyPromise2 = aContexts[1].setProperty("Note", "updated", "update");

				sNewNote = "from server";
				that.expectRequest({
						method : "PATCH",
						url : "SalesOrderList('2')",
						payload : {Note : "updated"}
					}, {ID : "2", Note : sNewNote})
					.expectChange("listNote", [, sNewNote]);
			}

			return Promise.all([
				oModel.submitBatch("update"),
				oSetPropertyPromise,
				oSetPropertyPromise2,
				that.waitForChanges(assert, "submit (no) pending changes")
			]);
		}).then(function () {
			var oCreatedPromise;

			assert.strictEqual(aContexts[1].getProperty("Note"), sNewNote);
			assert.strictEqual(oModel.hasPendingChanges("doNotSubmit"), bWithPendingChanges);
			assert.notOk(oModel.hasPendingChanges("update"));
			assert.strictEqual(oListBinding.hasPendingChanges(), bWithPendingChanges,
				"creation row");
			assert.strictEqual(aContexts[0].hasPendingChanges(), false);
			assert.strictEqual(aContexts[1].hasPendingChanges(), bWithPendingChanges,
				"creation row");

			if (oCreationRowContext) {
				// code under test
				oCreationRowContext.setProperty("Note", "alive & kicking");
				assert.strictEqual(oCreationRowContext.getProperty("Note"), "alive & kicking");

				oCreatedPromise = oCreationRowContext.created();
				oCreationRowContext.setSelected(true);
				// code under test (& clean up)
				oModel.resetChanges("doNotSubmit");
				assert.notOk(oCreationRowContext.isSelected(), "already destroyed");
				// binding is already destroyed
				// assert.notOk(oCreationRowContext.getProperty("@$ui5.context.isSelected"));
				assert.strictEqual(oCreationRowContext.created(), undefined, "already destroyed");

				return Promise.all([
					checkCanceled(assert, oCreatedPromise),
					that.waitForChanges(assert, "clean up")
				]);
			}
		}).then(function () {
			assert.notOk(oModel.hasPendingChanges("doNotSubmit"));
		});
	});
});

	//*********************************************************************************************
	// Scenario: List report with absolute binding, object page with items table. Parent context of
	// items table is not kept-alive, but one of the items contexts is. Pending change in there must
	// not be ignored when filtering etc. in list report.
	// JIRA: CPOUI5ODATAV4-1104
	//
	// A transient item must also not be ignored by the list report (JIRA: CPOUI5ODATAV4-1409)
	// Also check with refresh (JIRA: CPOUI5ODATAV4-1382)
	//
	// A refresh of the list report must not destroy inactive creation rows in the items table.
	// JIRA: CPOUI5ODATAV4-1566
	//
	// Selection must not make a difference here (JIRA: CPOUI5ODATAV4-2053).
	QUnit.test("JIRA: CPOUI5ODATAV4-1104 - do not ignore indirect kept-alive", function (assert) {
		var oInactiveCreationRow,
			oItemsTableBinding,
			oKeptAliveItem,
			oListReportBinding,
			oModel = this.createSalesOrdersModel({
				autoExpandSelect : true,
				updateGroupId : "update"
			}),
			oSetPropertyPromise,
			sView = '\
<Table id="listReport" items="{/SalesOrderList}">\
	<Text id="note" text="{Note}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Table id="itemsTable" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="itemPosition" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("note", ["First SalesOrder"])
			.expectChange("itemPosition", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$select=ItemPosition,SalesOrderID"
					+ "&$skip=0&$top=100", {
					value : [{
						ItemPosition : "0010",
						SalesOrderID : "42"
					}]
				})
				.expectChange("itemPosition", ["0010"]);

			oListReportBinding = that.oView.byId("listReport").getBinding("items");
			oItemsTableBinding = that.oView.byId("itemsTable").getBinding("items");
			oItemsTableBinding.setContext(oListReportBinding.getCurrentContexts()[0]);

			return that.waitForChanges(assert);
		}).then(function () {
			oKeptAliveItem = oItemsTableBinding.getCurrentContexts()[0];
			oKeptAliveItem.setKeepAlive(true);
			oKeptAliveItem.setSelected(true);

			that.expectChange("itemPosition", ["0001"]);

			oSetPropertyPromise = oKeptAliveItem.setProperty("ItemPosition", "0001", "doNotSubmit");

			assert.strictEqual(oKeptAliveItem.hasPendingChanges(), true);
			assert.strictEqual(oItemsTableBinding.hasPendingChanges(), true);
			assert.strictEqual(oItemsTableBinding.hasPendingChanges(true), false);
			assert.strictEqual(oListReportBinding.hasPendingChanges(), true);
			assert.strictEqual(oListReportBinding.hasPendingChanges(true), true, "do not ignore!");

			assert.throws(function () {
				// code under test
				oListReportBinding.filter(new Filter("SalesOrderID", FilterOperator.NE, "42"));
			}, new Error("Cannot filter due to pending changes"));

			assert.throws(function () {
				// code under test
				oListReportBinding.refresh();
			}, new Error("Cannot refresh due to pending changes"));

			assert.throws(function () {
				// code under test
				oKeptAliveItem.refresh();
			}, new Error("Cannot refresh entity due to pending changes: " + oKeptAliveItem));

			return that.waitForChanges(assert);
		}).then(function () {
			oKeptAliveItem.setKeepAlive(false);
			oKeptAliveItem.setSelected(false);

			that.expectChange("itemPosition", ["0010"])
				.expectCanceledError("Failed to update path /SalesOrderList('42')"
					+ "/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0010')/ItemPosition",
					"Request canceled: PATCH SalesOrderList('42')"
					+ "/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0010'); group: doNotSubmit");

			// cleanup
			oModel.resetChanges("doNotSubmit");

			return Promise.all([
				checkCanceled(assert, oSetPropertyPromise),
				that.waitForChanges(assert, "reset changes")
			]);
		}).then(function () {
			var oTransientItem = oItemsTableBinding.create({ItemPosition : "0000"});

			assert.strictEqual(oTransientItem.hasPendingChanges(), true);
			assert.strictEqual(oItemsTableBinding.hasPendingChanges(), true);
			assert.strictEqual(oItemsTableBinding.hasPendingChanges(true), false);
			assert.strictEqual(oListReportBinding.hasPendingChanges(), true);
			// code under test (JIRA: CPOUI5ODATAV4-1409)
			assert.strictEqual(oListReportBinding.hasPendingChanges(true), true, "do not ignore!");

			return Promise.all([
				oTransientItem.delete(), // cleanup
				checkCanceled(assert, oTransientItem.created()),
				that.waitForChanges(assert, "do not ignore transient")
			]);
		}).then(function () {
			that.expectChange("itemPosition", ["", "0010"]);

			oInactiveCreationRow = oItemsTableBinding.create({/*oInitialData*/},
				/*bSkipRefresh*/true, /*bAtEnd*/false, /*bInactive*/true);

			assert.strictEqual(oInactiveCreationRow.hasPendingChanges(), false);
			assert.strictEqual(oItemsTableBinding.hasPendingChanges(), false);
			assert.strictEqual(oListReportBinding.hasPendingChanges(), false);

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						Note : "1st SalesOrder",
						SalesOrderID : "42"
					}]
				})
				.expectChange("note", ["1st SalesOrder"])
				.expectRequest("SalesOrderList('42')/SO_2_SOITEM?$select=ItemPosition,SalesOrderID"
					+ "&$skip=0&$top=99", {
					value : [{
						ItemPosition : "0011",
						SalesOrderID : "42"
					}]
				})
				.expectChange("itemPosition", [, "0011"]);

			return Promise.all([
				// code under test (JIRA: CPOUI5ODATAV4-1566)
				oListReportBinding.requestRefresh(),
				that.waitForChanges(assert, "JIRA: CPOUI5ODATAV4-1566")
			]);
		}).then(function () {
			assert.strictEqual(oItemsTableBinding.getAllCurrentContexts()[0], oInactiveCreationRow);

			that.expectChange("itemPosition", ["0111"])
				.expectRequest({
					method : "POST",
					payload : {
						ItemPosition : "0111"
					},
					url : "SalesOrderList('42')/SO_2_SOITEM"
				}); // response does not matter here

			// code under test
			oInactiveCreationRow.setProperty("ItemPosition", "0111");

			return Promise.all([
				oModel.submitBatch("update"),
				oInactiveCreationRow.created(),
				that.waitForChanges(assert, "activate")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: List report with absolute binding, some kept-alive element outside of collection.
	// Side effect causes a refresh which succeeds. Check that kept-alive element is still working.
	// JIRA: CPOUI5ODATAV4-1104
	QUnit.test("JIRA: CPOUI5ODATAV4-1104 - kept-alive and bKeepCacheOnError", function (assert) {
		var oBinding,
			oKeptAliveItem,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="listReport" items="{/SalesOrderList}">\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,SalesOrderID&$skip=0&$top=100", {
				value : [{
					Note : "First SalesOrder",
					SalesOrderID : "42"
				}]
			})
			.expectChange("note", ["First SalesOrder"]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("listReport").getBinding("items");
			oKeptAliveItem = oBinding.getCurrentContexts()[0];
			oKeptAliveItem.setKeepAlive(true);

			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$filter=SalesOrderID ne '42'&$skip=0&$top=100", {
					value : [{
						Note : "Yet Another SalesOrder",
						SalesOrderID : "0"
					}]
				})
				.expectChange("note", ["Yet Another SalesOrder"]);

			oBinding.filter(new Filter("SalesOrderID", FilterOperator.NE, "42"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$filter=SalesOrderID eq '42'", {
					value : [{
						Note : "First SalesOrder###",
						SalesOrderID : "42"
					}]
				})
				.expectRequest("SalesOrderList?$select=Note,SalesOrderID"
					+ "&$filter=SalesOrderID ne '42'&$skip=0&$top=100", {
					value : [{
						Note : "Yet Another SalesOrder***",
						SalesOrderID : "0"
					}]
				})
				.expectChange("note", ["Yet Another SalesOrder***"]);

			return Promise.all([
				// code under test
				oBinding.getHeaderContext().requestSideEffects([""]),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oKeptAliveItem.getProperty("Note"), "First SalesOrder###");

			that.expectRequest({
					method : "PATCH",
					payload : {
						Note : "update"
					},
					url : "SalesOrderList('42')"
				}); // no response required

			return Promise.all([
				// code under test
				oKeptAliveItem.setProperty("Note", "update"),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: List report with static filter in the view and modified during runtime.
	// Get the array of filters of the ListBinding, replace the first one and add a new one to it.
	// Filter again using ODLB#filter
	//
	// JIRA: CPOUI5ODATAV4-1205
	QUnit.test("CPOUI5ODATAV4-1205: sap.ui.model.ListBinding#getFilters", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="list" items="{path: \'/SalesOrderList\',\
		filters : {path : \'GrossAmount\', operator : \'LE\', value1 : 125}}">\
	<Text id="note" text="{Note}"/>\
	<Text id="grossAmount" text="{GrossAmount}"/>\
	<Text id="soItemCount" text="{SOItemCount}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$filter=GrossAmount le 125&$select=GrossAmount,"
				+ "Note,SOItemCount,SalesOrderID&$skip=0&$top=100", {
				value : [{
					SalesOrderID : "1",
					SOItemCount : 5,
					GrossAmount : "125.00",
					Note : "Note 1"
				}, {
					SalesOrderID : "2",
					SOItemCount : 10,
					GrossAmount : "100.00",
					Note : "Note 2"
				}]
			})
			.expectChange("note", ["Note 1", "Note 2"])
			.expectChange("grossAmount", ["125.00", "100.00"])
			.expectChange("soItemCount", ["5", "10"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oListBinding = that.oView.byId("list").getBinding("items"),
				// code under test
				aFilters = oListBinding.getFilters(FilterType.Application);

			that.expectRequest("SalesOrderList?"
				+ "$filter=GrossAmount le 100 and SOItemCount ge 10"
				+ "&$select=GrossAmount,Note,SOItemCount,SalesOrderID&$skip=0&$top=100", {
					value : [{
						SalesOrderID : "2",
						SOItemCount : 10,
						GrossAmount : "100.00",
						Note : "Note 2"
					}]
				})
				.expectChange("note", ["Note 2"])
				.expectChange("grossAmount", ["100.00"])
				.expectChange("soItemCount", ["10"]);

			// code under test (Filter getter)
			aFilters[0] = new Filter(aFilters[0].getPath(), aFilters[0].getOperator(), 100);
			aFilters.push(new Filter("SOItemCount", FilterOperator.GE, "10"));
			oListBinding.filter(aFilters);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: New change requests for the same group ID (e.g. $auto) are submitted before the
	// previous response arrives, leading to the error "Unexpected second $batch". Here,
	// Context#delete is used.
	// BCP: 2170018878
	QUnit.test("BCP: 2170018878 via Context#delete", function (assert) {
		var aContexts,
			oDeletePromise0,
			oDeletePromise1,
			fnResolveDelete0,
			fnResolveDelete1,
			that = this;

		return this.createView(assert).then(function () {
			var oListBinding = that.oModel.bindList("/TEAMS");

			that.expectRequest("TEAMS?$skip=0&$top=100", {
					value : [
						{Team_Id : "Team_01"},
						{Team_Id : "Team_02"}
					]
				});

			return oListBinding.requestContexts();
		}).then(function (aContexts0) {
			aContexts = aContexts0;

			that.expectRequest("DELETE TEAMS('Team_01')", new Promise(function (resolve) {
					fnResolveDelete0 = resolve;
				}));

			// code under test
			oDeletePromise0 = aContexts[0].delete();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("DELETE TEAMS('Team_02')", new Promise(function (resolve) {
					fnResolveDelete1 = resolve;
				}));

			// code under test
			oDeletePromise1 = aContexts[1].delete();

			return that.waitForChanges(assert);
		}).then(function () {
			fnResolveDelete1();

			return oDeletePromise1;
		}).then(function () {
			fnResolveDelete0();

			return oDeletePromise0;
		});
	});

	//*********************************************************************************************
	// Scenario: New change requests for the same group ID (e.g. $auto) are submitted before the
	// previous response arrives, leading to the error "Unexpected second $batch". Here,
	// ODataListBinding#create is used.
	// BCP: 2170018878
	QUnit.test("BCP: 2170018878 via ODLB#create", function (assert) {
		var oContext0,
			oContext1,
			oListBinding,
			fnResolveCreate0,
			fnResolveCreate1,
			that = this;

		return this.createView(assert).then(function () {
			oListBinding = that.oModel.bindList("/TEAMS");

			that.expectRequest({
					method : "POST",
					payload : {},
					url : "TEAMS"
				}, new Promise(function (resolve) {
					fnResolveCreate0 = resolve.bind(null, {/* response does not matter here */});
				}));

			// code under test
			oContext0 = oListBinding.create({}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					payload : {},
					url : "TEAMS"
				}, new Promise(function (resolve) {
					fnResolveCreate1 = resolve.bind(null, {/* response does not matter here */});
				}));

			// code under test
			oContext1 = oListBinding.create({}, true);

			return that.waitForChanges(assert);
		}).then(function () {
			fnResolveCreate1();

			return oContext1.created();
		}).then(function () {
			fnResolveCreate0();

			return oContext0.created();
		});
	});

	//*********************************************************************************************
	// Scenario: A collection-valued structural property in the initial data of a created entity.
	// BCP: 2170084493
	QUnit.test("BCP: 2170084493", function (assert) {
		var oModel = this.createSalesOrdersModel({updateGroupId : "doNotSubmit"}),
			sView = '<Text id="code" text="{Messages/0/code}"/>',
			that = this;

		this.expectChange("code");

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = oModel.bindList("/SalesOrderList"),
				oContext = oBinding.create({
					Messages : [{code : "foo"}]
				});

			that.expectChange("code", "foo");

			that.oView.setBindingContext(oContext);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A newly created entity does not get a key predicate - the "refreshSingle" must
	// fail, but the POST's response is still used! Show that "refreshSingleWithRemove" also fails.
	// BCP: 2270132669
	QUnit.test("BCP: 2270132669", function (assert) {
		var oContext,
			oMessage = {
				message : "No key predicate known",
				persistent : true,
				technical : true,
				type : "Error"
			},
			that = this;

		return this.createView(assert).then(function () {
			var oBinding = that.oModel.bindList("/EMPLOYEES");

			that.expectRequest({
					method : "POST",
					payload : {AGE : 42},
					url : "EMPLOYEES"
				}, {
					AGE : 42,
					// intentionally no ID!
					Name : "John Doe"
				});
			that.oLogMock.expects("error")
				.withExactArgs(sinon.match(function (sMessage) {
					return normalizeUID(sMessage)
						=== "Failed to refresh entity: /EMPLOYEES($uid=...)[-1;transient]";
				}), sinon.match("No key predicate known"), sODLB);
			that.expectMessages([oMessage]);

			// code under test
			oContext = oBinding.create({AGE : 42});

			return Promise.all([
				that.waitForChanges(assert),
				oContext.created().catch(function (oError) {
					assert.strictEqual(oError.message, "No key predicate known");
				})
			]);
		}).then(function () {
			assert.deepEqual(oContext.getObject(), {
				"@$ui5.context.isTransient" : false,
				AGE : 42,
				Name : "John Doe"
			});
			assert.strictEqual(normalizeUID(oContext.toString()),
				"/EMPLOYEES($uid=...)[-1;createdPersisted]");
			assert.strictEqual(oContext.hasPendingChanges(), false);
			assert.strictEqual(oContext.getBinding().hasPendingChanges(), false);
			assert.strictEqual(oContext.getModel().hasPendingChanges(), false);

			that.oLogMock.expects("error")
				.withExactArgs(sinon.match(function (sMessage) {
					return normalizeUID(sMessage)
						=== "Failed to refresh entity: /EMPLOYEES($uid=...)[-1;createdPersisted]";
				}), sinon.match("No key predicate known"), sODLB);
			that.expectMessages([oMessage, oMessage]);

			return Promise.all([
				// code under test
				oContext.requestRefresh(undefined, /*bAllowRemoval*/true).catch(function (oError) {
					assert.strictEqual(oError.message, "No key predicate known");
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.deepEqual(oContext.getObject(), {
				"@$ui5.context.isTransient" : false,
				AGE : 42,
				Name : "John Doe"
			});
			assert.strictEqual(normalizeUID(oContext.toString()),
				"/EMPLOYEES($uid=...)[-1;createdPersisted]");
			assert.strictEqual(oContext.hasPendingChanges(), false);
			assert.strictEqual(oContext.getBinding().hasPendingChanges(), false);
			assert.strictEqual(oContext.getModel().hasPendingChanges(), false);
		});
	});

	//*********************************************************************************************
	// Scenario: New change requests for the same group ID (e.g. $auto) are submitted before the
	// previous response arrives, leading to the error "Unexpected second $batch". Here,
	// ODataContextBinding#invoke is used.
	// BCP: 2170018878
	QUnit.test("BCP: 2170018878 via ODCB#invoke", function (assert) {
		var oInvokePromise0,
			oInvokePromise1,
			fnResolveOperation0,
			fnResolveOperation1,
			that = this;

		return this.createView(assert).then(function () {
			var oOperationBinding = that.oModel.bindContext("/FireEmployee(...)");

			oOperationBinding.setParameter("EmployeeID", "1");

			that.expectRequest({
					method : "POST",
					payload : {EmployeeID : "1"},
					url : "FireEmployee"
				}, new Promise(function (resolve) {
					fnResolveOperation0 = resolve;
				}));

			// code under test
			oInvokePromise0 = oOperationBinding.invoke();

			return that.waitForChanges(assert);
		}).then(function () {
			var oOperationBinding = that.oModel.bindContext("/FireEmployee(...)");

			oOperationBinding.setParameter("EmployeeID", "2");

			that.expectRequest({
					method : "POST",
					payload : {EmployeeID : "2"},
					url : "FireEmployee"
				}, new Promise(function (resolve) {
					fnResolveOperation1 = resolve;
				}));

			// code under test
			oInvokePromise1 = oOperationBinding.invoke();

			return that.waitForChanges(assert);
		}).then(function () {
			fnResolveOperation1();

			return oInvokePromise1;
		}).then(function () {
			fnResolveOperation0();

			return oInvokePromise0;
		});
	});

	//*********************************************************************************************
	// Scenario: A list binding should be updated w.r.t. aggregation, filters, parameters, sorters
	// inside suspend/resume. If any of these updates fails, the binding should be recreated
	// ("rebind").
	// Q: If list binding is unresolved, can we safely update it?
	// A: Yes, see test "API calls before binding is resolved"
	// Q: Do we need to resume in case of rebind?
	// A: You better don't, in case it was "quasi-absolute" :-( "Cannot resume a relative binding: "
	//    + "sap.ui.model.odata.v4.ODataListBinding: undefined|TEAM_2_EMPLOYEES"
	// Q: If the list binding is not the root binding, should we resume *after* rebind?
	// A: Of course you must resume, and if you do it before, you get an addt'l request.
	// JIRA: CPOUI5ODATAV4-979
	QUnit.test("CPOUI5ODATAV4-979: rebind and suspend/resume", function (assert) {
		var sView = '\
<FlexBox binding="{/TEAMS(\'1\')}">\
	<t:Table id="table" rows="{path : \'TEAM_2_EMPLOYEES\', parameters : {$$ownRequest : true}}">\
		<Text id="age" text="{AGE}"/>\
		<Text binding="{}" id="name" text="{Name}"/>\
	</t:Table>\
</FlexBox>',
			that = this;

		this.expectRequest("TEAMS('1')/TEAM_2_EMPLOYEES?$skip=0&$top=110", {
				value : [{
					AGE : 30,
					ID : "0",
					Name : "Frederic Fall"
				}]
			})
			.expectChange("age", ["30"])
			.expectChange("name", ["Frederic Fall"]);

		return this.createView(assert, sView).then(function () {
			var oTable = that.oView.byId("table"),
				oListBinding = oTable.getBinding("rows"),
				oRootBinding = oListBinding.getRootBinding();

			oRootBinding.suspend();
			oListBinding.sort(new Sorter("AGE"));

			that.expectRequest("TEAMS('1')/TEAM_2_EMPLOYEES?$skip=0&$top=110", {
					value : [{
						AGE : 40,
						ID : "0",
						Name : "Frederic Fall *"
					}]
				})
				.expectChange("age", ["40"])
				.expectChange("name", ["Frederic Fall *"]);

			// code under test
			oTable.bindRows({path : "TEAM_2_EMPLOYEES", parameters : {$$ownRequest : true}});

			oRootBinding.resume();

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A control becomes target of a model message, but then its context is changed and
	// it is not target of a message anymore.
[false, true].forEach(function (bNull) {
	QUnit.test("_checkDataStateMessages, bNull=" + bNull, function (assert) {
		var oInput,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '<Input id="age" value="{AGE}"/>',
			that = this;

		this.expectChange("age");

		return this.createView(assert, sView, oModel).then(function () {
			var oContextBinding = oModel.bindContext("/EMPLOYEES('1')", null, {
					$select : "__CT__FAKE__Message/__FAKE__Messages"
				});

			oInput = that.oView.byId("age");

			that.expectRequest("EMPLOYEES('1')?$select=AGE,ID,__CT__FAKE__Message/__FAKE__Messages",
				{
					AGE : 18,
					ID : "1",
					__CT__FAKE__Message : {
						__FAKE__Messages : [{
							code : "1",
							message : "That is very young",
							numericSeverity : 3,
							target : "AGE",
							transition : false
						}]
					}
				})
				.expectChange("age", "18")
				.expectMessages([{
					code : "1",
					message : "That is very young",
					target : "/EMPLOYEES('1')/AGE",
					type : "Warning"
				}]);

			oInput.setBindingContext(oContextBinding.getBoundContext());

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, oInput, "Warning", "That is very young");
		}).then(function () {
			if (bNull) {
				that.expectChange("age", null);
			} else {
				that.expectRequest("EMPLOYEES('2')/AGE", {value : 3 * 7})
					.expectChange("age", "21");
			}

			// code under test
			oInput.setBindingContext(bNull ? null : oModel.createBindingContext("/EMPLOYEES('2')"));

			return that.waitForChanges(assert);
		}).then(function () {
			return that.checkValueState(assert, oInput, "None", "");
		});
	});
});

	//*********************************************************************************************
	// Scenario: A list binding with $$sharedRequest (e.g. from a value list) is refreshed. Other
	// bindings share that cache and must follow, one binding while resumed and one binding while
	// suspended.
	// BCP: 002075129500004766202022
	//
	// The refresh request must not be obsoleted (BCP: 2370078660)
[false, true].forEach(function (bSuspend) {
	QUnit.test("refresh list with $$sharedRequest, suspend=" + bSuspend, function (assert) {
		var oBinding1,
			oBinding3,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, sharedRequests : true}),
			sView = '\
<Text id="count1" text="{$count}"/>\
<Table id="table1" items="{/TEAMS}">\
	<Text id="name1" text="{Name}"/>\
	<Table items="{path : \'TEAM_2_EMPLOYEES\', templateShareable : true}">\
		<Text id="id1" text="{ID}"/>\
	</Table>\
</Table>\
<Text id="count2" text="{$count}"/>\
<Table id="table2" items="{/TEAMS}">\
	<Text id="name2" text="{Name}"/>\
	<Table items="{path : \'TEAM_2_EMPLOYEES\', templateShareable : true}">\
		<Text id="id2" text="{ID}"/>\
	</Table>\
</Table>\
<Table id="table3" items="{/TEAMS}">\
	<Text id="name3" text="{Name}"/>\
	<Table items="{path : \'TEAM_2_EMPLOYEES\', templateShareable : true}">\
		<Text id="id3" text="{ID}"/>\
	</Table>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Name,Team_Id&$expand=TEAM_2_EMPLOYEES($select=ID)"
				+ "&$skip=0&$top=100", {
				value : [
					{Team_Id : "1", Name : "Team #1", TEAM_2_EMPLOYEES : [{ID : "1"}]},
					{Team_Id : "2", Name : "Team #2", TEAM_2_EMPLOYEES : []}
				]
			})
			.expectChange("name1", ["Team #1", "Team #2"])
			.expectChange("name2", ["Team #1", "Team #2"])
			.expectChange("name3", ["Team #1", "Team #2"])
			.expectChange("count1")
			.expectChange("count2")
			.expectChange("id1", ["1"])
			.expectChange("id2", ["1"])
			.expectChange("id3", ["1"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("count1", "2")
				.expectChange("count2", "2");

			oBinding1 = that.oView.byId("table1").getBinding("items");
			that.oView.byId("count1").setBindingContext(oBinding1.getHeaderContext());
			that.oView.byId("count2").setBindingContext(
				that.oView.byId("table2").getBinding("items").getHeaderContext());

			return that.waitForChanges(assert, "count");
		}).then(function () {
			that.expectRequest("TEAMS?$select=Name,Team_Id&$expand=TEAM_2_EMPLOYEES($select=ID)"
					+ "&$skip=0&$top=100", {
					value : [
						{Team_Id : "1", Name : "Team #1", TEAM_2_EMPLOYEES : []},
						{Team_Id : "2", Name : "Team #2 (changed)", TEAM_2_EMPLOYEES : []},
						{Team_Id : "3", Name : "Team #3", TEAM_2_EMPLOYEES : []}
					]
				})
				.expectChange("name1", [, "Team #2 (changed)", "Team #3"])
				.expectChange("name2", [, "Team #2 (changed)", "Team #3"])
				.expectChange("count1", "3")
				.expectChange("count2", "3");

			oBinding3 = that.oView.byId("table3").getBinding("items");
			oBinding3.suspend();
			if (bSuspend) {
				oBinding1.suspend();
				oBinding1.refresh();
				oBinding1.resume();
			} else {
				oBinding1.refresh();
			}

			return that.waitForChanges(assert, "refresh");
		}).then(function () {
			that.expectChange("name3", [, "Team #2 (changed)", "Team #3"]);

			oBinding3.resume();

			return that.waitForChanges(assert, "resume 3rd binding");
		});
	});
});

	//*********************************************************************************************
	// Scenario: Refreshing a list with $$sharedRequest not using a non-standard group. Additionally
	// check that requestRefresh waits (for this purpose we let the request fail and check that
	// requestRefresh reports the error).
	// BCP: 002075129500004766202022
	QUnit.test("refresh list with $$sharedRequest, read error", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true, sharedRequests : true}),
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Text id="name" text="{Name}"/>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100", {
				value : [
					{Team_Id : "1", Name : "Team #1"},
					{Team_Id : "2", Name : "Team #2"}
				]
			})
			.expectChange("name", ["Team #1", "Team #2"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.oLogMock.expects("error")
				.withArgs("Failed to get contexts for " + sTeaBusi
					+ "TEAMS with start index 0 and length 100");
			that.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100",
					createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				that.oView.byId("table").getBinding("items").requestRefresh("$auto.foo")
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message, "Request intentionally failed");
					}),
				that.waitForChanges(assert, "refresh")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Refresh a binding with $$sharedRequest while a read request is pending.
	// BCP: 2370078660
	QUnit.test("BCP: 2370078660", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true, sharedRequests : true});
		const sView = `
<Table id="table" items="{path : '/TEAMS', suspended : true}">
	<Text id="name" text="{Name}"/>
</Table>`;

		this.expectChange("name", []);

		await this.createView(assert, sView, oModel);

		let fnResolve;
		const oResponsePromise = new Promise((resolve) => { fnResolve = resolve; });
		this.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100", oResponsePromise);

		const oBinding = this.oView.byId("table").getBinding("items");
		oBinding.resume();

		await this.waitForChanges(assert, "resume");

		this.expectCanceledError(
				"Failed to get contexts for /sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001"
					+ "/TEAMS with start index 0 and length 100",
				"Request is obsolete")
			.expectCanceledError(
				"Failed to get contexts for /sap/opu/odata4/IWBEP/TEA/default/IWBEP/TEA_BUSI/0001"
					+ "/TEAMS with start index 0 and length 100",
				"Request is obsolete")
			.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=100", {
				value : [
					{Team_Id : "1", Name : "Team #1"},
					{Team_Id : "2", Name : "Team #2"}
				]
			})
			.expectChange("name", ["Team #1", "Team #2"]);

		const oRefreshPromise = oBinding.requestRefresh();
		fnResolve(); // no need to give a result; it will be obsoleted anyway

		await Promise.all([
			oRefreshPromise,
			this.waitForChanges(assert, "refresh while resume request is pending")
		]);
	});

	//*********************************************************************************************
	// Scenario: Absolute property bindings for $count
	// 1. Refresh a simple absolute property binding for $count.
	// 2. Request absolute side effects that affect that simple binding twice - last one wins.
	// 3. (Quasi-)absolute property bindings for $count with system query options
	//    (JIRA: CPOUI5ODATAV4-1001)
	// 4. Request absolute side effects that affect all bindings for $count.
[false, true].forEach(function (bAutoExpandSelect) {
	var sTitle = "ODPrB: /SalesOrderList/$count, autoExpandSelect=" + bAutoExpandSelect;

	QUnit.test(sTitle, function (assert) {
		var sEntityContainer = "/com.sap.gateway.default.zui5_epm_sample.v0002.Container",
			oListBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : bAutoExpandSelect}),
			sView = '<Text id="count" text="{/SalesOrderList/$count}"/>',
			that = this;

		this.expectRequest("SalesOrderList/$count", 42)
			.expectChange("count", "42");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList/$count", 1234)
				.expectChange("count", "1,234"); // Edm.Int64 :-)

			// code under test
			that.oView.byId("count").getBinding("text").refresh();

			return that.waitForChanges(assert, "1");
		}).then(function () {
			// load $metadata for #requestSideEffects
			// (normally, this is done by auto-$expand/$select, but we have no real UI here)
			return oModel.getMetaModel().requestObject("/");
		}).then(function () {
			oListBinding = oModel.bindList("/SalesOrderList");

			that.expectRequest("SalesOrderList/$count", -1)
				.expectRequest("SalesOrderList/$count", 42)
				.expectCanceledError("Failed to read path /SalesOrderList/$count",
					sODPrB + ": /SalesOrderList/$count is ignoring response from inactive cache: "
						+ sSalesOrderService + "SalesOrderList/$count")
				.expectChange("count", "42");

			return Promise.all([
				// code under test
				oListBinding.getHeaderContext().requestSideEffects([
					sEntityContainer + "/SalesOrderList/$count"
				]),
				oListBinding.getHeaderContext().requestSideEffects([
					sEntityContainer + "/SalesOrderList/$count"
				]),
				that.waitForChanges(assert, "2")
			]);
		}).then(function () { // JIRA: CPOUI5ODATAV4-1001
			var oContext = oModel.createBindingContext("/SalesOrderList"),
				// code under test
				oCountBinding0 = oModel.bindProperty("/SalesOrderList/$count", null, {
					$apply : "A.P.P.L.E.",
					$filter : "GrossAmount gt 123",
					$search : "covfefe"
				}),
				// code under test
				oCountBinding1 = oModel.bindProperty("$count", oContext, {
					$apply : "A.P.P.L.E.",
					$filter : "GrossAmount gt 456",
					$search : "covfefe"
				}),
				// code under test
				oCountBinding2 = oModel.bindProperty("$count", null, {
					$apply : "A.P.P.L.E.",
					$filter : "GrossAmount gt 789",
					$search : "covfefe"
				});

			oCountBinding2.setContext(oContext);

			that.expectRequest("SalesOrderList/$count?$apply=A.P.P.L.E.&$filter=GrossAmount gt 123"
					+ "&$search=covfefe", 123)
				.expectRequest("SalesOrderList/$count?$apply=A.P.P.L.E.&$filter=GrossAmount gt 456"
					+ "&$search=covfefe", 456)
				.expectRequest("SalesOrderList/$count?$apply=A.P.P.L.E.&$filter=GrossAmount gt 789"
					+ "&$search=covfefe", 789);

			return Promise.all([
				oCountBinding0.requestValue(),
				oCountBinding1.requestValue(),
				oCountBinding2.requestValue(),
				that.waitForChanges(assert, "3")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], 123);
			assert.strictEqual(aResults[1], 456);
			assert.strictEqual(aResults[2], 789);

			that.expectRequest("SalesOrderList/$count", 1234)
				//TODO quasi-absolute bindings not affected?!
				.expectRequest("SalesOrderList/$count?$apply=A.P.P.L.E.&$filter=GrossAmount gt 123"
					+ "&$search=covfefe", 101)
				.expectChange("count", "1,234");

			return Promise.all([
				// code under test
				oListBinding.getHeaderContext().requestSideEffects([
					sEntityContainer + "/SalesOrderList"
				]),
				that.waitForChanges(assert, "4")
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: A parent binding is created with object values for $expand/$select. See that these
	// cannot be changed via #changeParameters in auto-$expand/$select mode.
	//
	// JIRA: CPOUI5ODATAV4-1098
	QUnit.test("ODPaB#changeParameters: object values", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			var mExpand = {SO_2_BP : {$select : ["BusinessPartnerRole"]}},
				aSelect = ["Note"],
				oContextBinding = oModel.bindContext("/SalesOrderList('1')", null, {
					$expand : mExpand,
					$select : aSelect
				});

			mExpand.SO_2_BP.$select.push("CompanyName");
			aSelect.push("NoteLanguage");

			assert.throws(function () {
				// code under test
				oContextBinding.changeParameters({$expand : mExpand, $select : aSelect});
			}, /Cannot change \$expand parameter in auto-\$expand\/\$select mode/);

			return that.waitForChanges(assert); // to get all group locks unlocked
		}).then(function () {
			var mExpand = {SO_2_BP : {$select : ["BusinessPartnerRole"]}},
				aSelect = ["Note"],
				oListBinding = oModel.bindList("/SalesOrderList", null, [], [], {
					$expand : mExpand,
					$select : aSelect
				});

			mExpand.SO_2_BP.$select.push("CompanyName");
			aSelect.push("NoteLanguage");

			assert.throws(function () {
				// code under test
				oListBinding.changeParameters({$expand : mExpand, $select : aSelect});
			}, /Cannot change \$expand parameter in auto-\$expand\/\$select mode/);

			return that.waitForChanges(assert); // to get all group locks unlocked
		});
	});

	//*********************************************************************************************
	// Scenario: Do not log drill-down errors for missing properties annotated with
	// @Core.Permissions: 'None'
	//
	// JIRA: CPOUI5ODATAV4-1065
	// JIRA: CPOUI5ODATAV4-1720 see that there is no EDM.Stream defaulting
	QUnit.test("Do not log drill-down errors for properties w/o permissions", function (assert) {
		var sView = '\
<FlexBox id="form" binding="{/Products(\'HT-1000\')}">\
	<Text id="id" text="{ID}"/>\
	<Text id="name" text="{Name}"/>\
	<Text id="supplier" text="{SupplierIdentifier}"/>\
	<Text id="picture" text="{ProductPicture/Picture}"/>\
</FlexBox>';

		this.expectRequest("Products('HT-1000')", {
				ID : 42,
				"Name@Core.Permissions" : 0,
				"SupplierIdentifier@Core.Permissions" : "None",
				ProductPicture : {
					"Picture@Core.Permissions" : 0
				}
			})
			.expectChange("id", "42")
			.expectChange("name", null)
			.expectChange("supplier", null)
			.expectChange("picture", undefined);

		return this.createView(assert, sView, this.createModel(
			"/sap/opu/odata4/IWBEP/TEA/default/iwbep/tea_busi_product/0001/", {}, {
				"/sap/opu/odata4/IWBEP/TEA/default/iwbep/tea_busi_product/0001/$metadata"
					: {source : "odata/v4/data/metadata_tea_busi_product.xml"}
			}));
	});

	//*********************************************************************************************
	// Scenario: Use an aggregation binding with no special refresher implementation.
	//
	// Background: Aggregation#refresh (in sap.ui.base.ManagedObjectMetadata) calls a refresher
	// implementation like sap.m.ListBase#refreshItems if available. The default behavior simply
	// falls back to sap.ui.base.ManagedObject#updateAggregation which calls ODLB#getContexts and
	// gets [] while the refresh request is in flight. It thus destroys all child controls because
	// it thinks there are too many of them. This in turn destroys their bindings, but our code
	// still tried to refresh those dependent bindings after we fired the "refresh" event.
	//
	// BCP: 002075129400006474012021
	QUnit.test("Do not refresh destroyed dependent bindings", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<IconTabBar id="employees" items="{/EMPLOYEES}">\
	<items>\
		<IconTabFilter key="foo">\
			<Text id="id__IN_LIST" text="{ID}"/>\
			<Table items="{path : \'EMPLOYEE_2_EQUIPMENTS\', templateShareable : false}">\
				<Text text="{Name}"/>\
			</Table>\
		</IconTabFilter>\
	</items>\
</IconTabBar>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID"
				+ "&$expand=EMPLOYEE_2_EQUIPMENTS($select=Category,ID,Name)&$skip=0&$top=100", {
					value : [{
						ID : "1",
						EMPLOYEE_2_EQUIPMENTS : []
					}]
			})
			// "__IN_LIST" confirms that control is in list, although no list/table seems present
			.expectChange("id__IN_LIST", ["1"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("EMPLOYEES?$select=ID"
					+ "&$expand=EMPLOYEE_2_EQUIPMENTS($select=Category,ID,Name)&$skip=0&$top=100", {
						value : [{
							ID : "2",
							EMPLOYEE_2_EQUIPMENTS : []
						}]
				})
				.expectChange("id__IN_LIST", ["2"]);

			return Promise.all([
				// code under test
				that.oView.byId("employees").getBinding("items").requestRefresh(),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Allow $$inheritExpandSelect in combination with $select
	// A bound operation inherits the $select query options from a parent list binding, but has its
	// own $select binding parameter.
	// (1) check that the inherited and own $select parameters are requested with the operation
	// (2) consume the return value context (this is a precondition for (3))
	// (3) check that refreshing the RVC requests the inherited and own $select parameters
	// but
	// (4) refreshing the parent list binding or
	// (5) refreshing the row context
	// does not request the $select parameters of the operation binding.
	//
	// JIRA: CPOUI5UISERVICESV3-1206
	QUnit.test("CPOUI5ODATAV4-1206: $$inheritExpandSelect with $select", function (assert) {
		var sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm",
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
	<Text id="lifecycleStatus" text="{LifecycleStatus}"/>\
</Table>\
<FlexBox id="objectPage">\
	<Text id="note" text="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=LifecycleStatus,SalesOrderID&$skip=0&$top=100", {
				value : [{SalesOrderID : "42", LifecycleStatus : "A"}]
			})
			.expectChange("salesOrderID", ["42"])
			.expectChange("lifecycleStatus", ["A"])
			.expectChange("note");

		return this.createView(assert, sView, oModel).then(function () {
			var oAction = oModel.bindContext(sAction + "(...)",
					that.oView.byId("table").getItems()[0].getBindingContext(),
					{$$inheritExpandSelect : true, $select : "Note,Messages,LifecycleStatus"});

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList('42')/" + sAction + "?$select=LifecycleStatus,Messages,"
						+ "Note,SalesOrderID",
					payload : {}
				}, {SalesOrderID : "42", LifecycleStatus : "B", Messages : [], Note : "some note"})
				.expectChange("lifecycleStatus", ["B"]);

			return Promise.all([
				// code under test
				oAction.invoke(),
				that.waitForChanges(assert, "(1) invoke")
			]);
		}).then(function (aResults) {
			that.expectChange("note", "some note");

			that.oView.byId("objectPage").setBindingContext(aResults[0]);

			return that.waitForChanges(assert, "(2) consume return value context");
		}).then(function () {
			that.expectRequest("SalesOrderList('42')?$select=LifecycleStatus,Messages,Note"
					+ ",SalesOrderID", {
					SalesOrderID : "42", LifecycleStatus : "B", Messages : [], Note : "changed note"
				}).expectChange("note", "changed note");

			// code under test
			that.oView.byId("objectPage").getBindingContext().refresh();

			return that.waitForChanges(assert, "(3) refresh return value context");
		}).then(function () {
			that.expectRequest("SalesOrderList('42')?$select=LifecycleStatus,SalesOrderID", {
					SalesOrderID : "42", LifecycleStatus : "C"
				})
				.expectChange("lifecycleStatus", ["C"]);

			// code under test
			that.oView.byId("table").getItems()[0].getBindingContext().refresh();

			return that.waitForChanges(assert, "(4) refresh row context");
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=LifecycleStatus,SalesOrderID"
				+ "&$skip=0&$top=100", {
					value : [{SalesOrderID : "42", LifecycleStatus : "D"}]
				})
				.expectChange("lifecycleStatus", ["D"]);

			// code under test
			that.oView.byId("table").getBinding("items").refresh();

			return that.waitForChanges(assert, "(5) refresh table");
		});
	});

	//*********************************************************************************************
	// Scenario: A property of a created-persisted entity in a binding w/o cache is modified, and
	// side effects are requested. Afterwards the PATCH fails.
	QUnit.test("BCP: 2280150835", function (assert) {
		var oCreatedContext,
			oListBinding,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oPromise,
			fnReject,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Table id="items" items="{SO_2_SOITEM}">\
		<Input id="note" value="{Note}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID)", {
				SalesOrderID : "1",
				SO_2_SOITEM : []
			})
			.expectChange("note", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("note", [""])
				.expectRequest({
					method : "POST",
					url : "SalesOrderList('1')/SO_2_SOITEM",
					payload : {}
				}, {
					ItemPosition : "10",
					Note : "initial",
					SalesOrderID : "1"
				})
				.expectChange("note", ["initial"]);

			oListBinding = that.oView.byId("items").getBinding("items");
			oCreatedContext = oListBinding.create({}, /*bSkipRefresh*/true);

			return Promise.all([
				oModel.submitBatch("update"),
				oCreatedContext.created(),
				that.waitForChanges(assert, "create and persist entity")
			]);
		}).then(function () {
			that.expectChange("note", ["modified"]);

			that.oView.byId("items").getItems()[0].getCells()[0].getBinding("value")
				.setValue("modified");

			return that.waitForChanges(assert, "patch");
		}).then(function () {
			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('1')/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')",
					payload : {Note : "modified"}
				}, new Promise(function (_resolve, reject) { fnReject = reject; }))
				.expectRequest("SalesOrderList('1')?$select=SO_2_SOITEM"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID)"
				); // no response required since the PATCH fails

			// code under test
			oPromise = that.oView.byId("form").getBindingContext()
				.requestSideEffects(["SO_2_SOITEM"]);
			oModel.submitBatch("update");

			return that.waitForChanges(assert, "requestSideEffects");
		}).then(function () {
			that.oLogMock.expects("error").withArgs(sinon.match("Failed to update path"));
			that.oLogMock.expects("error").withArgs("Failed to request side effects");
			that.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			fnReject(createErrorInsideBatch());

			return Promise.all([
				oPromise.then(mustFail(assert), function () {}),
				that.waitForChanges(assert, "response")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A property change fails. Before the error response arrives, the context is
	// destroyed. See that the error is still reported correctly.
	QUnit.test("BCP: 2280150835: update fails after context destroyed", function (assert) {
		var oForm,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "$direct"}),
			fnReject,
			sView = '\
<FlexBox id="form" binding="{}">\
	<Input id="note" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectChange("note");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=Note,SalesOrderID",
					{Note : "Note 1", SalesOrderID : "1"})
				.expectChange("note", "Note 1");

			oForm = that.oView.byId("form");
			oForm.setBindingContext(oModel.createBindingContext("/SalesOrderList('1')"));

			return that.waitForChanges(assert);
		}).then(function () {
			that.oLogMock.expects("error").twice().withArgs(sinon.match("Failed to update path"));
			that.expectChange("note", "Note 1 (changed)")
				.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('1')",
					payload : {Note : "Note 1 (changed)"}
				}, new Promise(function (_resolve, reject) { fnReject = reject; }));

			that.oView.byId("note").getBinding("value").setValue("Note 1 (changed)");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectRequest("SalesOrderList('2')?$select=Note,SalesOrderID",
					{Note : "Note 2", SalesOrderID : "2"})
				.expectChange("note", "Note 2")
				.expectMessages([{
						code : "CODE",
						message : "Request intentionally failed",
						persistent : true,
						technical : true,
						type : "Error"
					}]);

			oForm.setBindingContext(oModel.createBindingContext("/SalesOrderList('2')"));
			fnReject(createErrorInsideBatch()); // let the PATCH fail

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A table shows a visible area with three persisted rows. Three transient ones are
	// added at the end, outside of the visible area. The list is then filtered, sorted, etc.
	// Show that the transient ones properly survive.
	// JIRA: CPOUI5ODATAV4-1362
	//
	// Add refresh (JIRA: CPOUI5ODATAV4-1382) and side-effects refresh (JIRA: CPOUI5ODATAV4-1384)
	QUnit.test("CPOUI5ODATAV4-1362", function (assert) {
		var oBinding,
			oContextA,
			oContextB,
			oContextC,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			oTable,
			sView = '\
<t:Table id="table" rows="{parameters : {$count : true}, path : \'/TEAMS\'}" threshold="0"\
	visibleRowCount="3">\
	<Text id="id" text="{Team_Id}"/>\
	<Text id="name" text="{Name}"/>\
</t:Table>',
			that = this;

		this.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$skip=0&$top=3", {
				"@odata.count" : "3",
				value : [{
					Name : "Team #1",
					Team_Id : "TEAM_01"
				}, {
					Name : "Team #2",
					Team_Id : "TEAM_02"
				}, {
					Name : "Team #3",
					Team_Id : "TEAM_03"
				}]
			})
			.expectChange("id", ["TEAM_01", "TEAM_02", "TEAM_03"])
			.expectChange("name", ["Team #1", "Team #2", "Team #3"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			oContextA = oBinding.create({Name : "New Team A", Team_Id : "TEAM_A"}, true, true);
			oContextB = oBinding.create({Name : "New Team B", Team_Id : "TEAM_B"}, true, true);
			oContextC = oBinding.create({Name : "New Team C", Team_Id : "TEAM_C"}, true, true);

			return that.waitForChanges(assert, "create 3x transient at end");
		}).then(function () {
			that.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$orderby=Team_Id desc"
					+ "&$skip=0&$top=3", {
					"@odata.count" : "3",
					value : [{
						Name : "Team #3",
						Team_Id : "TEAM_03"
					}, {
						Name : "Team #2",
						Team_Id : "TEAM_02"
					}, {
						Name : "Team #1",
						Team_Id : "TEAM_01"
					}]
				})
				.expectChange("id", ["TEAM_03",, "TEAM_01"])
				.expectChange("name", ["Team #3",, "Team #1"]);

			// code under test
			assert.strictEqual(oBinding.hasPendingChanges(), true);
			assert.strictEqual(oBinding.hasPendingChanges(true), false);
			oBinding.sort(new Sorter("Team_Id", true));

			return that.waitForChanges(assert, "sort");
		}).then(function () {
			that.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$orderby=Team_Id desc"
					+ "&$filter=MANAGER_ID ne '666'&$skip=0&$top=3", {
					"@odata.count" : "2",
					value : [{
						Name : "Team #3",
						Team_Id : "TEAM_03"
					}, {
						Name : "Team #1",
						Team_Id : "TEAM_01"
					}]
				})
				.expectChange("id", [, "TEAM_01", "TEAM_A"])
				.expectChange("name", [, "Team #1", "New Team A"]);

			// code under test
			assert.strictEqual(oBinding.hasPendingChanges(), true);
			assert.strictEqual(oBinding.hasPendingChanges(true), false);
			oBinding.filter(new Filter("MANAGER_ID", FilterOperator.NE, 666));

			// code under test BCP: 2380097809
			const aContexts = oBinding.getAllCurrentContexts();

			assert.strictEqual(aContexts.length, 3);
			assert.strictEqual(aContexts[0], oContextC);
			assert.strictEqual(aContexts[1], oContextB);
			assert.strictEqual(aContexts[2], oContextA);

			return that.waitForChanges(assert, "filter");
		}).then(function () {
			that.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$orderby=Team_Id desc"
					+ "&$filter=MANAGER_ID ne '666'&$search=TDOP&$skip=0&$top=3", {
					"@odata.count" : "2",
					value : [{
						Name : "Team #3 TDO",
						Team_Id : "TEAM_03"
					}, {
						Name : "Team #1 T",
						Team_Id : "TEAM_01"
					}]
				})
				.expectChange("name", ["Team #3 TDO", "Team #1 T"]);

			// code under test
			assert.strictEqual(oBinding.hasPendingChanges(), true);
			assert.strictEqual(oBinding.hasPendingChanges(true), false);
			oBinding.changeParameters({$search : "TDOP"});

			return that.waitForChanges(assert, "change parameters");
		}).then(function () {
			that.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$orderby=Team_Id desc"
					+ "&$filter=MANAGER_ID ne '666'&$search=TDOP&$skip=0&$top=3", {
					"@odata.count" : "2",
					value : [{
						Name : "Team #3 *** TDO",
						Team_Id : "TEAM_03"
					}, {
						Name : "Team #1 * T",
						Team_Id : "TEAM_01"
					}]
				})
				.expectChange("name", ["Team #3 *** TDO", "Team #1 * T"]);

			return Promise.all([
				// code under test (JIRA: CPOUI5ODATAV4-1384)
				oBinding.getHeaderContext().requestSideEffects([""], "$auto"),
				that.waitForChanges(assert, "request side effects")
			]);
		}).then(function () {
			that.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$filter=MANAGER_ID ne '666'"
					+ "&$skip=0&$top=3", {
					"@odata.count" : "2",
					value : [{
						Name : "Team #1 * T",
						Team_Id : "TEAM_01"
					}, {
						Name : "Team #3 *** TDO",
						Team_Id : "TEAM_03"
					}]
				})
				.expectChange("id", ["TEAM_01", "TEAM_03"])
				.expectChange("name", ["Team #1 * T", "Team #3 *** TDO"]);

			// code under test
			assert.strictEqual(oBinding.hasPendingChanges(), true);
			assert.strictEqual(oBinding.hasPendingChanges(true), false);
			oBinding.suspend();
			oBinding.sort([]);
			// oBinding.filter([]); // do not drop this, it's good to have one transient visible!
			oBinding.changeParameters({$search : undefined});

			return Promise.all([
				oBinding.resumeAsync(),
				that.waitForChanges(assert, "suspend/resume")
			]);
		}).then(function () {
			that.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$filter=MANAGER_ID ne '666'"
					+ "&$skip=0&$top=3", {
					"@odata.count" : "2",
					value : [{
						Name : "Team #1 * T *",
						Team_Id : "TEAM_01"
					}, {
						Name : "Team #3 *** TDO ***",
						Team_Id : "TEAM_03"
					}]
				})
				.expectChange("name", ["Team #1 * T *", "Team #3 *** TDO ***"]);

			return Promise.all([
				// code under test (JIRA: CPOUI5ODATAV4-1382)
				oBinding.requestRefresh(),
				that.waitForChanges(assert, "refresh")
			]);
		}).then(function () {
			// Note: this proves that change listeners have survived the refresh
			that.expectChange("name", [,, "New A Team"]);

			oContextA.setProperty("Name", "New A Team");
			oContextB.setProperty("Name", "New B Team");
			oContextC.setProperty("Name", "New C Team");

			that.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {Name : "New A Team", Team_Id : "TEAM_A"}
				}, {Name : "New 'A' Team", Team_Id : "TEAM_A"})
				.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {Name : "New C Team", Team_Id : "TEAM_C"}
				}, {Name : "New 'C' Team", Team_Id : "TEAM_C"})
				.expectChange("name", [,, "New 'A' Team"]);

			return Promise.all([
				oContextA.created(),
				oContextB.delete(), // must not send a request!
				oContextB.created().then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message,
						"Request canceled: POST TEAMS; group: update"
					);
					assert.ok(oError.canceled);
				}),
				oContextC.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert, "submit")
			]);
		}).then(function () {
			that.expectChange("id", [, "TEAM_03", "TEAM_A", "TEAM_C"])
				.expectChange("name", [, "Team #3 *** TDO ***", "New 'A' Team", "New 'C' Team"]);

			oTable.setFirstVisibleRow(1);

			return that.waitForChanges(assert, "scroll down");
		});
	});

	//*********************************************************************************************
	// Scenario: A table shows a visible area with three persisted rows. Four transient ones are
	// added at the start, inside the visible area, and two of them are persisted. The list is then
	// either filtered, sorted, etc. Show that the transient ones properly survive, but the created
	// ones are removed.
	// JIRA: CPOUI5ODATAV4-1362
	//
	// The table's list binding is relative, but sends own requests. An ODCB with empty path in
	// between the root binding and the list binding is an addt'l hurdle for ignoring transient
	// rows on suspend.
	// JIRA: CPOUI5ODATAV4-1409
	//
	// Add refresh (JIRA: CPOUI5ODATAV4-1382) and side-effects refresh (JIRA: CPOUI5ODATAV4-1384)
	// and a refresh of a relative binding w/ $$ownRequest (JIRA: CPOUI5ODATAV4-2500)
	//
	// Show that a created persisted can stay kept-alive during refresh (JIRA: CPOUI5ODATAV4-1386)
[
	"changeParameters", "filter", "refresh", "resume", "sideEffectsRefresh", "sort"
].forEach(function (sMethod) {
	[false, true].forEach(function (bRelative) {
		var sTitle = "CPOUI5ODATAV4-1362: created persisted, " + sMethod
				+ ", $$ownRequest = " + bRelative;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oContextA,
			oContextB,
			oContextC,
			oContextD,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sTeams = bRelative ? "Departments(Sector='EMEA',ID='UI5')/DEPARTMENT_2_TEAMS" : "TEAMS",
			sView = bRelative ? '\
<FlexBox binding="{/Departments(Sector=\'EMEA\',ID=\'UI5\')}" id="objectPage">\
	<FlexBox binding="{}">\
		<t:Table id="table" threshold="0" visibleRowCount="4"\
			rows="{parameters : {$$ownRequest : true}, path : \'DEPARTMENT_2_TEAMS\'}">\
			<Text id="id" text="{Team_Id}"/>\
			<Text id="name" text="{Name}"/>\
		</t:Table>\
	</FlexBox>\
</FlexBox>' : '\
<t:Table id="table" rows="{/TEAMS}" threshold="0" visibleRowCount="4">\
	<Text id="id" text="{Team_Id}"/>\
	<Text id="name" text="{Name}"/>\
</t:Table>',
			that = this;

		this.expectRequest(sTeams + "?$select=Name,Team_Id&$skip=0&$top=4", {
				value : [{
					Name : "Team #1",
					Team_Id : "TEAM_01"
				}, {
					Name : "Team #2",
					Team_Id : "TEAM_02"
				}]
			})
			.expectChange("id", ["TEAM_01", "TEAM_02"])
			.expectChange("name", ["Team #1", "Team #2"]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("rows");

			that.expectChange("id", ["TEAM_B", "TEAM_A", "TEAM_01", "TEAM_02"])
				.expectChange("name", ["New Team B", "New Team A", "Team #1", "Team #2"]);

			oContextA = oBinding.create({Name : "New Team A", Team_Id : "TEAM_A"}, true);
			oContextB = oBinding.create({Name : "New Team B", Team_Id : "TEAM_B"}, true);

			that.expectRequest({
					method : "POST",
					url : sTeams,
					payload : {Name : "New Team A", Team_Id : "TEAM_A"}
				}, {Name : "New 'A' Team", Team_Id : "TEAM_A"})
				.expectRequest({
					method : "POST",
					url : sTeams,
					payload : {Name : "New Team B", Team_Id : "TEAM_B"}
				}, {Name : "New 'B' Team", Team_Id : "TEAM_B"})
				.expectChange("name", ["New 'B' Team", "New 'A' Team"]);

			return Promise.all([
				oContextA.created(),
				oContextB.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert, "2x created persisted")
			]);
		}).then(function () {
			that.expectChange("id", ["TEAM_D", "TEAM_C", "TEAM_B", "TEAM_A"])
				.expectChange("name", ["New Team D", "New Team C", "New 'B' Team", "New 'A' Team"]);

			oContextC = oBinding.create({Name : "New Team C", Team_Id : "TEAM_C"}, true);
			oContextD = oBinding.create({Name : "New Team D", Team_Id : "TEAM_D"}, true);

			return that.waitForChanges(assert, "2x transient");
		}).then(function () {
			var oPromise,
				oResult = {
					value : [{
						Name : "Team #2",
						Team_Id : "TEAM_02"
					}, {
						Name : "updateNonExisting ignores changes here!",
						Team_Id : "TEAM_A"
					}]
				},
				oResultA = {
					value : [{
						Name : "'A' Team",
						Team_Id : "TEAM_A"
					}]
				};

			assert.strictEqual(oBinding.hasPendingChanges(), true);
			assert.strictEqual(oBinding.hasPendingChanges(true), false);

			oContextA.setKeepAlive(true); // JIRA: CPOUI5ODATAV4-1386

			switch (sMethod) {
				case "changeParameters":
					that.expectRequest(sTeams + "?$select=Name,Team_Id&$search=TDOP&$skip=0&$top=2",
							oResult);

					// code under test
					oBinding.changeParameters({$search : "TDOP"});
					break;

				case "filter":
					that.expectRequest(sTeams + "?$select=Name,Team_Id&$filter=MANAGER_ID ne '666'"
							+ "&$skip=0&$top=2", oResult);

					// code under test
					oBinding.filter(new Filter("MANAGER_ID", FilterOperator.NE, "666"));
					break;

				case "refresh":
					that.expectRequest(sTeams + "?$select=Name,Team_Id&$filter=Team_Id eq 'TEAM_A'",
							oResultA)
						// Note: GET not yet processed, binding still "empty"
						.expectChange("name", [, "'A' Team"])
						.expectRequest(sTeams + "?$select=Name,Team_Id&$skip=0&$top=2", oResult);

					// code under test
					oPromise = oBinding.requestRefresh();
					break;

				case "resume":
					that.expectRequest(sTeams + "?$select=Name,Team_Id&$search=TDOP"
							+ "&$orderby=Team_Id desc&$filter=MANAGER_ID ne '666'&$skip=0&$top=2",
							oResult);

					// code under test
					oBinding.getRootBinding().suspend();
					oBinding.changeParameters({$search : "TDOP"});
					oBinding.filter(new Filter("MANAGER_ID", FilterOperator.NE, "666"));
					oBinding.sort(new Sorter("Team_Id", true));
					oPromise = oBinding.getRootBinding().resumeAsync();
					break;

				case "sideEffectsRefresh":
					that.expectRequest(sTeams + "?$select=Name,Team_Id&$filter=Team_Id eq 'TEAM_A'",
							oResultA)
						// Note: GET not yet processed, binding still "empty"
						.expectChange("name", [, "'A' Team"])
						.expectRequest(sTeams + "?$select=Name,Team_Id&$skip=0&$top=2", oResult);

					// code under test (JIRA: CPOUI5ODATAV4-1384)
					oPromise = oBinding.getHeaderContext().requestSideEffects([""], "$auto");
					break;

				case "sort":
					that.expectRequest(sTeams + "?$select=Name,Team_Id&$orderby=Team_Id desc"
							+ "&$skip=0&$top=2", oResult);

					// code under test
					oBinding.sort(new Sorter("Team_Id", true));
					break;

				// no default
			}

			that.expectChange("id", [,, "TEAM_02"])
				.expectChange("name", [,, "Team #2"]);

			return Promise.all([
				oPromise,
				that.waitForChanges(assert, sMethod)
			]);
		}).then(function () {
			// Note: this proves that change listeners have survived the refresh
			that.expectChange("name", ["New D Team", "New C Team"]);

			oContextC.setProperty("Name", "New C Team");
			oContextD.setProperty("Name", "New D Team");

			that.expectRequest({
					method : "POST",
					url : sTeams,
					payload : {Name : "New C Team", Team_Id : "TEAM_C"}
				}, {Name : "New 'C' Team", Team_Id : "TEAM_C"})
				.expectRequest({
					method : "POST",
					url : sTeams,
					payload : {Name : "New D Team", Team_Id : "TEAM_D"}
				}, {Name : "New 'D' Team", Team_Id : "TEAM_D"})
				.expectChange("name", ["New 'D' Team", "New 'C' Team"]);

			return Promise.all([
				oContextC.created(),
				oContextD.created(),
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert, "submit")
			]);
		}).then(function () {
			var aAllCurrentContexts = oBinding.getAllCurrentContexts();

			assert.deepEqual(aAllCurrentContexts.map(getPath), [
				"/" + sTeams + "('TEAM_D')",
				"/" + sTeams + "('TEAM_C')",
				"/" + sTeams + "('TEAM_02')",
				"/" + sTeams + "('TEAM_A')"
			]);
			assert.strictEqual(aAllCurrentContexts[0], oContextD, "D");
			assert.strictEqual(aAllCurrentContexts[1], oContextC, "C");
			assert.strictEqual(oContextB.getBinding(), undefined, "B already destroyed");
			assert.strictEqual(aAllCurrentContexts[3], oContextA, "A");
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: "browse & collect" - a table shows rows and some of them are selected, then the
	// table is filtered, hiding some originally selected rows, and more rows are selected. Still,
	// all selected rows are available any time. (A single selection should be enough. Various APIs
	// are used as well instead of filtering.)
	// A form is shown for the selected context to prove that late properties do not become part of
	// the table's $select. See that pending changes below the selected context can be ignored.
	// Create a new context, save and select it. Make a selected context visible again. Request a
	// side effect for all rows. Either delete via model or refresh with removal for a selected
	// context outside the collection. Refresh a single selected context inside the collection with
	// removal from the collection, but still implicitly kept alive.
	// JIRA: CPOUI5ODATAV4-2053
	//
	// Data binding for selection (JIRA: CPOUI5ODATAV4-1944).
[
	"changeParameters", "filter", "refresh", "resume", "sideEffectsRefresh", "sort"
].forEach(function (sMethod) {
	QUnit.test("CPOUI5ODATAV4-2053: browse & collect via " + sMethod, function (assert) {
		var oBinding,
			oCreatedContext,
			oContext_01,
			oContext_03,
			oExpectedNewObject = {
				"@$ui5.context.isSelected" : true,
				"@$ui5.context.isTransient" : false,
				MEMBER_COUNT : 0,
				Team_Id : "NEW"
			},
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = `
<t:Table id="table" rows="{/TEAMS}" threshold="0" visibleRowCount="3">
	<Text id="id" text="{Team_Id}"/>
<Text id="memberCount" text="{MEMBER_COUNT}"/>
</t:Table>
<FlexBox id="form">
	<Text id="name" text="{Name}"/>
</FlexBox>`,
			that = this;

		this.expectRequest("TEAMS?$select=MEMBER_COUNT,Team_Id&$skip=0&$top=3", {
				value : [{
					MEMBER_COUNT : 9,
					Team_Id : "TEAM_01"
				}, {
					MEMBER_COUNT : 10,
					Team_Id : "TEAM_02"
				}, {
					MEMBER_COUNT : 11,
					Team_Id : "TEAM_03"
				}]
			})
			.expectChange("id", ["TEAM_01", "TEAM_02", "TEAM_03"])
			.expectChange("memberCount", ["9", "10", "11"])
			.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			var aContexts;

			oBinding = that.oView.byId("table").getBinding("rows");

			aContexts = oBinding.getCurrentContexts();
			oContext_01 = aContexts[0];
			oContext_03 = aContexts[2]; // Note: selection should not make a difference here
			// code under test
			oContext_01.setSelected(true);

			that.expectRequest("TEAMS('TEAM_01')?$select=Name", {
					Name : "Team #1"
				})
				.expectChange("name", "Team #1");

			// code under test
			that.oView.byId("form").setBindingContext(oContext_01);

			return that.waitForChanges(assert, "object page with late property");
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {
						MEMBER_COUNT : 0,
						Team_Id : "NEW"
					}
				}, {
					MEMBER_COUNT : 0,
					Team_Id : "NEW"
				})
				.expectChange("id", ["NEW", "TEAM_01", "TEAM_02"])
				.expectChange("memberCount", ["0", "9", "10"]);

			oCreatedContext = oBinding.create({MEMBER_COUNT : 0, Team_Id : "NEW"}, true);

			// code under test
			oCreatedContext.setSelected(true);

			return Promise.all([
				oCreatedContext.created(),
				that.waitForChanges(assert, "create")
			]);
		}).then(function () {
			var sInfix = "",
				oPromise;

			if (sMethod === "refresh" || sMethod === "sideEffectsRefresh") {
				that.expectRequest("TEAMS?$select=MEMBER_COUNT,Name,Team_Id"
						+ "&$filter=Team_Id eq 'NEW' or Team_Id eq 'TEAM_01'&$top=2", {
						value : [{
							MEMBER_COUNT : 0,
							Name : "New Team",
							Team_Id : "NEW"
						}, {
							MEMBER_COUNT : 9,
							Name : "Team #1",
							Team_Id : "TEAM_01"
						}]
					});
				oExpectedNewObject.Name = "New Team";
			}

			switch (sMethod) {
				case "changeParameters":
					sInfix = "&$search=TDOP";

					// code under test
					oBinding.changeParameters({$search : "TDOP"});
					break;

				case "filter":
					sInfix = "&$filter=MEMBER_COUNT gt 10";

					// code under test
					oBinding.filter(new Filter("MEMBER_COUNT", FilterOperator.GT, 10));
					break;

				case "refresh":
					// code under test
					oPromise = oBinding.requestRefresh();
					break;

				case "resume":
					sInfix = "&$search=TDOP&$orderby=Team_Id desc&$filter=MEMBER_COUNT gt 10";

					// code under test
					oBinding.suspend();
					oBinding.changeParameters({$search : "TDOP"});
					oBinding.filter(new Filter("MEMBER_COUNT", FilterOperator.GT, 10));
					oBinding.sort(new Sorter("Team_Id", true));
					oPromise = oBinding.resumeAsync();
					break;

				case "sideEffectsRefresh":
					// code under test (JIRA: CPOUI5ODATAV4-1384)
					oPromise = oBinding.getHeaderContext().requestSideEffects([""]);
					break;

				case "sort":
					sInfix = "&$orderby=Team_Id desc";

					// code under test
					oBinding.sort(new Sorter("Team_Id", true));
					break;

				// no default
			}

			that.expectRequest("TEAMS?$select=MEMBER_COUNT,Team_Id" + sInfix + "&$skip=0&$top=3", {
					value : [{
						MEMBER_COUNT : 11,
						Team_Id : "TEAM_03"
					}]
				})
				.expectChange("id", ["TEAM_03"])
				.expectChange("memberCount", ["11"]);

			return Promise.all([
				oPromise,
				that.waitForChanges(assert, sMethod)
			]);
		}).then(function () {
			var aAllContexts = oBinding.getAllCurrentContexts();

			assert.strictEqual(aAllContexts.length, 3);
			assert.strictEqual(aAllContexts[0], oContext_03, "still the same");
			assert.strictEqual(aAllContexts[1], oContext_01, "implicitly kept alive");
			assert.strictEqual(aAllContexts[2], oCreatedContext, "implicitly kept alive");
			checkSelected(assert, oContext_01, true);
			assert.deepEqual(oContext_01.getObject(), {
				"@$ui5.context.isSelected" : true,
				MEMBER_COUNT : 9,
				Name : "Team #1",
				Team_Id : "TEAM_01"
			});
			checkSelected(assert, oCreatedContext, true);
			assert.deepEqual(oCreatedContext.getObject(), oExpectedNewObject);

			that.expectChange("name", "pending");
			oContext_01.setProperty("Name", "pending", "doNotSubmit");
			oModel.bindList("TEAM_2_EMPLOYEES", oContext_01, [], [],
					{$$updateGroupId : "doNotSubmit"})
				.create();

			assert.notOk(oBinding.hasPendingChanges(/*bIgnoreKeptAlive*/true));

			// code under test
			oContext_03.setSelected(true);

			// code under test
			oBinding.suspend();
			oBinding.changeParameters({$search : undefined});
			oBinding.filter(new Filter("MEMBER_COUNT", FilterOperator.LT, 10));
			oBinding.sort([]);

			that.expectRequest("TEAMS?$select=MEMBER_COUNT,Team_Id&$filter=MEMBER_COUNT lt 10"
					+ "&$skip=0&$top=3", {
					value : [{
						MEMBER_COUNT : 0,
						Team_Id : "NEW"
					}, {
						MEMBER_COUNT : 9,
						Team_Id : "TEAM_01"
					}]
				})
				.expectChange("id", ["NEW", "TEAM_01"])
				.expectChange("memberCount", ["0", "9"]);

			return Promise.all([
				oBinding.resumeAsync(),
				that.waitForChanges(assert, "some selected nodes become visible again")
			]);
		}).then(function () {
			var aAllContexts = oBinding.getAllCurrentContexts();

			assert.strictEqual(aAllContexts.length, 3);
			assert.strictEqual(aAllContexts[0], oCreatedContext);
			assert.strictEqual(aAllContexts[1], oContext_01);
			assert.strictEqual(aAllContexts[2], oContext_03);
			checkSelected(assert, oCreatedContext, true);
			assert.deepEqual(oCreatedContext.getObject(), oExpectedNewObject);
			checkSelected(assert, oContext_01, true);
			assert.deepEqual(oContext_01.getObject(), {
				"@$ui5.context.isSelected" : true,
				MEMBER_COUNT : 9,
				Name : "pending",
				Team_Id : "TEAM_01"
			});
			checkSelected(assert, oContext_03, true);
			assert.deepEqual(oContext_03.getObject(), {
				"@$ui5.context.isSelected" : true,
				MEMBER_COUNT : 11,
				Team_Id : "TEAM_03"
			});

			that.expectRequest("TEAMS?$select=MEMBER_COUNT,Team_Id"
					+ "&$filter=Team_Id eq 'NEW' or Team_Id eq 'TEAM_01' or Team_Id eq 'TEAM_03'"
					+ "&$top=3", {
					value : [{
						MEMBER_COUNT : 0,
						Team_Id : "NEW"
					}, {
						MEMBER_COUNT : 9,
						Team_Id : "TEAM_01"
					}, {
						MEMBER_COUNT : 11,
						Team_Id : "TEAM_03"
					}]
				});

			return Promise.all([
				// code under test
				oBinding.getHeaderContext().requestSideEffects(["MEMBER_COUNT"]),
				that.waitForChanges(assert, "side effect")
			]);
		}).then(function () {
			var aAllContexts = oBinding.getAllCurrentContexts();

			assert.strictEqual(aAllContexts.length, 3);
			assert.strictEqual(aAllContexts[0], oCreatedContext);
			assert.strictEqual(aAllContexts[1], oContext_01);
			assert.strictEqual(aAllContexts[2], oContext_03);

			// Note: method should not make a difference anymore at this point
			if (sMethod === "refresh") {
				that.expectRequest("TEAMS?$select=MEMBER_COUNT,Name,Team_Id"
						+ "&$filter=Team_Id eq 'TEAM_03'", {
						value : [] // gone for good
					});

				return Promise.all([
					oContext_03.requestRefresh("$auto", /*bAllowRemoval*/true), // code under test
					that.waitForChanges(assert,
						"refresh w/ removal of selected context outside collection")
				]);
			}

			that.expectRequest({
					headers : {
						"If-Match" : "*"
					},
					method : "DELETE",
					url : "TEAMS('TEAM_03')"
				});

			return Promise.all([
				oModel.delete("/TEAMS('TEAM_03')"), // code under test
				that.waitForChanges(assert, "delete selected context outside collection")
			]);
		}).then(function () {
			var aAllContexts = oBinding.getAllCurrentContexts();

			assert.strictEqual(aAllContexts.length, 2);
			assert.strictEqual(aAllContexts[0], oCreatedContext);
			assert.strictEqual(aAllContexts[1], oContext_01);
			// Note: oContext_03 has been removed due to deletion

			that.expectRequest("TEAMS?$select=MEMBER_COUNT,Name,Team_Id"
					+ "&$filter=Team_Id eq 'NEW'", {
					value : [{
						MEMBER_COUNT : 99,
						Name : "New Team",
						Team_Id : "NEW"
					}] // still alive
				})
				.expectRequest("TEAMS?$filter=(MEMBER_COUNT lt 10) and Team_Id eq 'NEW'"
					+ "&$count=true&$top=0", {
					"@odata.count" : "0", // sorry, too many members
					value : []
				})
				.expectChange("id", ["TEAM_01"])
				.expectChange("memberCount", ["9"]);
			oExpectedNewObject.MEMBER_COUNT = 99;
			oExpectedNewObject.Name = "New Team";

			// Note: "created" should not make a difference here, but
			// "Cannot refresh entity due to pending changes: /TEAMS('TEAM_01')[1;selected]"
			return Promise.all([
				oCreatedContext.requestRefresh("$auto", /*bAllowRemoval*/true), // code under test
				that.waitForChanges(assert,
					"refresh w/ removal of selected context inside collection")
			]);
		}).then(function () {
			var aAllContexts = oBinding.getAllCurrentContexts();

			assert.strictEqual(aAllContexts.length, 2);
			assert.strictEqual(aAllContexts[0], oContext_01);
			assert.strictEqual(aAllContexts[1], oCreatedContext, "implicitly kept alive");
			checkSelected(assert, oCreatedContext, true);
			assert.strictEqual(oCreatedContext.isTransient(), false, "created");
			delete oExpectedNewObject["@$ui5.context.isTransient"]; //TODO bug?!
			assert.deepEqual(oCreatedContext.getObject(), oExpectedNewObject);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Create a new context, save and select it. Have it drop out of the collection via a
	// refresh of the single context or the whole binding; see that it is destroyed because it does
	// not exist on the server anymore. Alternatively, cancel creation and see that the context is
	// destroyed. An inactive context must be kept intact all the time.
	// JIRA: CPOUI5ODATAV4-2053
[undefined, false, true].forEach(function (bSingle) {
	var sTitle = "CPOUI5ODATAV4-2053: removeCreated, w/ UI on top; bSingle=" + bSingle;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			bCancelCreation = bSingle === undefined,
			oCreatedContext,
			oInactiveContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			// Note: w/o a UI on top, ODLB#destroyLater behaves differently --> see next test
			sView = '\
<t:Table id="table" rows="{parameters : {$filter : \'MEMBER_COUNT gt 10\'}, path : \'/TEAMS\'}"\
		threshold="0" visibleRowCount="1">\
	<Text id="id" text="{Team_Id}"/>\
	<Text id="memberCount" text="{MEMBER_COUNT}"/>\
</t:Table>',
			that = this;

		this.expectRequest("TEAMS?$filter=MEMBER_COUNT gt 10&$select=MEMBER_COUNT,Team_Id"
				+ "&$skip=0&$top=1", {value : []})
			.expectChange("id", [])
			.expectChange("memberCount", []);

		return this.createView(assert, sView, oModel).then(function () {
			var oCreatedPromise;

			oBinding = that.oView.byId("table").getBinding("rows");

			that.expectChange("id", [bCancelCreation ? "???" : "NEW"])
				.expectChange("memberCount", [bCancelCreation ? null : "0"]);

			oInactiveContext = oBinding.create({Team_Id : "???"}, true, false, true);
			oCreatedContext = oBinding.create({MEMBER_COUNT : 0, Team_Id : "NEW"}, true);
			oCreatedPromise = oCreatedContext.created();

			// code under test
			oCreatedContext.setSelected(true);

			if (bCancelCreation) { // cancel creation now
				oCreatedContext.delete();
				oCreatedPromise = checkCanceled(assert, oCreatedPromise);
			} else {
				that.expectRequest({
						method : "POST",
						url : "TEAMS",
						payload : {
							MEMBER_COUNT : 0,
							Team_Id : "NEW"
						}
					}, {
						MEMBER_COUNT : 1,
						Team_Id : "NEW"
					})
					.expectChange("memberCount", ["1"]);
			}

			return Promise.all([
				oCreatedPromise,
				that.waitForChanges(assert, "create")
			]);
		}).then(function () {
			if (bCancelCreation) { // creation already canceled
				assert.notOk(oCreatedContext.isSelected(), "destroyed");
				// binding is already destroyed
				// assert.notOk(oCreatedContext.getProperty("@$ui5.context.isSelected"));
				assert.strictEqual(oCreatedContext.getModel(), undefined, "destroyed");

				return;
			}

			that.expectRequest("TEAMS?$filter=Team_Id eq 'NEW'&$select=MEMBER_COUNT,Team_Id", {
					value : []
				});
			if (bSingle) {
				that.expectRequest("TEAMS?$filter=(MEMBER_COUNT gt 10) and Team_Id eq 'NEW'"
						+ "&$count=true&$top=0", {
						"@odata.count" : "0",
						value : []
					})
					.expectChange("id", ["???"])
					.expectChange("memberCount", [null]);
			}

			return Promise.all([
				// code under test
				bSingle
				? oCreatedContext.requestRefresh("$auto", /*bAllowRemoval*/true)
				: oBinding.requestRefresh("$auto"),
				that.waitForChanges(assert, "removeCreated")
			]);
		}).then(function () {
			// Note: this invokes ODLB#destroyPreviousContextsLater, thus we need to wait below
			var aAllContexts = oBinding.getAllCurrentContexts();

			assert.strictEqual(aAllContexts.length, 1);
			assert.strictEqual(aAllContexts.shift(), oInactiveContext, "inactive kept intact");
			assert.strictEqual(oInactiveContext.isInactive(), true, "created, *inactive*");
			assert.strictEqual(oInactiveContext.isTransient(), true, "*created*, inactive");
			assert.deepEqual(oInactiveContext.getObject(), {
				"@$ui5.context.isInactive" : true,
				"@$ui5.context.isTransient" : true,
				Team_Id : "???"
			});

			return that.waitForChanges(assert, "ODLB#destroyPreviousContextsLater");
		}).then(function () {
			assert.notOk(oCreatedContext.isSelected(), "destroyed");
			// binding is already destroyed
			// assert.notOk(oCreatedContext.getProperty("@$ui5.context.isSelected"));
			assert.strictEqual(oCreatedContext.getModel(), undefined, "destroyed");
		});
	});
});

	//*********************************************************************************************
	// Scenario: Create a new context, save and select it. Have it drop out of the collection via a
	// refresh of the single context or the whole binding. See that it is not destroyed.
	// JIRA: CPOUI5ODATAV4-2053
	//
	// Data binding for selection (JIRA: CPOUI5ODATAV4-1944).
[false, true].forEach(function (bSingle) {
	[false, true].forEach(function (bUseAnnotation) {
	var sTitle = "CPOUI5ODATAV4-2053: removeCreated, w/o UI on top; bSingle=" + bSingle
		+ ", selection via annotation=" + bUseAnnotation;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oCreatedContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			oBinding = oModel.bindList("/TEAMS", null, [],
				[new Filter("MEMBER_COUNT", FilterOperator.GT, 10)]);

			that.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {
						MEMBER_COUNT : 0,
						Team_Id : "NEW"
					}
				}, {
					MEMBER_COUNT : 1,
					Team_Id : "NEW"
				});

			oCreatedContext = oBinding.create({MEMBER_COUNT : 0, Team_Id : "NEW"}, true);

			// code under test
			setSelected(bUseAnnotation, oCreatedContext, true);

			assert.ok(oCreatedContext.isSelected());

			return Promise.all([
				oCreatedContext.created(),
				that.waitForChanges(assert, "create")
			]);
		}).then(function () {
			assert.deepEqual(oCreatedContext.getObject(), {
				"@$ui5.context.isSelected" : true,
				"@$ui5.context.isTransient" : false,
				MEMBER_COUNT : 1,
				Team_Id : "NEW"
			});
			checkSelected(assert, oCreatedContext, true);

			that.expectRequest("TEAMS?$filter=Team_Id eq 'NEW'", {
					value : [{MEMBER_COUNT : 2, Team_Id : "NEW"}]
				});
			if (bSingle) {
				that.expectRequest("TEAMS?$filter=(MEMBER_COUNT gt 10) and Team_Id eq 'NEW'"
						+ "&$count=true&$top=0", {
						"@odata.count" : "0",
						value : []
					});
			}

			return Promise.all([
				// code under test
				bSingle
				? oCreatedContext.requestRefresh("$auto", /*bAllowRemoval*/true)
				: oBinding.requestRefresh("$auto"),
				that.waitForChanges(assert, "removeCreated")
			]);
		}).then(function () {
			var aAllContexts = oBinding.getAllCurrentContexts();

			assert.strictEqual(aAllContexts.length, 1);
			assert.strictEqual(aAllContexts[0], oCreatedContext, "implicitly kept alive");
			checkSelected(assert, oCreatedContext, true);
			assert.strictEqual(oCreatedContext.isTransient(), false, "created");
			assert.deepEqual(oCreatedContext.getObject(), bSingle ? {
				//TODO "@$ui5.context.isTransient" : false,
				"@$ui5.context.isSelected" : true,
				MEMBER_COUNT : 2,
				Team_Id : "NEW"
			} : {
				"@$ui5.context.isSelected" : true,
				"@$ui5.context.isTransient" : false,
				MEMBER_COUNT : 2,
				Team_Id : "NEW"
			});
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: A table shows a visible area with five persisted rows. Three transient ones are
	// added at the start, inside the visible area (two of them as inline creation rows, that is,
	// initially inactive). A side-effects refresh takes place and the GET is in the same $batch as
	// those POSTs. Show that the inline creation rows are kept in place and the persisted ones are
	// properly refreshed. Expect no "short read" - length remains unknown!
	// A 2nd side-effects refresh takes place, keeping the inline creation rows in place and
	// refreshing them separately, but one of them has been deleted on the server.
	// JIRA: CPOUI5ODATAV4-1384
	//
	// Prefetch compensates for exclusive filter, so that no extra GET is needed to replace the
	// deleted one inside the table's visible area.
	// JIRA: CPOUI5ODATAV4-1521
	//
	// A hint is sometimes given to use bSkipRefresh (BCP: 2370022413).
	QUnit.test("CPOUI5ODATAV4-1384: side-effects refresh at top", function (assert) {
		var oBinding,
			oContextA,
			oContextB,
			oContextC,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			// Note: threshold is either 0 or at least visibleRowCount
			sView = '\
<t:Table id="table" rows="{/TEAMS}" threshold="0" visibleRowCount="5">\
	<Text id="id" text="{Team_Id}"/>\
	<Text id="name" text="{Name}"/>\
</t:Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=5", {
				value : [
					{Name : "Team #1", Team_Id : "TEAM_01"},
					{Name : "Team #2", Team_Id : "TEAM_02"},
					{Name : "Team #3", Team_Id : "TEAM_03"},
					{Name : "Team #4", Team_Id : "TEAM_04"},
					{Name : "Team #5", Team_Id : "TEAM_05"}
				]
			})
			.expectChange("id", ["TEAM_01", "TEAM_02", "TEAM_03", "TEAM_04", "TEAM_05"])
			.expectChange("name", ["Team #1", "Team #2", "Team #3", "Team #4", "Team #5"]);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("rows");

			assert.strictEqual(oBinding.getCount(), undefined);
			assert.strictEqual(oBinding.getLength(), 15);
			assert.notOk(oBinding.isLengthFinal());

			that.expectChange("id", ["TEAM_C", "TEAM_B", "TEAM_A", "TEAM_01", "TEAM_02"])
				.expectChange("name",
					["New Team C", "New Team B", "New Team A", "Team #1", "Team #2"]);

			oContextA = oBinding.create({Team_Id : "TEAM_A"}, true, false, /*bInactive*/true);
			oContextA.setProperty("Name", "New Team A"); // activate
			oContextB = oBinding.create({Team_Id : "TEAM_B"}, true, false, /*bInactive*/true);
			oContextB.setProperty("Name", "New Team B"); // activate
			// code under test (BCP: 2370022413)
			oContextC = oBinding.create({Name : "New Team C", Team_Id : "TEAM_C"});

			return that.waitForChanges(assert, "3x transient");
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), undefined);
			assert.strictEqual(oBinding.getLength(), 18);
			assert.notOk(oBinding.isLengthFinal());
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getNormalizedPath), [
				"/TEAMS($uid=...)",
				"/TEAMS($uid=...)",
				"/TEAMS($uid=...)",
				"/TEAMS('TEAM_01')",
				"/TEAMS('TEAM_02')",
				"/TEAMS('TEAM_03')",
				"/TEAMS('TEAM_04')",
				"/TEAMS('TEAM_05')"
			]);

			that.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "TEAMS",
					payload : {Name : "New Team A", Team_Id : "TEAM_A"}
				}, {Name : "New 'A' Team", Team_Id : "TEAM_A"})
				.expectChange("name", [, "New 'A' Team"])
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "TEAMS",
					payload : {Name : "New Team B", Team_Id : "TEAM_B"}
				}, {"@odata.etag" : "b", Name : "New 'B' Team", Team_Id : "TEAM_B"})
				.expectChange("name", ["New 'B' Team"])
				.expectRequest({
					batchNo : 2,
					method : "POST",
					url : "TEAMS",
					payload : {Name : "New Team C", Team_Id : "TEAM_C"}
				}, {Name : "n/c", Team_Id : "TEAM_C"})
				// .expectChange("name", "New 'C' Team", -1) // would happen w/ bSkipRefresh
				.expectRequest({
					batchNo : 2,
					url : "TEAMS?$select=Name,Team_Id&$skip=0&$top=5"
				}, {
					value : [
						{Name : "n/a", Team_Id : "TEAM_A"},
						{Name : "'#1' Team", Team_Id : "TEAM_01"},
						{"@odata.etag" : "b", Name : "n/b", Team_Id : "TEAM_B"},
						{Name : "'#2' Team", Team_Id : "TEAM_02"},
						{Name : "New 'C' Team", Team_Id : "TEAM_C"}
					]
				})
				.expectChange("id", ["TEAM_B", "TEAM_A", "TEAM_01", "TEAM_02", "TEAM_C"])
				.expectChange("name",
					["New 'B' Team", "New 'A' Team", "'#1' Team", "'#2' Team", "New 'C' Team"])
				.expectRequest({ //TODO how to avoid this artefact?
					// _CollectionCache#read computes iCreatedPersisted = 2 because oBackup has not
					// yet been deleted (because oRefreshPromise not yet resolved); this extends
					// the prefetch unnecessarily here :-(
					batchNo : 3,
					url : "TEAMS?$select=Name,Team_Id"
						+ "&$filter=not (Team_Id eq 'TEAM_A' or Team_Id eq 'TEAM_B')&$skip=3&$top=2"
				}, {
					value : [
						{Name : "'#3' Team", Team_Id : "TEAM_03"},
						{Name : "'#4' Team", Team_Id : "TEAM_04"}
					]
				});

			return Promise.all([
				// code under test
				oBinding.getHeaderContext().requestSideEffects([""]),
				that.oModel.submitBatch("update"),
				oContextA.created(),
				oContextB.created(),
				oContextC.created().catch(function (oError) {
					assert.strictEqual(oError.message,
						"Cannot refresh. Hint: Side-effects refresh in parallel? "
						+ "/TEAMS('TEAM_C')[-3;transient]");
					assert.strictEqual(oContextC.toString(),
						"/TEAMS('TEAM_C')[-3;createdPersisted]", "Note: error was created earlier");
				}),
				that.waitForChanges(assert, "1st side-effects refresh")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), undefined);
			assert.strictEqual(oBinding.getLength(), 15);
			assert.notOk(oBinding.isLengthFinal());
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getPath), [
				"/TEAMS('TEAM_B')",
				"/TEAMS('TEAM_A')",
				"/TEAMS('TEAM_01')",
				"/TEAMS('TEAM_02')",
				"/TEAMS('TEAM_C')",
				"/TEAMS('TEAM_03')",
				"/TEAMS('TEAM_04')"
			]);

			that.expectRequest("TEAMS?$select=Name,Team_Id"
					+ "&$filter=Team_Id eq 'TEAM_A' or Team_Id eq 'TEAM_B'&$top=2", {
					value : [
						{Name : "'A' Team", Team_Id : "TEAM_A"}
						// {Name : "'B' Team", Team_Id : "TEAM_B"} // deleted on server
					]
				})
				.expectChange("name", [, "'A' Team"]) // #refreshKeptElements updates "on the fly"
				// prefetch compensates for exclusive filter (JIRA: CPOUI5ODATAV4-1521)
				.expectRequest("TEAMS?$select=Name,Team_Id"
					+ "&$filter=not (Team_Id eq 'TEAM_A' or Team_Id eq 'TEAM_B')&$skip=0&$top=5", {
					value : [
						{Name : "'#1' Team *", Team_Id : "TEAM_01"},
						{Name : "'#2' Team **", Team_Id : "TEAM_02"},
						{Name : "'#3' Team ***", Team_Id : "TEAM_03"},
						{Name : "'#4' Team ****", Team_Id : "TEAM_04"},
						{Name : "'#5' Team *****", Team_Id : "TEAM_05"}
					]
				})
				.expectChange("name",
					["'A' Team", "'#1' Team *", "'#2' Team **", "'#3' Team ***", "'#4' Team ****"])
				.expectChange("id", ["TEAM_A", "TEAM_01", "TEAM_02", "TEAM_03", "TEAM_04"]);

			return Promise.all([
				// code under test
				oBinding.getHeaderContext().requestSideEffects([""], "$auto"),
				that.waitForChanges(assert, "2nd side-effects refresh")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A table shows a visible area with five persisted rows. Three transient ones are
	// added at the end, inside the visible area (two of them as inline creation rows, that is,
	// initially inactive). A side-effects refresh takes place and the GET is in the same $batch as
	// those POSTs. Show that the inline creation rows are kept in place and the persisted ones are
	// properly refreshed. Expect no "short read" - count remains accurate!
	// A 2nd side-effects refresh takes place, keeping the inline creation rows in place and
	// refreshing them separately, but one of them has been deleted on the server.
	// JIRA: CPOUI5ODATAV4-1384
	//
	// Do not sent GET in same $batch as POSTs (JIRA: CPOUI5ODATAV4-1515)
	//
	// Prefetch compensates for exclusive filter, so that no extra GET is needed to replace the
	// deleted one inside the table's visible area.
	// JIRA: CPOUI5ODATAV4-1521
	QUnit.test("CPOUI5ODATAV4-1384: side-effects refresh at bottom", function (assert) {
		var oBinding,
			oContextA,
			oContextB,
			oContextC,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			oTable,
			// Note: threshold is either 0 or at least visibleRowCount
			sView = '\
<Text id="count" text="{headerContext>$count}"/>\
<t:Table id="table" rows="{path : \'/TEAMS\', parameters : {$count : true}}" threshold="0"\
		visibleRowCount="5">\
	<Text id="id" text="{Team_Id}"/>\
	<Text id="name" text="{Name}"/>\
</t:Table>',
			that = this;

		this.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$skip=0&$top=5", {
				"@odata.count" : "9",
				value : [
					{Name : "Team #1", Team_Id : "TEAM_01"},
					{Name : "Team #2", Team_Id : "TEAM_02"},
					{Name : "Team #3", Team_Id : "TEAM_03"},
					{Name : "Team #4", Team_Id : "TEAM_04"},
					{Name : "Team #5", Team_Id : "TEAM_05"}
				]
			})
			.expectChange("count")
			.expectChange("id", ["TEAM_01", "TEAM_02", "TEAM_03", "TEAM_04", "TEAM_05"])
			.expectChange("name", ["Team #1", "Team #2", "Team #3", "Team #4", "Team #5"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectChange("count", "9");

			// code under test
			that.oView.setModel(that.oView.getModel(), "headerContext");
			that.oView.byId("count").setBindingContext(oBinding.getHeaderContext(),
				"headerContext");

			return that.waitForChanges(assert, "$count");
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 9);
			assert.strictEqual(oBinding.getLength(), 9);
			assert.ok(oBinding.isLengthFinal());
			assert.strictEqual(oBinding.isFirstCreateAtEnd(), undefined);

			that.expectChange("count", "10");
			oContextA = oBinding.create({Team_Id : "TEAM_A"}, true, true, /*bInactive*/true);
			oContextA.setProperty("Name", "New A"); // activate
			that.expectChange("count", "11");
			oContextB = oBinding.create({Team_Id : "TEAM_B"}, true, true, /*bInactive*/true);
			oContextB.setProperty("Name", "New B"); // activate
			that.expectChange("count", "12");
			oContextC = oBinding.create({Name : "New C", Team_Id : "TEAM_C"}, true, true);

			assert.strictEqual(oBinding.getCount(), 12);
			assert.strictEqual(oBinding.getLength(), 12);
			assert.ok(oBinding.isLengthFinal());
			assert.strictEqual(oBinding.isFirstCreateAtEnd(), true);

			that.expectRequest("TEAMS?$count=true&$select=Name,Team_Id&$skip=7&$top=2", {
					"@odata.count" : "9",
					value : [
						{Name : "Team #8", Team_Id : "TEAM_08"},
						{Name : "Team #9", Team_Id : "TEAM_09"}
					]
				})
				.expectChange("id", [,,,,,,, "TEAM_08", "TEAM_09", "TEAM_A", "TEAM_B", "TEAM_C"])
				.expectChange("name", [,,,,,,, "Team #8", "Team #9", "New A", "New B", "New C"]);
			oTable.setFirstVisibleRow(7);

			return that.waitForChanges(assert, "3x transient at bottom");
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 12);
			assert.strictEqual(oBinding.getLength(), 12);
			assert.ok(oBinding.isLengthFinal());
			assert.strictEqual(oBinding.isFirstCreateAtEnd(), true);
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getNormalizedPath), [
				// Note: created ones are at the top here
				"/TEAMS($uid=...)",
				"/TEAMS($uid=...)",
				"/TEAMS($uid=...)",
				"/TEAMS('TEAM_01')",
				"/TEAMS('TEAM_02')",
				"/TEAMS('TEAM_03')",
				"/TEAMS('TEAM_04')",
				"/TEAMS('TEAM_05')",
				// Note: the gap is not visible here
				"/TEAMS('TEAM_08')",
				"/TEAMS('TEAM_09')"
			]);

			that.expectRequest({
					batchNo : 3,
					changeSetNo : 1,
					groupId : "update",
					method : "POST",
					url : "TEAMS",
					payload : {Name : "New A", Team_Id : "TEAM_A"}
				}, {Name : "'A' Team", Team_Id : "TEAM_A"})
				// Note: GET not yet processed, binding still "empty"
				.expectChange("name", ["'A' Team"])
				.expectRequest({
					batchNo : 3,
					changeSetNo : 1,
					groupId : "update",
					method : "POST",
					url : "TEAMS",
					payload : {Name : "New B", Team_Id : "TEAM_B"}
				}, {"@odata.etag" : "b", Name : "'B' Team", Team_Id : "TEAM_B"})
				.expectChange("name", [, "'B' Team"])
				.expectRequest({
					batchNo : 3,
					changeSetNo : 1,
					groupId : "update",
					method : "POST",
					url : "TEAMS",
					payload : {Name : "New C", Team_Id : "TEAM_C"}
				}, {Name : "n/c", Team_Id : "TEAM_C"})
				.expectChange("name", [,, "'C' Team"])
				.expectRequest({
					batchNo : 4,
					groupId : "$auto",
					// Note: expect no separate refresh immediately after creation
					// Note: TEAM_C is not an inline creation row!
					url : "TEAMS?$count=true&$select=Name,Team_Id"
						+ "&$filter=not (Team_Id eq 'TEAM_A' or Team_Id eq 'TEAM_B')&$skip=5&$top=9"
				}, {
					"@odata.count" : "10",
					value : [
						{Name : "'#6' Team", Team_Id : "TEAM_06"},
						{Name : "'#7' Team", Team_Id : "TEAM_07"},
						{Name : "'#8' Team", Team_Id : "TEAM_08"},
						{Name : "'C' Team", Team_Id : "TEAM_C"}, // this position matters!
						{Name : "'#9' Team", Team_Id : "TEAM_09"}
					]
				})
				.expectChange("id", [,,,,,,,, "TEAM_C", "TEAM_09", "TEAM_A", "TEAM_B"])
				.expectChange("name",
					[,,,,,,, "'#8' Team", "'C' Team", "'#9' Team", "'A' Team", "'B' Team"]);

			return Promise.all([
				// code under test
				oBinding.getHeaderContext().requestSideEffects([""]),
				that.oModel.submitBatch("update"),
				oContextA.created(),
				oContextB.created(),
				oContextC.created(),
				that.waitForChanges(assert, "1st side-effects refresh")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 12);
			assert.strictEqual(oBinding.getLength(), 12);
			assert.ok(oBinding.isLengthFinal());
			assert.strictEqual(oBinding.isFirstCreateAtEnd(), true);
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getNormalizedPath), [
				// Note: created ones are at the top here
				"/TEAMS('TEAM_B')",
				"/TEAMS('TEAM_A')",
				// Note: the gap is not visible here
				"/TEAMS('TEAM_06')",
				"/TEAMS('TEAM_07')",
				"/TEAMS('TEAM_08')",
				"/TEAMS('TEAM_C')",
				"/TEAMS('TEAM_09')"
			]);
			assert.deepEqual(oTable.getRows().map(getBindingContextPath), [
				"/TEAMS('TEAM_08')",
				"/TEAMS('TEAM_C')",
				"/TEAMS('TEAM_09')",
				"/TEAMS('TEAM_A')",
				"/TEAMS('TEAM_B')"
			]);

			that.expectRequest({
					batchNo : 5,
					groupId : "$auto",
					url : "TEAMS?$select=Name,Team_Id"
					+ "&$filter=Team_Id eq 'TEAM_A' or Team_Id eq 'TEAM_B'&$top=2"
				}, {
					value : [
						{Name : "Team 'A'", Team_Id : "TEAM_A"}
						// {Name : "Team 'B'", Team_Id : "TEAM_B"} // deleted on server
					]
				})
				// prefetch compensates for exclusive filter (JIRA: CPOUI5ODATAV4-1521)
				.expectRequest({
					batchNo : 5,
					groupId : "$auto",
					url : "TEAMS?$count=true&$select=Name,Team_Id"
					+ "&$filter=not (Team_Id eq 'TEAM_A' or Team_Id eq 'TEAM_B')&$skip=5&$top=9"
				}, {
					"@odata.count" : "10",
					value : [
						{Name : "Team no. 6", Team_Id : "TEAM_06"},
						{Name : "Team no. 7", Team_Id : "TEAM_07"},
						{Name : "Team no. 8", Team_Id : "TEAM_08"},
						{Name : "Team 'C'", Team_Id : "TEAM_C"},
						{Name : "Team no. 9", Team_Id : "TEAM_09"}
					]
				})
				.expectChange("count", "11")
				.expectChange("id", [,,,,,, "TEAM_07", "TEAM_08", "TEAM_C", "TEAM_09", "TEAM_A"])
				.expectChange("name",
					[,,,,,, "Team no. 7", "Team no. 8", "Team 'C'", "Team no. 9", "Team 'A'"]);

			return Promise.all([
				// code under test
				oBinding.getHeaderContext().requestSideEffects([""], "$auto"),
				that.waitForChanges(assert, "2nd side-effects refresh")
			]);
		}).then(function () {
			assert.strictEqual(oBinding.getCount(), 11);
			assert.strictEqual(oBinding.getLength(), 11);
			assert.ok(oBinding.isLengthFinal());
			assert.strictEqual(oBinding.isFirstCreateAtEnd(), true);
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getNormalizedPath), [
				// Note: created ones are at the top here
				"/TEAMS('TEAM_A')",
				// Note: the gap is not visible here
				"/TEAMS('TEAM_06')",
				"/TEAMS('TEAM_07')",
				"/TEAMS('TEAM_08')",
				"/TEAMS('TEAM_C')",
				"/TEAMS('TEAM_09')"
			]);
			assert.deepEqual(oTable.getRows().map(getBindingContextPath), [
				"/TEAMS('TEAM_07')",
				"/TEAMS('TEAM_08')",
				"/TEAMS('TEAM_C')",
				"/TEAMS('TEAM_09')",
				"/TEAMS('TEAM_A')"
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: side effects request on a SingleCache that failed to load its data.
	// BCP: 2280078004
	QUnit.test("requestSideEffects: broken SingleCache", function (assert) {
		var oModel = this.createTeaBusiModel(),
			sView = '\
<FlexBox id="form" binding="{/TEAMS(\'TEAM_01\')}">\
	<Text text="{Name}"/>\
</FlexBox>',
			that = this;

		this.oLogMock.expects("error").withArgs("Failed to read path /TEAMS('TEAM_01')/Name");
		this.oLogMock.expects("error").withArgs("Failed to read path /TEAMS('TEAM_01')");
		this.expectRequest("TEAMS('TEAM_01')", createErrorInsideBatch())
			.expectMessages([{
				code : "CODE",
				message : "Request intentionally failed",
				persistent : true,
				technical : true,
				type : "Error"
			}]);

		return Promise.all([
			// avoid that the metadata request disturbs the timing
			oModel.getMetaModel().requestObject("/"),
			that.createView(assert, sView, oModel)
		]).then(function () {
			// expect no request

			return Promise.all([
				that.oView.byId("form").getBindingContext().requestSideEffects(["Name"])
					.catch(function (oError) {
						assert.strictEqual(oError.message,
							sTeaBusi + "TEAMS('TEAM_01')"
							+ ": Cannot call requestSideEffects, cache is broken:"
							+ " Request intentionally failed");
					}),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: #getAllCurrentContexts returns contexts for all records that are available in the
	// collection cache of a list binding.
	// JIRA: CPOUI5ODATAV4-1402
	QUnit.test("OLDB#getAllCurrentContexts", function (assert) {
		var oBinding,
			oInput,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oTable,
			sView = '\
<t:Table id="table" rows="{/SalesOrderList}" threshold="2" visibleRowCount="2">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
	<Input id="grossAmount" value="{GrossAmount}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=0&$top=4", {
				value : [
					{SalesOrderID : "01", GrossAmount : "23"},
					{SalesOrderID : "02", GrossAmount : "23"},
					{SalesOrderID : "03", GrossAmount : "23"},
					{SalesOrderID : "04", GrossAmount : "23"}
				]
			})
			.expectChange("salesOrderID", ["01", "02"]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oBinding = oTable.getBinding("rows");

			that.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=6&$top=6", {
					value : [
						{SalesOrderID : "07", GrossAmount : "23"},
						{SalesOrderID : "08", GrossAmount : "23"},
						{SalesOrderID : "09", GrossAmount : "23"},
						{SalesOrderID : "10", GrossAmount : "23"},
						{SalesOrderID : "11", GrossAmount : "23"},
						{SalesOrderID : "12", GrossAmount : "23"}
					]
				})
				.expectChange("salesOrderID",
					[/*01*/, /*02*/, /*03*/, /*04*/, /*05*/, /*06*/, /*07*/, /*08*/, "09", "10"]);

			oTable.setFirstVisibleRow(8);

			return that.waitForChanges(assert);
		}).then(function () {
			oInput = oTable.getRows()[0].getCells()[1];

			that.expectMessages([{
					message : "EnterNumber",
					targets : [
						oInput.getId() + "/value"
					],
					type : "Error"
				}]);

			TestUtils.withNormalizedMessages(function () {
				oInput.setValue("INVALID");
			});

			// code under test
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getPath), [
				"/SalesOrderList('01')",
				"/SalesOrderList('02')",
				"/SalesOrderList('03')",
				"/SalesOrderList('04')",
				"/SalesOrderList('07')",
				"/SalesOrderList('08')",
				"/SalesOrderList('09')",
				"/SalesOrderList('10')",
				"/SalesOrderList('11')",
				"/SalesOrderList('12')"
			]);

			return Promise.all([
				that.checkValueState(assert, oInput, "Error", "EnterNumber"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			// Note: Because the invalid value has to be set via control, changes for that control
			// cannot be observed via expectChange.
			assert.strictEqual(oInput.getValue(), "INVALID");

			that.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=4&$top=2", {
					value : [
						{SalesOrderID : "05", GrossAmount : "23"},
						{SalesOrderID : "06", GrossAmount : "23"}
					]
				})
				.expectChange("salesOrderID", [/*01*/, /*02*/, /*03*/, /*04*/, "05", "06"])
				.expectMessages([]);

			oBinding.attachEventOnce("dataRequested", function () {
				// code under test
				assert.deepEqual(oBinding.getAllCurrentContexts().map(getPath), [
					"/SalesOrderList('01')",
					"/SalesOrderList('02')",
					"/SalesOrderList('03')",
					"/SalesOrderList('04')",
					"/SalesOrderList('07')",
					"/SalesOrderList('08')",
					"/SalesOrderList('09')",
					"/SalesOrderList('10')",
					"/SalesOrderList('11')",
					"/SalesOrderList('12')"
				]);
			});
			oTable.setFirstVisibleRow(4);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A binding tries to use $select=* with autoExpandSelect on.
	// BCP: 2280017225
	QUnit.test("BCP: 2280017225 - simplest case", function (assert) {
		var sView = '\
<FlexBox binding="{path : \'/SalesOrderList(\\\'1\\\')\', parameters : {$select : \'*\'}}">\
	<Text id="id" text="{SalesOrderID}"/>\
</FlexBox>';

		// Note: most properties are omitted from response data to improve readability
		this.expectRequest("SalesOrderList('1')?$select=*,SalesOrderID", {SalesOrderID : "1"})
			.expectChange("id", "1");

		return this.createView(assert, sView,
			this.createSalesOrdersModel({autoExpandSelect : true}));
	});
	//TODO w/ the following inside the FlexBox, there is a timing issue here with destroyed ODCB
	// (SOITEM_2_SO) trying to delegate ODPaB#fetchIfChildCanUseCache up...
	// <List items="{SO_2_SOITEM}">\
	//    <CustomListItem binding="{path : \'SOITEM_2_SO\', parameters : {$select : \'*\'}}">\
	//        <Text id="note" text="{Note}"/>

	//*********************************************************************************************
	// Scenario: A binding tries to use $select=SO_2_BP/* with autoExpandSelect on.
	// BCP: 2280017225
	QUnit.test("BCP: 2280017225 - select path ends with *", function (assert) {
		var sView = '\
<FlexBox binding="{path : \'/SalesOrderList(\\\'1\\\')\', parameters : {$select : \'SO_2_BP/*\'}}">\
	<Text id="name" text="{SO_2_BP/CompanyName}"/>\
</FlexBox>';

		this.expectRequest("SalesOrderList('1')?$select=SalesOrderID"
				+ "&$expand=SO_2_BP($select=*,BusinessPartnerID,CompanyName)", {
				SalesOrderID : "1",
				SO_2_BP : {
					BusinessPartnerID : "2",
					CompanyName : "SAP" // etc.
				}
			})
			.expectChange("name", "SAP");

		return this.createView(assert, sView,
			this.createSalesOrdersModel({autoExpandSelect : true}));
	});

	//*********************************************************************************************
	// Scenario: A binding tries to use $select=<namespace>.* with autoExpandSelect on in order to
	// retrieve all action/function advertisements.
	// BCP: 2280017225
	QUnit.test("BCP: 2280017225 - select a namespace", function (assert) {
		var sView = '\
<FlexBox binding="{path : \'/SalesOrderList(\\\'1\\\')\', parameters : {\
		$select : \'com.sap.gateway.default.zui5_epm_sample.v0002.*\'\
	}}">\
	<Text id="on"\
		text="{= !!%{#com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm} }"/>\
</FlexBox>';

		this.expectRequest("SalesOrderList('1')"
				+ "?$select=SalesOrderID,com.sap.gateway.default.zui5_epm_sample.v0002.*"
				// Note: the following could be absorbed, but who cares?
				+ ",com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm", {
				"#com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm" : {}, // etc.
				SalesOrderID : "1"
			})
			.expectChange("on", true);

		return this.createView(assert, sView,
			this.createSalesOrdersModel({autoExpandSelect : true}));
	});

	//*********************************************************************************************
	// Scenario: A message target contains a not normalized message target (the sort order of the
	// key predicate differs and the target has different percent encoding, for example with respect
	// to upper versus lower case). The UI5 message has to contain the normalized target and should
	// influence the value state of the corresponding control.
	//
	// JIRA: CPOUI5ODATAV4-1431
	// BCP: 2180384047
	QUnit.test("CPOUI5ODATAV4-1431: Normalize the message target", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{path : \'/SalesOrderList(\\\'42\\\')\', \
		parameters : {$select : \'Messages\'}}">\
	<Table id="productTable" items="{path : \'SO_2_BP/BP_2_PRODUCT\'}">\
		<Input id="height" value="{Height}"/>\
		<Input id="width" value="{Width}"/>\
	</Table>\
	<Table id="itemsTable" items="{path : \'SO_2_SOITEM\'}">\
		<Input id="note" value="{Note}"/>\
		<Input id="quantity" value="{Quantity}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('42')?$select=Messages,SalesOrderID&$expand="
			+ "SO_2_BP($select=BusinessPartnerID;"
				+ "$expand=BP_2_PRODUCT($select=Height,ProductID,Width)),"
			+ "SO_2_SOITEM($select=ItemPosition,Note,Quantity,SalesOrderID)", {
				Messages : [{
					// sort order of key properties
					code : "code 1",
					message : "Enter a minimum quantity of 2",
					numericSeverity : 3,
					target : "SO_2_SOITEM(ItemPosition='0010',SalesOrderID='42')/Quantity",
					additionalTargets : [
						"SO_2_SOITEM(ItemPosition='0010',SalesOrderID='42')/Note"
					]
				}, {
					// percent encoding (e.g. normalize upper- and lower-case)
					code : "code 2",
					message : "Some additional message",
					numericSeverity : 3,
					target : "SO_2_SOITEM(ItemPosition='0010',SalesOrderID='42%2f')/Quantity",
					additionalTargets : [
						"SO_2_SOITEM(ItemPosition='0010',SalesOrderID='42%2f')/Note"
					]
				}, { // only one key property (changing BO is intended, due insufficient meta data)
					code : "code 3",
					message : "Not more than twice as high as wide",
					numericSeverity : 3,
					target : "SO_2_BP/BP_2_PRODUCT(ProductID='HT-1024')/Height",
					additionalTargets : [
						"SO_2_BP/BP_2_PRODUCT('HT-1024')/Width"
					]
				}, { // percent encoding (with navigation property)
					code : "code 4",
					message : "some message",
					numericSeverity : 3,
					target : "SO_2_SOITEM(ItemPosition='0010',SalesOrderID='42%2f')"
						+ "/SOITEM_2_PRODUCT(ProductID='HT-1024')/Height",
					additionalTargets : [
						"SO_2_SOITEM(ItemPosition='0010',SalesOrderID='42%2f')"
							+ "/SOITEM_2_PRODUCT(ProductID='HT-1024')"
							+ "/PRODUCT_2_BP/BP_2_SO(SalesOrderID='42%2f')"
							+ "/SO_2_SOITEM(ItemPosition='0010',SalesOrderID='42%2f')"
					]
				}],
				SalesOrderID : "42",
				SO_2_BP : {
					BusinessPartnerID : "23",
					BP_2_PRODUCT : [{
						Height : "5",
						ProductID : "HT-1024",
						Width : "2"
					}]
				},
				SO_2_SOITEM : [{
					ItemPosition : "0010",
					Note : "some note",
					Quantity : "1",
					SalesOrderID : "42"
				}]
			})
			.expectChange("height", ["5.000"])
			.expectChange("width", ["2.000"])
			.expectChange("note", ["some note"])
			.expectChange("quantity", ["1.000"])
			.expectMessages([{
				code : "code 1",
				message : "Enter a minimum quantity of 2",
				targets : [
					"/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0010')"
						+ "/Quantity",
					"/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42',ItemPosition='0010')"
						+ "/Note"
				],
				type : "Warning"
			}, {
				code : "code 2",
				message : "Some additional message",
				targets : [
					"/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42%2F',ItemPosition='0010')"
						+ "/Quantity",
					"/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42%2F',ItemPosition='0010')"
						+ "/Note"
				],
				type : "Warning"
			}, {
				code : "code 3",
				message : "Not more than twice as high as wide",
				targets : [
					"/SalesOrderList('42')/SO_2_BP/BP_2_PRODUCT('HT-1024')/Height",
					"/SalesOrderList('42')/SO_2_BP/BP_2_PRODUCT('HT-1024')/Width"
				],
				type : "Warning"
			}, {
				code : "code 4",
				message : "some message",
				targets : [
					"/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42%2F',ItemPosition='0010')"
						+ "/SOITEM_2_PRODUCT('HT-1024')/Height",
					"/SalesOrderList('42')/SO_2_SOITEM(SalesOrderID='42%2F',ItemPosition='0010')"
						+ "/SOITEM_2_PRODUCT('HT-1024')/PRODUCT_2_BP/BP_2_SO('42%2F')"
						+ "/SO_2_SOITEM(SalesOrderID='42%2F',ItemPosition='0010')"
				],
				type : "Warning"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			var oProductTable = that.oView.byId("productTable"),
				oInputHeight = oProductTable.getItems()[0].getCells()[0],
				oInputWidth = oProductTable.getItems()[0].getCells()[1],
				oItemsTable = that.oView.byId("itemsTable"),
				oInputNote = oItemsTable.getItems()[0].getCells()[0],
				oInputQuantity = oItemsTable.getItems()[0].getCells()[1];

			return Promise.all([
				that.checkValueState(assert, oInputHeight, "Warning",
					"Not more than twice as high as wide"),
				that.checkValueState(assert, oInputWidth, "Warning",
					"Not more than twice as high as wide"),
				that.checkValueState(assert, oInputNote, "Warning",
					"Enter a minimum quantity of 2"),
				that.checkValueState(assert, oInputQuantity, "Warning",
					"Enter a minimum quantity of 2")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A header message target contains a not normalized message target (the sort order of
	// the key predicate differs). The UI5 message has to contain the normalized target.
	//
	// JIRA: CPOUI5ODATAV4-1431
	// BCP: 2180384047
	QUnit.test("CPOUI5ODATAV4-1431: Header messages normalize targets", function (assert) {
		var aMessages = [{
				code : "foo-42",
				message : "text",
				numericSeverity : 1,
				target : "TEAM_2_EMPLOYEES(ID='1')"
					+ "/EMPLOYEE_2_EQUIPMENTS(ID='33',Category='Electronics')/Name"
			}],
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox binding="{/TEAMS(\'42\')}">\
<Text id="id" text="{Team_Id}"/>\
</FlexBox>';

		function withTransition(oObject) {
			return Object.assign({}, {transition : true}, oObject);
		}

		this.expectRequest("TEAMS('42')?$select=Team_Id", {Team_Id : "23"}, {
				"sap-messages" : JSON.stringify(aMessages)
			})
			.expectMessages([{
				code : "foo-42",
				message : "text",
				persistent : true,
				target : "/TEAMS('42')/TEAM_2_EMPLOYEES('1')"
					+ "/EMPLOYEE_2_EQUIPMENTS(Category='Electronics',ID='33')/Name",
				technicalDetails : {
					originalMessage : withTransition(aMessages[0])
				},
				type : "Success"
			}])
			.expectChange("id", "23");

		return this.createView(assert, sView, oModel);
	});

	//*********************************************************************************************
	// Scenario: While a POST request is in flight, a property is updated. For an inline creation
	// row, data is entered in one field, sending the POST, and then in another before that POST has
	// returned. No error must happen and user input must win over server's default value. This
	// must also work if the 1st POST fails (PATCH is then still merged).
	// JIRA: CPOUI5ODATAV4-1583
	// JIRA: CPOUI5ODATAV4-1600
[false, true].forEach(function (bSkipRefresh) {
	QUnit.test("JIRA: CPOUI5ODATAV4-1583, bSkipRefresh=" + bSkipRefresh, function (assert) {
		var oBinding,
			oContext,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			fnRespond0,
			fnRespond1,
			sView = '\
<t:Table id="table" rows="{/EMPLOYEES}">\
	<Text id="id" text="{ID}"/>\
	<Text id="name" text="{Name}"/>\
	<Text id="salary" text="{SALARY/MONTHLY_BASIC_SALARY_AMOUNT}"/>\
	<Text id="salaryCurrency" text="{SALARY/BASIC_SALARY_CURR}"/>\
</t:Table>',
			that = this;

		this.expectRequest("EMPLOYEES?$select=ID,Name,SALARY/BASIC_SALARY_CURR,"
			+ "SALARY/MONTHLY_BASIC_SALARY_AMOUNT&$skip=0&$top=110",
				{value : []})
			.expectChange("id", [])
			.expectChange("name", [])
			.expectChange("salary", [])
			.expectChange("salaryCurrency", []);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("rows");
			oContext = oBinding.create({}, bSkipRefresh, /*bAtEnd*/false, /*bInactive*/true);

			that.expectChange("id", [""])
				.expectChange("name", ["New A"])
				.expectChange("salary", [null])
				.expectChange("salaryCurrency", [""])
				.expectRequest({
					method : "POST",
					payload : {Name : "New A"},
					url : "EMPLOYEES"
				}, new Promise(function (_resolve, reject) {
					fnRespond0 = reject.bind(null, createError()); // take care of timing
				}));

			oContext.setProperty("Name", "New A"); // activate

			return that.waitForChanges(assert, "activate");
		}).then(function () {
			that.expectChange("salaryCurrency", ["GBP"]);

			// code under test
			oContext.setProperty("SALARY/BASIC_SALARY_CURR", "GBP");

			return that.waitForChanges(assert, "1st update");
		}).then(function () {
			that.oLogMock.expects("error").withArgs("$batch failed");
			that.oLogMock.expects("error")
				.withArgs("POST on 'EMPLOYEES' failed; will be repeated automatically");
			that.expectMessages([{
					message : "Communication error: 500 ",
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					message : "HTTP request was not processed because $batch failed",
					persistent : true,
					technical : true,
					type : "Error"
				}])
				.expectRequest({
					method : "POST",
					// Note: PATCH is merged into POST
					payload : {
						SALARY : {
							BASIC_SALARY_CURR : "GBP"
						},
						Name : "New A"
					},
					url : "EMPLOYEES"
				}, new Promise(function (resolve) {
					fnRespond1 = resolve.bind(null, {
						"@odata.etag" : "etag0",
						SALARY : {
							MONTHLY_BASIC_SALARY_AMOUNT : "0", //CPOUI5ODATAV4-1600: 1234 survives
							BASIC_SALARY_CURR : "EUR"
						},
						Name : "New Employee A",
						ID : "A"
					});
				}));

			fnRespond0();

			return that.waitForChanges(assert, "1st response");
		}).then(function () {
			that.expectChange("salary", ["1,234"]);

			// code under test
			oContext.setProperty("SALARY/MONTHLY_BASIC_SALARY_AMOUNT", "1234");

			return that.waitForChanges(assert, "2nd update");
		}).then(function () {
			that.expectChange("id", ["A"])
				.expectChange("name", ["New Employee A"])
				.expectChange("salaryCurrency", ["EUR"]);
			if (!bSkipRefresh) {
				that.expectRequest("EMPLOYEES('A')?$select=ID,Name,SALARY/BASIC_SALARY_CURR,"
					+ "SALARY/MONTHLY_BASIC_SALARY_AMOUNT", {
					"@odata.etag" : "etag1",
					SALARY : {
						MONTHLY_BASIC_SALARY_AMOUNT : "1", //CPOUI5ODATAV4-1600: 1234 survives
						BASIC_SALARY_CURR : "DEM"
					},
					Name : "New Employee 'A'",
					ID : "A"
					})
					.expectChange("name", ["New Employee 'A'"])
					.expectChange("salaryCurrency", ["DEM"]);
			}
			that.expectRequest({
					headers : {"If-Match" : bSkipRefresh ? "etag0" : "etag1"},
					method : "PATCH",
					// Note: up-to-date currency value is used!
					payload : {
						SALARY : {
							MONTHLY_BASIC_SALARY_AMOUNT : "1234",
							BASIC_SALARY_CURR : bSkipRefresh ? "EUR" : "DEM"
						}
					},
					url : "EMPLOYEES('A')"
				}, {
					"@odata.etag" : "etag2",
					SALARY : {
						MONTHLY_BASIC_SALARY_AMOUNT : "4321",
						BASIC_SALARY_CURR : "USD"
					},
					Name : "'A' Team",
					ID : "A"
				})
				.expectChange("name", ["'A' Team"])
				.expectChange("salary", ["4,321"])
				.expectChange("salaryCurrency", ["USD"]);

			fnRespond1();

			return that.waitForChanges(assert, "2nd response");
		}).then(function () {
			assert.strictEqual(oContext.getProperty("@odata.etag"), "etag2");
		});
	});
});

	//*********************************************************************************************
	// Scenario: A table shows a visible area with one persisted row. Two inline creation rows are
	// added at the end, inside the visible area, when data is received. There is an ODCB with empty
	// path inside the row template so that oCachePromise becomes pending again. This lead to a
	// "Failed to drill-down into ($uid=id-...), invalid segment: ($uid=id-...)" issue inside
	// ODLB#create.
	// BCP: 2270085667
	QUnit.test("BCP: 2270085667", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<t:Table id="table" rows="{path : \'TEAMS\', parameters : {$$ownRequest : true}}">\
	<Text id="id" text="{Team_Id}"/>\
	<Text binding="{}" id="name" text="{Name}"/>\
</t:Table>',
			that = this;

		this.expectChange("id", [])
			.expectChange("name", []);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("table").getBinding("rows"),
				oRootContext = that.oModel.createBindingContext("/");

			function addInlineCreationRows() {
				oBinding.create({Team_Id : "TEAM_A"}, true, true, /*bInactive*/true);
				oBinding.create({Team_Id : "TEAM_B"}, true, true, /*bInactive*/true);
			}

			oBinding.attachDataReceived(function () {
				// that's the way you do it ;-) (kind of, in real life)
				Promise.resolve().then(addInlineCreationRows);
			});

			that.expectRequest("TEAMS?$select=Name,Team_Id&$skip=0&$top=110", {
					value : [
						{Name : "Team #1", Team_Id : "TEAM_01"}
					]
				})
				.expectChange("id", ["TEAM_01", "TEAM_A", "TEAM_B"])
				.expectChange("name", ["Team #1", "", ""]);

			// t:Table does not support initially suspended rows binding :-(
			oBinding.setContext(oRootContext);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Create three inactive contexts on a table. Show how to use the createActivate
	// event for required properties (to control activation of the contexts).
	// JIRA: CPOUI5ODATAV4-1582
	//
	// Reset changes on the binding (CPOUI5ODATAV4-1867), context, and model (CPOUI5ODATAV4-1942) to
	// reset the contexts to their initial inactive state including initial data. "Normal" inactive
	// rows are unaffected.
["binding", "context", "model"].forEach(function (sCase) {
	var sTitle = "Creation Rows: Support for required properties, reset at " + sCase;

	QUnit.test(sTitle, function (assert) {
		var oBinding,
			oContext1,
			oContext2,
			oContext3,
			oContext4,
			oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<Table id="table" items="{/TEAMS}">\
	<Input id="id" value="{Team_Id}"/>\
	<Input id="name" value="{Name}"/>\
	<Input id="budget" value="{Budget}"/>\
	<Text id="inactive" text="{= %{@$ui5.context.isInactive} }"/>\
</Table>',
			that = this;

		function checkStates(vInactiveCtx1, vInactiveCtx2, vInactiveCtx3, bChangesCtx1,
			bChangesCtx2, bChangesBinding, bChangesBindingFlag, bChangesModel) {
			// code under test
			assert.strictEqual(oContext1.isInactive(), vInactiveCtx1);
			assert.strictEqual(oContext2.isInactive(), vInactiveCtx2);
			assert.strictEqual(oContext3.isInactive(), vInactiveCtx3);

			// code under test
			assert.strictEqual(oContext1.hasPendingChanges(), bChangesCtx1);
			assert.strictEqual(oContext2.hasPendingChanges(), bChangesCtx2);
			assert.strictEqual(oBinding.hasPendingChanges(), bChangesBinding);
			assert.strictEqual(oBinding.hasPendingChanges(true), bChangesBindingFlag);
			assert.strictEqual(oModel.hasPendingChanges(), bChangesModel);
		}

		that.expectRequest("TEAMS?$select=Budget,Name,Team_Id&$skip=0&$top=100", {value : []})
			.expectChange("id", [])
			.expectChange("name", [])
			.expectChange("budget", [])
			.expectChange("inactive", []);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");

			oBinding.attachCreateActivate(function (oEvent) {
				const oContext = oEvent.getParameter("context");
				assert.ok(oContext.isInactive());
				assert.strictEqual(
					oContext.isInactive(),
					oContext.getProperty("@$ui5.context.isInactive"));
				if (!oContext.getProperty("Team_Id")) {
					// code under test
					oEvent.preventDefault();
				} else {
					oContext.setProperty("BudgetCurrency", "EUR");
				}
			});

			that.expectChange("id", ["", "", ""])
				.expectChange("name", ["", "Team #2 inactive", ""])
				.expectChange("budget", [null, null, null])
				.expectChange("inactive", [true, true, true]);

			oContext1 = oBinding.create(undefined, true, true, /*bInactive*/true);
			oContext2 = oBinding.create({Name : "Team #2 inactive"}, true, true, /*bInactive*/true);
			oContext3 = oBinding.create(undefined, true, true, /*bInactive*/true);

			// inactive: ctx1, ctx2, ctx3; pendingChanges: ctx1, ctx2, ODLB, ODLB(true), ODM
			checkStates(true, true, true, false, false, false, false, false, false);

			return that.waitForChanges(assert, "create inactive");
		}).then(function () {
			// no requests
			that.expectChange("name", ["Team #1 edited", "Team #2 edited", "Team #3 edited"])
				.expectChange("budget", [, "5,000"])
				.expectChange("inactive", [1, 1, 1]);

			// code under test
			oContext1.setProperty("Name", "Team #1 edited");
			oContext2.setProperty("Name", "Team #2 edited");
			oContext2.setProperty("Budget", 5000);
			oContext3.setProperty("Name", "Team #3 edited");

			// inactive: ctx1, ctx2, ctx3; pendingChanges: ctx1, ctx2, ODLB, ODLB(true), ODM
			checkStates(1, 1, 1, true, true, true, false, false);

			return Promise.all([
				oContext3.created().then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message,
						"Request canceled: POST TEAMS; group: $inactive.$auto");
					assert.ok(oError.canceled);
				}),
				// deleting an edited inactive context works as expected
				oContext3.delete(),
				that.waitForChanges(assert, "edit, delete context 3")
			]);
		}).then(function () {
			if (sCase === "context") {
				that.expectRequest({
						method : "POST",
						url : "TEAMS",
						payload : {
							BudgetCurrency : "EUR",
							Name : "Team #1 edited",
							Team_Id : "TEAM_01"
						}
					}, {
						Budget : 0,
						Name : "Team #1 persisted",
						Team_Id : "TEAM_01"
					})
					.expectChange("id", ["TEAM_01"])
					.expectChange("name", ["Team #1 persisted", "Team #2 inactive"])
					.expectChange("budget", ["0", null])
					.expectChange("inactive", [false, true]);

				// code under test
				oContext1.setProperty("Team_Id", "TEAM_01");
				oContext2.resetChanges();

				// ctx1 is now active but still transient
				// inactive: ctx1, ctx2, ctx3; pendingChanges: ctx1, ctx2, ODLB, ODLB(true), ODM
				checkStates(false, true, undefined, true, false, true, false, true);
			} else {
				that.expectChange("id", [,, ""])
					.expectChange("name", ["", "Team #2 inactive", ""])
					.expectChange("budget", [, null, null])
					.expectChange("inactive", [true, true, true]);

				// resetChanges should not delete a inactive row
				oContext4 = oBinding.create(undefined, true, true, /*bInactive*/true);
				assert.strictEqual(oContext4.isInactive(), true);

				if (sCase === "binding") {
					// code under test
					oBinding.resetChanges();
				} else {
					// code under test
					oModel.resetChanges();
				}

				// inactive: ctx1, ctx2, ctx3; pendingChanges: ctx1, ctx2, ODLB, ODLB(true), ODM
				checkStates(true, true, undefined, false, false, false, false, false);
				assert.strictEqual(oContext4.isInactive(), true);
			}

			return Promise.all([
				sCase === "context" && oContext1.created(),
				that.waitForChanges(assert, "resetChanges")
			]);
		}).then(function () {
			that.expectRequest({
				method : "POST",
				url : "TEAMS",
				payload : {
					BudgetCurrency : "EUR",
					Name : "Team #2 inactive",
					Team_Id : "TEAM_02"
				}
			}, {
				Budget : 0,
				Name : "Team #2 persisted",
				Team_Id : "TEAM_02"
			})
			.expectChange("id", [, "TEAM_02"])
			.expectChange("name", [, "Team #2 persisted"])
			.expectChange("budget", [, "0"])
			.expectChange("inactive", [, false]);

			// code under test
			oContext2.setProperty("Team_Id", "TEAM_02");

			// ctx2 is now active but still transient
			// inactive: ctx1, ctx2, ctx3; pendingChanges: ctx1, ctx2, ODLB, ODLB(true), ODM
			checkStates(sCase !== "context", false, undefined, false, true, true, false, true);

			return Promise.all([
				oContext2.created(),
				that.waitForChanges(assert, "activate")
			]);
		}).then(function () {
			// inactive: ctx1, ctx2, ctx3; pendingChanges: ctx1, ctx2, ODLB, ODLB(true), ODM
			checkStates(sCase !== "context", false, undefined, false, false, false, false, false);
		});
	});
});

	//*********************************************************************************************
	// Scenario: List of orders and items in one request. Create one item (nested in the cache),
	// request more orders causing a short read. See that the count is calculated correctly.
	// JIRA: CPOUI5ODATAV4-2039
	QUnit.test("Nested create & inactive contexts", function (assert) {
		var oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "doNotSubmit"}),
			oOrdersTable,
			sView = '\
<Text id="count" text="{$count}"/>\
<Table id="orders" growing="true" growingThreshold="2" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
	<Table items="{path : \'SO_2_SOITEM\', templateShareable : true}">\
		<Text id="position" text="{ItemPosition}"/>\
	</Table>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)&$skip=0&$top=2", {
				value : [
					{SalesOrderID : "1", SO_2_SOITEM : []},
					{SalesOrderID : "2", SO_2_SOITEM : []}
				]
			})
			.expectChange("count")
			.expectChange("id", ["1", "2"])
			.expectChange("position", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("count", null);

			oOrdersTable = that.oView.byId("orders");
			that.oView.byId("count").setBindingContext(
				oOrdersTable.getBinding("items").getHeaderContext()
			);

			return that.waitForChanges(assert, "count");
		}).then(function () {
			that.expectChange("position", [""]);

			oOrdersTable.getItems()[0].getCells()[1].getBinding("items").create();

			return that.waitForChanges(assert, "nested create");
		}).then(function () {
			that.expectRequest("SalesOrderList?$select=SalesOrderID"
					+ "&$expand=SO_2_SOITEM($select=ItemPosition,SalesOrderID)&$skip=2&$top=2", {
					value : [
						{SalesOrderID : "3", SO_2_SOITEM : []}
					]
				})
				.expectChange("id", [,, "3"])
				.expectChange("count", "3");

			oOrdersTable.requestItems();

			return that.waitForChanges(assert, "more");
		});
	});

	//*********************************************************************************************
	// Scenario: Inactive rows for entities with default values.
	// Reset an edited inactive row and see that the value is reset to the default value (from
	// metadata).
	// JIRA: CPOUI5ODATAV4-1967
	QUnit.test("Creation rows: reset changes with default values", function (assert) {
		var oBinding,
			aCells,
			oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			oNoteBinding,
			oNoteLanguageBinding,
			sView = '\
<Table id="table" items="{/SalesOrderList}">\
	<Input id="note" value="{Note}"/>\
	<Input id="noteLanguage" value="{NoteLanguage}"/>\
	<Text id="inactive" text="{= %{@$ui5.context.isInactive} }"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=Note,NoteLanguage,SalesOrderID&$skip=0&$top=100",
				{value : []})
			.expectChange("note", [])
			.expectChange("noteLanguage", []);

		return this.createView(assert, sView, oModel).then(function () {
			oBinding = that.oView.byId("table").getBinding("items");

			oBinding.attachCreateActivate(function (oEvent) {
				oEvent.preventDefault();
			});

			that.expectChange("note", [""])
				.expectChange("noteLanguage", ["E"]);

			oContext = oBinding.create(undefined, true, true, /*bInactive*/true);

			return that.waitForChanges(assert);
		}).then(function () {
			aCells = that.oView.byId("table").getItems()[0].getCells();
			oNoteBinding = aCells[0].getBinding("value");
			oNoteLanguageBinding = aCells[1].getBinding("value");

			that.expectChange("note", ["My Note"]);
			that.expectChange("noteLanguage", ["D"]);

			// code under test
			oNoteBinding.setValue("My Note");
			oNoteLanguageBinding.setValue("D");

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", [""]);
			that.expectChange("noteLanguage", ["E"]);

			// code under test
			oContext.resetChanges();

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", ["My Note 2"]);
			that.expectChange("noteLanguage", ["C"]);

			// code under test
			oNoteBinding.setValue("My Note 2");
			oNoteLanguageBinding.setValue("C");

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Main & dependent detail table. Create inactive rows for the detail table.
	// Deleting the parent contexts works although there are inactive rows in dependent binding.
	// JIRA: CPOUI5ODATAV4-1468
	// For non-deferred deletion, the context's dependent bindings stay resolved (BCP: 2380002990)
	QUnit.test("delete parent context, inactive rows are in dependent binding", function (assert) {
		var oContext,
			oDeletePromise,
			oDetailTable,
			oDetailBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<Table id="mainTable" items="{/SalesOrderList}">\
	<Text id="salesOrderId" text="{SalesOrderID}"/>\
</Table>\
<Table id="detailTable" items="{path: \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
	<Text id="itemPosition" text="{ItemPosition}"/>\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
			value : [{
				SalesOrderID : "42"
			}]
		})
			.expectChange("salesOrderId", ["42"])
			.expectChange("itemPosition", [])
			.expectChange("note", []);

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("mainTable").getItems()[0].getBindingContext();
			oDetailTable = that.oView.byId("detailTable");

			that.expectRequest("SalesOrderList('42')/SO_2_SOITEM?"
					+ "$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						SalesOrderID : "42",
						ItemPosition : "1",
						Note : "Foohoo"
					}]
				})
				.expectChange("itemPosition", ["1"])
				.expectChange("note", ["Foohoo"]);

			oDetailTable.setBindingContext(oContext);

			return that.waitForChanges(assert);
		}).then(function () {
			oDetailBinding = oDetailTable.getBinding("items");

			that.expectChange("itemPosition", [, "", ""])
				.expectChange("note", [, "First", "Second"]);

			oDetailBinding.create({Note : "First"}, true, true, true);
			oDetailBinding.create({Note : "Second"}, true, true, true);

			assert.deepEqual(oDetailBinding.getCurrentContexts().length, 3);

			return that.waitForChanges(assert);
		}).then(function () {
			that.oLogMock.expects("error")
				.withExactArgs("Failed to delete /SalesOrderList('42')",
					sinon.match("Request intentionally failed"), sContext);

			that.expectRequest("DELETE SalesOrderList('42')", createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}])
				.expectChange("salesOrderId", ["42"]); // happens via context restauration on error

			// code under test
			oDeletePromise = oContext.delete();

			assert.strictEqual(
				that.oView.byId("mainTable").getBinding("items").getCurrentContexts().length, 0);
			assert.strictEqual(oDetailBinding.getContext(), oContext); // BCP: 2380002990

			return Promise.all([
				oDeletePromise.then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, "Request intentionally failed");
				}),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("DELETE SalesOrderList('42')")
				.expectChange("salesOrderId", []);

			return Promise.all([
				// code under test
				oContext.delete(),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(oContext.oBinding, undefined);
			assert.deepEqual(oDetailBinding.getCurrentContexts(), []);
		});
	});

	//*********************************************************************************************
	// Scenario: Deep create, nested list binding w/o own cache; create is called twice in the
	// nested binding while the parent context is still transient. Patch one nested entity while
	// transient and when persisted.
	// JIRA: CPOUI5ODATAV4-1973
	//
	// Forbidden methods (CPOUI5ODATAV4-2035)
	// The response has fewer nested entities in different order (CPOUI5ODATAV4-2079)
	// Nested entities via initial data and via #create (CPOUI5ODATAV4-2036)
	// Optimize the refresh after create w/o bSkipRefresh (CPOUI5ODATAV4-2048)
	// Accept the complete response, not only $select (esp. GrossAmount) (CPOUI5ODATAV4-1977)
	// Also create the product (nested single below collection) (CPOUI5ODATAV4-1977)
[false, true].forEach(function (bSkipRefresh) {
	var sTitle = "CPOUI5ODATAV4-1973: Deep create, nested ODLB w/o cache, bSkipRefresh="
			+ bSkipRefresh;

	QUnit.test(sTitle, function (assert) {
		var oCreatedOrderContext,
			oItemsBinding,
			oOrdersBinding,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<Table id="orders" items="{/SalesOrderList}">\
	<Text id="order" text="{SalesOrderID}"/>\
	<Table items="{path : \'SO_2_SOITEM\', templateShareable : true}">\
		<Input id="note" value="{Note}"/>\
		<Text id="productId" text="{SOITEM_2_PRODUCT/ProductID}"/>\
		<Input id="productName" value="{SOITEM_2_PRODUCT/Name}"/>\
	</Table>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID"
				+ "&$expand=SO_2_SOITEM($select=ItemPosition,Note,SalesOrderID"
				+ ";$expand=SOITEM_2_PRODUCT($select=Name,ProductID))&$skip=0&$top=100",
				{value : []})
			.expectChange("order", [])
			.expectChange("note", [])
			.expectChange("productId", [])
			.expectChange("productName", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("order", [""])
				.expectChange("note", ["A", "B"])
				.expectChange("productId", ["", ""])
				.expectChange("productName", ["PA", ""]);

			oOrdersBinding = that.oView.byId("orders").getBinding("items");

			// code under test
			oCreatedOrderContext = oOrdersBinding.create({
				SO_2_SOITEM : [
					{Note : "A", SOITEM_2_PRODUCT : {Name : "PA"}},
					{Note : "B"}
				]
			}, bSkipRefresh);

			return that.waitForChanges(assert, "create order");
		}).then(function () {
			var aContexts;

			oItemsBinding = that.oView.byId("orders").getItems()[0].getCells()[1]
				.getBinding("items");
			aContexts = oItemsBinding.getCurrentContexts();
			assert.deepEqual(aContexts.map(getObject), [{
				"@$ui5.context.isTransient" : true,
				Note : "A",
				SOITEM_2_PRODUCT : {
					Name : "PA"
				}
			}, {
				"@$ui5.context.isTransient" : true,
				Note : "B"
			}]);
			aContexts.forEach(function (oContext) {
				assert.strictEqual(oContext.isTransient(), true);
			});

			that.expectChange("note", [,, "C", "D"])
				.expectChange("productId", [,, "", ""])
				.expectChange("productName", [, "PB", "", ""]);

			// code under test
			aContexts[1].setProperty("SOITEM_2_PRODUCT/Name", "PB");
			oItemsBinding.create({Note : "C"}, false, true); // at end
			oItemsBinding.create({Note : "D"}, false, true); // at end

			aContexts = oItemsBinding.getCurrentContexts();
			assert.deepEqual(aContexts.map(getObject), [{
				"@$ui5.context.isTransient" : true,
				Note : "A",
				SOITEM_2_PRODUCT : {
					Name : "PA"
				}
			}, {
				"@$ui5.context.isTransient" : true,
				Note : "B",
				SOITEM_2_PRODUCT : {
					Name : "PB"
				}
			}, {
				"@$ui5.context.isTransient" : true,
				Note : "C"
			}, {
				"@$ui5.context.isTransient" : true,
				Note : "D"
			}]);
			aContexts.forEach(function (oContext) {
				assert.strictEqual(oContext.isTransient(), true);
			});

			// code under test - CPOUI5ODATAV4-2035
			[
				"changeParameters", "filter", "getDownloadUrl", "requestDownloadUrl",
				"resetChanges", "setAggregation", "sort"
			].forEach(function (sMethod) {
				assert.throws(function () {
					oItemsBinding[sMethod]();
				}, new Error("Must not call method when the binding is part of a deep create: "
					+ oItemsBinding), sMethod);
			});

			return that.waitForChanges(assert, "create items");
		}).then(function () {
			that.expectChange("note", ["AA", "BB", "CC", "DD"]);

			return Promise.all(
				oItemsBinding.getCurrentContexts().map(function (oContext) {
					// code under test
					return oContext.setProperty("Note", oContext.getProperty("Note").repeat(2));
				})
				.concat(that.waitForChanges(assert, "patch transient items"))
			);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {
						SO_2_SOITEM : [
							{Note : "AA", SOITEM_2_PRODUCT : {Name : "PA"}},
							{Note : "BB", SOITEM_2_PRODUCT : {Name : "PB"}},
							{Note : "CC"},
							{Note : "DD"}
						]
					}
				}, {
					"@odata.etag" : "etag",
					GrossAmount : "128.97",
					SalesOrderID : "new",
					SO_2_SOITEM : [{
						"@odata.etag" : "etag10",
						GrossAmount : "41.99",
						ItemPosition : "0010",
						Note : "AAA",
						SalesOrderID : "new",
						SOITEM_2_PRODUCT : {
							"@odata.etag" : "etagP1",
							Name : "PA",
							ProductID : "P1"
						}
					}, {
						"@odata.etag" : "etag20",
						GrossAmount : "42.99",
						ItemPosition : "0020",
						Note : "CCC",
						SalesOrderID : "new",
						SOITEM_2_PRODUCT : null
					}, {
						"@odata.etag" : "etag30",
						GrossAmount : "43.99",
						ItemPosition : "0030",
						Note : "BBB",
						SalesOrderID : "new",
						SOITEM_2_PRODUCT : {
							"@odata.etag" : "etagP2",
							Name : "PB",
							ProductID : "P2"
						}
					}]
				})
				// optimized refresh: even w/o bSkipRefresh nothing is requested
				.expectChange("order", ["new"])
				.expectChange("note", ["AAA", "CCC", "BBB"])
				.expectChange("productId", ["P1", , "P2"])
				.expectChange("productName", [, "", "PB"]);

			that.expectCanceledError(
					"Deep create of SalesOrderList succeeded. Do not use this promise.")
				.expectCanceledError(
					"Deep create of SalesOrderList succeeded. Do not use this promise.")
				.expectCanceledError(
					"Deep create of SalesOrderList succeeded. Do not use this promise.")
				.expectCanceledError(
					"Deep create of SalesOrderList succeeded. Do not use this promise.");

			return Promise.all([
				oModel.submitBatch("update"),
				oCreatedOrderContext.created(),
				oItemsBinding.getCurrentContexts().map(function (oContext) {
					return checkCanceled(assert, oContext.created());
				}),
				that.waitForChanges(assert, "submit POST")
			].flat());
		}).then(function () {
			assert.strictEqual(oCreatedOrderContext.getProperty("GrossAmount"), "128.97");
			const aContexts = oItemsBinding.getAllCurrentContexts();
			assert.deepEqual(aContexts.map(getPath), [
				"/SalesOrderList('new')/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0010')",
				"/SalesOrderList('new')/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0020')",
				"/SalesOrderList('new')/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0030')"
			]);
			assert.deepEqual(aContexts.map(getObject), [{
				"@odata.etag" : "etag10",
				GrossAmount : "41.99",
				ItemPosition : "0010",
				Note : "AAA",
				SalesOrderID : "new",
				SOITEM_2_PRODUCT : {
					"@odata.etag" : "etagP1",
					Name : "PA",
					ProductID : "P1"
				}
			}, {
				"@odata.etag" : "etag20",
				GrossAmount : "42.99",
				ItemPosition : "0020",
				Note : "CCC",
				SalesOrderID : "new",
				SOITEM_2_PRODUCT : null
			}, {
				"@odata.etag" : "etag30",
				GrossAmount : "43.99",
				ItemPosition : "0030",
				Note : "BBB",
				SalesOrderID : "new",
				SOITEM_2_PRODUCT : {
					"@odata.etag" : "etagP2",
					Name : "PB",
					ProductID : "P2"
				}
			}]);

			that.expectChange("note", ["AAAA"])
				.expectRequest({
					method : "PATCH",
					headers : {"If-Match" : "etag10"},
					url : "SalesOrderList('new')"
						+ "/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0010')",
					payload : {Note : "AAAA"}
				});

			return Promise.all([
				// code under test
				oItemsBinding.getCurrentContexts()[0].setProperty("Note", "AAAA"),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, "patch persisted item")
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Deep create with $count, nested list binding with own cache. Create is called twice
	// in the nested binding while the parent context is still transient. There is an additional :1
	// navigation which is not part of the created data. Patch one nested entity while transient and
	// when created persisted. See that the nested list does not refresh afterwards if created with
	// bSkipRefresh, but refreshes correctly otherwise. See also that the :1 navigation is fetched
	// in both cases.
	// JIRA: CPOUI5ODATAV4-2033
	//
	// POST first fails, then is repeated (CPOUI5ODATAV4-2034)
	// Create an additional item and delete it before submitting (CPOUI5ODATAV4-1975)
	// The response is reordered and contains an additional item (CPOUI5ODATAV4-2079)
	//
	// Optimize the refresh after create w/o bSkipRefresh. For this purpose the order has a $expand
	// to the BusinessPartner plus CurrencyCode in $select which is not delivered by the POST
	// response, and the item a $expand to the Product. Also check that the
	// @$ui5.context.isTransient annotation fires all change events.
	// CPOUI5ODATAV4-2048
	//
	// Accept the complete response, not only $select (esp. GrossAmount) (CPOUI5ODATAV4-1977)
[false, true].forEach(function (bSkipRefresh) {
	var sTitle = "CPOUI5ODATAV4-2033: Deep create, nested ODLB w/ own cache, bSkipRefresh="
			+ bSkipRefresh;

	QUnit.test(sTitle, function (assert) {
		var oCreatedItemContext1,
			oCreatedItemContext2,
			oCreatedItemContext3,
			oCreatedOrderContext,
			oItemsBinding,
			oItemsTable,
			oOrdersBinding,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<Text id="orderCount" text="{$count}"/>\
<Table id="orders" items="{path : \'/SalesOrderList\', parameters : {$count : true}}">\
	<Text id="isTransient" text="{= %{@$ui5.context.isTransient}}"/>\
	<Text id="order" text="{SalesOrderID}"/>\
</Table>\
<Text id="itemCount" text="{$count}"/>\
<FlexBox id="detail">\
	<Text id="bp" text="{SO_2_BP/BusinessPartnerID}"/>\
	<Text id="currency" text="{CurrencyCode}"/>\
	<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$count : true}}">\
		<Input id="note" value="{Note}"/>\
		<Text id="product" text="{SOITEM_2_PRODUCT/Name}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID&$skip=0&$top=100", {
				"@odata.count" : "1",
				value : [{SalesOrderID : "1"}]
			})
			.expectChange("orderCount")
			.expectChange("isTransient", [undefined])
			.expectChange("order", ["1"])
			.expectChange("itemCount")
			.expectChange("bp")
			.expectChange("currency")
			.expectChange("note", [])
			.expectChange("product", []);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("isTransient", [true, undefined])
				.expectChange("order", ["", "1"])
				.expectChange("bp", "")
				.expectChange("currency", "EUR") // default value
				.expectChange("orderCount", "2")
				.expectChange("itemCount", "0");

			oOrdersBinding = that.oView.byId("orders").getBinding("items");
			that.oView.byId("orderCount").setBindingContext(oOrdersBinding.getHeaderContext());
			oItemsTable = that.oView.byId("items");
			oItemsBinding = oItemsTable.getBinding("items");

			// code under test
			oCreatedOrderContext = oOrdersBinding.create({}, bSkipRefresh);
			that.oView.byId("detail").setBindingContext(oCreatedOrderContext);
			that.oView.byId("itemCount").setBindingContext(oItemsBinding.getHeaderContext());

			return that.waitForChanges(assert, "create order");
		}).then(function () {
			that.expectChange("note", ["AA", "doNotSubmit", "B"])
				.expectChange("product", ["", "", ""])
				.expectChange("itemCount", "1")
				.expectChange("itemCount", "2")
				.expectChange("itemCount", "3");

			// code under test
			oCreatedItemContext1 = oItemsBinding.create({Note : "B"});
			// this one is deleted again before submitting (intentionally in between)
			oCreatedItemContext3 = oItemsBinding.create({Note : "doNotSubmit"});
			oCreatedItemContext2 = oItemsBinding.create({Note : "AA"});

			assert.strictEqual(oCreatedItemContext1.isTransient(), true);
			assert.strictEqual(oCreatedItemContext2.isTransient(), true);
			assert.strictEqual(oCreatedItemContext3.isTransient(), true);

			return that.waitForChanges(assert, "create items");
		}).then(function () {
			that.expectChange("note", [, "B"])
				.expectChange("itemCount", "2");
			that.expectCanceledError("Deleted from deep create");

			// code under test
			oCreatedItemContext3.delete();

			return Promise.all([
				checkCanceled(assert, oCreatedItemContext3.created()),
				that.waitForChanges(assert, "delete an item")
			]);
		}).then(function () {
			that.expectChange("note", [, "BB"]);

			return Promise.all([
				// code under test
				oCreatedItemContext1.setProperty("Note", "BB"),
				that.waitForChanges(assert, "patch transient item")
			]);
		}).then(function () {
			that.oLogMock.expects("error")
				.withArgs("POST on 'SalesOrderList' failed; will be repeated automatically");
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {
						SO_2_SOITEM : [
							{Note : "AA"},
							{Note : "BB"}
						]
					}
				}, createErrorInsideBatch())
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				oModel.submitBatch("update"),
				that.waitForChanges(assert, "submit -> error")
			]);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {
						SO_2_SOITEM : [
							{Note : "AA"},
							{Note : "BB"}
						]
					}
				}, {
					"@odata.etag" : "etag",
					GrossAmount : "128.97",
					SalesOrderID : "new",
					SO_2_SOITEM : [{
						"@odata.etag" : "etag10",
						GrossAmount : "41.99",
						ItemPosition : "0010",
						Note : "BBB",
						SalesOrderID : "new"
					}, {
						"@odata.etag" : "etag20",
						GrossAmount : "42.99",
						ItemPosition : "0020",
						Note : "additional",
						SalesOrderID : "new"
					}, {
						"@odata.etag" : "etag30",
						GrossAmount : "43.99",
						ItemPosition : "0030",
						Note : "AAA",
						SalesOrderID : "new"
					}]
				})
				.expectCanceledError(
					"Deep create of SalesOrderList succeeded. Do not use this promise.")
				.expectCanceledError(
					"Deep create of SalesOrderList succeeded. Do not use this promise.")
				.expectChange("isTransient", [false])
				.expectChange("order", ["new"])
				.expectChange("note", ["BBB", "additional", "AAA"])
				// late property request
				.expectRequest("SalesOrderList('new')?$select=CurrencyCode"
					+ "&$expand=SO_2_BP($select=BusinessPartnerID)", {
					"@odata.etag" : "etag",
					CurrencyCode : "USD",
					SO_2_BP : {
						"@odata.etag" : "etag.bp",
						BusinessPartnerID : "BP"
					}
				});
			if (bSkipRefresh) { // multiple requests, one for each nested entity!
				that.expectRequest("SalesOrderList('new')"
						+ "/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0010')"
						+ "?$select=SOITEM_2_PRODUCT"
						+ "&$expand=SOITEM_2_PRODUCT($select=Name,ProductID)", {
						"@odata.etag" : "etag10",
						ItemPosition : "0010",
						SalesOrderID : "new",
						SOITEM_2_PRODUCT : {
							"@odata.etag" : "etag.p1",
							ProductID : "P1",
							Name : "Product 1"
						}
					})
					.expectRequest("SalesOrderList('new')"
						+ "/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0020')"
						+ "?$select=SOITEM_2_PRODUCT"
						+ "&$expand=SOITEM_2_PRODUCT($select=Name,ProductID)", {
						"@odata.etag" : "etag20",
						ItemPosition : "0020",
						SalesOrderID : "new",
						SOITEM_2_PRODUCT : {
							"@odata.etag" : "etag.p2",
							ProductID : "P2",
							Name : "Product 2"
						}
					})
					.expectRequest("SalesOrderList('new')"
						+ "/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0030')"
						+ "?$select=SOITEM_2_PRODUCT"
						+ "&$expand=SOITEM_2_PRODUCT($select=Name,ProductID)", {
						"@odata.etag" : "etag30",
						ItemPosition : "0030",
						SalesOrderID : "new",
						SOITEM_2_PRODUCT : {
							"@odata.etag" : "etag.p3",
							ProductID : "P3",
							Name : "Product 3"
						}
					});
			} else { // one single optimized request for all nested entities
				that.expectRequest("SalesOrderList('new')/SO_2_SOITEM"
						+ "?$select=ItemPosition,SalesOrderID"
						+ "&$expand=SOITEM_2_PRODUCT($select=Name,ProductID)"
						+ "&$filter=SalesOrderID eq 'new' and ItemPosition eq '0010'"
						+ " or SalesOrderID eq 'new' and ItemPosition eq '0020'"
						+ " or SalesOrderID eq 'new' and ItemPosition eq '0030'&"
						+ "$top=3", {
						value : [{
							"@odata.etag" : "etag10",
							ItemPosition : "0010",
							SalesOrderID : "new",
							SOITEM_2_PRODUCT : {
								"@odata.etag" : "etag.p1",
								ProductID : "P1",
								Name : "Product 1"
							}
						}, {
							"@odata.etag" : "etag20",
							ItemPosition : "0020",
							SalesOrderID : "new",
							SOITEM_2_PRODUCT : {
								"@odata.etag" : "etag.p2",
								ProductID : "P2",
								Name : "Product 2"
							}
						}, {
							"@odata.etag" : "etag30",
							ItemPosition : "0030",
							SalesOrderID : "new",
							SOITEM_2_PRODUCT : {
								"@odata.etag" : "etag.p3",
								ProductID : "P3",
								Name : "Product 3"
							}
						}]
					});
			}
			that.expectChange("itemCount", "3") // because there are 3 elements in the POST response
				.expectChange("bp", "BP")
				.expectChange("currency", "USD")
				.expectChange("product", ["Product 1", "Product 2", "Product 3"]);

			return Promise.all([
				oModel.submitBatch("update"),
				oCreatedOrderContext.created().then(function () {
					assert.strictEqual(
						oCreatedOrderContext.getValue("SO_2_BP/BusinessPartnerID"),
						undefined,
						"$expand request still pending");
				}),
				checkCanceled(assert, oCreatedItemContext2.created()),
				that.waitForChanges(assert, "submit -> success")
			]);
		}).then(function () {
			assert.strictEqual(oCreatedOrderContext.getProperty("GrossAmount"), "128.97");
			const aContexts = oItemsBinding.getAllCurrentContexts();
			assert.strictEqual(oCreatedOrderContext.getValue("@$ui5.context.isTransient"), false);
			assert.strictEqual(oCreatedOrderContext.getValue("SO_2_BP/BusinessPartnerID"), "BP");
			assert.deepEqual(aContexts.map(getPath), [
				"/SalesOrderList('new')/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0010')",
				"/SalesOrderList('new')/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0020')",
				"/SalesOrderList('new')/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0030')"
			]);
			assert.deepEqual(aContexts.map(getObject), [{
				"@odata.etag" : "etag10",
				ItemPosition : "0010",
				GrossAmount : "41.99",
				Note : "BBB",
				SalesOrderID : "new",
				SOITEM_2_PRODUCT : {
					"@odata.etag" : "etag.p1",
					ProductID : "P1",
					Name : "Product 1"
				}
			}, {
				"@odata.etag" : "etag20",
				ItemPosition : "0020",
				GrossAmount : "42.99",
				Note : "additional",
				SalesOrderID : "new",
				SOITEM_2_PRODUCT : {
					"@odata.etag" : "etag.p2",
					ProductID : "P2",
					Name : "Product 2"
				}
			}, {
				"@odata.etag" : "etag30",
				ItemPosition : "0030",
				GrossAmount : "43.99",
				Note : "AAA",
				SalesOrderID : "new",
				SOITEM_2_PRODUCT : {
					"@odata.etag" : "etag.p3",
					ProductID : "P3",
					Name : "Product 3"
				}
			}]);

			that.expectChange("note", [, "BBBB"])
				.expectRequest({
					method : "PATCH",
					headers : {"If-Match" : "etag20"},
					url : "SalesOrderList('new')"
						+ "/SO_2_SOITEM(SalesOrderID='new',ItemPosition='0020')",
					payload : {Note : "BBBB"}
				});

			// code under test
			oItemsTable.getItems()[1].getCells()[0].getBinding("value").setValue("BBBB");

			return Promise.all([
				oModel.submitBatch("update"),
				that.waitForChanges(assert, "patch persisted item")
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Deep create, nested list binding with own cache. No initial data for the nested
	// list. Items are created. The deep creation is canceled.
	// JIRA: CPOUI5ODATAV4-2034
	//
	// Alternatively delete the created (top-level) order context (CPOUI5ODATAV4-1975)
	// Initial data: Create 2 + 2 (CPOUI5ODATAV4-2036)
	// Deep create during view construction via controller events (BCP: 2370038939)
	//
	// Add a second level to see that the created promises are also rejected here, and that multiple
	// calls to create in the first level also work when there is a second level.
	// JIRA: CPOUI5ODATAV4-1976
[false, true].forEach(function (bDelete) {
	var sTitle = "CPOUI5ODATAV4-2034: Deep create, "
			+ (bDelete ? "delete top-level context" : "reset changes");

	QUnit.test(sTitle, function (assert) {
		var oCreatedEmployeeContext1,
			oCreatedEmployeeContext3,
			oCreatedEmployeeContext4,
			oCreatedTeamContext,
			oEmployeesTable,
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<Table id="teams" items="{/TEAMS}">\
	<Text id="id" text="{Team_Id}"/>\
</Table>\
<Table id="employees" items="{path : \'TEAM_2_EMPLOYEES\', parameters : {$$ownRequest : true}}">\
	<Text id="employeeName" text="{Name}"/>\
	<List items="{path : \'EMPLOYEE_2_EQUIPMENTS\', templateShareable : true}">\
		<CustomListItem>\
			<Text id="equipmentName" text="{Name}"/>\
		</CustomListItem>\
	</List>\
</Table>',
			that = this;

		this.expectRequest("TEAMS?$select=Team_Id&$skip=0&$top=99", {value : []})
			.expectChange("id", [""])
			.expectChange("employeeName", ["AA", "BB"])
			.expectChange("equipmentName", ["AAA"]); // cannot take the employee into account

		return this.createView(assert, sView, oModel, {
			onInit : function () {
				this.getView().attachModelContextChange(this.onModelContextChange, this);
			},
			onModelContextChange : function () {
				oCreatedTeamContext = this.byId("teams").getBinding("items").create({
					TEAM_2_EMPLOYEES : [
						{Name : "AA", EMPLOYEE_2_EQUIPMENTS : [{Name : "AAA"}]},
						{Name : "BB"}
					]
				});
				oEmployeesTable = this.byId("employees");
				oEmployeesTable.setBindingContext(oCreatedTeamContext);
			}
		}).then(function () {
			var oEmployeesBinding = oEmployeesTable.getBinding("items");

			that.expectChange("employeeName", ["DD", "CC", "AA", "BB"])
				.expectChange("equipmentName", ["CCC"])
				.expectChange("equipmentName", ["AAA"]); // moved to another row

			oCreatedEmployeeContext1 = oEmployeesBinding.getCurrentContexts()[0];
			oCreatedEmployeeContext3 = oEmployeesBinding.create(
				{Name : "CC", EMPLOYEE_2_EQUIPMENTS : [{Name : "CCC"}]});
			oCreatedEmployeeContext4 = oEmployeesBinding.create({Name : "DD"});

			return that.waitForChanges(assert, "create items");
		}).then(function () {
			var oCreatedEquipmentsContext1 = oEmployeesTable.getItems()[2].getCells()[1]
					.getBinding("items").getAllCurrentContexts()[0],
				oCreatedEquipmentsContext2 = oEmployeesTable.getItems()[1].getCells()[1]
					.getBinding("items").getAllCurrentContexts()[0];

			that.expectCanceledError("Deep create of TEAMS canceled; group: update")
				.expectCanceledError("Deep create of TEAMS canceled; group: update")
				.expectCanceledError("Deep create of TEAMS canceled; group: update")
				.expectCanceledError("Deep create of TEAMS canceled; group: update")
				.expectCanceledError("Deep create of TEAMS canceled; group: update")
				.expectCanceledError("Deep create of TEAMS canceled; group: update");

			return Promise.all([
				checkCanceled(assert, oCreatedTeamContext.created()),
				checkCanceled(assert, oCreatedEmployeeContext1.created()),
				// do not check the 2nd context from initial data, expect no "uncaught (in promise)"
				checkCanceled(assert, oCreatedEmployeeContext3.created()),
				checkCanceled(assert, oCreatedEmployeeContext4.created()),
				checkCanceled(assert, oCreatedEquipmentsContext1.created()),
				checkCanceled(assert, oCreatedEquipmentsContext2.created()),
				// code under test
				bDelete
					? oCreatedTeamContext.delete()
					: oModel.resetChanges(),
				that.waitForChanges(assert, bDelete ? "delete" : "resetChanges")
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Deep create, nested list binding with own cache. Create an item, delete it again,
	// and submit. See that there is a deep create with an empty collection.
	// CPOUI5ODATAV4-1975
	QUnit.test("CPOUI5ODATAV4-1975: Deep create, delete nested", function (assert) {
		var oCreatedItemContext,
			oCreatedOrderContext,
			oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			sView = '\
<Table id="orders" items="{/SalesOrderList}">\
	<Text id="order" text="{SalesOrderID}"/>\
</Table>\
<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {value : []});

		return this.createView(assert, sView, oModel).then(function () {
			oCreatedOrderContext = that.oView.byId("orders").getBinding("items").create({}, true);
			that.oView.byId("items").setBindingContext(oCreatedOrderContext);

			return that.waitForChanges(assert, "create order");
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {SO_2_SOITEM : []}
				}, {
					SalesOrderID : "new1",
					SO_2_SOITEM : []
				})
				.expectCanceledError("Deleted from deep create");

			oCreatedItemContext = that.oView.byId("items").getBinding("items")
				.create({Note : "doNotSubmit"});
			oCreatedItemContext.delete();

			return Promise.all([
				oModel.submitBatch("update"),
				checkCanceled(assert, oCreatedItemContext.created()),
				oCreatedOrderContext.created(),
				that.waitForChanges(assert, "create and delete")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Deep create, nested list in nested list
	// (1) Create a team with two employees and two equipment items each (in initial data) and bind
	//     the employees list to the created team context
	// (2) Create a third equipment item at the first employee
	// (3) Create a third employee w/o equipment
	// (4) Create an equipment item at the third employee
	// (5) Delete the second employee
	// (6) Submit; the number of equipment items changes for each employee
	// JIRA: CPOUI5ODATAV4-1976
	//
	// Accept the complete response, not only $select (esp. EmployeeId) (CPOUI5ODATAV4-1977)
[false, true].forEach(function (bOwnRequest) {
	["Table", "t:Table"].forEach(function (sTable) {
		var sTitle = "CPOUI5ODATAV4-1976: Deep create, nested list in nested list, $$ownRequest="
				+ bOwnRequest + ", " + sTable;

	QUnit.test(sTitle, function (assert) {
		var oEmployeesBinding,
			oEmployeesTable,
			sItems = sTable === "t:Table" ? "rows" : "items",
			oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"}),
			sOwnRequest = bOwnRequest ? ", $$ownRequest : true" : "",
			oTeamContext,
			sView = '\
<Text id="employeeCount" text="{$count}"/>\
<' + sTable + ' id="employees" ' + sItems + '="{path : \'TEAM_2_EMPLOYEES\',\
			parameters : {$$ownRequest : true, $count : true}}">\
	<Text id="employeeName" text="{Name}"/>\
	<List items="{path : \'EMPLOYEE_2_EQUIPMENTS\', \
			parameters : {$count : true' + sOwnRequest + '}, templateShareable : false}">\
		<CustomListItem>\
			<Text id="equipmentName" text="{Name}"/>\
		</CustomListItem>\
	</List>\
</' + sTable + ">",
			that = this;

		// returns a list of all equipment bindings
		function getEquipmentsBindings(iExpectedCount) {
			var aBindings = oEmployeesTable.getAggregation(sItems).map(function (oItem) {
					return oItem.getCells()[1].getBinding("items");
				}).filter(function (oBinding) {
					// in the t:Table excess rows have an unresolved binding
					return oBinding.isResolved();
				});

			assert.strictEqual(aBindings.length, iExpectedCount);
			return aBindings;
		}

		this.expectChange("employeeCount")
			.expectChange("employeeName", [])
			.expectChange("equipmentName", []); // cannot take the employee into account

		return this.createView(assert, sView, oModel).then(function () {
			oEmployeesTable = that.oView.byId("employees");
			oEmployeesBinding = oEmployeesTable.getBinding(sItems);

			// code under test
			oTeamContext = oModel.bindList("/TEAMS").create({
				TEAM_2_EMPLOYEES : [{
					Name : "Jonathan Smith",
					EMPLOYEE_2_EQUIPMENTS : [ // J1 comes later :-)
						{Name : "J2"},
						{Name : "J3"}
					]
				}, {
					Name : "Frederic Fall",
					EMPLOYEE_2_EQUIPMENTS : [
						{Name : "F1"},
						{Name : "F2"}
					]
				}]
			});

			that.expectChange("employeeCount", "2")
				.expectChange("employeeName", ["Jonathan Smith", "Frederic Fall"])
				.expectChange("equipmentName", ["F1", "F2"])
				.expectChange("equipmentName", ["J2", "J3"]);

			oEmployeesTable.setBindingContext(oTeamContext);
			that.oView.byId("employeeCount")
				.setBindingContext(oEmployeesBinding.getHeaderContext());

			return that.waitForChanges(assert, "(1) deep create & bind");
		}).then(function () {
			var aEquipmentsBindings = getEquipmentsBindings(2);

			that.expectChange("equipmentName", ["J1", "J2", "J3"]);

			// code under test
			aEquipmentsBindings[0].create({Name : "J1"});

			assert.deepEqual(aEquipmentsBindings[0].getCurrentContexts().map(getObject), [
				{"@$ui5.context.isTransient" : true, Name : "J1"},
				{"@$ui5.context.isTransient" : true, Name : "J2"},
				{"@$ui5.context.isTransient" : true, Name : "J3"}
			]);
			assert.deepEqual(aEquipmentsBindings[1].getCurrentContexts().map(getObject), [
				{"@$ui5.context.isTransient" : true, Name : "F1"},
				{"@$ui5.context.isTransient" : true, Name : "F2"}
			]);

			return that.waitForChanges(assert, "(2) add equipment");
		}).then(function () {
			that.expectChange("employeeCount", "3")
				.expectChange("employeeName", ["Peter Burke", "Jonathan Smith", "Frederic Fall"])
				.expectChange("equipmentName", ["J1", "J2", "J3"]) // moved to another row
				.expectChange("equipmentName", ["F1", "F2"]); // moved to another row

			// code under test
			oEmployeesBinding.create({Name : "Peter Burke"});

			return that.waitForChanges(assert, "(3) create employee");
		}).then(function () {
			that.expectChange("equipmentName", ["P1"]);

			// code under test
			getEquipmentsBindings(3)[0].create({Name : "P1"});

			return that.waitForChanges(assert, "(4) create equipment");
		}).then(function () {
			var oEmployeeContext = oEmployeesBinding.getCurrentContexts()[1],
				oEquipmentsBinding = getEquipmentsBindings(3)[1],
				aEquipmentsContexts = oEquipmentsBinding.getCurrentContexts();

			that.expectChange("employeeCount", "2")
				.expectChange("employeeName", [, "Frederic Fall"])
				.expectChange("equipmentName", ["F1", "F2"]) // moved to another row
				.expectCanceledError("Deleted from deep create")
				.expectCanceledError("Deleted from deep create")
				.expectCanceledError("Deleted from deep create")
				.expectCanceledError("Deleted from deep create");

			assert.strictEqual(aEquipmentsContexts.length, 3);
			return Promise.all([
				checkCanceled(assert, oEmployeeContext.created()),
				aEquipmentsContexts.map(function (oContext) {
					return checkCanceled(assert, oContext.created());
				}),
				// code under test
				oEmployeeContext.delete(),
				that.waitForChanges(assert, "(5) delete 2nd employee")
			].flat());
		}).then(function () {
			var aEmployeesContexts = oEmployeesBinding.getCurrentContexts(),
				aEquipmentsBindings = getEquipmentsBindings(2),
				aEquipmentsContexts0 = aEquipmentsBindings[0].getCurrentContexts(),
				aEquipmentsContexts1 = aEquipmentsBindings[1].getCurrentContexts();

			that.expectRequest({
					method : "POST",
					url : "TEAMS",
					payload : {
						TEAM_2_EMPLOYEES : [{
							Name : "Peter Burke",
							EMPLOYEE_2_EQUIPMENTS : [
								{Name : "P1"}
							]
						}, {
							Name : "Frederic Fall",
							EMPLOYEE_2_EQUIPMENTS : [
								{Name : "F1"},
								{Name : "F2"}
							]
						}]
					}
				}, {
					"@odata.etag" : "etag.T1",
					Team_Id : "T1",
					TEAM_2_EMPLOYEES : [{
						"@odata.etag" : "etag.E1",
						ID : "E1",
						Name : "Peter Burke",
						EMPLOYEE_2_EQUIPMENTS : [{
							"@odata.etag" : "etag.P1",
							Category : "C",
							EmployeeId : "E1",
							ID : 1,
							Name : "P1"
						}, {
							"@odata.etag" : "etag.P2",
							Category : "C",
							EmployeeId : "E1",
							ID : 2,
							Name : "P2"
						}]
					}, {
						"@odata.etag" : "etag.E2",
						ID : "E2",
						Name : "Frederic Fall",
						EMPLOYEE_2_EQUIPMENTS : [{
							"@odata.etag" : "etag.F1",
							Category : "C",
							EmployeeId : "E2",
							ID : 3,
							Name : "F1"
						}]
					}]
				})
				.expectCanceledError("Deep create of TEAMS succeeded. Do not use this promise.")
				.expectCanceledError("Deep create of TEAMS succeeded. Do not use this promise.")
				.expectCanceledError("Deep create of TEAMS succeeded. Do not use this promise.")
				.expectCanceledError("Deep create of TEAMS succeeded. Do not use this promise.")
				.expectCanceledError("Deep create of TEAMS succeeded. Do not use this promise.")
				.expectChange("equipmentName", ["P1", "P2"])
				.expectChange("equipmentName", ["F1"]);

			assert.strictEqual(aEmployeesContexts.length, 2);
			assert.strictEqual(aEquipmentsContexts0.length, 1);
			assert.strictEqual(aEquipmentsContexts1.length, 2);
			return Promise.all([
				oTeamContext.created(),
				aEmployeesContexts.map(function (oContext) {
					return checkCanceled(assert, oContext.created());
				}),
				aEquipmentsContexts0.map(function (oContext) {
					return checkCanceled(assert, oContext.created());
				}),
				aEquipmentsContexts1.map(function (oContext) {
					return checkCanceled(assert, oContext.created());
				}),
				// code under test
				oModel.submitBatch("update"),
				that.waitForChanges(assert, "(6) submit")
			].flat());
		}).then(function () {
			var aEquipmentsBindings = getEquipmentsBindings(2);

			assert.deepEqual(aEquipmentsBindings[0].getAllCurrentContexts().map(getObject), [{
				"@odata.etag" : "etag.P1",
				Category : "C",
				EmployeeId : "E1",
				ID : 1,
				Name : "P1"
			}, {
				"@odata.etag" : "etag.P2",
				Category : "C",
				EmployeeId : "E1",
				ID : 2,
				Name : "P2"
			}]);
			assert.deepEqual(aEquipmentsBindings[1].getAllCurrentContexts().map(getObject), [{
				"@odata.etag" : "etag.F1",
				Category : "C",
				EmployeeId : "E2",
				ID : 3,
				Name : "F1"
			}]);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: Deep create, nested single entity incl. recursion.
	// Create an employee with a nested team (one property via initial data, another one set
	// afterward) with a nested manager. See that the complete response is accepted, not only
	// $select (esp. Name, MEMBER_COUNT)
	// JIRA: CPOUI5ODATAV4-1977
	QUnit.test("CPOUI5ODATAV4-1977: Deep create, nested single entity", function (assert) {
		let oBinding;
		let oCreatedContext;
		const oModel = this.createTeaBusiModel({autoExpandSelect : true, updateGroupId : "update"});
		const sView = `
<Table id="employees" items="{/EMPLOYEES}">
	<Text id="id" text="{ID}"/>
	<Text id="teamId" text="{EMPLOYEE_2_TEAM/Team_Id}"/>
	<Input id="teamName" value="{EMPLOYEE_2_TEAM/Name}"/>
	<Input id="manager" value="{EMPLOYEE_2_TEAM/TEAM_2_MANAGER/ID}"/>
	<Text id="managerTeamId" text="{EMPLOYEE_2_TEAM/TEAM_2_MANAGER/TEAM_ID}"/>
</Table>`;
		const that = this;

		this.expectRequest("EMPLOYEES?$select=ID&$expand=EMPLOYEE_2_TEAM($select=Name,Team_Id"
				+ ";$expand=TEAM_2_MANAGER($select=ID,TEAM_ID))&$skip=0&$top=100", {
				value : [{
					ID : "E1",
					EMPLOYEE_2_TEAM : {
						Name : "Team 1",
						Team_Id : "T1",
						TEAM_2_MANAGER : {
							ID : "M1",
							TEAM_ID : "T1"
						}
					}
				}]
			})
			.expectChange("id", ["E1"])
			.expectChange("teamId", ["T1"])
			.expectChange("teamName", ["Team 1"])
			.expectChange("manager", ["M1"])
			.expectChange("managerTeamId", ["T1"]);

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("id", ["", "E1"])
				.expectChange("teamId", ["Tnew", "T1"])
				.expectChange("teamName", ["", "Team 1"])
				.expectChange("manager", ["", "M1"])
				.expectChange("managerTeamId", ["", "T1"]);

			oBinding = that.oView.byId("employees").getBinding("items");
			// code under test
			// bSkipRefresh not needed due to deep create
			oCreatedContext = oBinding.create({EMPLOYEE_2_TEAM : {Team_Id : "Tnew"}});

			return that.waitForChanges(assert, "create employee");
		}).then(function () {
			that.expectChange("teamName", ["Team 2"])
				.expectChange("manager", ["M2"]);

			oCreatedContext.setProperty("EMPLOYEE_2_TEAM/Name", "Team 2");
			oCreatedContext.setProperty("EMPLOYEE_2_TEAM/TEAM_2_MANAGER/ID", "M2");

			return that.waitForChanges(assert, "patch transient");
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "EMPLOYEES",
					payload : {
						EMPLOYEE_2_TEAM : {
							Name : "Team 2",
							Team_Id : "Tnew",
							TEAM_2_MANAGER : {
								ID : "M2"
							}
						}
					}
				}, {
					"@odata.etag" : "etagE2",
					ID : "E2",
					Name : "Peter Burke",
					EMPLOYEE_2_TEAM : {
						"@odata.etag" : "etagT2",
						MEMBER_COUNT : 1,
						Name : "Team 2 (from server)",
						Team_Id : "T2",
						TEAM_2_MANAGER : {
							"@odata.etag" : "etagM2",
							ID : "M2",
							TEAM_ID : "T2"
						}
					}
				})
				.expectChange("id", ["E2"])
				.expectChange("teamId", ["T2"])
				.expectChange("teamName", ["Team 2 (from server)"])
				.expectChange("managerTeamId", ["T2"]);

			return Promise.all([
				oModel.submitBatch("update"),
				oCreatedContext.created(),
				that.waitForChanges(assert, "submit")
			]);
		}).then(function () {
			assert.deepEqual(oCreatedContext.getObject(), {
				"@$ui5.context.isTransient" : false,
				"@odata.etag" : "etagE2",
				ID : "E2",
				Name : "Peter Burke",
				EMPLOYEE_2_TEAM : {
					"@odata.etag" : "etagT2",
					MEMBER_COUNT : 1,
					Name : "Team 2 (from server)",
					Team_Id : "T2",
					TEAM_2_MANAGER : {
						"@odata.etag" : "etagM2",
						ID : "M2",
						TEAM_ID : "T2"
					}
				}
			});
		});
	});

	//*********************************************************************************************
	// Scenario: A deep create of a sales order with items is tried, but there is an ODCB w/o path
	// (w/ or w/o own cache) in between. A non-deep create however must work.
	// JIRA: CPOUI5ODATAV4-1976
[false, true].forEach(function (bOwnRequest) {
	var sTitle = "CPOUI5ODATAV4-1976, no deep create due to ODCB, ownRequest=" + bOwnRequest;

	QUnit.test(sTitle, function (assert) {
		var oModel = this.createSalesOrdersModel(
				{autoExpandSelect : true, updateGroupId : "update"}),
			oOrderContext,
			sOwnRequest = bOwnRequest ? ", parameters : {$$ownRequest : true}" : "",
			sView = '\
<FlexBox id="form" binding="{path : \'\'' + sOwnRequest + '}">\
	<Text id="note" text="{Note}"/>\
	<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
		<Text id="position" text="{ItemPosition}"/>\
	</Table>\
</FlexBox>',
			that = this;

		this.expectChange("note")
			.expectChange("position", []);

		return this.createView(assert, sView, oModel).then(function () {
			var oOrdersBinding = oModel.bindList("/SalesOrderList");

			that.expectChange("note", "Note");

			oOrderContext = oOrdersBinding.create({Note : "Note"}, /*bSkipRefresh*/true);
			that.oView.byId("form").setBindingContext(oOrderContext);

			return that.waitForChanges(assert, "create & bind");
		}).then(function () {
			var oItemsBinding = that.oView.byId("items").getBinding("items");

			assert.throws(function () {
				oItemsBinding.create();
			}, new Error("Unexpected ODataContextBinding in deep create"));

			that.expectRequest({
					method : "POST",
					url : "SalesOrderList",
					payload : {Note : "Note"}
				}, {
					Note : "Note*",
					SalesOrderID : "new"
				})
				.expectChange("note", "Note*")
				.expectRequest("SalesOrderList('new')/SO_2_SOITEM?$select=ItemPosition,SalesOrderID"
					+ "&$skip=0&$top=100",
					{value : []}
				);
			if (bOwnRequest) {
				that.expectRequest("SalesOrderList('new')?$select=Note,SalesOrderID", {
						Note : "Note*",
						SalesOrderID : "new"
					});
			}

			return Promise.all([
				oOrderContext.created(),
				oModel.submitBatch("update"),
				that.waitForChanges(assert, "submit")
			]);
		});
	});
});

	//*********************************************************************************************
	// Scenario: A list of teams with an expanded list of employees. Create a team and show it in
	// the object page. This object page has another employee table w/ own requests. Immediately
	// (before it starts reading) create an employee in this list.
	// BCP: 2380101762
	QUnit.test("BCP: 2380101762", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<Table id="teams" items="{/TEAMS}">
	<Text id="teamId" text="{Team_Id}"/>
	<List items="{path : 'TEAM_2_EMPLOYEES', templateShareable : true}">
		<CustomListItem>
			<Text text="{ID}"/>
		</CustomListItem>
	</List>
</Table>
<FlexBox id="objectPage">
	<Table id="employees" items="{path : 'TEAM_2_EMPLOYEES', parameters : {$$ownRequest : true}}">
		<Text id="employeeId" text="{ID}"/>
	</Table>
</FlexBox>
`;
		this.expectRequest("TEAMS?$select=Team_Id&$expand=TEAM_2_EMPLOYEES($select=ID)"
				+ "&$skip=0&$top=100",
				{value : []})
			.expectChange("teamId", [])
			.expectChange("employeeId", []);

		await this.createView(assert, sView, oModel);

		this.expectChange("teamId", ["new"])
			.expectRequest({
				method : "POST",
				url : "TEAMS",
				payload : {Team_Id : "new", TEAM_2_EMPLOYEES : []}
			}, {Team_Id : "new", TEAM_2_EMPLOYEES : []});

		const oTeamContext = this.oView.byId("teams").getBinding("items").create(
			{Team_Id : "new", TEAM_2_EMPLOYEES : []});

		await Promise.all([
			oTeamContext,
			this.waitForChanges(assert, "create team")
		]);

		this.expectChange("employeeId", ["E1"])
			.expectRequest({
				method : "POST",
				url : "TEAMS('new')/TEAM_2_EMPLOYEES",
				payload : {ID : "E1"}
			}, {ID : "E1", Team_Id : "new"})
			// the binding does not get the data from the deep create using another binding
			.expectRequest("TEAMS('new')/TEAM_2_EMPLOYEES?$select=ID&$skip=0&$top=100",
				{value : []});

		this.oView.byId("objectPage").setBindingContext(oTeamContext);

		await Promise.all([
			this.oView.byId("employees").getBinding("items").create({ID : "E1"}, true),
			this.waitForChanges(assert, "create employee")
		]);
	});

	//*********************************************************************************************
	// Scenario: An object page with an items table. Request a side effect for a single row and one
	// for the root object which refreshes the items table. This must not fail due to call order.
	QUnit.test("DINC0012327", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		const sView = `
<FlexBox id="team" binding="{/TEAMS('TEAM_01')}">
	<Text id="teamId" text="{Team_Id}"/>
	<Text id="teamName" text="{Name}"/>
	<Table id="employees" items="{path : 'TEAM_2_EMPLOYEES', parameters : {$$ownRequest : true}}">
		<Text id="employeeId" text="{ID}"/>
		<Text id="employeeName" text="{Name}"/>
	</Table>
</FlexBox>`;
		this.expectRequest("TEAMS('TEAM_01')?$select=Name,Team_Id", {
				Name : "Team #1",
				Team_Id : "TEAM_01"
			})
			.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name&$skip=0&$top=100", {
				value : [{
					ID : "2",
					Name : "Frederic Fall"
				}]
			})
			.expectChange("teamId", "TEAM_01")
			.expectChange("teamName", "Team #1")
			.expectChange("employeeId", ["2"])
			.expectChange("employeeName", ["Frederic Fall"]);

		await this.createView(assert, sView, oModel);

		this.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name&$filter=ID eq '2'", {
				value : [{
					ID : "2",
					Name : "Frederic Winter"
				}]
			})
			.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name&$skip=0&$top=100", {
				value : [{
					ID : "2",
					Name : "Frederic Winter"
				}]
			})
			.expectChange("employeeName", ["Frederic Winter"]);

		const oTeamContext = this.oView.byId("team").getBindingContext();
		let oEmployeeContext
			= this.oView.byId("employees").getBinding("items").getCurrentContexts()[0];

		await Promise.all([
			oEmployeeContext.requestSideEffects(["Name"]),
			oTeamContext.requestSideEffects(["TEAM_2_EMPLOYEES"]),
			this.waitForChanges(assert)
		]);

		this.expectRequest("TEAMS('TEAM_01')/TEAM_2_EMPLOYEES?$select=ID,Name&$skip=0&$top=100", {
				value : [{
					ID : "2",
					Name : "Frederic Spring"
				}]
			})
			.expectChange("employeeName", ["Frederic Spring"]);

		oEmployeeContext = this.oView.byId("employees").getBinding("items").getCurrentContexts()[0];

		await Promise.all([
			oTeamContext.requestSideEffects(["TEAM_2_EMPLOYEES"]),
			oEmployeeContext.requestSideEffects(["Name"]),
			this.waitForChanges(assert)
		]);
	});

	//*********************************************************************************************
	// Scenario:
	// (1) Binding for a part of a structural instance annotation works without binding the
	//     property itself
	// (2) Late request for another annotation of the same property does not invoke a GET request
	// (3) Late request for an instance annotation which was not requested before
	// (4), (5) Edm.Stream simulation: initial response is empty, no further requests
	// (6) Request side effects for property of (4), empty response
	// (7) Again late request property (4), no further requests
	// (8) Late request a structural instance annotation
	//
	// JIRA: CPOUI5ODATAV4-1290
	QUnit.test("CPOUI5ODATAV4-1290: Bind & late request an instance annotation", function (assert) {
		var oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/BusinessPartnerList(\'1\')}">\
	<Text id="name" text="{CompanyName}"/>\
	<Text id="annotation1" text="{= %{WebAddress@some.Annotation/foo} }"/>\
	<Text id="annotation2" text="{= %{WebAddress@some.Annotation/bar} }"/>\
</FlexBox>',
			that = this;

		this.expectRequest("BusinessPartnerList('1')"
				+ "?$select=BusinessPartnerID,CompanyName,WebAddress", {
				BusinessPartnerID : "1",
				CompanyName : "BOPF",
				WebAddress : "example.com",
				"WebAddress@some.Annotation" : {foo : "string"}
			})
			.expectChange("name", "BOPF")
			.expectChange("annotation1", "string");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("form").getBindingContext();

			return Promise.all([
				oContext.requestProperty("WebAddress@missing.Annotation"),
				that.waitForChanges(assert, "(2)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], undefined);

			that.expectRequest("BusinessPartnerList('1')?$select=EmailAddress", {
					EmailAddress : "foo@bar",
					"EmailAddress@some.other.Annotation" : "smtp"
			});

			return Promise.all([
				oContext.requestProperty("EmailAddress@some.other.Annotation"),
				that.waitForChanges(assert, "(3)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], "smtp");

			that.expectRequest("BusinessPartnerList('1')?$select=FaxNumber", {});

			return Promise.all([
				oContext.requestProperty("FaxNumber@some.missing.Annotation"),
				that.waitForChanges(assert, "(4)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], undefined);

			return Promise.all([
				oContext.requestProperty("FaxNumber@some.missing.Annotation"),
				that.waitForChanges(assert, "(5)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], undefined);

			that.expectRequest("BusinessPartnerList('1')?$select=FaxNumber", {});

			return Promise.all([
				oContext.requestSideEffects(["FaxNumber"]),
				that.waitForChanges(assert, "(6)")
			]);
		}).then(function () {
			return Promise.all([
				oContext.requestProperty("FaxNumber@some.missing.Annotation"),
				that.waitForChanges(assert, "(7)")
			]);
		}).then(function () {
			that.expectRequest("BusinessPartnerList('1')?$select=PhoneNumber", {
				"PhoneNumber@some.Annotation" : {foo : {bar : "baz"}}
			});

			return Promise.all([
				oContext.requestProperty("PhoneNumber@some.Annotation/foo/bar"),
				that.waitForChanges(assert, "(8)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], "baz");
		});
	});

	//*********************************************************************************************
	// Scenario:
	// - Edm.Stream property is read from a complex type and is missing from the response
	// - Accessing a missing annotation does not cause a GET request
	//
	// JIRA: CPOUI5ODATAV4-1290
	// JIRA: CPOUI5ODATAV4-1640
[{
	oProductPicture : {},
	sResult : sTeaBusi + "Equipments('1')/EQUIPMENT_2_PRODUCT/ProductPicture/Picture"
}, {
	oProductPicture : {"Picture@mediaReadLink" : "/foo/bar"},
	sResult : "/foo/bar"
}].forEach(function (oFixture, i) {
	QUnit.test("CPOUI5ODATAV4-1290: complex type, Edm.Stream: " + i, function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/Equipments(\'1\')/EQUIPMENT_2_PRODUCT}">\
	<Text id="url" text="{ProductPicture/Picture}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Equipments('1')/EQUIPMENT_2_PRODUCT"
				+ "?$select=ID,ProductPicture/Picture", {
				ID : "42",
				ProductPicture : oFixture.oProductPicture
			})
			.expectChange("url", oFixture.sResult);

		return this.createView(assert, sView, oModel).then(function () {
			return Promise.all([
				that.oView.byId("form").getBindingContext()
					.requestProperty("ProductPicture/Picture@some.missing.annotation"),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], undefined);
		});
	});
});

	//*********************************************************************************************
	// Scenario: Request a client annotation of a missing instance as a late property. See that no
	// request happens and no drill-down error is logged.
	// BCP: 2280122602
	QUnit.test("BCP: 2280122602 - EMPLOYEE_2_TEAM/@$ui5.context.isTransient", function (assert) {
		var oModel = this.createTeaBusiModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form0" binding="{/EMPLOYEES(\'1\')}">\
	<Text id="id" text="{ID}"/>\
</FlexBox>\
<FlexBox id="form1" binding="{EMPLOYEE_2_TEAM}">\
	<Text id="isTransient" text="{= %{@$ui5.context.isTransient}}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('1')?$select=ID", {ID : "1"})
			.expectChange("id", "1")
			.expectChange("isTransient");

		return this.createView(assert, sView, oModel).then(function () {
			that.expectChange("isTransient", undefined);

			// code under test
			that.oView.byId("form1")
				.setBindingContext(that.oView.byId("form0").getBindingContext());

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario:
	// - Edm.Stream property is read from a complex type, w/o autoExpandSelect but binding parameter
	// - Accessing a missing annotation does not cause a GET request because it is already selected
	// - Check that the special handling for a not existing Edm.Stream property takes place
	//
	// JIRA: CPOUI5ODATAV4-1290
	// JIRA: CPOUI5ODATAV4-1640
[undefined, "*", "ProductPicture/Picture", "ProductPicture"].forEach(function (sSelect) {
	QUnit.test("CPOUI5ODATAV4-1290: Edm.Stream w/o autoExpandSelect:" + sSelect, function (assert) {
		var oModel = this.createTeaBusiModel(),
			sExpectedUrl = "/foo/bar",
			sProductPath = "TEAM_2_EMPLOYEES('1')/"
				+ "EMPLOYEE_2_EQUIPMENTS(Category='Electronics',ID=1)"
				+ "/EQUIPMENT_2_PRODUCT/",
			oProductPicture = {"Picture@mediaReadLink" : "/foo/bar"},
			sView = '\
<FlexBox id="form" binding="{path : \'/TEAMS(\\\'TEAM_01\\\')\',\
	parameters : {\
		$select : \'Team_Id,Name\',\
		$expand : {\
			TEAM_2_EMPLOYEES : {\
				$select : \'ID,AGE\',\
				$expand : {\
					EMPLOYEE_2_EQUIPMENTS : {\
						$select : \'Category,ID\',\
						$expand : { EQUIPMENT_2_PRODUCT : '
							 + (sSelect ? "{$select :'" + sSelect + "'}" : "true") + '\
						}\
					}\
				}\
			}\
		}\
	}}">\
	<Text id="url" text="{' + sProductPath + 'ProductPicture/Picture}"/>\
</FlexBox>',
			that = this;

		if (sSelect === "*") { // test fallback to service URL + property path
			delete oProductPicture["Picture@mediaReadLink"];
			sExpectedUrl = sTeaBusi + "TEAMS('TEAM_01')/TEAM_2_EMPLOYEES('1')"
				+ "/EMPLOYEE_2_EQUIPMENTS(Category='Electronics',ID=1)"
				+ "/EQUIPMENT_2_PRODUCT/ProductPicture/Picture";
		}
		this.expectRequest("TEAMS('TEAM_01')?$select=Team_Id,Name&$expand=TEAM_2_EMPLOYEES("
			+ "$select=ID,AGE;$expand=EMPLOYEE_2_EQUIPMENTS("
			+ "$select=Category,ID;$expand=EQUIPMENT_2_PRODUCT"
			+ (sSelect ? "($select=" + sSelect + ")" : "") + "))", {
				Team_Id : "TEAM_01",
				Name : "Business Suite",
				TEAM_2_EMPLOYEES : [{
					ID : "1",
					AGE : 52,
					EMPLOYEE_2_EQUIPMENTS : [{
						Category : "Electronics",
						ID : 1,
						EQUIPMENT_2_PRODUCT : {
							ID : "HT-1000",
							ProductPicture : oProductPicture
						}
					}]
				}]
			})
			.expectChange("url", sExpectedUrl);

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("form").getBindingContext();

			return Promise.all([
				oContext.requestProperty(sProductPath
					+ "ProductPicture/Picture@some.missing.annotation"),
				oContext.requestProperty(sProductPath + "ProductPicture/Picture"),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], undefined);
			assert.strictEqual(aResults[1], sExpectedUrl);
		});
	});
});

	//*********************************************************************************************
	// Scenario: request Edm.Stream property as late property
	// (1) request instance annotation for Edm.Stream property as late property
	// (2) request property again and see that no request happen because property was not returned
	//     before
	//
	// JIRA: CPOUI5ODATAV4-1290
	// JIRA: CPOUI5ODATAV4-1640
	// BCP: 2280130543 request also late Edm.Stream property and test whether defaulting for not
	// existing stream property happens
	QUnit.test("CPOUI5ODATAV4-1290: late Edm.Stream property annotation", function (assert) {
		var oContext,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="form" binding="{/Artists(ArtistID=\'42\',IsActiveEntity=true)}">\
	<Text id="name" text="{Name}"/>\
</FlexBox>\
<FlexBox id="subform" binding="{}">\
	<Text id="contentType" text="{= %{Picture@odata.mediaContentType}}"/>\
	<Text id="url" text="{= %{Picture} }"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)"
			+ "?$select=ArtistID,IsActiveEntity,Name", {
				ArtistID : "42",
				Name : "The Beatles"
			})
			.expectChange("name", "The Beatles")
			.expectChange("contentType")
			.expectChange("url");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("form").getBindingContext();

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=true)?$select=Picture", {
					ID : "42",
					// Picture property not seen in late response -> "Picture@$ui5.noData" : true
					"Picture@odata.mediaContentType" : "image/gif"
				})
				.expectChange("contentType", "image/gif")
				.expectChange("url",
					"/special/cases/Artists(ArtistID='42',IsActiveEntity=true)/Picture");

			that.oView.byId("subform").setBindingContext(oContext);

			return that.waitForChanges(assert, "(1) stream property fetched late");
		}).then(function () {
			return Promise.all([
				oContext.requestProperty("Picture@odata.mediaContentType"),
				oContext.requestProperty("Picture@someOtherInstanceAnnotation"),
				oContext.requestProperty("Picture"),
				that.waitForChanges(assert, "(2) not further late request")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], "image/gif");
			assert.strictEqual(aResults[1], undefined);
			assert.strictEqual(aResults[2],
				"/special/cases/Artists(ArtistID='42',IsActiveEntity=true)/Picture");
		});
	});

	//*********************************************************************************************
	// Scenario: Absolute property bindings that belong to the same singleton share requests and
	// cache
	// (1) consume different property bindings by UI (usually not as LATE properties) from singleton
	//     and singleton's navigation property
	// (2) request further late properties for singleton itself (merged), etag change is not allowed
	//     (only from null to not null)
	// (3) request further late properties for singleton and entity via singleton's navigation
	//     property (not merged, because different entities)
	// (4) create a new property binding that reuses the same singleton cache (no request)
	// (5) create a new property binding for the same singleton property but different query option
	//      and show that it does NOT reuse the same singleton cache (own request)
	// (6) refresh multiple properties, properties for the same entity are merged in one request,
	//     the entity's ETag may change
	// (7) requestSideEffects: as absolute property bindings have no v4 Context, a dummy context is
	//     used in order to call #requestSideEffects with the absolute singleton property paths
	//
	// JIRA: CPOUI5ODATAV4-1594
	QUnit.test("CPOUI5ODATAV4-1594: absolute singleton property bindings", function (assert) {
		var oDefaultChannel0,
			oDefaultChannel1,
			oDummyContext,
			oLastUsedChannel0,
			oLastUsedChannel1,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			oSendsAutoGraphs,
			sView = '\
<FlexBox id="form">\
	<Text id="artistID" text="{/MyFavoriteArtist/ArtistID}"/>\
	<Text id="name" text="{/MyFavoriteArtist/Name}"/>\
	<Text id="bestFriend" text="{/MyFavoriteArtist/BestFriend/Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("MyFavoriteArtist?$select=ArtistID,Name"
				+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,Name)", {
				ArtistID : "42",
				Name : "The Beatles",
				BestFriend : {
					"@odata.etag" : "etag43-0",
					ArtistID : 43,
					IsActiveEntity : true,
					Name : "Beatles BestFriend"
				}
			})
			.expectChange("artistID", "42")
			.expectChange("name", "The Beatles")
			.expectChange("bestFriend", "Beatles BestFriend");

		return this.createView(assert, sView, oModel).then(function () {
			oSendsAutoGraphs = oModel.bindProperty("/MyFavoriteArtist/BestFriend/sendsAutographs");
			oLastUsedChannel0 = oModel.bindProperty("/MyFavoriteArtist/BestFriend/lastUsedChannel");

			that.expectRequest("MyFavoriteArtist/BestFriend?$select=ArtistID,IsActiveEntity,"
					+ "lastUsedChannel,sendsAutographs", {
					"@odata.etag" : "etag43-0", // etag must not change (because fetched late)
					ArtistID : 43,
					IsActiveEntity : true,
					lastUsedChannel : "mail",
					sendsAutographs : false
				});

			return Promise.all([
				oSendsAutoGraphs.requestValue(),
				oLastUsedChannel0.requestValue(),
				that.waitForChanges(assert, "(2)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], false);
			assert.strictEqual(oSendsAutoGraphs.getValue(), false);
			assert.strictEqual(aResults[1], "mail");
			assert.strictEqual(oLastUsedChannel0.getValue(), "mail");

			oDefaultChannel0 = oModel.bindProperty("/MyFavoriteArtist/defaultChannel");
			oDefaultChannel1 = oModel.bindProperty("/MyFavoriteArtist/BestFriend/defaultChannel");

			that.expectRequest("MyFavoriteArtist?$select=defaultChannel", {
					// ArtistID : 42,
					// IsActiveEntity : true,
					defaultChannel : "42's default channel"
				})
				.expectRequest("MyFavoriteArtist/BestFriend?$select=ArtistID,IsActiveEntity"
					+ ",defaultChannel", {
					"@odata.etag" : "etag43-0", // etag must not change because fetched as late
					ArtistID : 43,
					IsActiveEntity : true,
					defaultChannel : "43's default channel"
				});

			return Promise.all([
				oDefaultChannel0.requestValue(),
				oDefaultChannel1.requestValue(),
				oLastUsedChannel0.requestValue(),
				that.waitForChanges(assert, "(3)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], "42's default channel");
			assert.strictEqual(oDefaultChannel0.getValue(), "42's default channel");
			assert.strictEqual(aResults[1], "43's default channel");
			assert.strictEqual(oDefaultChannel1.getValue(), "43's default channel");
			assert.strictEqual(aResults[2], "mail");
			assert.strictEqual(oLastUsedChannel0.getValue(), "mail");

			oLastUsedChannel0 = oModel.bindProperty("/MyFavoriteArtist/BestFriend/lastUsedChannel");

			return Promise.all([
				oLastUsedChannel0.requestValue(),
				that.waitForChanges(assert, "(4)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], "mail");
			assert.strictEqual(oLastUsedChannel0.getValue(), "mail");

			that.expectRequest("MyFavoriteArtist?custom=query&$select=BestFriend"
					+ "&$expand=BestFriend($select=ArtistID,IsActiveEntity,lastUsedChannel)", {
					BestFriend : {
						ArtistID : 43,
						IsActiveEntity : true,
						lastUsedChannel : "mail (otherQueryOptions)"
					}
				});

			oLastUsedChannel1 = oModel.bindProperty("/MyFavoriteArtist/BestFriend/lastUsedChannel"
				, null, {custom : "query"});

			return Promise.all([
				oLastUsedChannel1.requestValue(),
				that.waitForChanges(assert, "(5)")
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], "mail (otherQueryOptions)");
			assert.strictEqual(oLastUsedChannel1.getValue(), "mail (otherQueryOptions)");

			that.expectRequest("MyFavoriteArtist?$select=Name,defaultChannel", {
					Name : "The Beatles (refreshed)",
					defaultChannel : "42's default channel (refreshed)"
				})
				.expectRequest("MyFavoriteArtist/BestFriend?$select=ArtistID,IsActiveEntity"
					+ ",Name,defaultChannel", {
					"@odata.etag" : "etag43-1", // etag may change
					ArtistID : 43,
					IsActiveEntity : true,
					defaultChannel : "43's default channel (refreshed)",
					Name : "Beatles BestFriend (refreshed)"
				})
				.expectChange("name", "The Beatles (refreshed)")
				.expectChange("bestFriend", "Beatles BestFriend (refreshed)");

			that.oView.byId("name").getBinding("text").refresh();
			that.oView.byId("bestFriend").getBinding("text").refresh();
			oDefaultChannel0.refresh();
			oDefaultChannel1.refresh();

			return that.waitForChanges(assert, "(6)");
		}).then(function () {
			assert.strictEqual(oDefaultChannel0.getValue(), "42's default channel (refreshed)");
			assert.strictEqual(oDefaultChannel1.getValue(), "43's default channel (refreshed)");
			assert.strictEqual(oLastUsedChannel0.getValue(), "mail");
			assert.strictEqual(oSendsAutoGraphs.getValue(), false);
		}).then(function () {
			oDummyContext = oModel.bindContext("/Artists('41')").getBoundContext();

			that.expectRequest("Artists('41')", {/*response doesn't matter*/});

			return Promise.all([
				oDummyContext.requestObject(""),
				that.waitForChanges(assert, "preparation for (7)")
			]);
		}).then(function () {
			that.expectRequest("MyFavoriteArtist?$select=Name", {
					Name : "The Beatles (via requestSideEffects)"
				})
				.expectRequest("MyFavoriteArtist/BestFriend?$select=ArtistID,IsActiveEntity"
					+ ",Name", {
					"@odata.etag" : "etag43-2", // etag may change
					ArtistID : 43,
					IsActiveEntity : true,
					Name : "Beatles BestFriend (via requestSideEffects)"
				})
				.expectChange("name", "The Beatles (via requestSideEffects)")
				.expectChange("bestFriend", "Beatles BestFriend (via requestSideEffects)");

			return Promise.all([
				oDummyContext.requestSideEffects([
					"/special.cases.Container/MyFavoriteArtist/Name",
					"/special.cases.Container/MyFavoriteArtist/BestFriend/Name"
				]),
				that.waitForChanges(assert, "(7)")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Multiple properties of two entities are changed, but no PATCH is sent. After
	// changing different properties several times, the PATCHES are sent and responded with an
	// error. Afterwards all changes are reverted via ODM#resetChanges. The initial values of the
	// properties are displayed.
	// JIRA: CPOUI5ODATAV4-1603
	// BCP: 2270079668, 2280103069
	QUnit.test("BCP: 2270079668 - #resetChanges after failed PATCH", function (assert) {
		var oBinding,
			oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			iPatchCompleted = 0,
			aPatchPromises = [],
			iPatchSent = 0,
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Input id="grossAmount" value="{GrossAmount}"/>\
	<Input id="note" value="{Note}"/>\
	<Input id="city" value="{SO_2_BP/Address/City}"/>\
	<Input id="postalCode" value="{SO_2_BP/Address/PostalCode}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=GrossAmount,Note,SalesOrderID"
				+ "&$expand=SO_2_BP($select=Address/City,Address/PostalCode,BusinessPartnerID)", {
				GrossAmount : "100",
				Note : "Foo",
				SalesOrderID : "1",
				SO_2_BP : {
					Address : {
						City : "Walldorf",
						PostalCode : "42"
					},
					BusinessPartnerID : "23"
				}
			})
			.expectChange("grossAmount", "100.00")
			.expectChange("note", "Foo")
			.expectChange("city", "Walldorf")
			.expectChange("postalCode", "42");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("form").getBindingContext();
			oBinding = oContext.getBinding();

			oBinding.attachPatchSent(function () {
				iPatchSent += 1;
			});
			oBinding.attachPatchCompleted(function (oEvent) {
				// the event is modified later, so we have to check immediately
				assert.strictEqual(oEvent.getParameter("success"), false);
				assert.strictEqual(iPatchSent, 1, "patchSent was fired before");
				iPatchCompleted += 1;
			});

			that.expectChange("grossAmount", "200.00")
				.expectChange("note", "Bar")
				.expectChange("city", "Qo'noS")
				.expectChange("postalCode", "23");

			aPatchPromises.push(
				oContext.setProperty("GrossAmount", "200", "update", true));
			aPatchPromises.push(
				oContext.setProperty("Note", "Bar", "update", true));
			aPatchPromises.push(
				oContext.setProperty("SO_2_BP/Address/City", "Qo'noS", "update", true));
			// make sure that the old data of a complex property is merged correctly
			aPatchPromises.push(
				oContext.setProperty("SO_2_BP/Address/PostalCode", "23", "update", true));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("grossAmount", "300.00")
				.expectChange("note", "Baz")
				.expectChange("city", "Tellar");

			aPatchPromises.push(
				oContext.setProperty("GrossAmount", "300", "update", true));
			aPatchPromises.push(
				oContext.setProperty("Note", "Baz", "update", true));
			aPatchPromises.push(
				oContext.setProperty("SO_2_BP/Address/City", "Tellar", "update", true));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("grossAmount", "400.00")
				.expectChange("note", "RAISE_ERROR")
				.expectChange("city", "Trill");

			aPatchPromises.push(
				oContext.setProperty("GrossAmount", "400", "update", true));
			aPatchPromises.push(
				oContext.setProperty("Note", "RAISE_ERROR", "update", true));
			aPatchPromises.push(
				oContext.setProperty("SO_2_BP/Address/City", "Trill", "update", true));

			return that.waitForChanges(assert);
		}).then(function () {
			assert.strictEqual(iPatchSent, 0);
			assert.strictEqual(iPatchCompleted, 0);

			that.oLogMock.expects("error").thrice()
				.withArgs("Failed to update path /SalesOrderList('1')/Note");
			that.oLogMock.expects("error").thrice()
				.withArgs("Failed to update path /SalesOrderList('1')/GrossAmount");
			that.oLogMock.expects("error").thrice()
				.withArgs("Failed to update path /SalesOrderList('1')/SO_2_BP/Address/City");
			that.oLogMock.expects("error")
				.withArgs("Failed to update path /SalesOrderList('1')/SO_2_BP/Address/PostalCode");

			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('1')",
					payload : {
						GrossAmount : "400",
						Note : "RAISE_ERROR"
					}
				}, createErrorInsideBatch())
				.expectRequest({
					method : "PATCH",
					url : "BusinessPartnerList('23')",
					payload : {
						Address : {
							City : "Trill",
							PostalCode : "23"
						}
					}
				}) // no response required since the 1st PATCH fails
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				oModel.submitBatch("update"),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			assert.strictEqual(iPatchSent, 1);
			assert.strictEqual(iPatchCompleted, 1);

			that.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/GrossAmount",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/GrossAmount",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/GrossAmount",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/SO_2_BP/Address/City",
					"Request canceled: PATCH BusinessPartnerList('23'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/SO_2_BP/Address/PostalCode",
					"Request canceled: PATCH BusinessPartnerList('23'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/SO_2_BP/Address/City",
					"Request canceled: PATCH BusinessPartnerList('23'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/SO_2_BP/Address/City",
					"Request canceled: PATCH BusinessPartnerList('23'); group: update")
				.expectChange("grossAmount", "100.00")
				.expectChange("note", "Foo")
				.expectChange("city", "Walldorf")
				.expectChange("postalCode", "42");

			// code under test
			oModel.resetChanges("update");

			return Promise.all(
				aPatchPromises.map(checkCanceled.bind(null, assert))
					.concat([that.waitForChanges(assert)])
			);
		}).then(function () {
			assert.strictEqual(oContext.getValue("Note"), "Foo");
			assert.strictEqual(oContext.getValue("GrossAmount"), "100");
			assert.strictEqual(oContext.getValue("SO_2_BP/Address/City"), "Walldorf");
			assert.strictEqual(oContext.getValue("SO_2_BP/Address/PostalCode"), "42");
			assert.strictEqual(oContext.hasPendingChanges(), false);
			assert.strictEqual(oModel.hasPendingChanges(), false);
			assert.strictEqual(iPatchSent, 1);
			assert.strictEqual(iPatchCompleted, 1);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: A property is changed twice. The first change is using the automatic retry feature,
	// the second is not. The changes are not submitted, they are canceled via #resetChanges. The
	// initial state should be present again.
	// JIRA: CPOUI5ODATAV4-1603
	// BCP: 2280153659,
	QUnit.test("BCP: 2280153659 - #resetChanges skipRetry", function (assert) {
		var oContext,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			aPatchPromises = [],
			sView = '\
<FlexBox id="form" binding="{/SalesOrderList(\'1\')}">\
	<Input id="note" value="{Note}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')?$select=Note,SalesOrderID", {
				Note : "Foo",
				SalesOrderID : "1"
			})
			.expectChange("note", "Foo");

		return this.createView(assert, sView, oModel).then(function () {
			oContext = that.oView.byId("form").getBindingContext();

			that.expectChange("note", "Bar");

			aPatchPromises.push(
				oContext.setProperty("Note", "Bar", "update", true));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectChange("note", "Baz");

			aPatchPromises.push(
				oContext.setProperty("Note", "Baz", "update", false));

			return that.waitForChanges(assert);
		}).then(function () {
			that.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectCanceledError(
					"Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectChange("note", "Bar")
				.expectChange("note", "Foo");

			// code under test
			oModel.resetChanges("update");

			return Promise.all(
				aPatchPromises.map(checkCanceled.bind(null, assert))
					.concat([that.waitForChanges(assert)])
			);
		}).then(function () {
			assert.strictEqual(oContext.getValue("Note"), "Foo");
			assert.strictEqual(oContext.hasPendingChanges(), false);
			assert.strictEqual(oModel.hasPendingChanges(), false);

			return that.waitForChanges(assert);
		});
	});

	//*********************************************************************************************
	// Scenario: Create a new draft entity and invoke the ActivationAction to replace the draft
	// context with the active context. Request a side-effects refresh for the active context.
	// BCP: 2180347338
	// BCP: 2280113990
	// BCP: 2280127015
	// BCP: 2280134548
	QUnit.test("BCP: 2180347338, 2280113990, 2280127015, 2280134548", function (assert) {
		var oActiveContext,
			oDraftContext,
			oListBinding,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<Table id="list" items="{/Artists}">\
	<Text id="artistID" text="{ArtistID}"/>\
	<Text id="isActiveEntity" text="{IsActiveEntity}"/>\
</Table>',
			that = this;

		this.expectRequest("Artists?$select=ArtistID,IsActiveEntity&$skip=0&$top=100", {
			value : [{
				ArtistID : "42",
				IsActiveEntity : true
			}]
		})
		.expectChange("artistID", ["42"])
		.expectChange("isActiveEntity", ["Yes"]);

		return this.createView(assert, sView, oModel).then(function () {
			oListBinding = that.oView.byId("list").getBinding("items");

			that.expectChange("artistID", ["", "42"])
				.expectChange("isActiveEntity", [null, "Yes"])
				.expectRequest({
					method : "POST",
					url : "Artists",
					payload : {}
				}, {
					ArtistID : "23",
					IsActiveEntity : false
				})
				.expectChange("artistID", ["23"])
				.expectChange("isActiveEntity", ["No"]);

			oDraftContext = oListBinding.create({}, /*bSkipRefresh*/true);

			assert.strictEqual(oDraftContext.isTransient(), true);

			return Promise.all([
				oDraftContext.created(),
				that.waitForChanges(assert, "create new draft entity")
			]);
		}).then(function () {
			var oActionBinding
				= that.oModel.bindContext("special.cases.ActivationAction(...)", oDraftContext);

			assert.strictEqual(oDraftContext.isTransient(), false);

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='23',IsActiveEntity=false)"
						+ "/special.cases.ActivationAction",
					payload : {}
				}, {
					ArtistID : "23",
					IsActiveEntity : true
				})
				.expectChange("isActiveEntity", ["Yes"]);

			return Promise.all([
				// code under test
				oActionBinding.invoke(/*sGroupId*/undefined, /*bIgnoreETag*/false,
					/*fnOnStrictHandlingFailed*/null, /*bReplaceWithRVC*/true),
				that.waitForChanges(assert, "invoke ActivationAction")
			]);
		}).then(function (aResults) {
			oActiveContext = aResults[0];

			assert.deepEqual(oListBinding.getAllCurrentContexts().map(getPath), [
				"/Artists(ArtistID='23',IsActiveEntity=true)",
				"/Artists(ArtistID='42',IsActiveEntity=true)"
			]);
			assert.strictEqual(oActiveContext.isTransient(), undefined, "no change here");

			// Note: this test is just about the right key predicate, no need for fake side effect
			that.expectRequest("Artists(ArtistID='23',IsActiveEntity=true)"
					+ "?$select=ArtistID,IsActiveEntity,Messages", {
					ArtistID : "23",
					IsActiveEntity : true,
					Messages : []
				});

			return Promise.all([
				// code under test
				oActiveContext.requestSideEffects([""]),
				that.waitForChanges(assert, "side-effects refresh (BCP: 2280113990)")
			]);
		}).then(function () {
			that.expectRequest("Artists?$select=ArtistID,IsActiveEntity"
					+ "&$filter=ArtistID eq '23' and IsActiveEntity eq true", {
					value : [] // gone for good
				})
				.expectChange("artistID", ["42"]);

			return Promise.all([
				// code under test
				oActiveContext.requestRefresh(/*sGroupId*/undefined, /*bAllowRemoval*/true),
				that.waitForChanges(assert, "refreshSingleWithRemove")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: In an ODLB w/ filter, but w/o UI, create a new draft entity and invoke the
	// ActivationAction to replace the draft context with the active context. Refresh the active
	// context in order to make it drop out of the collection, alternatively delete it. See that
	// internal bookkeeping is OK by creating an inactive row at the other end.
	// BCP: 2180347338, 2280113990, 2280127015, 2280134548
[false, true].forEach(function (bAtEnd) {
	[false, true].forEach(function (bDelete) {
		var sTitle = "refreshSingle|onRemove: destroyCreated; at end = " + bAtEnd
				+ ", delete = " + bDelete;

	QUnit.test(sTitle, function (assert) {
		var oActiveContext,
			oDraftContext,
			oInactiveContext,
			oListBinding,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			oListBinding = oModel.bindList("/Artists", null, [],
				[new Filter("sendsAutographs", FilterOperator.EQ, true)]);

			that.expectRequest("Artists?$filter=sendsAutographs eq true&$skip=0&$top=100", {
					value : []
				});

			return Promise.all([
				oListBinding.requestContexts(),
				that.waitForChanges(assert, "make length final")
			]);
		}).then(function () {
			that.expectRequest({
					method : "POST",
					url : "Artists",
					payload : {}
				}, {
					ArtistID : "23",
					IsActiveEntity : false
				});

			oDraftContext = oListBinding.create({}, /*bSkipRefresh*/true, bAtEnd);

			return Promise.all([
				oDraftContext.created(),
				that.waitForChanges(assert, "create new draft entity")
			]);
		}).then(function () {
			var oActionBinding
				= that.oModel.bindContext("special.cases.ActivationAction(...)", oDraftContext);

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='23',IsActiveEntity=false)"
						+ "/special.cases.ActivationAction",
					payload : {}
				}, {
					ArtistID : "23",
					IsActiveEntity : true
				});

			return Promise.all([
				// code under test
				oActionBinding.invoke(undefined, false, null, /*bReplaceWithRVC*/true),
				that.waitForChanges(assert, "invoke ActivationAction")
			]);
		}).then(function (aResults) {
			oActiveContext = aResults[0];

			if (bDelete) {
				that.expectRequest("DELETE Artists(ArtistID='23',IsActiveEntity=true)");

				return Promise.all([
					// code under test
					oActiveContext.delete(),
					that.waitForChanges(assert, "delete")
				]);
			}

			that.expectRequest("Artists?$filter=(sendsAutographs eq true)"
					+ " and ArtistID eq '23' and IsActiveEntity eq true", {
					value : [] // sorry, no autographs anymore ;-)
				});

			return Promise.all([
				// code under test
				oActiveContext.requestRefresh(/*sGroupId*/undefined, /*bAllowRemoval*/true),
				that.waitForChanges(assert, "refreshSingleWithRemove")
			]);
		}).then(function () {
			// code under test
			oInactiveContext = oListBinding.create({}, true, !bAtEnd, /*bInactive*/true);

			return Promise.all([
				checkCanceled(assert, oInactiveContext.created()),
				// code under test
				oInactiveContext.delete(),
				that.waitForChanges(assert, "create at other end")
			]);
		});
	});
	});
});

	//*********************************************************************************************
	// Scenario: In an ODLB w/ filter, but w/o UI, create a new draft entity and invoke the
	// ActivationAction to replace the draft context with the active context. Keep the active
	// context alive and refresh it in order to make it drop out of the collection. See that it is
	// still alive.
	//
	// Invoke the EditAction with empty response to check that bReplaceWithRVC requires a key
	// predicate.
	// JIRA: CPOUI5ODATAV4-1683
	QUnit.test("JIRA: CPOUI5ODATAV4-1683", function (assert) {
		var oActiveContext,
			oDraftContext,
			oListBinding,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			fnOnBeforeDestroy = sinon.spy(),
			that = this;

		return this.createView(assert, "", oModel).then(function () {
			oListBinding = oModel.bindList("/Artists", null, [],
				[new Filter("sendsAutographs", FilterOperator.EQ, true)]);

			that.expectRequest({
					method : "POST",
					url : "Artists",
					payload : {}
				}, {
					ArtistID : "23",
					IsActiveEntity : false
				});

			oDraftContext = oListBinding.create({}, /*bSkipRefresh*/true);

			return Promise.all([
				oDraftContext.created(),
				that.waitForChanges(assert, "create new draft entity")
			]);
		}).then(function () {
			var oActionBinding
				= that.oModel.bindContext("special.cases.ActivationAction(...)", oDraftContext);

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='23',IsActiveEntity=false)"
						+ "/special.cases.ActivationAction",
					payload : {}
				}, {
					ArtistID : "23",
					IsActiveEntity : true
				});

			return Promise.all([
				// code under test
				oActionBinding.invoke(undefined, false, null, /*bReplaceWithRVC*/true),
				that.waitForChanges(assert, "invoke ActivationAction")
			]);
		}).then(function (aResults) {
			oActiveContext = aResults[0];
			oActiveContext.setKeepAlive(true, fnOnBeforeDestroy);

			that.expectRequest("Artists?$filter=ArtistID eq '23' and IsActiveEntity eq true", {
					value : [{
						ArtistID : "23",
						IsActiveEntity : true
					}] // still alive
				})
				.expectRequest("Artists?$filter=(sendsAutographs eq true)"
					+ " and ArtistID eq '23' and IsActiveEntity eq true&$count=true&$top=0", {
					"@odata.count" : "0", // sorry, no autographs anymore ;-)
					value : []
				});

			return Promise.all([
				// code under test
				oActiveContext.requestRefresh(/*sGroupId*/undefined, /*bAllowRemoval*/true),
				that.waitForChanges(assert, "refreshSingleWithRemove")
			]);
		}).then(function () {
			var oActionBinding
				= that.oModel.bindContext("special.cases.EditAction(...)", oActiveContext);

			assert.notOk(fnOnBeforeDestroy.called, "still alive");

			that.expectRequest({
					method : "POST",
					url : "Artists(ArtistID='23',IsActiveEntity=true)"
						+ "/special.cases.EditAction",
					payload : {}
				}, {/* This page intentionally left blank. */})
				.expectMessages([{
					message : "Cannot replace w/o return value context",
					persistent : true,
					technical : true,
					type : "Error"
				}]);
			that.oLogMock.expects("error")
				.withExactArgs("Failed to invoke /Artists(ArtistID='23',IsActiveEntity=true)"
					+ "/special.cases.EditAction(...)",
					sinon.match("Cannot replace w/o return value context"), sODCB);

			return Promise.all([
				// code under test
				oActionBinding.invoke(undefined, false, null, /*bReplaceWithRVC*/true)
					.then(mustFail(assert), function (oError) {
						assert.strictEqual(oError.message,
							"Cannot replace w/o return value context");
					}),
				that.waitForChanges(assert, "invoke EditAction")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Combine the various forms of filters and remove them again.
	// BCP: 2280148151
	QUnit.test("BCP: 2280148151", function (assert) {
		var oListBinding,
			that = this;

		return this.createView(assert, "").then(function () {
			var aApplicationFilters = [
					new Filter("MEMBER_COUNT", FilterOperator.GT, 3),
					new Filter({
						caseSensitive : false,
						operator : FilterOperator.EQ,
						path : "BudgetCurrency",
						value1 : "EUR"
					}),
					new Filter({
						condition : new Filter("employee/AGE", FilterOperator.GT, 18),
						operator : FilterOperator.Any,
						path : "TEAM_2_EMPLOYEES",
						variable : "employee"
					})
				],
				aControlFilters = [
					new Filter("Budget", FilterOperator.GE, 1000),
					new Filter("Name", FilterOperator.StartsWith, "T")
				];

			that.expectRequest("TEAMS?$filter=Budget ge 1000 and startswith(Name,'T')"
				+ " and MEMBER_COUNT gt 3 and tolower(BudgetCurrency) eq tolower('EUR')"
				+ " and TEAM_2_EMPLOYEES/any(employee:employee/AGE gt 18)"
				+ " and (Team_Id)&$skip=0&$top=42", {value : []});

			oListBinding = that.oModel.bindList("/TEAMS", null, [], aApplicationFilters, {
				$filter : "Team_Id"
			});

			that.expectCanceledError("Cache discarded as a new cache has been created");

			// code under test
			oListBinding.filter(aControlFilters, FilterType.Control);

			return Promise.all([
				oListBinding.requestContexts(0, 42),
				that.waitForChanges(assert)
			]);
		}).then(function () {
			that.expectRequest("TEAMS?$skip=8&$top=15", {value : []});

			oListBinding.changeParameters({$filter : undefined});
			oListBinding.filter([]);
			// code under test
			oListBinding.filter([], FilterType.Control);

			return Promise.all([
				oListBinding.requestContexts(8, 15),
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: A return value context is destroyed as soon as a new cache is created during
	// #invoke, no matter what happens after that.
	//
	// JIRA: CPOUI5ODATAV4-1687
	QUnit.test("JIRA: CPOUI5ODATAV4-1687", function (assert) {
		var oActionBinding,
			sActionName = "com.sap.gateway.default.iwbep.tea_busi.v0001.AcChangeTeamOfEmployee",
			oModel = this.createTeaBusiModel(),
			oReturnValueContext,
			sView = '\
<FlexBox binding="{/EMPLOYEES(\'2\')}">\
	<Text id="name" text="{Name}"/>\
	<Text id="team" text="{TEAM_ID}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("EMPLOYEES('2')", {
				ID : "2",
				Name : "Frederic Fall",
				TEAM_ID : "TEAM_01"
			})
			.expectChange("name", "Frederic Fall")
			.expectChange("team", "TEAM_01");

		return this.createView(assert, sView, oModel).then(function () {
			var oContext = that.oView.byId("name").getBindingContext();

			oActionBinding = oModel.bindContext(sActionName + "(...)", oContext);
			oActionBinding.setParameter("TeamID", "TEAM_02");

			that.expectRequest({
					method : "POST",
					payload : {TeamID : "TEAM_02"},
					url : "EMPLOYEES('2')/" + sActionName
				}, {
					ID : "2",
					Name : "Frederic Fall",
					TEAM_ID : "TEAM_02"
				})
				.expectChange("team", "TEAM_02");

			return Promise.all([
				oActionBinding.invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			oReturnValueContext = aResults[0];

			assert.strictEqual(oReturnValueContext.getProperty("Name"), "Frederic Fall");

			that.expectRequest({
					method : "POST",
					payload : {TeamID : "TEAM_0815"},
					url : "EMPLOYEES('2')/" + sActionName
				}, {
					// ID : "2", // no key predicate here!
					Name : "n/a",
					TEAM_ID : "TEAM_0815"
				});
			// Note: w/o key predicate, do not update binding parameter!

			return Promise.all([
				// code under test
				oActionBinding.setParameter("TeamID", "TEAM_0815").invoke(),
				that.waitForChanges(assert)
			]);
		}).then(function (aResults) {
			assert.strictEqual(aResults[0], undefined, "no R.V.C. w/o key predicate");
			assert.strictEqual(oReturnValueContext.getModel(), undefined, "destroyed");
		});
	});

	//*********************************************************************************************
	// Scenario: PATCHing a nested entity below an RVC fails. Check the resulting target path in the
	// error message.
	//
	// BCP: 2270142577
	//
	// Test whether #resetChanges for a RVC works as expected (JIRA: CPOUI5ODATAV4-2062)
	QUnit.test("BCP: 2270142577", function (assert) {
		var oDirtyControl,
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<FlexBox id="artist" binding="{/Artists(ArtistID=\'1\',IsActiveEntity=true)}">\
	<Text id="artistId" text="{ArtistID}"/>\
</FlexBox>\
<FlexBox id="form">\
	<Input id="user" value="{DraftAdministrativeData/InProcessByUser}"/>\
	<Input id="sendsAutographs" value="{sendsAutographs}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("Artists(ArtistID='1',IsActiveEntity=true)"
				+ "?$select=ArtistID,IsActiveEntity",
				{ArtistID : "1", IsActiveEntity : true})
			.expectChange("artistId", "1")
			.expectChange("user");
			//.expectChange("sendsAutographs"); do not observe so that we can call Control#setValue

		return this.createView(assert, sView, oModel).then(function () {
			var oAction = oModel.bindContext("special.cases.EditAction(...)",
					that.oView.byId("artist").getBindingContext());

			that.expectRequest({
				method : "POST",
				url : "Artists(ArtistID='1',IsActiveEntity=true)/special.cases.EditAction",
				payload : {}
			}, {
				ArtistID : "1",
				IsActiveEntity : false
			});

			return Promise.all([
				oAction.invoke(),
				that.waitForChanges(assert, "edit")
			]);
		}).then(function (aResults) {
			that.expectRequest("Artists(ArtistID='1',IsActiveEntity=false)"
					+ "?$select=sendsAutographs"
					+ "&$expand=DraftAdministrativeData($select=DraftID,InProcessByUser)", {
					DraftAdministrativeData : {
						DraftID : "2",
						InProcessByUser : "JOHNDOE"
					},
					sendsAutographs : false
				})
				.expectChange("user", "JOHNDOE");

			that.oView.byId("form").setBindingContext(aResults[0]);

			return that.waitForChanges(assert, "bind RVC");
		}).then(function () {
			that.expectChange("user", "invalid")
				.expectRequest({
					method : "PATCH",
					url : "Artists(ArtistID='1',IsActiveEntity=false)/DraftAdministrativeData",
					payload : {InProcessByUser : "invalid"}
				}, createErrorInsideBatch({
					details : [{
						message : "Invalid User",
						target : "InProcessByUser",
						"@Common.numericSeverity" : 4
					}]
				}))
				.expectMessages([{
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					technical : true,
					type : "Error"
				}, {
					message : "Invalid User",
					persistent : true,
					target : "/Artists(ArtistID='1',IsActiveEntity=false)/DraftAdministrativeData"
						+ "/InProcessByUser",
					type : "Error"
				}]);

			that.oLogMock.expects("error")
				.withArgs("Failed to update path /Artists(ArtistID='1',IsActiveEntity=false)"
					+ "/DraftAdministrativeData/InProcessByUser");

			that.oView.byId("user").getBinding("value").setValue("invalid");

			return that.waitForChanges(assert, "patch nested entity");
		}).then(function () {
			oDirtyControl = that.oView.byId("sendsAutographs");

			oDirtyControl.setValue("bad"); // "bad" does not reach the model

			assert.ok(oDirtyControl.getBinding("value").getDataState().isControlDirty());

			return Promise.all([
				that.checkValueState(assert, "user", "Error", "Invalid User"),
				that.checkValueState(assert, "sendsAutographs", "Error", 'Enter "Yes" or "No".')
			]);
		}).then(function () {
			that.expectChange("user", "JOHNDOE")
				.expectCanceledError("Failed to update path /Artists(ArtistID='1',"
					+ "IsActiveEntity=false)/DraftAdministrativeData/InProcessByUser",
					"Request canceled: PATCH Artists(ArtistID='1',IsActiveEntity=false)"
					+ "/DraftAdministrativeData; group: $parked.$auto");

			return Promise.all([
				// code under test (JIRA: CPOUI5ODATAV4-2062)
				that.oView.byId("form").getBindingContext().resetChanges(),
				that.waitForChanges(assert, "JIRA: CPOUI5ODATAV4-2062")
			]);
		}).then(function () {
			assert.notOk(oDirtyControl.getBinding("value").getDataState().isControlDirty());

			return Promise.all([
				that.checkValueState(assert, "sendsAutographs", "None", ""),
				// transition message must be removed by application code
				that.checkValueState(assert, "user", "Error", "Invalid User")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: ODLB#getAllCurrentContexts must not fire unnecessary change events and must not
	// modify internal states of the binding. Calling ODLB#getLength afterwards works as expected.
	//
	// Simulate a possible infinite loop here.
	// If a t:Table (with MDCTable wrapper) uses rowMode=Auto, then there is a "change"
	// listener in RowMode#updateTable. It calls ODLB#getContexts (which calls fetchContexts ->
	// createContexts -> modifies bLengthFinal) and fires a "rowsUpdated" event, where another
	// listener in MDCTable#_handleUpdateFinished reacts on. That listener calls
	// ODLB#getAllCurrentContexts, which would again fire a change event, creating an infinite loop.
	// BCP: 2270093727
	//
	// Check that v4.Context#hasPendingChanges also works for unbound properties (1) and test a
	// workaround for the missing v4.Context#resetChanges (2)
	// (https://github.com/SAP/openui5/issues/3562)
	QUnit.test("BCP: 2270093727", function (assert) {
		var oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sView = '\
<t:Table id="table" rows="{path: \'/SalesOrderList\', parameters: {$count : true}}"\
		threshold="0" visibleRowCount="4">\
	<Text id="salesOrderID" text="{SalesOrderID}"/>\
	<Input id="grossAmount" value="{GrossAmount}"/>\
</t:Table>',
			that = this;

		this.expectRequest("SalesOrderList"
				+ "?$count=true&$select=GrossAmount,SalesOrderID&$skip=0&$top=4", {
				"@odata.count" : "20",
				value : [
					{SalesOrderID : "01", GrossAmount : "23"},
					{SalesOrderID : "02", GrossAmount : "23"},
					{SalesOrderID : "03", GrossAmount : "23"},
					{SalesOrderID : "04", GrossAmount : "23"}
				]
			})
			.expectChange("salesOrderID", ["01", "02", "03", "04"]);

		return this.createView(assert, sView, oModel).then(function () {
			var oBinding = that.oView.byId("table").getBinding("rows"),
				oContext = oBinding.getCurrentContexts()[0],
				oPatchPromise,
				oResetPromise;

			// code under test (1)
			oPatchPromise = oContext.setProperty("Note", "n/a", "doNotSubmit");

			assert.ok(oContext.hasPendingChanges());

			that.expectCanceledError("Failed to update path /SalesOrderList('01')/Note",
				"Request canceled: PATCH SalesOrderList('01'); group: doNotSubmit");

			// code under test (2)
			oResetPromise = oModel.bindContext("", oContext).resetChanges();

			oBinding.attachChange(function () {
				assert.ok(false);
				oBinding.getContexts(0, 4);
				oBinding.getAllCurrentContexts();
			});

			assert.strictEqual(oBinding.getLength(), 20, "before");

			// code under test
			assert.deepEqual(oBinding.getAllCurrentContexts().map(getPath), [
				"/SalesOrderList('01')",
				"/SalesOrderList('02')",
				"/SalesOrderList('03')",
				"/SalesOrderList('04')"
			]);

			assert.strictEqual(oBinding.getLength(), 20, "after");

			return Promise.all([
				checkCanceled(assert, oPatchPromise),
				oResetPromise.then(function () {
					assert.notOk(oContext.hasPendingChanges());
				}),
				oModel.submitBatch("doNotSubmit"), // expect no PATCH
				that.waitForChanges(assert)
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: An object page is requesting messages for its root object, including messages for
	// its items. For a single item, messages are requested as a side effect, replacing exactly
	// those of this one item. Still, the items table does not request messages when paging.
	//
	// A side effect for all structural properties ("*") or an empty navigation property path ("")
	// of a single(!) row requests messages, but does not remove other rows' messages. On the other
	// hand, a refresh of a single row does not treat messages specially. Sorting of the items table
	// does not remove any messages, although its cache has reported some of them.
	// BCP: 2380020646
	QUnit.test("BCP: 2380020646", function (assert) {
		var oListBinding,
			oModel = this.createSalesOrdersModel({autoExpandSelect : true}),
			sPrefix = "/SalesOrderList('1')/",
			oTable,
			sView = '\
<FlexBox binding="{path : \'/SalesOrderList(\\\'1\\\')\', parameters : {$select : \'Messages\'}}"\
		id="form">\
	<Text id="id" text="{SalesOrderID}"/>\
	<t:Table id="table" rows="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}"\
			 threshold="0" visibleRowCount="2">\
		<Text id="itemPosition" text="{ItemPosition}"/>\
		<Text id="quantity" text="{Quantity}"/>\
	</t:Table>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
				+ "?$select=ItemPosition,Quantity,SalesOrderID&$skip=0&$top=2", {
				value : [{
					ItemPosition : "0010",
					Quantity : "0",
					SalesOrderID : "1"
				}, {
					ItemPosition : "0020",
					Quantity : "20",
					SalesOrderID : "1"
				}]
			})
			.expectChange("itemPosition", ["0010", "0020"])
			.expectChange("quantity", ["0.000", "20.000"])
			.expectRequest("SalesOrderList('1')?$select=Messages,SalesOrderID", {
				Messages : [{
					code : "1.0010",
					message : "Enter a minimum quantity of 0010",
					numericSeverity : 3,
					target : "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')/Quantity",
					transition : false
				}, {
					code : "1.0030",
					message : "Enter a minimum quantity of 0030",
					numericSeverity : 3,
					target : "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0030')/Quantity",
					transition : false
				}],
				SalesOrderID : "1"
			})
			.expectChange("id", "1")
			.expectMessages([{
				code : "1.0010",
				message : "Enter a minimum quantity of 0010",
				target : sPrefix + "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')/Quantity",
				type : "Warning"
			}, {
				code : "1.0030",
				message : "Enter a minimum quantity of 0030",
				target : sPrefix + "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0030')/Quantity",
				type : "Warning"
			}]);

		return this.createView(assert, sView, oModel).then(function () {
			oTable = that.oView.byId("table");
			oListBinding = oTable.getBinding("rows");

			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Messages,SalesOrderID"
					+ "&$filter=SalesOrderID eq '1' and ItemPosition eq '0010'", {
					value : [{
						ItemPosition : "0010",
						Messages : [{
							code : "OK",
							message : "Just A Message",
							numericSeverity : 1,
							target : "Quantity",
							transition : false
						}],
						SalesOrderID : "1"
					}]
				})
				.expectMessages([{
					code : "OK",
					message : "Just A Message",
					target : sPrefix + "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')/Quantity",
					type : "Success"
				}, {
					code : "1.0030",
					message : "Enter a minimum quantity of 0030",
					target : sPrefix + "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0030')/Quantity",
					type : "Warning"
				}]);

			return Promise.all([
				// code under test
				oListBinding.getCurrentContexts()[0].requestSideEffects(["Messages"]),
				that.waitForChanges(assert, "side effect: single row's messages")
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Quantity,SalesOrderID&$skip=2&$top=2", {
					value : [{
						ItemPosition : "0030",
						Quantity : "0",
						SalesOrderID : "1"
					}, {
						ItemPosition : "0040",
						Quantity : "40",
						SalesOrderID : "1"
					}]
				})
				.expectChange("itemPosition", [,, "0030", "0040"])
				.expectChange("quantity", [,, "0.000", "40.000"]);

			// code under test
			oTable.setFirstVisibleRow(2);

			return that.waitForChanges(assert, "scroll down");
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Messages,Quantity,SalesOrderID"
					+ "&$filter=SalesOrderID eq '1' and ItemPosition eq '0030'", {
					value : [{
						ItemPosition : "0030",
						Messages : [{
							code : "NEW",
							message : "Yet Another Message",
							numericSeverity : 2,
							target : "Quantity",
							transition : false
						}],
						Quantity : "30",
						SalesOrderID : "1"
					}]
				})
				.expectChange("quantity", [,, "30.000"])
				.expectMessages([{
					code : "OK",
					message : "Just A Message",
					target : sPrefix + "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')/Quantity",
					type : "Success"
				}, {
					code : "NEW",
					message : "Yet Another Message",
					target : sPrefix + "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0030')/Quantity",
					type : "Information"
				}]);

			return Promise.all([
				// code under test
				oListBinding.getCurrentContexts()[0].requestSideEffects(["*"]),
				that.waitForChanges(assert, "side effect: * for single row")
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')"
					+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0030')"
					+ "?$select=ItemPosition,Messages,Quantity,SalesOrderID", {
					ItemPosition : "0030",
					Messages : [{
						code : "OLD",
						message : "Yesterday",
						numericSeverity : 4,
						target : "Quantity",
						transition : true
					}],
					Quantity : "31",
					SalesOrderID : "1"
				})
				.expectChange("quantity", [,, "31.000"])
				.expectMessages([{
					code : "OK",
					message : "Just A Message",
					target : sPrefix + "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0010')/Quantity",
					type : "Success"
				}, {
					code : "OLD",
					message : "Yesterday",
					persistent : true,
					target : sPrefix + "SO_2_SOITEM(SalesOrderID='1',ItemPosition='0030')/Quantity",
					type : "Error"
				}]);

			return Promise.all([
				// code under test
				oListBinding.getCurrentContexts()[0].requestSideEffects([""]),
				that.waitForChanges(assert, "side-effects refresh of single row")
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')"
					+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='0040')"
					+ "?$select=ItemPosition,Quantity,SalesOrderID", {
					ItemPosition : "0040",
					Quantity : "41",
					SalesOrderID : "1"
				})
				.expectChange("quantity", [,,, "41.000"]);

			return Promise.all([
				// code under test
				oListBinding.getCurrentContexts()[1].requestRefresh(),
				that.waitForChanges(assert, "refresh single row: no messages")
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
					+ "?$select=ItemPosition,Quantity,SalesOrderID&$orderby=ItemPosition desc"
					+ "&$skip=0&$top=2", {
					value : [{
						ItemPosition : "0040",
						Quantity : "42",
						SalesOrderID : "1"
					}, {
						ItemPosition : "0030",
						Quantity : "32",
						SalesOrderID : "1"
					}]
				})
				.expectChange("itemPosition", ["0040", "0030"])
				.expectChange("quantity", ["42.000", "32.000"]);
				// Note: expect NO change in messages

			// code under test
			oListBinding.sort(new Sorter("ItemPosition", true));

			return that.waitForChanges(assert, "sort");
		});
	});

	//*********************************************************************************************
	// Scenario: (1+2) Context#resetChanges within an absolute ODLB (only PATCHes, and DELETEs)
	// Patch two entities, patch and delete a third entity, delete a fourth entity, call
	// Context#resetChanges for first and the third entity, submit the batch and see that only the
	// remaining PATCH request and the remaining DELETE request are sent.
	//
	// JIRA: CPOUI5ODATAV4-1786
	QUnit.test("CPOUI5ODATAV4-1786: (1+2) Context#resetChanges absolute ODLB", function (assert) {
		var oBinding,
			oContext1,
			oContext2,
			oContext3,
			oContext4,
			oDeletePromise3,
			oDeletePromise4,
			oModel = this.createSalesOrdersModel({updateGroupId : "update"}),
			oPatchPromise1,
			oPatchPromise2,
			oPatchPromise3,
			fnResolveDelete,
			fnResolvePatch,
			oSubmitBatchPromise,
			sView = '\
<Table id="orders" items="{/SalesOrderList}">\
	<Text id="note" text="{Note}"/>\
</Table>',
			that = this;

		this.expectRequest("SalesOrderList?$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1", Note : "Order 1"},
					{SalesOrderID : "2", Note : "Order 2"},
					{SalesOrderID : "3", Note : "Order 3"},
					{SalesOrderID : "4", Note : "Order 4"}
				]
			})
			.expectChange("note", ["Order 1", "Order 2", "Order 3", "Order 4"]);

		return this.createView(assert, sView, oModel).then(function () {
			var aContexts;

			oBinding = that.oView.byId("orders").getBinding("items");
			aContexts = oBinding.getCurrentContexts();
			oContext1 = aContexts[0]; // patched context to be reset
			oContext2 = aContexts[1]; // PATCH to be submitted
			oContext3 = aContexts[2]; // patched+deleted context to be reset and undeleted
			oContext4 = aContexts[3]; // DELETE to be submitted

			that.expectChange("note", ["Order 1 changed", "Order 2 changed", "Order 3 changed"]);

			oPatchPromise1 = oContext1.setProperty("Note", "Order 1 changed");
			oPatchPromise2 = oContext2.setProperty("Note", "Order 2 changed");
			oPatchPromise3 = oContext3.setProperty("Note", "Order 3 changed");
			oDeletePromise3 = oContext3.delete();
			oDeletePromise4 = oContext4.delete();

			assert.ok(oContext1.hasPendingChanges());
			assert.ok(oContext2.hasPendingChanges());
			assert.ok(oContext3.hasPendingChanges());
			assert.ok(oContext3.isDeleted());
			assert.ok(oContext4.hasPendingChanges());
			assert.ok(oContext4.isDeleted());
			assert.ok(oBinding.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges());

			return that.waitForChanges(assert, "patch + delete entities");
		}).then(function () {
			that.expectCanceledError("Failed to update path /SalesOrderList('1')/Note",
					"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectChange("note", ["Order 1"]);

			return Promise.all([
				// code under test
				oContext1.resetChanges().then(function () {
					assert.notOk(oContext1.hasPendingChanges());
					assert.ok(oContext2.hasPendingChanges());
					assert.ok(oContext3.hasPendingChanges());
					assert.ok(oContext3.isDeleted());
					assert.ok(oContext4.hasPendingChanges());
					assert.ok(oContext4.isDeleted());
					assert.ok(oBinding.hasPendingChanges());
					assert.ok(oModel.hasPendingChanges());
				}),
				checkCanceled(assert, oPatchPromise1),
				that.waitForChanges(assert, "reset one patched entity")
			]);
		}).then(function () {
			that.expectCanceledError("Failed to delete /SalesOrderList('3')",
					"Request canceled: DELETE SalesOrderList('3'); group: update")
				.expectCanceledError("Failed to update path /SalesOrderList('3')/Note",
					"Request canceled: PATCH SalesOrderList('3'); group: update")
				.expectChange("note", [,, "Order 3"]);

			return Promise.all([
				// code under test
				oContext3.resetChanges().then(function () {
					assert.notOk(oContext1.hasPendingChanges());
					assert.ok(oContext2.hasPendingChanges());
					assert.notOk(oContext3.hasPendingChanges());
					assert.notOk(oContext3.isDeleted());
					assert.ok(oContext4.hasPendingChanges());
					assert.ok(oContext4.isDeleted());
					assert.ok(oBinding.hasPendingChanges());
					assert.ok(oModel.hasPendingChanges());
				}),
				checkCanceled(assert, oPatchPromise3),
				checkCanceled(assert, oDeletePromise3),
				that.waitForChanges(assert, "reset one patched+deleted entity")
			]);
		}).then(function () {
			that.expectRequest({
					batchNo : 2,
					method : "PATCH",
					url : "SalesOrderList('2')",
					payload : {Note : "Order 2 changed"}
				}, new Promise(function (resolve) {
					fnResolvePatch = resolve;
				}))
				.expectRequest({
					batchNo : 2,
					method : "DELETE",
					url : "SalesOrderList('4')"
				}, new Promise(function (resolve) {
					fnResolveDelete = resolve;
				}));

			oSubmitBatchPromise = oModel.submitBatch("update");

			return that.waitForChanges(assert, "submit remaining change and deletion");
		}).then(function () {
			assert.throws(function () {
				// code under test
				oContext2.resetChanges();
			}, new Error("Cannot reset the changes, the batch request is running"));

			fnResolvePatch(); // 204 No Content
			fnResolveDelete(); // 204 No Content

			return Promise.all([
				oPatchPromise2,
				oDeletePromise4,
				oSubmitBatchPromise,
				that.waitForChanges(assert, "throw error during running $batch")
			]);
		}).then(function () {
			assert.notOk(oContext1.hasPendingChanges());
			assert.notOk(oContext2.hasPendingChanges());
			assert.notOk(oContext3.hasPendingChanges());
			assert.notOk(oContext3.isDeleted());
			assert.notOk(oContext4.hasPendingChanges());
			assert.ok(oContext4.isDeleted());
			assert.notOk(oBinding.hasPendingChanges());
			assert.notOk(oModel.hasPendingChanges());
		});
	});

	//*********************************************************************************************
	// Scenario: (5a) Context#resetChanges within a relative ODLB below an object page ODCB w/ own
	// cache, below and not below an intermediate ODCB w/o cache. For the first sales order patch a
	// property in the object page and one line item in the relative ODLB, patch another line item
	// for a different sales order. Select the sales order of the first patched line item and call
	// #resetChanges. Submit changes and see that only the 2nd patch is sent.
	// JIRA: CPOUI5ODATAV4-1818
	//
	// See that edited inactive creation rows are also reset to their initial state.
	// JIRA: CPOUI5ODATAV4-2011
[true, false].forEach(function (bIntermediate) {
	var sTitle = "CPOUI5ODATAV4-1818: (5a) Context#resetChanges, resolved ODLB, bIntermediate="
		+ bIntermediate;

	QUnit.test(sTitle, function (assert) {
		var oItem1New,
			oItem2New,
			oItems,
			oIntermediate,
			oModel = this.createSalesOrdersModel({
				updateGroupId : "update",
				autoExpandSelect : true
			}),
			oObjectPage,
			aOrderContexts,
			oOrders,
			oPatchPromise1,
			oPatchPromise11,
			oPatchPromise1New,
			oPatchPromise22,
			oPatchPromise2New,
			sView = '\
<Table id="orders" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>\
<FlexBox id="intermediate" ' + (bIntermediate ? 'binding="{}"' : "") + '>\
	<FlexBox id="objectPage" binding="{path : \'\', parameters : {$$ownRequest : true}}">\
		<Input id="soNote" value="{Note}"/>\
		<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
			<Input id="note" value="{Note}"/>\
		</Table>\
	</FlexBox>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"}
				]
			})
			.expectChange("id", ["1", "2"])
			.expectChange("soNote")
			.expectChange("note", []);

		return this.createView(assert, sView, oModel).then(function () {
			oOrders = that.oView.byId("orders").getBinding("items");
			oItems = that.oView.byId("items").getBinding("items");
			aOrderContexts = oOrders.getCurrentContexts();
			oObjectPage = that.oView.byId("objectPage");
			oIntermediate = bIntermediate ? that.oView.byId("intermediate") : oObjectPage;

			oItems.attachCreateActivate(function (oEvent) {
				oEvent.preventDefault(); // always results in an edited inactive creation row
			});

			that.expectRequest("SalesOrderList('2')?$select=Note,SalesOrderID", {Note : "SO 2"})
				.expectRequest("SalesOrderList('2')/SO_2_SOITEM"
				+ "?$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : 10, Note : "Item 2.10", SalesOrderID : "2"
					}, {
						ItemPosition : 20, Note : "Item 2.20", SalesOrderID : "2"
					}]
				})
				.expectChange("soNote", "SO 2")
				.expectChange("note", ["Item 2.10", "Item 2.20"]);

			oIntermediate.setBindingContext(aOrderContexts[1]);

			return that.waitForChanges(assert, "set context to '2'");
		}).then(function () {
			var oItem20 = oItems.getCurrentContexts()[1];

			that.expectChange("note", [, "Item 2.20 changed", "Item 2.new"]);

			oPatchPromise22 = oItem20.setProperty("Note", "Item 2.20 changed");
			oItem2New = oItems.create(undefined, true, true, /*bInactive*/true);
			oPatchPromise2New = oItem2New.setProperty("Note", "Item 2.new");

			assert.strictEqual(oItem2New.isInactive(), 1);
			assert.ok(oItem20.hasPendingChanges());
			assert.ok(oItems.hasPendingChanges());
			assert.ok(aOrderContexts[1].hasPendingChanges());
			assert.ok(oOrders.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges());

			return Promise.all([
				that.waitForChanges(assert, "patch item 2.20, create inactive 2.new"),
				oPatchPromise2New // already resolved because update was stored in the POST body
			]);
		}).then(function () {
			that.expectRequest("SalesOrderList('1')?$select=Note,SalesOrderID", {Note : "SO 1"})
				.expectRequest("SalesOrderList('1')/SO_2_SOITEM"
				+ "?$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : 10, Note : "Item 1.10", SalesOrderID : "1"
					}]
				})
				.expectChange("soNote", "SO 1")
				.expectChange("note", ["Item 1.10"]);

			oIntermediate.setBindingContext(aOrderContexts[0]);

			return that.waitForChanges(assert, "set context to '1'");
		}).then(function () {
			var oItem10 = oItems.getCurrentContexts()[0];

			//assert.ok(aOrderContexts[1].hasPendingChanges()); // don't care, because not current
			assert.notOk(oItems.hasPendingChanges()); // sees no changes in inactive caches
			assert.notOk(aOrderContexts[0].hasPendingChanges());

			that.expectChange("soNote", "SO 1 changed")
				.expectChange("note", ["Item 1.10 changed", "Item 1.new"]);

			oPatchPromise11 = oItem10.setProperty("Note", "Item 1.10 changed");
			oPatchPromise1 = oObjectPage.getBindingContext().setProperty("Note", "SO 1 changed");
			oItem1New = oItems.create(undefined, true, true, /*bInactive*/true);
			oPatchPromise1New = oItem1New.setProperty("Note", "Item 1.new");

			assert.strictEqual(oItem1New.isInactive(), 1);
			assert.strictEqual(oItem2New.isInactive(), 1);
			assert.ok(oItem10.hasPendingChanges());
			assert.ok(oItems.hasPendingChanges());
			assert.ok(aOrderContexts[0].hasPendingChanges());
			assert.ok(oOrders.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges());

			return Promise.all([
				that.waitForChanges(assert, "patch item 1.10, create inactive 1.new"),
				oPatchPromise1New
			]);
		}).then(function () {
			assert.ok(aOrderContexts[0].hasPendingChanges());

			that.expectCanceledError("Failed to update path /SalesOrderList('1')/Note",
				"Request canceled: PATCH SalesOrderList('1'); group: update")
				.expectCanceledError("Failed to update path /SalesOrderList('1')"
				+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10')/Note",
				"Request canceled: PATCH SalesOrderList('1')"
				+ "/SO_2_SOITEM(SalesOrderID='1',ItemPosition='10'); group: update")
				.expectChange("soNote", "SO 1")
				.expectChange("note", ["Item 1.10", ""]);

			return Promise.all([
				// code under test
				aOrderContexts[0].resetChanges(),
				checkCanceled(assert, oPatchPromise11),
				checkCanceled(assert, oPatchPromise1),
				that.waitForChanges(assert, "reset patched item 1.10 + edited inactive 1.new")
			]);
		}).then(function () {
			assert.strictEqual(oItem1New.isInactive(), true);
			assert.strictEqual(oItem2New.isInactive(), 1);
			assert.notOk(oItems.hasPendingChanges());
			assert.notOk(aOrderContexts[0].hasPendingChanges());
			assert.ok(oOrders.hasPendingChanges());
			assert.ok(oModel.hasPendingChanges());

			that.expectRequest({
					method : "PATCH",
					url : "SalesOrderList('2')/SO_2_SOITEM(SalesOrderID='2',ItemPosition='20')",
					payload : {Note : "Item 2.20 changed"}
				});// response does not matter here

			return Promise.all([
				oModel.submitBatch("update"),
				oPatchPromise22,
				that.waitForChanges(assert, "only remaining PATCH for 2.20")
			]);
		}).then(function () {
			assert.strictEqual(oItem1New.isInactive(), true);
			assert.strictEqual(oItem2New.isInactive(), 1);
			assert.notOk(oItems.hasPendingChanges()); // inactive is not in current binding hierar.
			assert.ok(oOrders.hasPendingChanges()); // parent binding sees still the edited inactive
			assert.notOk(aOrderContexts[0].hasPendingChanges());
			// assert.notOk(aOrderContexts[1].hasPendingChanges()); don't care
			assert.notOk(oModel.hasPendingChanges()); // model does not see inactive creation rows
		});
	});
});

	//*********************************************************************************************
	// Scenario: A draft version is shown in an object page and is discarded. It needs to be deleted
	// on the server, but in the background, with the draft still being shown on the UI. Only after
	// the deletion is successful, UI switches to the active version and the draft is deleted also
	// on the client (as a cleanup). Property bindings on the object page must not become unresolved
	// in between, because default values would be used by controls then, for example for "visible".
	//
	// BCP: 109953 / 2023 (002075129500001099532023)
	QUnit.test("BCP: 109953 / 2023 - delete context on server only", function (assert) {
		var oActiveContext,
			oDraftContext,
			sMessage1 = "It sure feels fine to see one's name in print",
			oModel = this.createSpecialCasesModel({autoExpandSelect : true}),
			sView = '\
<Text id="artistID" text="{ArtistID}"/>\
<Text id="isActiveEntity" text="{IsActiveEntity}"/>\
<Input id="name" value="{Name}"/>',
			that = this;

		this.expectChange("artistID")
			.expectChange("isActiveEntity")
			.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			oDraftContext = oModel.getKeepAliveContext(
				"/Artists(ArtistID='42',IsActiveEntity=false)", /*bRequestMessages*/true);

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)"
					+ "?$select=ArtistID,IsActiveEntity,Messages,Name", {
					"@odata.etag" : "ETag",
					ArtistID : "42",
					IsActiveEntity : false,
					Messages : [{
						message : sMessage1,
						numericSeverity : 1,
						target : "Name"
					}],
					Name : "Ms. Eliot"
				})
				.expectChange("artistID", "42")
				.expectChange("isActiveEntity", "No")
				.expectChange("name", "Ms. Eliot")
				.expectMessages([{
					message : sMessage1,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
					type : "Success"
				}]);

			that.oView.setBindingContext(oDraftContext);

			return that.waitForChanges(assert, "show draft");
		}).then(function () {
			return that.checkValueState(assert, that.oView.byId("name"), "Success", sMessage1);
		}).then(function () {
			var oSiblingEntity = that.oModel.bindContext("SiblingEntity(...)",
					oDraftContext, {$$inheritExpandSelect : true});

			that.expectRequest("Artists(ArtistID='42',IsActiveEntity=false)"
					+ "/SiblingEntity?$select=ArtistID,IsActiveEntity,Messages,Name", {
					ArtistID : "42",
					IsActiveEntity : true,
					Messages : [],
					Name : "Missy Eliot"
				});

			return Promise.all([
				// code under test
				oSiblingEntity.invoke("$auto", /*bIgnoreETag*/false,
					/*fnOnStrictHandlingFailed*/null, /*bReplaceWithRVC*/true),
				that.waitForChanges(assert, "SiblingEntity")
			]);
		}).then(function (aResults) {
			oActiveContext = aResults[0];

			that.expectRequest({
					headers : {"If-Match" : "ETag"},
					method : "DELETE",
					url : "Artists(ArtistID='42',IsActiveEntity=false)"
				}, undefined, {
					"sap-messages" : JSON.stringify([{
						code : "foo-42",
						message : "What a nice name!",
						numericSeverity : 2,
						target : "Name"
					}])
				})
				.expectMessages([{
					message : sMessage1,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
					type : "Success"
				}, {
					code : "foo-42",
					message : "What a nice name!",
					persistent : true,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
					type : "Information"
				}]);

			return Promise.all([
				// code under test
				oModel.delete(oDraftContext),
				that.waitForChanges(assert, "delete")
			]);
		}).then(function () { // Note: no changes to UI so far!
			return that.checkValueState(assert, that.oView.byId("name"), "Success", sMessage1);
		}).then(function () {
			that.expectChange("isActiveEntity", "Yes")
				.expectChange("name", "Missy Eliot");

			that.oView.setBindingContext(oActiveContext);

			return that.waitForChanges(assert, "show active");
		}).then(function () {
			return that.checkValueState(assert, that.oView.byId("name"), "None", "");
		}).then(function () {
			that.oLogMock.expects("error")
				.withArgs("Failed to delete /Artists(ArtistID='42',IsActiveEntity=false)");
			that.expectRequest({
					headers : {"If-Match" : "ETag"},
					method : "DELETE",
					url : "Artists(ArtistID='42',IsActiveEntity=false)"
				}, createErrorInsideBatch({target : "ArtistID"}))
				.expectMessages([{
					message : sMessage1,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
					type : "Success"
				}, {
					code : "foo-42",
					message : "What a nice name!",
					persistent : true,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/Name",
					type : "Information"
				}, {
					code : "CODE",
					message : "Request intentionally failed",
					persistent : true,
					target : "/Artists(ArtistID='42',IsActiveEntity=false)/ArtistID",
					technical : true,
					type : "Error"
				}]);

			return Promise.all([
				// code under test
				oModel.delete(oDraftContext).then(mustFail(assert), function (oError) {
					assert.strictEqual(oError.message, "Request intentionally failed");
				}),
				that.waitForChanges(assert, "delete again")
			]);
		}).then(function () {
			that.expectMessages([]);

			return Promise.all([
				// code under test
				oDraftContext.delete(null),
				that.waitForChanges(assert, "cleanup")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: When working with group $auto, first call ODLB#create and then immediately call
	// ODM#submitBatch. Expect that the latter's promise does not resolve before the create request
	// is completed.
	// BCP: 2370151708
	// No "sap-cancel-on-close" header in POST request (JIRA: CPOUI5ODATAV4-2506)
	QUnit.test("BCP: 2370151708 - submitBatch includes create ($auto)", async function (assert) {
		const oModel = this.createTeaBusiModel({autoExpandSelect : true});
		await this.createView(assert, "", oModel);

		let fnResolveCreate;
		this.expectRequest({
				method : "POST",
				headers : {/*NO "sap-cancel-on-close"*/},
				payload : {},
				url : "EMPLOYEES"
			}, new Promise(function (resolve) {
				fnResolveCreate = resolve.bind(null, {/* response does not matter here */});
			}));

		const oBinding = oModel.bindList("/EMPLOYEES");
		const oContext = oBinding.create({}, true);
		let bSubmitBatchCompleted = false;

		// code under test
		const oSubmitPromise = oModel.submitBatch("$auto").then(() => {
			bSubmitBatchCompleted = true;
		});

		await this.waitForChanges(assert, "create+submitBatch");

		assert.strictEqual(bSubmitBatchCompleted, false);

		fnResolveCreate();

		await Promise.all([oContext.created(), oSubmitPromise]);

		assert.strictEqual(bSubmitBatchCompleted, true);
	});

	//*********************************************************************************************
	// Scenario: Invoke actions and delete rows using group id "$single" and "$direct". Observe
	// that each invoke and delete request using "$single" is in its own batch request and does not
	// get overtaken by the "$direct" request.
	// JIRA: CPOUI5ODATAV4-2413
	QUnit.test("Invoke and delete immediately using groupId='$single'", async function (assert) {
		const oModel = this.createSalesOrdersModel({autoExpandSelect : true});
		const sView = `
<Table id="orders" items="{/SalesOrderList}">
	<Text id="id" text="{SalesOrderID}"/>
</Table>`;

		this.expectRequest({
				batchNo : 1,
				groupId : "$auto",
				url : "SalesOrderList?$select=SalesOrderID&$skip=0&$top=100"
			}, {value : [
				{SalesOrderID : "1"},
				{SalesOrderID : "2"},
				{SalesOrderID : "3"},
				{SalesOrderID : "4"},
				{SalesOrderID : "5"},
				{SalesOrderID : "6"}
			]})
			.expectChange("id", ["1", "2", "3", "4", "5", "6"]);

		await this.createView(assert, sView, oModel);

		const sAction = "com.sap.gateway.default.zui5_epm_sample.v0002.SalesOrder_Confirm";
		this.expectRequest({
				batchNo : 2,
				groupId : "$single",
				method : "POST",
				payload : {},
				url : "SalesOrderList('1')/" + sAction
			})
			.expectRequest({
				method : "POST",
				batchNo : 3,
				groupId : "$single",
				payload : {},
				url : "SalesOrderList('2')/" + sAction
			})
			.expectRequest({
				batchNo : -4,
				method : "POST",
				payload : {},
				url : "SalesOrderList('3')/" + sAction
		});

		const oListBinding = this.oView.byId("orders").getBinding("items");
		const [oContext0, oContext1, oContext2] = oListBinding.getAllCurrentContexts();

		const oContextBinding0 = oModel.bindContext(sAction + "(...)", oContext0);
		const oContextBinding1 = oModel.bindContext(sAction + "(...)", oContext1);
		const oContextBinding2 = oModel.bindContext(sAction + "(...)", oContext2);

		const oRVCPromise0 = oContextBinding0.invoke("$single");
		const oRVCPromise1 = oContextBinding1.invoke("$single");
		const oRVCPromise2 = oContextBinding2.invoke("$direct");

		await Promise.all([
			// code under test
			oRVCPromise0,
			oRVCPromise1,
			oRVCPromise2,
			this.waitForChanges(assert)
		]);

		this.expectRequest({
				batchNo : 5,
				groupId : "$single",
				method : "DELETE",
				url : "SalesOrderList('1')"
			})
			.expectRequest({
				batchNo : 6,
				groupId : "$single",
				method : "DELETE",
				url : "SalesOrderList('2')"
			})
			.expectRequest({
				batchNo : -7,
				method : "DELETE",
				url : "SalesOrderList('3')"
			})
			.expectChange("id", ["4", "5", "6"]);

		await Promise.all([
			// code under test
			oContext0.delete("$single"),
			oContext1.delete("$single"),
			oContext2.delete("$direct"),
			this.waitForChanges(assert)
		]);

		this.expectRequest({
				batchNo : 8,
				groupId : "$single",
				headers : {"If-Match" : "*"},
				method : "DELETE",
				url : "SalesOrderList('4')"
			})
			.expectRequest({
				batchNo : 9,
				groupId : "$single",
				headers : {"If-Match" : "*"},
				method : "DELETE",
				url : "SalesOrderList('5')"
			})
			.expectRequest({
				batchNo : -10,
				headers : {"If-Match" : "*"},
				method : "DELETE",
				url : "SalesOrderList('6')"
			});

		await Promise.all([
			// code under test
			oModel.delete("/SalesOrderList('4')", "$single"),
			oModel.delete("/SalesOrderList('5')", "$single"),
			oModel.delete("/SalesOrderList('6')", "$direct"),
			this.waitForChanges(assert)
		]);
	});

	//*********************************************************************************************
	// Scenario: Set a context to selected using a property binding to the client-side annotation
	// "@$ui5.context.isSelected".
	// JIRA: CPOUI5ODATAV4-1944
	//
	// Select a header context via all three possible ways: setSelected and write to the annotation
	// via context or property binding. Selecting the header context selects and deselects all row
	// contexts. A newly created inactive (and transient) row is also selected. Newly loaded rows
	// inherit the selection from the header context. Swap the context of the "select all" property
	// binding and check if change listeners are correctly removed.
	// JIRA: CPOUI5ODATAV4-2493
	QUnit.test("Selection on header context and row context", async function (assert) {
		const oModel = this.createSalesOrdersModel({autoExpandSelect : true});
		const sView = `
<Input id="selectAll" value="{path: '@$ui5.context.isSelected', targetType: 'any'}"/>
<Table id="table" growing="true" growingThreshold="3" items="{/SalesOrderList}">
	<Text id="id" text="{SalesOrderID}"/>
	<Input id="selected" value="{path : '@$ui5.context.isSelected', targetType: 'any'}"/>
</Table>`;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=3", {
				value : [
						{SalesOrderID : "1"},
						{SalesOrderID : "2"},
						{SalesOrderID : "3"}
					]
			})
			.expectChange("selectAll")
			.expectChange("id", ["1", "2", "3"])
			.expectChange("selected", [undefined, undefined, undefined]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oPropertyBinding = oTable.getItems()[0].getCells()[1].getBinding("value");
		const oContext = oPropertyBinding.getContext();

		this.expectChange("selected", [true]);

		// code under test
		oPropertyBinding.setValue(true);

		checkSelected(assert, oContext, true);
		await this.waitForChanges(assert, "rowContext selected");

		this.expectChange("selected", [false]);

		// code under test
		oPropertyBinding.setValue(false);

		checkSelected(assert, oContext, false);
		await this.waitForChanges(assert, "rowContext deselected");

		const oListBinding = oTable.getBinding("items");
		const oHeaderContext = oListBinding.getHeaderContext();
		const oSelectAllInput = this.oView.byId("selectAll");
		oSelectAllInput.setBindingContext(oHeaderContext);
		const oSelectAllBinding = oSelectAllInput.getBinding("value");

		this.expectChange("selectAll", true)
			.expectChange("selected", [true, true, true]);

		// code under test
		oSelectAllBinding.setValue(true);

		checkSelected(assert, oHeaderContext, true);
		await this.waitForChanges(assert, "headerContext selected via setValue");

		this.expectChange("id", [""])
			.expectChange("selected", [true]);

		// code under test - newly created row context is selected
		const oInactiveContext = oListBinding.create(undefined, true, false, true);

		assert.ok(oInactiveContext.isTransient());
		assert.ok(oInactiveContext.isInactive());
		assert.ok(oInactiveContext.isSelected());

		await this.waitForChanges(assert, "new row is selected");

		this.expectChange("selectAll", false)
			.expectChange("selected", [false, false, false]);

		// code under test
		oSelectAllBinding.setValue(false);

		checkSelected(assert, oHeaderContext, false);
		await this.waitForChanges(assert, "headerContext deselected via setValue");

		this.expectChange("selectAll", true)
			.expectChange("selected", [true, true, true]);

		// code under test
		oHeaderContext.setProperty("@$ui5.context.isSelected", true);

		checkSelected(assert, oHeaderContext, true);
		await this.waitForChanges(assert, "headerContext selected via setProperty");

		this.expectChange("selectAll", false)
			.expectChange("selected", [false, false, false]);

		// code under test
		oHeaderContext.setProperty("@$ui5.context.isSelected", false);

		checkSelected(assert, oHeaderContext, false);
		await this.waitForChanges(assert, "headerContext deselected via setProperty");

		this.expectChange("selectAll", true)
			.expectChange("selected", [true, true, true]);

		// code under test
		oHeaderContext.setSelected(true);

		checkSelected(assert, oHeaderContext, true);
		await this.waitForChanges(assert, "headerContext selected via setSelected");

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=3&$top=2", {
				value : [
					{SalesOrderID : "4"},
					{SalesOrderID : "5"}
				]
			})
			.expectChange("id", [,,, "3", "4", "5"])
			.expectChange("selected", [,,, true, true, true]);

		// code under test
		oTable.requestItems();

		await this.waitForChanges(assert, "contexts created by paging are also selected");

		this.expectChange("selectAll", false)
			.expectChange("selected", [false, false, false, false, false, false]);

		// code under test
		oHeaderContext.setSelected(false);

		checkSelected(assert, oHeaderContext, false);
		await this.waitForChanges(assert, "headerContext deselected via setSelected");

		this.expectChange("selectAll", true); // for setBindingContext

		const oNewListBinding = this.oModel.bindList("/SalesOrderList");
		oNewListBinding.getHeaderContext().setSelected(true);
		oSelectAllInput.setBindingContext(oNewListBinding.getHeaderContext());

		// code under test - no further change expected for "select all" binding
		oHeaderContext.setSelected(false);

		await this.waitForChanges(assert, "swap context of property binding");
	});

	//*********************************************************************************************
	// Scenario: With binding parameter $$clearSelectionOnFilter set, setting a filter or changing
	// $filter or $search parameters resets the selection state of all contexts of a list binding.
	// (1) : "Select all" & unselect one row context
	// (2) : Selecting an already selected header context selects all row contexts again
	// (3) : Select two row contexts (no "select all")
	// JIRA: CPOUI5ODATAV4-2203
	// SNOW: CS20240007001494
[
	{method : "filter", value : FilterType.Application, query : "GrossAmount ge 0"},
	{method : "filter", value : FilterType.Control, query : "GrossAmount ge 0"},
	{method : "changeParameters", value : "$filter", query : "GrossAmount ge 0"},
	{method : "changeParameters", value : "$search", query : "0"}
].forEach((oFixture) => {
	[false, true].forEach((bSuspend) => {
	const sTitle = `CPOUI5ODATAV4-2203: Reset selection on ${oFixture.value}, suspend=${bSuspend}`;
	QUnit.test(sTitle, async function (assert) {
		const oModel = this.createSalesOrdersModel({autoExpandSelect : true});
		const sView = `
<Table id="table" items="{parameters: {$$clearSelectionOnFilter: true}, path:'/SalesOrderList'}">
	<Text id="id" text="{SalesOrderID}"/>
	<Text id="grossAmount" text="{GrossAmount}"/>
	<Input id="selected" value="{path : '@$ui5.context.isSelected', targetType: 'any'}"/>
</Table>`;

		this.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1", GrossAmount : "1000"},
					{SalesOrderID : "2", GrossAmount : "2000"},
					{SalesOrderID : "3", GrossAmount : "3000"}
				]
			})
			.expectChange("id", ["1", "2", "3"])
			.expectChange("grossAmount", ["1,000.00", "2,000.00", "3,000.00"])
			.expectChange("selected", [undefined, undefined, undefined]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oListBinding = oTable.getBinding("items");
		const oHeaderContext = oListBinding.getHeaderContext();
		const oItems = oTable.getItems();

		this.expectChange("selected", [true, true, true]);
		this.expectChange("selected", [, false]);

		oHeaderContext.setSelected(true);
		oItems[1].getBindingContext().setSelected(false);

		assert.strictEqual(oHeaderContext.isSelected(), true);

		this.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&"
				+ (oFixture.method === "filter" ? "$filter" : oFixture.value) + "=" + oFixture.query
				+ "&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1", GrossAmount : "1000"},
					{SalesOrderID : "2", GrossAmount : "2000"},
					{SalesOrderID : "3", GrossAmount : "3000"}
				]
			})
			// #filter / #changeParameters resets the selection for "old" contexts
			.expectChange("selected", [false, /*false*/, false])
			.expectChange("selected", [undefined, undefined, undefined]);

		if (bSuspend) {
			oListBinding.suspend();
		}
		if (oFixture.method === "filter") {
			// code under test
			oListBinding.filter(new Filter("GrossAmount", FilterOperator.GE, 0), oFixture.value);
		} else {
			// code under test
			oListBinding.changeParameters({[oFixture.value] : oFixture.query});
		}
		if (bSuspend) {
			oListBinding.resume();
		}

		assert.strictEqual(oHeaderContext.isSelected(), false);

		await this.waitForChanges(assert, "after (1)");

		this.expectChange("selected", [true, true, true]);
		this.expectChange("selected", [false]);
		this.expectChange("selected", [true]);
		this.expectChange("selected", [false, false, false]); // preparation for test below

		oHeaderContext.setSelected(true);
		oItems[0].getBindingContext().setSelected(false);
		// code under test - "select all" again selects all row contexts, even if the header context
		// is already selected
		oHeaderContext.setSelected(true);
		oHeaderContext.setSelected(false); // preparation for test below

		await this.waitForChanges(assert, "reselect all (2)");

		this.expectChange("selected", [true, , true]);

		oItems[0].getBindingContext().setSelected(true);
		oItems[2].getBindingContext().setSelected(true);

		// same filter/search value will do nothing
		const sQuery = oFixture.query.replace("0", "1");

		this.expectRequest("SalesOrderList?$select=GrossAmount,SalesOrderID&"
				+ (oFixture.method === "filter" ? "$filter" : oFixture.value) + "=" + sQuery
				+ "&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1", GrossAmount : "1000"},
					{SalesOrderID : "2", GrossAmount : "2000"},
					{SalesOrderID : "3", GrossAmount : "3000"}
				]
			})
			.expectChange("selected", [false, , false])
			.expectChange("selected", [undefined, undefined, undefined]);

		if (bSuspend) {
			oListBinding.suspend();
		}
		if (oFixture.method === "filter") {
			// code under test
			oListBinding.filter(new Filter("GrossAmount", FilterOperator.GE, 1), oFixture.value);
		} else {
			// code under test
			oListBinding.changeParameters({[oFixture.value] : sQuery});
		}
		if (bSuspend) {
			oListBinding.resume();
		}

		await this.waitForChanges(assert, "after (2)");
	});
	});
});

	//*********************************************************************************************
	// Scenario: Dependent ContextBinding below a dependent ListBinding, below of an absolute
	// ListBinding, all w/ own cache. Set a row context of the absolute ListBinding as parent
	// context for the dependent ListBinding, and a row context of the dependent ListBinding as
	// parent context for the ContextBinding. A property in the ContextBinding is changed.
	// Afterwards this change is parked by setting another row context of the dependent ListBinding
	// as parent context of the ContextBinding. Now Context#resetChanges for the current parent
	// context of the dependent ListBinding is called. Check that the parked change is reset.
	// JIRA: CPOUI5ODATAV4-2015
	QUnit.test("CPOUI5ODATAV4-2015", function (assert) {
		var oItems,
			aItemContexts,
			oModel = this.createSalesOrdersModel({
				updateGroupId : "update",
				autoExpandSelect : true
			}),
			oOrders,
			aOrderContexts,
			oPatchPromise,
			sView = '\
<Table id="orders" items="{/SalesOrderList}">\
	<Text id="id" text="{SalesOrderID}"/>\
</Table>\
<Table id="items" items="{path : \'SO_2_SOITEM\', parameters : {$$ownRequest : true}}">\
	<Input id="note" value="{Note}"/>\
</Table>\
<FlexBox id="product" binding="{path : \'SOITEM_2_PRODUCT\', parameters : {$$ownRequest : true}}">\
	<Input id="name" value="{Name}"/>\
</FlexBox>',
			that = this;

		this.expectRequest("SalesOrderList?$select=SalesOrderID&$skip=0&$top=100", {
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"}
				]
			})
			.expectChange("id", ["1", "2"])
			.expectChange("note", [])
			.expectChange("name");

		return this.createView(assert, sView, oModel).then(function () {
			oOrders = that.oView.byId("orders").getBinding("items");
			aOrderContexts = oOrders.getCurrentContexts();

			that.expectRequest("SalesOrderList('2')/SO_2_SOITEM"
				+ "?$select=ItemPosition,Note,SalesOrderID&$skip=0&$top=100", {
					value : [{
						ItemPosition : 10, Note : "Item 2.10", SalesOrderID : "2"
					}, {
						ItemPosition : 20, Note : "Item 2.20", SalesOrderID : "2"
					}]
				})
				.expectChange("note", ["Item 2.10", "Item 2.20"]);

			oItems = that.oView.byId("items").setBindingContext(aOrderContexts[1]);

			return that.waitForChanges(assert, "select order '2'");
		}).then(function () {
			oItems = that.oView.byId("items").getBinding("items");
			aItemContexts = oItems.getCurrentContexts();

			that.expectRequest("SalesOrderList('2')/SO_2_SOITEM(SalesOrderID='2',ItemPosition='20')"
				+ "/SOITEM_2_PRODUCT?$select=Name,ProductID", {
					Name : "Notebook Basic 15",
					ProductID : "HT-1000"
				})
				.expectChange("name", "Notebook Basic 15");

			that.oView.byId("product").setBindingContext(aItemContexts[1]);

			return that.waitForChanges(assert, "select item '20'");
		}).then(function () {
			that.expectChange("name", "Notebook Basic 15 - changed");

			oPatchPromise = that.oView.byId("product").getBindingContext()
				.setProperty("Name", "Notebook Basic 15 - changed");

			return that.waitForChanges(assert, "patch 'HT-1000'");
		}).then(function () {
			that.expectRequest("SalesOrderList('2')/SO_2_SOITEM(SalesOrderID='2',ItemPosition='10')"
				+ "/SOITEM_2_PRODUCT?$select=Name,ProductID", {
					Name : "Notebook Basic 19",
					ProductID : "HT-1003"
				})
				.expectChange("name", "Notebook Basic 19");

			that.oView.byId("product").setBindingContext(aItemContexts[0]);

			return that.waitForChanges(assert, "select item '10'");
		}).then(function () {
			assert.notOk(aOrderContexts[0].hasPendingChanges());
			// below the current item (10) there is also no change visible
			assert.notOk(that.oView.byId("product").getBindingContext().hasPendingChanges());
			// but from the sales order root the change is reflected
			assert.ok(aOrderContexts[1].hasPendingChanges());
			// and also for the higher level bindings
			assert.ok(oOrders.hasPendingChanges());
			assert.ok(oItems.hasPendingChanges());
			assert.notOk(// the ODCB is bound to HT-1003 and does not see the PATCH for HT-1000
				that.oView.byId("product").getBindingContext().getBinding().hasPendingChanges());

			that.expectCanceledError(
				"Failed to update path /SalesOrderList('2')/"
				+ "SO_2_SOITEM(SalesOrderID='2',ItemPosition='20')/SOITEM_2_PRODUCT/Name",
				"Request canceled: PATCH ProductList('HT-1000'); group: update");

			return Promise.all([
				// code under test
				aOrderContexts[1].resetChanges(),
				checkCanceled(assert, oPatchPromise),
				that.waitForChanges(assert, "reset all changes below order '2'")
			]);
		}).then(function () {
			assert.notOk(that.oModel.hasPendingChanges());

			return Promise.all([
				that.oModel.submitBatch("update"),
				that.waitForChanges(assert, "no patch request")
			]);
		});
	});

	//*********************************************************************************************
	// Scenario: Create an item, persist it, select it and sort the cache. Because of the selected
	// (and thus effectively kept-alive) element, the cache cannot be recreated. Then delete the
	// created persisted item again and create another item. See that it is excluded when paging,
	// and that all elements are shown. $count is used so that we have a size limit for the read
	// requests.
	// (The bug caused $created and iActiveElements to be wrong. And iActiveElements is used to
	// calculate $count and the limit for subsequent reads.)
	// SNOW: DINC0109748
	QUnit.test("DINC0109748", async function (assert) {
		const oModel = this.createSalesOrdersModel({autoExpandSelect : true});
		const sView = `
<Text id="count" text="{$count}"/>
<Table id="table" growing="true" growingThreshold="2"
		items="{path : '/SalesOrderList', parameters : {$count : true}}">
	<Text id="id" text="{SalesOrderID}"/>
</Table>`;

		this.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID&$skip=0&$top=2", {
				"@odata.count" : "4",
				value : [
					{SalesOrderID : "1"},
					{SalesOrderID : "2"}
				]
			})
			.expectChange("count")
			.expectChange("id", ["1", "2"]);

		await this.createView(assert, sView, oModel);

		const oTable = this.oView.byId("table");
		const oListBinding = oTable.getBinding("items");

		this.expectChange("count", "4");

		this.oView.byId("count").setBindingContext(oListBinding.getHeaderContext());

		await this.waitForChanges(assert, "count");

		this.expectChange("id", ["5"])
			.expectChange("count", "5")
			.expectRequest({
				method : "POST",
				url : "SalesOrderList",
				payload : {SalesOrderID : "5"}
			}, {
				SalesOrderID : "5"
			});

		const oSalesOrder5 = oListBinding.create({SalesOrderID : "5"}, true);

		await Promise.all([
			oSalesOrder5.created(),
			this.waitForChanges(assert, "create Sales Order 5")
		]);

		oSalesOrder5.setSelected(true); // ensure that the cache is reset and not recreated

		this.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID"
				+ "&$orderby=SalesOrderID desc&$skip=0&$top=2", {
				"@odata.count" : "5",
				value : [
					{SalesOrderID : "5"},
					{SalesOrderID : "4"}
				]
			})
			.expectChange("id", [, "4"]);

		oListBinding.sort(new Sorter("SalesOrderID", true));

		await this.waitForChanges(assert, "sort desc");

		checkTable("after sort", assert, oTable, [
			"/SalesOrderList('5')",
			"/SalesOrderList('4')"
		], [["5"], ["4"]], 5);

		this.expectChange("count", "4")
			.expectRequest("DELETE SalesOrderList('5')")
			.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID"
				+ "&$orderby=SalesOrderID desc&$filter=not (SalesOrderID eq '5')&$skip=1&$top=1", {
				"@odata.count" : "4",
				value : [
					{SalesOrderID : "3"}
				]
			})
			.expectChange("id", [, "3"]);

		await Promise.all([
			// code under test
			oSalesOrder5.delete(),
			this.waitForChanges(assert, "delete Sales Order 4")
		]);

		checkTable("after delete", assert, oTable, [
			"/SalesOrderList('4')",
			"/SalesOrderList('3')"
		], [["4"], ["3"]], 4);

		this.expectChange("id", ["6"])
			.expectChange("count", "5")
			.expectRequest({
				method : "POST",
				url : "SalesOrderList",
				payload : {SalesOrderID : "6"}
			}, {
				SalesOrderID : "6"
			});

		oListBinding.create({SalesOrderID : "6"}, true);

		await this.waitForChanges(assert, "create Sales Order 6");

		checkTable("after create", assert, oTable, [
			"/SalesOrderList('6')",
			"/SalesOrderList('4')",
			"/SalesOrderList('3')"
		], [["6"], ["4"]], 5);

		this.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID"
				+ "&$orderby=SalesOrderID desc&$filter=not (SalesOrderID eq '6')&$skip=2&$top=1", {
				"@odata.count" : "4",
				value : [
					{SalesOrderID : "2"}
				]
			})
			.expectChange("id", [,, "3", "2"]);

		oTable.requestItems(); // show more items (requests one to have four)

		await this.waitForChanges(assert, "show more items");

		checkTable("after 'more'", assert, oTable, [
			"/SalesOrderList('6')",
			"/SalesOrderList('4')",
			"/SalesOrderList('3')",
			"/SalesOrderList('2')"
		], [["6"], ["4"], ["3"], ["2"]], 5);

		this.expectRequest("SalesOrderList?$count=true&$select=SalesOrderID"
				+ "&$orderby=SalesOrderID desc&$filter=not (SalesOrderID eq '6')&$skip=3&$top=1", {
				"@odata.count" : "4",
				value : [
					{SalesOrderID : "1"}
				]
			})
			.expectChange("id", [,,,, "1"]);

		oTable.requestItems(); // show more items (requests the missing one)

		await this.waitForChanges(assert, "show more items again");

		checkTable("after 'more' again", assert, oTable, [
			"/SalesOrderList('6')",
			"/SalesOrderList('4')",
			"/SalesOrderList('3')",
			"/SalesOrderList('2')",
			"/SalesOrderList('1')"
		], [["6"], ["4"], ["3"], ["2"], ["1"]]);
	});
});
