<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>QUnit Page for sap.m.StepInput</title>

	<script src="../shared-config.js"></script>
	<script id="sap-ui-bootstrap"
			src="../../../../resources/sap-ui-core.js"
			data-sap-ui-noConflict="true"
			data-sap-ui-libs="sap.m">
	</script>

	<link rel="stylesheet" href="../../../../resources/sap/ui/thirdparty/qunit.css" type="text/css" media="screen">
	<script src="../../../../resources/sap/ui/thirdparty/qunit.js"></script>
	<script src="../../../../resources/sap/ui/qunit/qunit-junit.js"></script>
	<script src="../../../../resources/sap/ui/thirdparty/sinon.js"></script>
	<script src="../../../../resources/sap/ui/thirdparty/sinon-ie.js"></script>
	<script src="../../../../resources/sap/ui/thirdparty/sinon-qunit.js"></script>
	<script src="../../../../resources/sap/ui/qunit/QUnitUtils.js"></script>
	<script src="../../../../resources/sap/ui/qunit/qunit-coverage.js"></script>

	<script>
		sinon.config.useFakeTimers = true;

		var oCore = sap.ui.getCore();

		QUnit.module("API", {
			beforeEach: function () {
				this.stepInput = new sap.m.StepInput();

				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
			}
		});

		QUnit.test("DOM", function (assert) {
			//assert
			var $stepInput = this.stepInput.$();
			ok($stepInput.length > 0, "The control was successfully rendered");
			equals($stepInput.attr("tabindex"), "-1", "tabindex attribute should be negative");
		});

		QUnit.test("incrementButton", function (assert) {
			//prepare
			var oIncrementButton = this.stepInput.getAggregation("_incrementButton");

			//assert
			equal(oIncrementButton.getNoTabStop(), true, "the button should not be part of tabchain")
			strictEqual(oIncrementButton.getMetadata().getName(), "sap.ui.core.Icon",
					"the picker aggregation holds an instance of an icon");

			assert.equal(oIncrementButton.getTooltip(), sap.m.StepInput.STEP_INPUT_INCREASE_BTN_TOOLTIP, "The tooltip is correct");

			//act
			oIncrementButton.firePress();
			this.clock.tick(1000);

			//assert
			strictEqual(this.stepInput.getValue(), 1,
					"The increment button successfully incremented the value");
		});

		QUnit.test("decrementButton", function (assert) {
			//prepare
			var oDecrementButton = this.stepInput.getAggregation("_decrementButton");

			//assert
			equal(oDecrementButton.getNoTabStop(), true, "the button should not be part of tabchain")
			strictEqual(oDecrementButton.getMetadata().getName(), "sap.ui.core.Icon",
					"the step input _decrementButton aggregation holds an instance of an icon");

			assert.equal(oDecrementButton.getTooltip(), sap.m.StepInput.STEP_INPUT_DECREASE_BTN_TOOLTIP, "The tooltip is correct");

			//act
			oDecrementButton.firePress();
			this.clock.tick(1000);

			//assert
			strictEqual(this.stepInput.getValue(), -1,
					"The decrement button successfully decremented the value");
		});

		QUnit.test("increase and decrease buttons are created only when actually needed", function() {
			//Prepare and Act
			var oSI = new sap.m.StepInput({editable: false});
			oSI.placeAt('qunit-fixture');
			oCore.applyChanges();
			//Assert
			equal(oSI.getAggregation("_decrementButton"), null,
					"No decrement button since the StepInput is not editable");
			equal(oSI.getAggregation("_incrementButton"), null,
					"No increment button since the StepInput is not editable");

			//Act
			oSI.setEditable(true);
			//Assert
			ok(oSI.getAggregation("_decrementButton"),
					"Decrement button is available once StepInput is editable");
			ok(oSI.getAggregation("_incrementButton"),
					"Increment button is available once StepInput is editable");

			//destroy
			oSI.destroy();
		});


		QUnit.test("input", function (assert) {
			//assert
			strictEqual(this.stepInput._getInput().getMetadata().getName(), "NumericInput",
					"the picker aggregation holds an instance of a numeric input");
			strictEqual(this.stepInput.getValue(), 0, "The default value is correctly set in the input");

			//act
			this.stepInput._getInput().setValue("random string");
			//assert
			strictEqual(this.stepInput.getValue(), 0, "The value is successfully set in the input");

		});


		QUnit.test("textAlign", function () {
			//assert
			strictEqual(this.stepInput._getInput().getTextAlign(), "End",
					"Text align is 'End'");

			//act
			this.stepInput.setEditable(false);
			//assert
			strictEqual(this.stepInput._getInput().getTextAlign(), "End",
					"Text align is 'End' also when is set to read-only");

			//act
			this.stepInput.setEditable(true);
			this.stepInput.setEnabled(false);
			//assert
			strictEqual(this.stepInput._getInput().getTextAlign(), "End",
					"Text align is 'End' also when the control is disabled");
		});

		QUnit.test("setMin", function () {
			//prepare & act
			var oSpyDisableButtons,
				oSpyVerifyValue;
			this.stepInput.setMin(undefined);
			//assert
			strictEqual(this.stepInput.getMin(), undefined,
					"Value of undefined is set");

			//act
			this.stepInput.setMin("string");
			//assert
			strictEqual(this.stepInput.getMin(), undefined,
					"Value of 'min' is not changed");

			//prepare
			oSpyDisableButtons = sinon.spy(this.stepInput, "_disableButtons");
			//act
			this.stepInput.setMin(9);
			//assert
			equal(oSpyDisableButtons.callCount, 1, "setMin always calls _disableButtons so the buttons state is reflected");
			strictEqual(oSpyDisableButtons.getCall(0).args[2], 9,
					"_disableButtons is called and argument 2 is 'min'");

			//prepare
			oSpyVerifyValue = sinon.spy(this.stepInput, "_verifyValue");
			//act
			this.stepInput.setMin(8);
			//assert
			equal(oSpyVerifyValue.callCount, 1, "setMin always calls _verifyValue so the valueState is addressed");
		});

		QUnit.test("setMax", function () {
			var oSpyDisableButtons,
					oSpyVerifyValue;
			//prepare
			this.stepInput.setMax(undefined);
			//assert
			strictEqual(this.stepInput.getMax(), undefined,
					"Value of undefined is set to the 'max'");

			//prepare
			this.stepInput.setMax("string");
			//assert
			strictEqual(this.stepInput.getMax(), undefined,
					"Value of 'max' is not changed");

			//prepare
			oSpyDisableButtons = sinon.spy(this.stepInput, "_disableButtons");
			//Act
			this.stepInput.setMax(20);
			// Assert
			equal(oSpyDisableButtons.callCount, 1,
					"setMax always calls _disableButtons so the buttons state is reflected");
			strictEqual(oSpyDisableButtons.getCall(0).args[1], 20,
					"_disableButtons is called and argument 1 is 'max'");

			//prepare
			oSpyVerifyValue = sinon.spy(this.stepInput, "_verifyValue");
			//Act
			this.stepInput.setMax(21);
			// Assert
			equal(oSpyVerifyValue.callCount, 1, "setMax always calls _verifyValue so the valueState is addressed");
		});

		QUnit.test('Testing for duplicate id', function (assert) {
			var oStepInput;

			try {
				oStepInput = new sap.m.StepInput({
					editable: true
				});
				assert.equal(1, 1, "The control is created succesfully");
			} catch (e) {
				assert.equal(1, 0, "Throws an error " + e.stack);
			}

			// destroy
			if (oStepInput) {
				oStepInput.destroy();
			}
		});

		QUnit.module("Operations", {
			beforeEach: function () {
				this.stepInput = new sap.m.StepInput({
							value: 3,
							max: 10
				});

				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
			}
		});


		QUnit.test("Disable button based on the value", function (assert) {
			//assert
			strictEqual(this.stepInput._getIncrementButton().$().hasClass("sapMStepInputIconDisabled"), false,
					"The increment button is enabled because the value fits to limits");
			strictEqual(this.stepInput._getDecrementButton().$().hasClass("sapMStepInputIconDisabled"), false,
					"The decrement button is enabled because the value fits to limits");

			//act
			this.stepInput.setMin(3);
			this.stepInput.onfocusout();
			//assert
			strictEqual(this.stepInput._getDecrementButton().$().hasClass("sapMStepInputIconDisabled"), true,
					"The decrement button is disabled because there's min and min = value");

			//act
			this.stepInput.setValue(2);
			//assert
			strictEqual(this.stepInput._getDecrementButton().$().hasClass("sapMStepInputIconDisabled"), true,
					"The decrement button is disabled because value < min");

			//act
			this.stepInput.setValue(4);
			this.stepInput.onfocusout();
			//assert
			strictEqual(this.stepInput._getDecrementButton().$().hasClass("sapMStepInputIconDisabled"), false,
					"The decrement button is enabled because the value > min");

			//act
			this.stepInput.setEnabled(false);
			oCore.applyChanges();
			//assert
			strictEqual(this.stepInput._getIncrementButton().$().hasClass("sapMStepInputIconDisabled"), true,
					"The increment button is disabled because setEnabled is set to false");

			//act
			this.stepInput.setEnabled(true);
			oCore.applyChanges();
			//assert
			strictEqual(this.stepInput._getIncrementButton().$().hasClass("sapMStepInputIconDisabled"), false,
					"The increment button is enabled because setEnabled is set to true");
			strictEqual(this.stepInput._getDecrementButton().$().hasClass("sapMStepInputIconDisabled"), false,
					"The decrement button is enabled because setEnabled is set to true");
		});

		QUnit.test("Increment button enabled/disabled state", function (assert) {
			//act
			this.stepInput._getInput().setValue(11);
			this.stepInput.onfocusout();
			//assert
			strictEqual(this.stepInput._getIncrementButton().$().hasClass("sapMStepInputIconDisabled"),
					true,
					"The increment button is disabled because value > max");
		});

		QUnit.test("Error state when setting values out of the limit", function (assert) {
			//act
			this.stepInput.setMin(3);
			this.stepInput.setValue(2);
			this.stepInput.onfocusout();

			//assert
			strictEqual(this.stepInput._getInput().getValueState(), "Error",
					"The value state is Error as it should be because the value is under the limit");

			//act
			//value becomes 3
			this.stepInput._getIncrementButton().firePress();
			this.stepInput.onfocusout();

			//assert
			strictEqual(this.stepInput._getInput().getValueState(), "None",
					"The value state is None as it should be because the value is equal to the min");
		});


		QUnit.module("Floating point", {
			beforeEach: function () {
				this.stepInput = new sap.m.StepInput({
					step: 1.1,
					max: 2,
					displayValuePrecision: 1
				});

				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
			}
		});

		QUnit.test("working with floating point", function (assert) {
			//prepare & act
			var oIncrementButton = this.stepInput.getAggregation("_incrementButton"),
			oDecrementButton = this.stepInput.getAggregation("_decrementButton");
			oIncrementButton.firePress();

			//assert
			strictEqual(this.stepInput.getValue(), 1.1, "The value is successfuly incremented");
			oDecrementButton.firePress();
			strictEqual(this.stepInput.getValue(), 0,
					"The value is successfuly decremented");

			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_UP);
			this.clock.tick(1000);

			//assert
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "1.1",
					"The input's value is successfully incremented");

			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_DOWN);
			this.clock.tick(1000);

			//assert
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "0.0",
					"The value is successfully decremented");

			//act
			oIncrementButton.firePress();
			oIncrementButton.firePress();

			//assert
			strictEqual(this.stepInput.getValue(), 2,
					"The value is successfully decremented");
		});

		QUnit.test("working with floating point value precision set to 2", function (assert) {
			this.stepInput.setDisplayValuePrecision(2);
			this.stepInput.setValue(431.15);
			this.stepInput.setMin(410.00);
			this.stepInput.setMax(440.00);
			this.stepInput.setStep(0.05);
			oCore.applyChanges();

			var oIncrementButton = this.stepInput.getAggregation("_incrementButton"),
				oDecrementButton = this.stepInput.getAggregation("_decrementButton");

			oIncrementButton.firePress();
			strictEqual(this.stepInput.getValue(), 431.2,
					"The value is successfuly incremented");
			oDecrementButton.firePress();
			strictEqual(this.stepInput.getValue(), 431.15,
					"The value is successfuly decremented");

			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_UP);
			this.clock.tick(1000);
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "431.20",
					"The input's value is successfully incremented");
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_DOWN);
			this.clock.tick(1000);
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "431.15",
					"The input's value is successfully decremented");
		});

		QUnit.test("working with floating point value precision set to 20", function (assert) {
			this.stepInput.setDisplayValuePrecision(20);
			this.stepInput.setValue(0.01);
			this.stepInput.setStep(0.06);
			oCore.applyChanges();
			var oIncrementButton = this.stepInput.getAggregation("_incrementButton");

			oIncrementButton.firePress();
			strictEqual(this.stepInput.getValue(), 0.07, "The value is successfuly incremented");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "0.07000000000000000000", "The input's value is successfully incremented");
		});

		QUnit.test("working with floating point value precision set to 17", function (assert) {
			this.stepInput.setDisplayValuePrecision(17);
			this.stepInput.setValue(0.01);
			this.stepInput.setStep(0.02);
			oCore.applyChanges();
			var oIncrementButton = this.stepInput.getAggregation("_incrementButton");

			oIncrementButton.firePress();
			strictEqual(this.stepInput.getValue(), 0.03, "The value is successfuly incremented");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "0.03000000000000000", "The input's value is successfully incremented");
		});

		QUnit.test("setting default displayValuePrecision when it is not correct", function (assert) {
			this.stepInput.setDisplayValuePrecision(25);
			oCore.applyChanges();

			strictEqual(this.stepInput.getDisplayValuePrecision(), 0, "The displayValuePrecision is set to 0");
		});

		QUnit.test("setting default displayValuePrecision when it is not correct and can't be converted to int", function (assert) {
			this.stepInput.setDisplayValuePrecision("test");
			oCore.applyChanges();

			strictEqual(this.stepInput.getDisplayValuePrecision(), 0, "The displayValuePrecision is set to 0");
		});

		QUnit.test("setting default displayValuePrecision when it is undefined", function (assert) {
			this.stepInput.setDisplayValuePrecision();
			oCore.applyChanges();

			strictEqual(this.stepInput.getDisplayValuePrecision(), 0, "The displayValuePrecision is set to 0");
		});

		QUnit.test("displayValuePrecision formating when digits after the dot are more than the value precision", function (assert) {
			this.stepInput.setDisplayValuePrecision(2);
			this.stepInput.setValue(1.104);
			oCore.applyChanges();

			strictEqual(this.stepInput.getValue(), 1.104, "The value is formated correctly");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "1.10", "The input value is correctly formatted");
		});

		QUnit.test("displayValuePrecision formating when digits after the dot are less than the value precision", function (assert) {
			this.stepInput.setDisplayValuePrecision(5);
			this.stepInput.setValue(1.104);
			oCore.applyChanges();

			strictEqual(this.stepInput.getValue(), 1.104, "The value is formated correctly");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "1.10400", "The input value is correctly formatted");
		});

		QUnit.test("displayValuePrecision formating when there are no digits after the dot and the value precision is bigger than 0", function (assert) {
			this.stepInput.setDisplayValuePrecision(5);
			this.stepInput.setValue(0);
			oCore.applyChanges();

			strictEqual(this.stepInput.getValue(), 0, "The value is formated correctly");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "0.00000", "The input value is correctly formatted");
		});

		QUnit.test("displayValuePrecision formating when there are digits after the dot and the value precision is 0", function (assert) {
			this.stepInput.setDisplayValuePrecision(0);
			this.stepInput.setValue(1.325);
			oCore.applyChanges();

			strictEqual(this.stepInput.getValue(), 1.325, "The value is formated correctly");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "1", "The input value is correctly formatted");
		});

		QUnit.test("Formating when displayValuePrecision is equal to the step precision", function (assert) {
			this.stepInput.setDisplayValuePrecision(4);
			this.stepInput.setStep(1.0035);
			this.stepInput.setValue(0.325);
			oCore.applyChanges();

			var oIncrementButton = this.stepInput.getAggregation("_incrementButton");

			oIncrementButton.firePress();

			strictEqual(this.stepInput.getValue(), 1.3285, "The value is formated correctly");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "1.3285", "The input value is correctly formatted");
		});

		QUnit.test("Formating when displayValuePrecision is smaller than the step precision", function (assert) {
			this.stepInput.setDisplayValuePrecision(2);
			this.stepInput.setStep(1.0035);
			this.stepInput.setValue(0.325);
			oCore.applyChanges();

			var oIncrementButton = this.stepInput.getAggregation("_incrementButton");

			oIncrementButton.firePress();

			strictEqual(this.stepInput.getValue(), 1.3285, "The value is formated correctly");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "1.33", "The input value is correctly formatted");
		});

		QUnit.test("Formating when displayValuePrecision is bigger than the step precision", function (assert) {
			this.stepInput.setDisplayValuePrecision(6);
			this.stepInput.setStep(1.0035);
			this.stepInput.setValue(0.325);
			oCore.applyChanges();

			var oIncrementButton = this.stepInput.getAggregation("_incrementButton");

			oIncrementButton.firePress();

			strictEqual(this.stepInput.getValue(), 1.3285, "The value is formated correctly");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "1.328500", "The input value is correctly formatted");
		});

		QUnit.test("Formating when displayValuePrecision is equal to the step precision, but the given value is with smaller precision than the displayValuePrecision", function (assert) {
			var oSI = new sap.m.StepInput({
				value: 431.5,
				min: 410.00,
				max: 440.00,
				step: 0.05,
				displayValuePrecision: 2
			});

			oSI.placeAt('qunit-fixture');
			oCore.applyChanges();

			strictEqual(oSI.getValue(), 431.5, "The value is formated correctly");
			strictEqual(oSI.getAggregation("_input")._getInputValue(), "431.50", "The input value is correctly formatted");

			oSI.destroy();
		});

		QUnit.test("Formatting when we have two different controls with values with different precision, but which will be resolved to one and the same display value", function (assert) {
			var oSI = new sap.m.StepInput({
				value: 1.3267,
				step: 0.004999,
				displayValuePrecision: 3
			}),
			oIncBtn = oSI.getAggregation("_incrementButton"),
			oSI2 = new sap.m.StepInput({
				value: 1.3266999999999999999,
				step: 0.00499999999999,
				displayValuePrecision: 3
			}),
			oIncBtn2 = oSI2.getAggregation("_incrementButton");

			oSI.placeAt('qunit-fixture');
			oSI2.placeAt('qunit-fixture');
			oCore.applyChanges();

			strictEqual(oSI.getValue(), 1.3267, "The value is formatted correctly");
			strictEqual(oSI.getAggregation("_input")._getInputValue(), "1.327", "The input value is rounded to the given displayValuePrecision");

			oIncBtn.firePress();

			strictEqual(oSI.getValue(), 1.331699, "The value is formatted correctly");
			strictEqual(oSI.getAggregation("_input")._getInputValue(), "1.332", "The input value is correctly formatted");

			//second test
			strictEqual(oSI2.getValue(), 1.3266999999999999999, "The value is formated correctly");
			strictEqual(oSI2.getAggregation("_input")._getInputValue(), "1.327", "The input value is rounded to the given displayValuePrecision");

			oIncBtn2.firePress();

			strictEqual(oSI2.getValue(), 1.3316999999999899999, "The value is formated correctly");
			strictEqual(oSI2.getAggregation("_input")._getInputValue(), "1.332", "The input value is correctly formatted");

			oSI.destroy();
			oSI2.destroy();
		});

		QUnit.module("Keyboard Handling", {
			beforeEach: function () {
				this.oChangeSpy = sinon.spy();
				this.stepInput = new sap.m.StepInput({
					value: 4,
					max: 10,
					min: -4,
					change: this.oChangeSpy
				});

				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
				this.oChangeSpy.reset();
			}
		});

		QUnit.test("Value is changed upon Enter press", function(assert) {
			//prepare
			var oInput = this.stepInput._getInput();

			//act
			jQuery(this.stepInput).focus();
			oInput.$("inner").val(7);

			//assert
			strictEqual(this.stepInput.getValue(), 4, "Value should not be changed because ENTER is not pressed yet");
			equal(this.oChangeSpy.callCount, 0, "Change Event should not be called");

			//act
			qutils.triggerKeydown(oInput.getDomRef(), jQuery.sap.KeyCodes.ENTER);

			//assert
			equal(this.stepInput.getValue(), 7, "Value should be changed due to ENTER pressed");
			this.clock.tick(1000); //needed because the change event is fired inside a timeout callback
			equal(this.oChangeSpy.callCount, 1, "Change Event should be called once");
		});

		QUnit.test("Change event is fired only once when element is focused, changed and then + button is clicked", function(assert) {
			//prepare
			var oInput = this.stepInput._getInput(),
			oIncrementBtn = this.stepInput.getAggregation("_incrementButton");

			//assert
			strictEqual(this.stepInput.getValue(), 4, "Value should not be changed because ENTER is not pressed yet"); //value not changed
			equal(this.oChangeSpy.callCount, 0, "Change Event should not be called");

			//act
			oInput.$("inner").val(7);
			//No way to simulate real click on the “+” button, so make sure the same event handlers are called in the same order
			this.stepInput.onfocusout();
			oInput.onChange();
			oIncrementBtn.firePress();

			//assert
			equal(this.stepInput.getValue(), 8, "Value should be changed from 7 to 8 due to increment button pressed");
			equal(this.oChangeSpy.callCount, 1, "Change Event should be called once");
		});

		QUnit.test("Change Event is fired when  +/- buttons are clicked", function(assert) {
			//prepare
			var oIncrementBtn = this.stepInput.getAggregation("_incrementButton"),
					oDecrementBtn = this.stepInput.getAggregation("_decrementButton");

			//act
			jQuery(this.stepInput).focus();
			oIncrementBtn.firePress();

			//assert
			equal(this.stepInput.getValue(), 5, "Value should be changed 5 due to increment button pressed");
			equal(this.oChangeSpy.callCount, 1, "Change Event should be called once");
			this.oChangeSpy.reset();

			//act
			oDecrementBtn.firePress();

			//assert
			equal(this.stepInput.getValue(), 4, "Value should be changed 4 due to decrement button pressed");
			equal(this.oChangeSpy.callCount, 1, "Change Event should be called once");
		});

		QUnit.test("up/down increases/decreases the value", function (assert) {
			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_UP);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 5,
					"The input's value is increasing with 1 after arrow up");

			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_DOWN);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 4,
					"The input's value is decreasing with 1 after arrow down");

			//act
			this.stepInput.setStep(5);
			this.clock.tick(1000);
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_UP);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 9,
					"The input's value is decreasing with 5 after arrow up");
		});

		QUnit.test("pageup and pagedown increases/decreases the value with a larger step", function (assert) {
			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.PAGE_UP);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 6, "The input's value is increasing with step=step*2 after pageup");

			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.PAGE_DOWN);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 4,
					"The input's value is decreasing with step=step*2 after pagedown");

			//act
			this.stepInput.setStep(5);
			this.clock.tick(1000);
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.PAGE_UP);
			this.clock.tick(1000);

			//assert
			equal(Number(this.stepInput.getAggregation("_input")._getInputValue()) + this.stepInput.getValue(), 14,
					"The input's value is decreasing with step=step*2 after pageup");
		});

		QUnit.test("shift+up/down increases/decreases the value with a larger step if specified", function (assert) {
			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_UP, true, false, false);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 6,
					"The input's value is increasing with step=2*step after arrow up");

			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_DOWN, true, false, false);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 4,
					"The input's value is decreasing with step=1 after arrow down");

			//act
			this.stepInput.setStep(5);
			this.clock.tick(1000);
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_UP, true, false, false);
			this.clock.tick(1000);

			//assert
			equal(Number(this.stepInput.getAggregation("_input")._getInputValue()) + this.stepInput.getValue(), 14,
					"The input's value is decreasing with step=2*step after arrow up");
		});

		QUnit.test("shift+pageup/pagedown sets value to max/min", function (assert) {
			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.PAGE_UP, true, false, false);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 10,
					"The input's value is set to max after page up");

			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.PAGE_DOWN, true, false, false);
			this.clock.tick(1000);

			//asser
			equal(this.stepInput.getAggregation("_input")._getInputValue(), -4,
					"The input's value is set to min after page down");
		});

		QUnit.test("ctrl+shift+up/down sets value to max/min", function (assert) {
			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_UP, true, false, true);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(), 10,
					"The input's value is set to max after page up");

			//act
			qutils.triggerKeydown(this.stepInput.getDomRef(), jQuery.sap.KeyCodes.ARROW_DOWN, true, false, true);
			this.clock.tick(1000);

			//assert
			equal(this.stepInput.getAggregation("_input")._getInputValue(),-4,
					"The input's  value is set to min after page down");
		});

		QUnit.module("Accessibility", {
			beforeEach: function () {
				this.stepInput = new sap.m.StepInput({
					value: 4,
					max: 10,
					min: -4,
					ariaLabelledBy: "__text0"
				});
				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
			}
		});

		QUnit.test("Internal 'sap.m.Input' has correct ARIA attributes when StepInput is initialized with default values", function (assert) {
			//prepare
			var oSUT = new sap.m.StepInput(),
				oInput = oSUT._getInput(),
				$Input;
			//act
			oSUT.placeAt('qunit-fixture');
			oCore.applyChanges();
			$Input = oInput.$(oInput.getRenderer().getInnerSuffix());
			//assert
			assert.ok($Input.is("[role]"), "Internal Input has 'role' attribute");
			assert.strictEqual($Input.attr("role"), "spinbutton", "Internal input's 'role' attribute has correct value");
			assert.ok($Input.is("[aria-valuenow]"), "Internal Input has 'aria-valuenow' attribute");
			assert.strictEqual($Input.attr("aria-valuenow"), "0", "Internal input's 'aria-valuenow' attribute has correct value");
			assert.notOk($Input.is("[aria-valuemin]"), "Internal Input doesn't have 'aria-valuemin' attribute");
			assert.notOk($Input.is("[aria-valuemax]"), "Internal Input doesn't have 'aria-valuemax' attribute");
			/* Inherited InputBase aria properties */
			assert.notOk(oInput.$().is("[title]"), "Internal Input wrapper doesn't have 'title' attribute");
			assert.notOk($Input.is("[name]"), "Internal Input doesn't have 'name' attribute");
			assert.notOk($Input.is("[placeholder]"), "Internal Input doesn't have 'placeholder' attribute");
			assert.notOk($Input.is("[aria-invalid]"), "Internal Input doesn't have 'aria-invalid' attribute");
			assert.notOk($Input.is("[aria-readonly]"), "Internal Input doesn't have 'aria-readonly' attribute");
			assert.notOk($Input.is("[aria-disabled]"), "Internal Input doesn't have 'aria-disabled' attribute");
			assert.notOk($Input.is("[aria-required]"), "Internal Input doesn't have 'aria-required' attribute");
			assert.notOk($Input.is("[aria-labelledby]"), "Internal Input doesn't have 'aria-labelledby' attribute");
			assert.notOk($Input.is("[aria-describedby]"), "Internal Input doesn't have 'aria-describedby' attribute");
			//clean
			oSUT.destroy();
		});

		QUnit.test("Internal 'sap.m.Input' has correct ARIA attributes when initialized with specific values", function (assert) {
			//prepare
			var oSUT = new sap.m.StepInput({
					name: "useful name",
					required: true,
					editable: false,
					enabled: false,
					placeholder: 'useful placeholder',
					tooltip: 'useful tooltip',
					min: 0,
					max: 10,
					value: 15
				}),
				oInput = oSUT._getInput(),
				$Input;
			//act
			oSUT.placeAt('qunit-fixture');
			oCore.applyChanges();
			$Input = oInput.$(oInput.getRenderer().getInnerSuffix());
			//assert
			assert.ok($Input.is("[role]"), "Internal Input has 'role' attribute");
			assert.strictEqual($Input.attr("role"), "spinbutton", "Internal input's 'role' attribute has correct value");
			assert.ok($Input.is("[aria-valuenow]"), "Internal Input has 'aria-valuenow' attribute");
			/** ToDo: This should be corrected when we apply the latest IxD specification */
			assert.strictEqual($Input.attr("aria-valuenow"), "10", "Internal input's 'aria-valuenow' attribute has correct value");
			assert.ok($Input.is("[aria-valuemin]"), "Internal Input has 'aria-valuemin' attribute");
			assert.strictEqual($Input.attr("aria-valuemin"), "0", "Internal input's 'aria-valuemin' attribute has correct value");
			assert.ok($Input.is("[aria-valuemax]"), "Internal Input has 'aria-valuemax' attribute");
			assert.strictEqual($Input.attr("aria-valuemax"), "10", "Internal input's 'aria-valuemax' attribute has correct value");
			/* Inherited InputBase aria properties */
			assert.ok(oInput.$().is("[title]"), "Internal Input wrapper has 'title' attribute");
			assert.strictEqual(oInput.$().attr("title"), 'useful tooltip', "Internal input's wrapper 'title' attribute has correct value");
			assert.ok($Input.is("[name]"), "Internal Input has 'name' attribute");
			assert.strictEqual($Input.attr("name"), 'useful name', "Internal input's 'name' attribute has correct value");
			assert.ok($Input.is("[placeholder]"), "Internal Input has 'placeholder' attribute");
			assert.strictEqual($Input.attr("placeholder"), 'useful placeholder', "Internal input's 'placeholder' attribute has correct value");
			/** ToDo: This should be corrected when we apply the latest IxD specification */
			assert.notOk($Input.is("[aria-invalid]"), "Internal Input has 'aria-invalid' attribute");
			assert.ok($Input.is("[aria-readonly]"), "Internal Input has 'aria-readonly' attribute");
			assert.strictEqual($Input.attr("aria-readonly"), 'true', "Internal input's 'aria-readonly' attribute has correct value");
			assert.ok($Input.is("[aria-disabled]"), "Internal Input has 'aria-disabled' attribute");
			assert.strictEqual($Input.attr("aria-disabled"), 'true', "Internal input's 'aria-disabled' attribute has correct value");
			assert.ok($Input.is("[aria-required]"), "Internal Input has 'aria-required' attribute");
			assert.strictEqual($Input.attr("aria-required"), 'true', "Internal input's 'aria-required' attribute has correct value");
			assert.ok($Input.is("[aria-labelledby]"), "Internal Input has 'aria-labelledby' attribute");
			assert.strictEqual($Input.attr("aria-labelledby"), oInput.getId() + '-labelledby', "Internal input's 'aria-labelledby' attribute has correct value");
			assert.ok($Input.is("[aria-describedby]"), "Internal Input has 'aria-describedby' attribute");
			assert.strictEqual($Input.attr("aria-describedby"), oInput.getId() + '-describedby', "Internal input's 'aria-describedby' attribute has correct value");
			//clean
			oSUT.destroy();
		});

		QUnit.test("StepInput correctly alters its internal 'sap.m.Input' ARIA attributes on property changes", function (assert) {
			//prepare
			var oInput = this.stepInput._getInput();
			var sInputSuffix = oInput.getRenderer().getInnerSuffix();
			//assert - initial values
			assert.ok(oInput.$(sInputSuffix).is('[aria-valuenow]'), "'aria-valuenow' attribute is rendered in the DOM");
			assert.strictEqual(oInput.$(sInputSuffix).attr("aria-valuenow"), "4", "'aria-valuenow' attribute has correct initial value");
			//act - change the 'value' property
			this.stepInput.setValue(9);
			oCore.applyChanges();
			//assert - expect aria-valuenow to be changed accordingly
			assert.strictEqual(oInput.$(sInputSuffix).attr("aria-valuenow"), "9", "'aria-valuenow' attribute was updated when the 'value' property was changed");
			//act - change the 'editable' property
			this.stepInput.setEditable(false);
			oCore.applyChanges();
			//assert - expect 'aria-readonly=true' to be rendered in the DOM
			assert.ok(oInput.$(sInputSuffix).is('[aria-readonly]'), "'aria-readonly' attribute was rendered in the DOM");
			assert.strictEqual(oInput.$(sInputSuffix).attr("aria-readonly"), "true", "'aria-readonly' attribute was updated when the 'editable' property was changed");
			//act - change the 'editable' property
			this.stepInput.setEditable(true);
			oCore.applyChanges();
			//assert - expect 'aria-readonly' not to be rendered in the DOM
			assert.notOk(oInput.$(sInputSuffix).is('[aria-readonly]'), "'aria-readonly' attribute is not rendered in the DOM");
			//act - change the 'enabled' property
			this.stepInput.setEnabled(false);
			oCore.applyChanges();
			//assert - expect 'aria-disabled=true' to be rendered in the DOM
			assert.ok(oInput.$(sInputSuffix).is('[aria-disabled]'), "'aria-disabled' attribute was rendered");
			assert.strictEqual(oInput.$(sInputSuffix).attr("aria-disabled"), "true", "'aria-disabled' attribute was updated when the 'enabled' property was changed");
			//act - change the 'enabled' property
			this.stepInput.setEnabled(true);
			oCore.applyChanges();
			//assert - expect 'aria-disabled' not to be rendered on the DOM
			assert.notOk(oInput.$(sInputSuffix).is('[aria-disabled]'), "'aria-disabled' attribute is not rendered in the DOM");
			//act - simulate changing the 'value' outside the possible range with typing
			oInput.$(sInputSuffix).val(11);
			qutils.triggerKeydown(oInput.$(sInputSuffix)[0], jQuery.sap.KeyCodes.TAB, false, false, false);
			oCore.applyChanges();
			//assert - expect 'aria-invalid=true' to be rendered in the DOM
			assert.ok(oInput.$(sInputSuffix).is('[aria-invalid]'), "'aria-invalid' is rendered in the DOM");
			assert.strictEqual(oInput.$(sInputSuffix).attr('aria-invalid'), "true", "'aria-invalid' attribute was updated when the invalid value is typed and confirmed");
		});

		QUnit.module("binding", {
			beforeEach: function () {
				this.stepInput = new sap.m.StepInput({
					value: {
						path: "/vValue"
					},
					displayValuePrecision: {
						path: "/vPrecision"
					},
					max: {
						path: "/vMax"
					},
					min: {
						path: "/vMin"
					}
				});
				this.oModel = new sap.ui.model.json.JSONModel();
				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
			}
		});

		QUnit.test("When value set via binding is undefined", function (assert) {
			this.oModel.setData({});
			this.stepInput.setModel(this.oModel);
			oCore.applyChanges();

			equal(this.stepInput.getAggregation("_input")._getInputValue(), 0, "The input is set correctly");
			strictEqual(this.stepInput.getValue(), 0, "Value is set to the default one if it was undefined");
		});

		QUnit.test("value set via binding", function (assert) {
			this.oModel.setData({
				vValue: 6
			});
			this.stepInput.setModel(this.oModel);
			oCore.applyChanges();

			strictEqual(this.stepInput.getValue(), 6, "Value is set correctly");
			equal(this.stepInput.getAggregation("_input")._getInputValue(), "6", "The input is set correctly");
		});

		QUnit.test("value set via binding and has precision", function (assert) {
			this.oModel.setData({
				vValue: 6,
				vPrecision: 3
			});
			this.stepInput.setModel(this.oModel);
			oCore.applyChanges();

			strictEqual(this.stepInput.getValue(), 6, "Value is set correctly");
			strictEqual(this.stepInput.getDisplayValuePrecision(), 3, "Value precision is set correctly");
			strictEqual(this.stepInput.getAggregation("_input")._getInputValue(), "6.000", "The input is set and formated correctly");
		});

		QUnit.test("less than Min value set via binding", function (assert) {
			this.oModel.setData({
				vValue: 4,
				vMin: 5
			});
			this.stepInput.setModel(this.oModel);
			oCore.applyChanges();

			strictEqual(this.stepInput.getValue(), 5, "Value is set correctly");
			equal(this.stepInput.getAggregation("_input")._getInputValue(), "5", "The input is set correctly");
		});

		QUnit.test("value 0 Min value set via binding", function (assert) {
			this.oModel.setData({
				vValue: 0,
				vMin: 5
			});
			this.stepInput.setModel(this.oModel);
			oCore.applyChanges();

			strictEqual(this.stepInput.getValue(), 5, "Value is set correctly");
			equal(this.stepInput.getAggregation("_input")._getInputValue(), "5", "The input is set correctly");
		});


		QUnit.module("calculate decimals", {
			beforeEach: function () {
				this.stepInput = new sap.m.StepInput();

				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
			}
		});

		QUnit.test("Adding additional zeros to reach the precision value", function (assert) {
			strictEqual(this.stepInput._padZeroesRight("34", 5), "34000", "returns '34000'");
		});

		QUnit.test("Adding zeros equal to precision value", function (assert) {
			strictEqual(this.stepInput._padZeroesRight("0", 5), "00000", "returns '00000'");
		});

		module("onfocusout() and onsapescape()", {
			beforeEach: function () {
				this.stepInput = new sap.m.StepInput({
				});

				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
			}
		});

		QUnit.test("onfocusout()", function () {
			//act
			this.stepInput.getDomRef().focus();
			this.stepInput._getInput().setValue("");
			this.stepInput.onfocusout();

			//assert
			strictEqual(this.stepInput.getValue(), 0, "The value is set to 0 because there's no min or max set");

			//act
			this.stepInput._getInput().setValue("");
			this.stepInput.getDomRef().focus();
			this.stepInput.setMax(-2);
			this.stepInput.onfocusout();
			//assert
			strictEqual(this.stepInput.getValue(), -2, "The value is set to the max because it's smaller than 0 and there's no min");

			//act
			this.stepInput._getInput().setValue("");
			this.stepInput.getDomRef().focus();
			this.stepInput.setMin(5);
			this.stepInput.onfocusout();
			//assert
			strictEqual(this.stepInput.getValue(), 5, "The value is set to the min because it's bigger than 0");

		});

		QUnit.test("onsapescape()", function () {
			//prepare & act
			var oSpy = sinon.spy(this.stepInput._getInput(), "onsapescape");
			this.stepInput.onsapescape();
			// Assert
			equal(oSpy.callCount, 1, "onsapescape() of the input is called once");
		});

		module("Private API", {
			beforeEach: function () {
				this.stepInput = new sap.m.StepInput({

				});

				this.stepInput.placeAt('qunit-fixture');
				oCore.applyChanges();
			},
			afterEach: function () {
				this.stepInput.destroy();
			}
		});

		QUnit.test("_calculateValue() with positive numbers", function () {
			//assert
			strictEqual(this.stepInput._calculateNewValue(1, true).displayValue, 1, "The value of 0 is increased by 1");

			//act
			this.stepInput.setMin(-1);
			//assert
			strictEqual(this.stepInput._calculateNewValue(2, false).displayValue, this.stepInput.getMin(),
					"The value of 0 is decreased by 2 but min > 2, so it returns min");

			//act
			this.stepInput.setMax(5);
			//assert
			strictEqual(this.stepInput._calculateNewValue(6, true).displayValue, this.stepInput.getMax(),
					"The value of 0 is increased by 6 but max < 6, so it returns max");

			//act
			this.stepInput.setMax(6);
			this.stepInput.setValue(3);

			//assert
			strictEqual(this.stepInput._calculateNewValue(2, true).displayValue,
					5,
					"The value of 3 is increased by 2 * 1(default step) and max is not returned");
			strictEqual(this.stepInput._calculateNewValue(5, true).displayValue,
					this.stepInput.getMax(),
					"The value of 3 is increased by 5 * 1 and the max is returned");
		});

		QUnit.test("_calculateNewValue() with negative numbers", function () {
			//assert
			strictEqual(this.stepInput._calculateNewValue(-1, true).displayValue, 1, "The value of 0 is increased by 1");

			//act
			this.stepInput.setMin(-1);
			//assert
			strictEqual(this.stepInput._calculateNewValue(-2, false).displayValue, this.stepInput.getMin(),
					"The value of 0 is decreased by 2 but min > 2, so it returns min");

			//act
			this.stepInput.setMax(5);
			//assert
			strictEqual(this.stepInput._calculateNewValue(-6, true).displayValue, this.stepInput.getMax(),
					"The value of 0 is increased by 6 but max < 6, so it returns max");

			//act
			this.stepInput.setMax(6);
			this.stepInput.setValue(3);
			//assert
			strictEqual(this.stepInput._calculateNewValue(-2, true).displayValue,
					5,
					"The value of 3 is increased by 2 * 1(default step) and max is not returned");
			strictEqual(this.stepInput._calculateNewValue(-5, true).displayValue,
					this.stepInput.getMax(),
					"The value of 3 is increased by 5 * 1 and the max is returned");
		});

		QUnit.test("_isNumericLike()", function () {
			//assert
			strictEqual(this.stepInput._isNumericLike(0), true, "The value of 0 is a number");
			strictEqual(this.stepInput._isNumericLike("not a number"), false,
					"The value of 'not a number' is not a number");
			strictEqual(this.stepInput._isNumericLike(null), false,
					"The value of null is not a number");
			strictEqual(this.stepInput._isNumericLike(undefined), false,
					"The value of undefined is not a number");
			strictEqual(this.stepInput._isNumericLike("5"), true,
					"The value '5' is a number");
			strictEqual(this.stepInput._isNumericLike(""), false,
					"Empty string is not a number");
		});

		QUnit.test("_applyValue()", function () {
			// Prepare & act
			var oSpy = sinon.spy(this.stepInput, "setValue");
			this.stepInput.setEnabled(false);
			this.stepInput._applyValue(7);
			// Assert
			equal(oSpy.callCount, 0, "setValue() is not called after setEnabled(false)");
			strictEqual(this.stepInput.getValue(), 0, "'value' still holds the old value");

			// Act
			this.stepInput.setEnabled(true);
			this.stepInput.setEditable(false);
			this.stepInput._applyValue(8);
			// Assert
			equal(oSpy.callCount, 0, "setValue() is not called after setEditable(false)");
			strictEqual(this.stepInput.getValue(), 0, "'value' still holds the old value");
		});

		QUnit.test("_inputLiveChangeHandler()", function () {
			//prepare & act
			var oSpy = sinon.spy(this.stepInput, "setProperty"),
					oEvent = {};
			oEvent.getParameter = function() {
				return 63;
			};
			this.stepInput._inputLiveChangeHandler(oEvent);
			//assert
			equal(oSpy.callCount, 1,
					"_inputLiveChangeHandler always calls setProperty()");
			strictEqual(oSpy.getCall(0).args[0], "value",
					"setProperty is called and it's first parameter is 'value'");
			strictEqual(oSpy.getCall(0).args[1], 63,
					"setProperty is called and it's second parameter is 63");
			strictEqual(oSpy.getCall(0).args[2], true,
					"setProperty is called and it's third parameter is 'true'");
		});

	</script>

</head>
<body id="body" class="sapUiBody">
<div id="qunit"></div>
<div id="qunit-fixture"></div>
<div id="content"></div>
</body>
</html>
